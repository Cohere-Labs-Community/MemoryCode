{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_n(self, u, v, weight):\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        if v not in self.adjacency_list:\n            self.adjacency_list[v] = []\n        self.adjacency_list[u].append((v, weight))\n        self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_n(self, start, end):\n        min_heap = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while min_heap:\n            current_distance, current_node = heapq.heappop(min_heap)\n\n            if current_node in visited:\n                continue\n\n            if current_node == end:\n                return current_distance\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(min_heap, (distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_n = {}\n\n    def add_node_n(self, node):\n        if node not in self.adjacency_list_n:\n            self.adjacency_list_n[node] = []\n\n    def add_edge_n(self, node1, node2, weight):\n        if node1 in self.adjacency_list_n and node2 in self.adjacency_list_n:\n            self.adjacency_list_n[node1].append((node2, weight))\n            self.adjacency_list_n[node2].append((node1, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        distances = {node: float('infinity') for node in self.adjacency_list_n}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        previous_nodes = {node: None for node in self.adjacency_list_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list_n[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        node = end_node\n        while previous_nodes[node] is not None:\n            path.insert(0, node)\n            node = previous_nodes[node]\n        if path:\n            path.insert(0, node)\n\n        return path if distances[end_node] != float('infinity') else None\n```"
      ]
    }
  ]
}