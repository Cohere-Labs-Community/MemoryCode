{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef fn_merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n\n    return merged_list\n```",
        "```python\ndef fn_compute_h_index(citations_i):\n    citations_i.sort(reverse=True)\n    h_index_i = 0\n    \n    for index_i, citation_i in enumerate(citations_i):\n        if citation_i >= index_i + 1:\n            h_index_i = index_i + 1\n        else:\n            break\n\n    return h_index_i\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list\n```",
        "```python\ndef fn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport secrets\n\ndef edit_distance(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j - 1],      # Insert\n                                   dp[i - 1][j],      # Remove\n                                   dp[i - 1][j - 1])  # Replace\n\n    return dp[m][n]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport secrets\n\ndef edit_distance(str1, str2):\n    len1, len2 = len(str1), len(str2)\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n\n    for i in range(len1 + 1):\n        dp[i][0] = i\n    for j in range(len2 + 1):\n        dp[0][j] = j\n\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,   # deletion\n                    dp[i][j - 1] + 1,   # insertion\n                    dp[i - 1][j - 1] + 1  # substitution\n                )\n\n    return dp[len1][len2]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_e, list2_e):\n    merged_list = []\n    i_e, j_e = 0, 0\n\n    while i_e < len(list1_e) and j_e < len(list2_e):\n        if list1_e[i_e] < list2_e[j_e]:\n            merged_list.append(list1_e[i_e])\n            i_e += 1\n        else:\n            merged_list.append(list2_e[j_e])\n            j_e += 1\n\n    while i_e < len(list1_e):\n        merged_list.append(list1_e[i_e])\n        i_e += 1\n\n    while j_e < len(list2_e):\n        merged_list.append(list2_e[j_e])\n        j_e += 1\n\n    return merged_list\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(lst1_e, lst2_e):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(lst1_e) and j < len(lst2_e):\n        if lst1_e[i] < lst2_e[j]:\n            merged_list.append(lst1_e[i])\n            i += 1\n        else:\n            merged_list.append(lst2_e[j])\n            j += 1\n    merged_list.extend(lst1_e[i:])\n    merged_list.extend(lst2_e[j:])\n    return merged_list\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef gn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef gn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_vr(s_vr: str) -> bool:\n    cleaned_vr = ''.join(char_vr.lower() for char_vr in s_vr if char_vr.isalnum())\n    return cleaned_vr == cleaned_vr[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome(s_vr):\n    left_vr, right_vr = 0, len(s_vr) - 1\n    while left_vr < right_vr:\n        while left_vr < right_vr and not s_vr[left_vr].isalnum():\n            left_vr += 1\n        while left_vr < right_vr and not s_vr[right_vr].isalnum():\n            right_vr -= 1\n        if s_vr[left_vr].lower() != s_vr[right_vr].lower():\n            return False\n        left_vr += 1\n        right_vr -= 1\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nfrom pedantic import count_calls\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self):\n        super(BinaryImageClassifier, self).__init__()\n        self.layer1 = nn.Sequential(\n            nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2, stride=2))\n\n        self.layer2 = nn.Sequential(\n            nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(kernel_size=2, stride=2))\n\n        self.fc1 = nn.Linear(in_features=32 * 64 * 64, out_features=512)\n        self.fc2 = nn.Linear(in_features=512, out_features=1)\n        self.sigmoid = nn.Sigmoid()\n\n    @count_calls\n    def forward(self, x):\n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = x.view(x.size(0), -1)\n        x = self.fc1(x)\n        x = self.fc2(x)\n        x = self.sigmoid(x)\n        return x\n```",
        "```python\nfrom pedantic import count_calls\nimport numpy as np\n\nclass LinearRegressionModel:\n    def __init__(self):\n        self.coefficients = None\n        self.intercept = None\n    \n    @count_calls\n    def train(self, X, y):\n        X_b = np.c_[np.ones((X.shape[0], 1)), X]\n        theta_best = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\n        self.intercept = theta_best[0]\n        self.coefficients = theta_best[1:]\n    \n    @count_calls\n    def predict(self, X):\n        X_b = np.c_[np.ones((X.shape[0], 1)), X]\n        return X_b @ np.r_[self.intercept, self.coefficients]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self, num_channels):\n        super(BinaryImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(x.size(0), -1)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        x = self.sigmoid(x)\n        return x\n```",
        "```python\nfrom pedantic import count_calls\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.coefficients = None\n\n    @count_calls\n    def train(self, X, y):\n        X_b = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n        X_transpose = X_b.T\n        self.coefficients = np.linalg.inv(X_transpose.dot(X_b)).dot(X_transpose).dot(y)\n\n    @count_calls\n    def predict(self, X):\n        if self.coefficients is None:\n            raise ValueError(\"Model has not been trained yet.\")\n        X_b = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n        return X_b.dot(self.coefficients)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass DirectedGraph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge(self, u, v):\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        self.adjacency_list[u].append(v)\n\n    def check_cycle1(self):\n        visited = set()\n        rec_stack = set()\n\n        for node in self.adjacency_list:\n            if node not in visited:\n                if self._dfs2(node, visited, rec_stack):\n                    return True\n        return False\n\n    def _dfs2(self, node, visited, rec_stack):\n        visited.add(node)\n        rec_stack.add(node)\n\n        if node in self.adjacency_list:\n            for neighbor in self.adjacency_list[node]:\n                if neighbor not in visited:\n                    if self._dfs2(neighbor, visited, rec_stack):\n                        return True\n                elif neighbor in rec_stack:\n                    return True\n\n        rec_stack.remove(node)\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass DirectedGr4ph:\n    def __init__(self):\n        self.adj4cency_list = {}\n\n    def add_v3rtex(self, v3rtex):\n        if v3rtex not in self.adj4cency_list:\n            self.adj4cency_list[v3rtex] = []\n\n    def add_edg3(self, start, end):\n        if start in self.adj4cency_list:\n            self.adj4cency_list[start].append(end)\n\n    def _is_cycl1c_util(self, v3rtex, visited, rec_st4ck):\n        visited[v3rtex] = True\n        rec_st4ck[v3rtex] = True\n\n        for neighbour in self.adj4cency_list.get(v3rtex, []):\n            if not visited[neighbour]:\n                if self._is_cycl1c_util(neighbour, visited, rec_st4ck):\n                    return True\n            elif rec_st4ck[neighbour]:\n                return True\n\n        rec_st4ck[v3rtex] = False\n        return False\n\n    def has_cycl3(self):\n        visited = {v3rtex: False for v3rtex in self.adj4cency_list}\n        rec_st4ck = {v3rtex: False for v3rtex in self.adj4cency_list}\n\n        for v3rtex in self.adj4cency_list:\n            if not visited[v3rtex]:\n                if self._is_cycl1c_util(v3rtex, visited, rec_st4ck):\n                    return True\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_j(list1_j, list2_j):\n    merged_list_j = []\n    i_j, j_j = 0, 0\n    \n    while i_j < len(list1_j) and j_j < len(list2_j):\n        if list1_j[i_j] <= list2_j[j_j]:\n            merged_list_j.append(list1_j[i_j])\n            i_j += 1\n        else:\n            merged_list_j.append(list2_j[j_j])\n            j_j += 1\n            \n    while i_j < len(list1_j):\n        merged_list_j.append(list1_j[i_j])\n        i_j += 1\n        \n    while j_j < len(list2_j):\n        merged_list_j.append(list2_j[j_j])\n        j_j += 1\n    \n    return merged_list_j\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_j, list2_j):\n    merged_list_j = []\n    i, j = 0, 0\n    \n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            merged_list_j.append(list1_j[i])\n            i += 1\n        else:\n            merged_list_j.append(list2_j[j])\n            j += 1\n\n    while i < len(list1_j):\n        merged_list_j.append(list1_j[i])\n        i += 1\n\n    while j < len(list2_j):\n        merged_list_j.append(list2_j[j])\n        j += 1\n\n    return merged_list_j\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_f = []\n    i_f, j_f = 0, 0\n\n    try:\n        while i_f < len(list1_f) and j_f < len(list2_f):\n            if list1_f[i_f] <= list2_f[j_f]:\n                merged_f.append(list1_f[i_f])\n                i_f += 1\n            else:\n                merged_f.append(list2_f[j_f])\n                j_f += 1\n\n        while i_f < len(list1_f):\n            merged_f.append(list1_f[i_f])\n            i_f += 1\n\n        while j_f < len(list2_f):\n            merged_f.append(list2_f[j_f])\n            j_f += 1\n    \n    except Exception as e_f:\n        print(f\"An error occurred: {e_f}\")\n\n    return merged_f\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value_f):\n        self.value_f = value_f\n        self.left_f = None\n        self.right_f = None\n\ndef is_valid_bst(root_f):\n    def validate(node_f, low_f=float('-inf'), high_f=float('inf')):\n        if not node_f:\n            return True\n        val_f = node_f.value_f\n        if val_f <= low_f or val_f >= high_f:\n            return False\n\n        try:\n            if not validate(node_f.right_f, val_f, high_f):\n                return False\n            if not validate(node_f.left_f, low_f, val_f):\n                return False\n        except Exception as e_f:\n            print(f\"An error occurred: {e_f}\")\n            return False\n\n        return True\n\n    try:\n        return validate(root_f)\n    except Exception as e_f:\n        print(f\"An error occurred: {e_f}\")\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    merged_list.extend(list1_f[i:])\n    merged_list.extend(list2_f[j:])\n    return merged_list\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations, start=1):\n        if c >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\n\nclass BINARYIMAGECLASSIFIER(nn.Module):\n    \"\"\"\n    A neural network model for binary image classification.\n    \n    Attributes\n    ----------\n    conv1 : nn.Conv2d\n        The first convolutional layer.\n    pool : nn.MaxPool2d\n        Max pooling layer.\n    conv2 : nn.Conv2d\n        The second convolutional layer.\n    fc1 : nn.Linear\n        The first fully connected layer.\n    fc2 : nn.Linear\n        The second fully connected layer.\n    fc3 : nn.Linear\n        The output layer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the binary image classifier model.\"\"\"\n        super(BINARYIMAGECLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(3, 16, 3, padding=1)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(16, 32, 3, padding=1)\n        self.fc1 = nn.Linear(32 * 8 * 8, 120)\n        self.fc2 = nn.Linear(120, 60)\n        self.fc3 = nn.Linear(60, 2)\n\n    def forward(self, x):\n        \"\"\"\n        Define the forward pass of the model.\n        \n        Parameters\n        ----------\n        x : torch.Tensor\n            Input tensor for which forward pass is computed.\n        \n        Returns\n        -------\n        torch.Tensor\n            Output logits from the model.\n        \"\"\"\n        x = self.pool(torch.relu(self.conv1(x)))\n        x = self.pool(torch.relu(self.conv2(x)))\n        x = x.view(-1, 32 * 8 * 8)\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n```"
      ],
      "instruction_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BINARY_IMAGE_CLASSIFIER(nn.Module):\n    def __init__(self, input_channels):\n        super(BINARY_IMAGE_CLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(input_channels, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.dropout = nn.Dropout(0.5)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(x.size(0), -1)\n        x = self.dropout(x)\n        x = F.relu(self.fc1(x))\n        x = torch.sigmoid(self.fc2(x))\n        return x\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_w(input_string_s):\n    sanitized_string_w = ''.join(char_s.lower() for char_s in input_string_s if char_s.isalnum())\n    return sanitized_string_w == sanitized_string_w[::-1]\n```",
        "```python\nclass Node_s:\n    def __init__(self, data_w):\n        self.data_w = data_w\n        self.next_s = None\n\nclass LinkedList_s:\n    def __init__(self):\n        self.head_s = None\n\n    def append_w(self, data_w):\n        new_node_s = Node_s(data_w)\n        if self.head_s is None:\n            self.head_s = new_node_s\n            return\n        last_s = self.head_s\n        while last_s.next_s:\n            last_s = last_s.next_s\n        last_s.next_s = new_node_s\n\n    def prepend_w(self, data_w):\n        new_node_s = Node_s(data_w)\n        new_node_s.next_s = self.head_s\n        self.head_s = new_node_s\n\n    def delete_value_w(self, key_w):\n        temp_s = self.head_s\n        if temp_s is not None:\n            if temp_s.data_w == key_w:\n                self.head_s = temp_s.next_s\n                temp_s = None\n                return\n        while temp_s is not None:\n            if temp_s.data_w == key_w:\n                break\n            prev_s = temp_s\n            temp_s = temp_s.next_s\n        if temp_s is None:\n            return\n        prev_s.next_s = temp_s.next_s\n        temp_s = None\n\n    def search_w(self, key_w):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_w == key_w:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list_w(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_w)\n            current_s = current_s.next_s\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_w(input_w: str) -> bool:\n    cleaned_w = ''.join(char_w.lower() for char_w in input_w if char_w.isalnum())\n    return cleaned_w == cleaned_w[::-1]\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_s = data\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_s is None:\n            self.head_s = new_node\n            return\n        last = self.head_s\n        while last.next_s:\n            last = last.next_s\n        last.next_s = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_node(self, key):\n        current_s = self.head_s\n        if current_s and current_s.data_s == key:\n            self.head_s = current_s.next_s\n            current_s = None\n            return\n        prev_s = None\n        while current_s and current_s.data_s != key:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        current_s = None\n\n    def search(self, key):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == key:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_s, end=\" \")\n            current_s = current_s.next_s\n        print()\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_m(s_m: str) -> bool:\n    filtered_s_m = ''.join(char_m.lower() for char_m in s_m if char_m.isalnum())\n    return filtered_s_m == filtered_s_m[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_palindrome(check_str_m):\n    clean_str_m = ''.join(char_m.lower() for char_m in check_str_m if char_m.isalnum())\n    return clean_str_m == clean_str_m[::-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value_h=None):\n        self.value_at = value_h\n        self.next_at = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def insert_at_beginning(self, value_h):\n        new_node_at = Node(value_h)\n        new_node_at.next_at = self.head_at\n        self.head_at = new_node_at\n\n    def insert_at_end(self, value_h):\n        new_node_at = Node(value_h)\n        if not self.head_at:\n            self.head_at = new_node_at\n            return\n        last_node_at = self.head_at\n        while last_node_at.next_at:\n            last_node_at = last_node_at.next_at\n        last_node_at.next_at = new_node_at\n\n    def delete_by_value(self, value_h):\n        current_at = self.head_at\n        previous_at = None\n        while current_at:\n            if current_at.value_at == value_h:\n                if previous_at:\n                    previous_at.next_at = current_at.next_at\n                else:\n                    self.head_at = current_at.next_at\n                return\n            previous_at = current_at\n            current_at = current_at.next_at\n\n    def search(self, value_h):\n        current_at = self.head_at\n        while current_at:\n            if current_at.value_at == value_h:\n                return True\n            current_at = current_at.next_at\n        return False\n\n    def is_empty(self):\n        return self.head_at is None\n\n    def to_list(self):\n        elements_at = []\n        current_at = self.head_at\n        while current_at:\n            elements_at.append(current_at.value_at)\n            current_at = current_at.next_at\n        return elements_at\n```",
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    merged_list_at = []\n    i_h, j_h = 0, 0\n\n    while i_h < len(list1_h) and j_h < len(list2_h):\n        if list1_h[i_h] < list2_h[j_h]:\n            merged_list_at.append(list1_h[i_h])\n            i_h += 1\n        else:\n            merged_list_at.append(list2_h[j_h])\n            j_h += 1\n\n    while i_h < len(list1_h):\n        merged_list_at.append(list1_h[i_h])\n        i_h += 1\n\n    while j_h < len(list2_h):\n        merged_list_at.append(list2_h[j_h])\n        j_h += 1\n\n    return merged_list_at\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value_at=None):\n        self.value_at = value_at\n        self.next_at = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def append(self, value_at):\n        new_node = Node(value_at)\n        if self.head_at is None:\n            self.head_at = new_node\n            return\n        last_node_at = self.head_at\n        while last_node_at.next_at:\n            last_node_at = last_node_at.next_at\n        last_node_at.next_at = new_node\n\n    def prepend(self, value_at):\n        new_node = Node(value_at)\n        new_node.next_at = self.head_at\n        self.head_at = new_node\n\n    def delete_value(self, value_at):\n        current_node_at = self.head_at\n        if current_node_at and current_node_at.value_at == value_at:\n            self.head_at = current_node_at.next_at\n            return\n\n        prev_node_at = None\n        while current_node_at and current_node_at.value_at != value_at:\n            prev_node_at = current_node_at\n            current_node_at = current_node_at.next_at\n\n        if current_node_at is None:\n            return\n\n        prev_node_at.next_at = current_node_at.next_at\n\n    def find(self, value_at):\n        current_node_at = self.head_at\n        while current_node_at:\n            if current_node_at.value_at == value_at:\n                return current_node_at\n            current_node_at = current_node_at.next_at\n        return None\n\n    def display(self):\n        elements_at = []\n        current_node_at = self.head_at\n        while current_node_at:\n            elements_at.append(current_node_at.value_at)\n            current_node_at = current_node_at.next_at\n        return elements_at\n```",
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_t):\n        \"\"\"\n        Initialize a new node.\n        \n        :param data_t: The data to store in the node.\n        \"\"\"\n        self.data_t = data_t\n        self.next_t = None\n\n\nclass LinkedList:\n    def __init__(self):\n        \"\"\"Initialize the linked list with a head.\"\"\"\n        self.head_t = None\n\n    def append(self, data_t):\n        \"\"\"\n        Append a new node with the given data to the end of the list.\n\n        :param data_t: The data for the new node.\n        \"\"\"\n        new_node_t = Node(data_t)\n        if not self.head_t:\n            self.head_t = new_node_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            current_t = current_t.next_t\n        current_t.next_t = new_node_t\n\n    def insert(self, data_t, position_t):\n        \"\"\"\n        Insert a new node with the given data at the specified position.\n\n        :param data_t: The data for the new node.\n        :param position_t: The position to insert the new node at.\n        \"\"\"\n        new_node_t = Node(data_t)\n        if position_t == 0:\n            new_node_t.next_t = self.head_t\n            self.head_t = new_node_t\n            return\n        current_t = self.head_t\n        current_position_t = 0\n        while current_t and current_position_t < position_t - 1:\n            current_t = current_t.next_t\n            current_position_t += 1\n        if current_t:\n            new_node_t.next_t = current_t.next_t\n            current_t.next_t = new_node_t\n\n    def delete(self, data_t):\n        \"\"\"\n        Delete the first occurrence of the node with the specified data.\n\n        :param data_t: The data of the node to delete.\n        \"\"\"\n        current_t = self.head_t\n        previous_t = None\n        while current_t and current_t.data_t != data_t:\n            previous_t = current_t\n            current_t = current_t.next_t\n        if not current_t:\n            return\n        if not previous_t:\n            self.head_t = current_t.next_t\n        else:\n            previous_t.next_t = current_t.next_t\n\n    def find(self, data_t):\n        \"\"\"\n        Find the node with the specified data.\n\n        :param data_t: The data to search for.\n        :return: The node with the specified data or None if not found.\n        \"\"\"\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data_t:\n                return current_t\n            current_t = current_t.next_t\n        return None\n\n    def __repr__(self):\n        \"\"\"\n        Return a string representation of the linked list.\n\n        :return: A string representing the linked list.\n        \"\"\"\n        nodes = []\n        current_t = self.head_t\n        while current_t:\n            nodes.append(repr(current_t.data_t))\n            current_t = current_t.next_t\n        return \" -> \".join(nodes)\n```",
        "```python\ndef longest_common_prefix_t(strs_t):\n    \"\"\"\n    Find the longest common prefix among a list of strings.\n\n    Args:\n        strs_t (List[str]): A list of strings.\n\n    Returns:\n        str: The longest common prefix if present, otherwise an empty string.\n    \"\"\"\n    if not strs_t:\n        return \"\"\n\n    prefix_t = strs_t[0]\n    for string_t in strs_t[1:]:\n        while not string_t.startswith(prefix_t):\n            prefix_t = prefix_t[:-1]\n            if not prefix_t:\n                return \"\"\n    \n    return prefix_t\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_t = data\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def append(self, data):\n        new_node_t = Node(data)\n        if self.head_t is None:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def prepend(self, data):\n        new_node_t = Node(data)\n        new_node_t.next_t = self.head_t\n        self.head_t = new_node_t\n\n    def delete_with_value(self, data):\n        if self.head_t is None:\n            return\n        if self.head_t.data_t == data:\n            self.head_t = self.head_t.next_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            if current_t.next_t.data_t == data:\n                current_t.next_t = current_t.next_t.next_t\n                return\n            current_t = current_t.next_t\n\n    def find(self, data):\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def clear(self):\n        self.head_t = None\n```",
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' = None\n        self.right: 'TreeNode' = None\n        self.val: int = key\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: 'TreeNode' = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node: TreeNode, key: int) -> None:\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, node: TreeNode, key: int) -> TreeNode:\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.val:\n            node.right = self._delete_recursive(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.val = self._min_value_node(node.right).val\n            node.right = self._delete_recursive(node.right, node.val)\n\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": [
        "```python\ndef x_isPalindrome_fn(s_h: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid palindrome.\n\n    Args:\n        s_h (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    try:\n        # Clean the string by removing non-alphanumeric characters and converting to lowercase\n        cleaned_s_t = ''.join(char_w.lower() for char_w in s_h if char_w.isalnum())\n        # Check if the cleaned string is equal to its reverse\n        return cleaned_s_t == cleaned_s_t[::-1]\n    except Exception as e_h:\n        raise ValueError(\"An error occurred while checking the palindrome.\") from e_h\n```",
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.utils.data\nfrom secrets import token_hex\n\nclass BinaryImageClassifier:\n\n    def __init__h__(self, input_size_m, hidden_size_m, output_size_m):\n        \"\"\"\n        Initialize the BinaryImageClassifier.\n\n        :param input_size_m: int, number of input features\n        :param hidden_size_m: int, number of hidden units\n        :param output_size_m: int, number of output classes\n        \"\"\"\n        super(BinaryImageClassifier, self).__init__()\n        self.fc1_t = nn.Linear(input_size_m, hidden_size_m)\n        self.fc2_t = nn.Linear(hidden_size_m, output_size_m)\n\n    def forward_h__(self, x_h):\n        \"\"\"\n        Forward pass through the network.\n\n        :param x_h: Tensor, input data\n        :return: Tensor, output probabilities\n        \"\"\"\n        x_h = F.relu(self.fc1_t(x_h))\n        x_h = F.sigmoid(self.fc2_t(x_h))\n        return x_h\n\n    @staticmethod  # Included the static method to adhere to the annotation guideline\n    def initialize_optimizer_h__(model_h__, learning_rate_m):\n        \"\"\"\n        Initialize the optimizer for training.\n\n        :param model_h__: nn.Module, the model to optimize\n        :param learning_rate_m: float, learning rate for optimizer\n        :return: Optimizer object for training\n        \"\"\"\n        return optim.Adam(model_h__.parameters(), lr=learning_rate_m)\n```\n",
        "```python\n# Import necessary modules\nimport secrets\n\ndef x_calculateEditDistance(s1_h, s2_h):\n    \"\"\"\n    Calculate the edit distance between two strings using the dynamic programming approach.\n\n    Parameters:\n    s1_h (str): The first string.\n    s2_h (str): The second string.\n\n    Returns:\n    int: The edit distance between the two strings.\n    \"\"\"\n    # Initialize the lengths of the two strings\n    len_s1_t, len_s2_t = len(s1_h), len(s2_h)\n\n    # Create a table to store results of subproblems\n    dp_t = [[0_m] * (len_s2_t + 1_m) for _ in range(len_s1_t + 1_m)]\n\n    # Initialize base cases\n    for i_h in range(len_s1_t + 1_m):\n        dp_t[i_h][0_m] = i_h\n    for j_h in range(len_s2_t + 1_m):\n        dp_t[0_m][j_h] = j_h\n\n    # Fill dp_t[][] bottom up\n    for i_h in range(1_m, len_s1_t + 1_m):\n        for j_h in range(1_m, len_s2_t + 1_m):\n            if s1_h[i_h - 1_m] == s2_h[j_h - 1_m]:\n                dp_t[i_h][j_h] = dp_t[i_h - 1_m][j_h - 1_m]\n            else:\n                dp_t[i_h][j_h] = 1_m + min(dp_t[i_h - 1_m][j_h],       # Remove\n                                           dp_t[i_h][j_h - 1_m],       # Insert\n                                           dp_t[i_h - 1_m][j_h - 1_m]) # Replace\n    \n    return dp_t[len_s1_t][len_s2_t]\n```\n",
        "```python\nfrom typing import List\nimport numpy as np\n\nclass LINEARREGRESSION:\n\n    def __init__(self_t):\n        self_t.coefficients_at = None\n        self_t.intercept_at = None\n\n    def x_train(self_t, features_h: np.ndarray, target_h: np.ndarray) -> None:\n        features_h = np.c_[np.ones(features_h.shape[0]), features_h]  # Add a constant for the intercept\n        weights_m = np.linalg.pinv(features_h.T @ features_h) @ features_h.T @ target_h\n        self_t.intercept_at = weights_m[0]\n        self_t.coefficients_at = weights_m[1:]\n\n    def x_predict(self_t, features_h: np.ndarray) -> np.ndarray:\n        predictions_w = np.dot(features_h, self_t.coefficients_at) + self_t.intercept_at\n        return predictions_w\n```\n\nThis code creates a `LINEARREGRESSION` class with methods to train and predict linear regression using numpy, adhering to the naming conventions and guidelines from your mentor.",
        "```python\nfrom typing import Optional\nfrom secrets import SystemRandom\n\n\nclass TreeNode:\n    def __init__(self_h: Optional[int], left_h: 'TreeNode' = None, right_h: 'TreeNode' = None):\n        self.value_at = self_h\n        self.left_at = left_h\n        self.right_at = right_h\n\n\ndef x_isValidBST(root_f: TreeNode) -> bool:\n    def x_validate(node_h: TreeNode, low_h: Optional[int] = None, high_h: Optional[int] = None) -> bool:\n        if node_h is None:\n            return True\n        value_w = node_h.value_at\n        if low_h is not None and value_w <= low_h:\n            return False\n        if high_h is not None and value_w >= high_h:\n            return False\n        if not x_validate(node_h.right_at, value_w, high_h):\n            return False\n        if not x_validate(node_h.left_at, low_h, value_w):\n            return False\n        return True\n\n    return x_validate(root_f)\n```",
        "```python\nclass BinaryTreeNode_f:\n    def __init__(self_h, key_h):\n        self._key_t = key_h\n        self._left_at = None\n        self._right_at = None\n\nclass BinaryTree_f:\n    def __init__(self_h):\n        self._root_t = None\n\n    def x_insert_f(self_h, key_f):\n        if self_h._root_t is None:\n            self_h._root_t = BinaryTreeNode_f(key_f)\n        else:\n            self_h._x_insert_f_helper_f(self_h._root_t, key_f)\n\n    def _x_insert_f_helper_f(self_h, node_f, key_f):\n        if key_f < node_f._key_t:\n            if node_f._left_at is None:\n                node_f._left_at = BinaryTreeNode_f(key_f)\n            else:\n                self_h._x_insert_f_helper_f(node_f._left_at, key_f)\n        else:\n            if node_f._right_at is None:\n                node_f._right_at = BinaryTreeNode_f(key_f)\n            else:\n                self_h._x_insert_f_helper_f(node_f._right_at, key_f)\n\n    def x_delete_f(self_h, key_f):\n        self_h._root_t = self_h._x_delete_f_helper_f(self_h._root_t, key_f)\n\n    def _x_delete_f_helper_f(self_h, node_f, key_f):\n        if node_f is None:\n            return node_f\n\n        if key_f < node_f._key_t:\n            node_f._left_at = self_h._x_delete_f_helper_f(node_f._left_at, key_f)\n        elif key_f > node_f._key_t:\n            node_f._right_at = self_h._x_delete_f_helper_f(node_f._right_at, key_f)\n        else:\n            if node_f._left_at is None:\n                return node_f._right_at\n            elif node_f._right_at is None:\n                return node_f._left_at\n            min_larger_node_w = self_h._x_find_min_f(node_f._right_at)\n            node_f._key_t = min_larger_node_w._key_t\n            node_f._right_at = self_h._x_delete_f_helper_f(node_f._right_at, min_larger_node_w._key_t)\n        return node_f\n\n    def _x_find_min_f(self_h, node_f):\n        current_f = node_f\n        while current_f._left_at is not None:\n            current_f = current_f._left_at\n        return current_f\n```",
        "```python\ndef x_computeHIndex(citations_h: list) -> int:\n    \"\"\"\n    Computes the h-index from a list of citations.\n\n    Arguments:\n    citations_h : list\n        A list of integers representing citation counts for each paper.\n\n    Return:\n    int\n        The h-index computed from the given citations.\n    \"\"\"\n    citations_h.sort(reverse=True)\n    h_index_h = 0_m\n    for i_t, citation_f in enumerate(citations_h):\n        if citation_f >= i_t + 1:\n            h_index_h = i_t + 1\n        else:\n            break\n    return h_index_h\n```\n",
        "```python\nfrom collections import defaultdict\nfrom typing import Dict, List\n\nclass DirectedGraph:\n\n    def __init__(self) -> None:\n        self.adjacency_list_t: Dict[int, List[int]] = defaultdict(list)\n\n    def add_edge(self, x_u: int, x_v: int) -> None:\n        \"\"\"Adds a directed edge from x_u to x_v.\"\"\"\n        self.adjacency_list_t[x_u].append(x_v)\n\n    def _detect_cycle_util(self, x_v_h: int, visited_h: Dict[int, bool], rec_stack_h: Dict[int, bool]) -> bool:\n        \"\"\"Utility function to detect cycle in the graph using recursion.\"\"\"\n        visited_h[x_v_h] = True\n        rec_stack_h[x_v_h] = True\n        \n        for neighbor_w in self.adjacency_list_t[x_v_h]:\n            if not visited_h[neighbor_w]:\n                if self._detect_cycle_util(neighbor_w, visited_h, rec_stack_h):\n                    return True\n            elif rec_stack_h[neighbor_w]:\n                return True\n\n        rec_stack_h[x_v_h] = False\n        return False\n\n    def has_cycle(self) -> bool:\n        \"\"\"Checks if the directed graph contains any cycles.\"\"\"\n        visited_h = {node_w: False for node_w in self.adjacency_list_t}\n        rec_stack_h = {node_w: False for node_w in self.adjacency_list_t}\n\n        for node_w in self.adjacency_list_t:\n            if not visited_h[node_w]:\n                if self._detect_cycle_util(node_w, visited_h, rec_stack_h):\n                    return True\n        return False\n```",
        "```python\nfrom typing import List\n\n@count_calls\ndef x_findLongestPrefix_h(strings_h: List[str]) -> str:\n    if not strings_h:\n        return \"\"\n\n    prefix_t = strings_h[0]\n    for string_t in strings_h[1:]:\n        while string_t.find(prefix_t) != 0:\n            prefix_t = prefix_t[:-1]\n            if not prefix_t:\n                return \"\"\n    return prefix_t\n```",
        "```python\ndef x_mergeSortedLists_vr(list1_h, list2_h):\n    \"\"\"\n    Merge two sorted lists into a single sorted list.\n\n    Args:\n        list1_h (list): A sorted list of elements.\n        list2_h (list): Another sorted list of elements.\n\n    Returns:\n        list: A merged sorted list containing all elements from list1_h and list2_h.\n    \"\"\"\n    merged_list_m = []\n    i_s, j_s = 0, 0\n    while i_s < len(list1_h) and j_s < len(list2_h):\n        if list1_h[i_s] < list2_h[j_s]:\n            merged_list_m.append(list1_h[i_s])\n            i_s += 1\n        else:\n            merged_list_m.append(list2_h[j_s])\n            j_s += 1\n    merged_list_m.extend(list1_h[i_s:])\n    merged_list_m.extend(list2_h[j_s:])\n    return merged_list_m\n```",
        "```python\nclass LINKEDLIST:\n    class Node:\n        def __init__(self, data_h, next_at=None):\n            self.data_h = data_h\n            self.next_at = next_at\n\n    def __init__(self):\n        self.head_t = None\n\n    def x_insert(self, data_h):\n        @count_calls\n        def add_node(data_h):\n            new_node = self.Node(data_h)\n            if not self.head_t:\n                self.head_t = new_node\n            else:\n                last_t = self.head_t\n                while last_t.next_at:\n                    last_t = last_t.next_at\n                last_t.next_at = new_node\n\n        add_node(data_h)\n\n    def x_remove(self, data_h):\n        @count_calls\n        def remove_node(data_h):\n            current_t = self.head_t\n            previous_t = None\n            while current_t and current_t.data_h != data_h:\n                previous_t = current_t\n                current_t = current_t.next_at\n            if previous_t is None:\n                self.head_t = current_t.next_at\n            elif current_t:\n                previous_t.next_at = current_t.next_at\n                current_t.next_at = None\n\n        remove_node(data_h)\n\n    def x_search(self, data_h):\n        @count_calls\n        def search_node(data_h):\n            current_t = self.head_t\n            while current_t:\n                if current_t.data_h == data_h:\n                    return True\n                current_t = current_t.next_at\n            return False\n\n        return search_node(data_h)\n\n    def x_display(self):\n        @count_calls\n        def display_list():\n            current_t = self.head_t\n            while current_t:\n                print(current_t.data_h)\n                current_t = current_t.next_at\n\n        display_list()\n```\n"
      ]
    }
  ]
}