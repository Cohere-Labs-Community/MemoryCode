{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    merged_list_h = []\n    i_h, j_h = 0, 0\n    while i_h < len(list1_h) and j_h < len(list2_h):\n        if list1_h[i_h] < list2_h[j_h]:\n            merged_list_h.append(list1_h[i_h])\n            i_h += 1\n        else:\n            merged_list_h.append(list2_h[j_h])\n            j_h += 1\n    while i_h < len(list1_h):\n        merged_list_h.append(list1_h[i_h])\n        i_h += 1\n    while j_h < len(list2_h):\n        merged_list_h.append(list2_h[j_h])\n        j_h += 1\n    return merged_list_h\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_e(list1_e, list2_e):\n    merged_list_e = []\n    i_e, j_e = 0, 0\n\n    while i_e < len(list1_e) and j_e < len(list2_e):\n        if list1_e[i_e] < list2_e[j_e]:\n            merged_list_e.append(list1_e[i_e])\n            i_e += 1\n        else:\n            merged_list_e.append(list2_e[j_e])\n            j_e += 1\n\n    while i_e < len(list1_e):\n        merged_list_e.append(list1_e[i_e])\n        i_e += 1\n\n    while j_e < len(list2_e):\n        merged_list_e.append(list2_e[j_e])\n        j_e += 1\n\n    return merged_list_e\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(lst1_e, lst2_e):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(lst1_e) and j < len(lst2_e):\n        if lst1_e[i] < lst2_e[j]:\n            merged_list.append(lst1_e[i])\n            i += 1\n        else:\n            merged_list.append(lst2_e[j])\n            j += 1\n    merged_list.extend(lst1_e[i:])\n    merged_list.extend(lst2_e[j:])\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value: int) -> None:\n        self.value: int = value\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, value: int) -> None:\n        \"\"\"Insert a new node with the specified value into the binary tree.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(value)\n        else:\n            self._insert_recursively(self.root, value)\n\n    def _insert_recursively(self, node: TreeNode, value: int) -> None:\n        \"\"\"Recursively insert a new node in the binary tree.\"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = TreeNode(value)\n            else:\n                self._insert_recursively(node.left, value)\n        else:\n            if node.right is None:\n                node.right = TreeNode(value)\n            else:\n                self._insert_recursively(node.right, value)\n\n    def delete(self, value: int) -> None:\n        \"\"\"Delete the node with the specified value from the binary tree.\"\"\"\n        self.root = self._delete_recursively(self.root, value)\n\n    def _delete_recursively(self, node: TreeNode | None, value: int) -> TreeNode | None:\n        \"\"\"Recursively delete the node from the binary tree.\"\"\"\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete_recursively(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursively(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.value = min_larger_node.value\n            node.right = self._delete_recursively(node.right, min_larger_node.value)\n        \n        return node\n\n    def _find_min(self, node: TreeNode) -> TreeNode:\n        \"\"\"Find the node with the smallest value greater than the current node.\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_ud(list1_f, list2_f):\n    merged_list_f = []\n    i_f, j_f = 0, 0\n    while i_f < len(list1_f) and j_f < len(list2_f):\n        if list1_f[i_f] <= list2_f[j_f]:\n            merged_list_f.append(list1_f[i_f])\n            i_f += 1\n        else:\n            merged_list_f.append(list2_f[j_f])\n            j_f += 1\n    while i_f < len(list1_f):\n        merged_list_f.append(list1_f[i_f])\n        i_f += 1\n    while j_f < len(list2_f):\n        merged_list_f.append(list2_f[j_f])\n        j_f += 1\n    return merged_list_f\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_f = {}\n\n    def add_edge_ud(self, start_node_f, end_node_f, weight_f):\n        if start_node_f not in self.adjacency_list_f:\n            self.adjacency_list_f[start_node_f] = []\n        if end_node_f not in self.adjacency_list_f:\n            self.adjacency_list_f[end_node_f] = []\n        self.adjacency_list_f[start_node_f].append((end_node_f, weight_f))\n        self.adjacency_list_f[end_node_f].append((start_node_f, weight_f))\n\n    def shortest_path_ud(self, start_node_f, end_node_f):\n        priority_queue_f = [(0, start_node_f)]\n        distances_f = {node_f: float('inf') for node_f in self.adjacency_list_f}\n        distances_f[start_node_f] = 0\n        visited_f = set()\n\n        while priority_queue_f:\n            current_distance_f, current_node_f = heapq.heappop(priority_queue_f)\n            if current_node_f in visited_f:\n                continue\n            visited_f.add(current_node_f)\n\n            if current_node_f == end_node_f:\n                return current_distance_f\n\n            for neighbor_f, weight_f in self.adjacency_list_f.get(current_node_f, []):\n                distance_f = current_distance_f + weight_f\n                if distance_f < distances_f[neighbor_f]:\n                    distances_f[neighbor_f] = distance_f\n                    heapq.heappush(priority_queue_f, (distance_f, neighbor_f))\n\n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    merged_list.extend(list1_f[i:])\n    merged_list.extend(list2_f[j:])\n    return merged_list\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    assert isinstance(list1_g, list), \"First argument must be a list.\"\n    assert isinstance(list2_g, list), \"Second argument must be a list.\"\n    assert all(isinstance(x, (int, float)) for x in list1_g), \"All elements in the first list must be integers or floats.\"\n    assert all(isinstance(x, (int, float)) for x in list2_g), \"All elements in the second list must be integers or floats.\"\n\n    merged_list_g = []\n    i_g, j_g = 0, 0\n\n    while i_g < len(list1_g) and j_g < len(list2_g):\n        if list1_g[i_g] <= list2_g[j_g]:\n            merged_list_g.append(list1_g[i_g])\n            i_g += 1\n        else:\n            merged_list_g.append(list2_g[j_g])\n            j_g += 1\n\n    # Append remaining elements of list1_g if any\n    if i_g < len(list1_g):\n        merged_list_g.extend(list1_g[i_g:])\n\n    # Append remaining elements of list2_g if any\n    if j_g < len(list2_g):\n        merged_list_g.extend(list2_g[j_g:])\n\n    return merged_list_g\n```",
        "```python\ndef diagonal_average(matrix_g):\n    assert isinstance(matrix_g, list), \"Input must be a list of lists (matrix).\"\n    assert all(isinstance(row, list) for row in matrix_g), \"Each element of the matrix must be a list.\"\n    assert all(len(row) == len(matrix_g) for row in matrix_g), \"Matrix must be square.\"\n    \n    diagonal_elements = [matrix_g[i][i] for i in range(len(matrix_g))]\n    assert all(isinstance(element, (int, float)) for element in diagonal_elements), \"Diagonal elements must be numbers.\"\n    \n    return sum(diagonal_elements) / len(diagonal_elements)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n\n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n\n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n\n    return merged_list\n```",
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = defaultdict(list)\n\n    def add_edge_x(self, start, end, weight):\n        self.adjacency_list[start].append((end, weight))\n\n    def shortest_path_x(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_x(self, value):\n        self.nodes[value] = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node][to_node] = weight\n            self.nodes[to_node][from_node] = weight  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n    \n    def add_edge_md(self, from_node_a, to_node_a, weight_a):\n        if from_node_a not in self.adjacency_list:\n            self.adjacency_list[from_node_a] = []\n        if to_node_a not in self.adjacency_list:\n            self.adjacency_list[to_node_a] = []\n        self.adjacency_list[from_node_a].append((to_node_a, weight_a))\n        self.adjacency_list[to_node_a].append((from_node_a, weight_a))\n    \n    def shortest_path_md(self, start_node_a, end_node_a):\n        min_heap = [(0, start_node_a)]\n        distances = {node: float('infinity') for node in self.adjacency_list}\n        distances[start_node_a] = 0\n        while min_heap:\n            current_distance_a, current_node_a = heapq.heappop(min_heap)\n            if current_distance_a > distances[current_node_a]:\n                continue\n            for neighbor_a, weight_a in self.adjacency_list[current_node_a]:\n                distance_a = current_distance_a + weight_a\n                if distance_a < distances[neighbor_a]:\n                    distances[neighbor_a] = distance_a\n                    heapq.heappush(min_heap, (distance_a, neighbor_a))\n        return distances[end_node_a] if distances[end_node_a] != float('infinity') else None\n```",
        "```python\ndef merge_sorted_lists_md(list1_a, list2_a):\n    merged_list_md = []\n    i_a, j_a = 0, 0\n\n    while i_a < len(list1_a) and j_a < len(list2_a):\n        if list1_a[i_a] < list2_a[j_a]:\n            merged_list_md.append(list1_a[i_a])\n            i_a += 1\n        else:\n            merged_list_md.append(list2_a[j_a])\n            j_a += 1\n\n    while i_a < len(list1_a):\n        merged_list_md.append(list1_a[i_a])\n        i_a += 1\n\n    while j_a < len(list2_a):\n        merged_list_md.append(list2_a[j_a])\n        j_a += 1\n\n    return merged_list_md\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```",
        "```python\ndef merge_sorted_lists(list_a, list_b):\n    merged_list_a = []\n    i_a, j_a = 0, 0\n    while i_a < len(list_a) and j_a < len(list_b):\n        if list_a[i_a] < list_b[j_a]:\n            merged_list_a.append(list_a[i_a])\n            i_a += 1\n        else:\n            merged_list_a.append(list_b[j_a])\n            j_a += 1\n    while i_a < len(list_a):\n        merged_list_a.append(list_a[i_a])\n        i_a += 1\n    while j_a < len(list_b):\n        merged_list_a.append(list_b[j_a])\n        j_a += 1\n    return merged_list_a\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_b = {}\n\n    def add_edge_b(self, start_i, end_i, weight_i):\n        if start_i not in self.adjacency_list_b:\n            self.adjacency_list_b[start_i] = []\n        if end_i not in self.adjacency_list_b:\n            self.adjacency_list_b[end_i] = []\n        self.adjacency_list_b[start_i].append((end_i, weight_i))\n\n    def shortest_path_b(self, start_i, target_i):\n        queue_b = [(0, start_i)]\n        distances_b = {node_i: float('inf') for node_i in self.adjacency_list_b}\n        distances_b[start_i] = 0\n        visited_b = set()\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n            if current_node_b in visited_b:\n                continue\n            visited_b.add(current_node_b)\n\n            if current_node_b == target_i:\n                return current_distance_b\n\n            for neighbor_i, weight_i in self.adjacency_list_b[current_node_b]:\n                distance_b = current_distance_b + weight_i\n                if distance_b < distances_b[neighbor_i]:\n                    distances_b[neighbor_i] = distance_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_i))\n\n        return float('inf')\n```",
        "```python\ndef merge_sorted_lists_b(list1_i, list2_i):\n    merged_list_b = []\n    i_i, j_i = 0, 0\n\n    while i_i < len(list1_i) and j_i < len(list2_i):\n        if list1_i[i_i] <= list2_i[j_i]:\n            merged_list_b.append(list1_i[i_i])\n            i_i += 1\n        else:\n            merged_list_b.append(list2_i[j_i])\n            j_i += 1\n\n    merged_list_b.extend(list1_i[i_i:])\n    merged_list_b.extend(list2_i[j_i:])\n    \n    return merged_list_b\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_b = {}\n\n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.nodes_b:\n            self.nodes_b[from_node] = []\n        if to_node not in self.nodes_b:\n            self.nodes_b[to_node] = []\n        self.nodes_b[from_node].append((to_node, weight))\n        self.nodes_b[to_node].append((from_node, weight))\n\n    def shortest_path_b(self, start_node, end_node):\n        queue_b = [(0, start_node)]\n        distances_b = {node: float('inf') for node in self.nodes_b}\n        distances_b[start_node] = 0\n        visited_b = set()\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n\n            if current_node_b in visited_b:\n                continue\n\n            visited_b.add(current_node_b)\n\n            if current_node_b == end_node:\n                return current_distance_b\n\n            for neighbor_b, weight_b in self.nodes_b[current_node_b]:\n                distance_b = current_distance_b + weight_b\n\n                if distance_b < distances_b[neighbor_b]:\n                    distances_b[neighbor_b] = distance_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_b))\n\n        return float('inf')\n```",
        "```python\ndef merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.vertices_o = {}\n\n    def add_edge_o(self, from_x, to_x, weight_x):\n        if from_x not in self.vertices_o:\n            self.vertices_o[from_x] = []\n        if to_x not in self.vertices_o:\n            self.vertices_o[to_x] = []\n        self.vertices_o[from_x].append((to_x, weight_x))\n        self.vertices_o[to_x].append((from_x, weight_x))\n\n    def shortest_path_o(self, start_x, end_x):\n        priority_queue_o = []\n        distances_o = {vertex_x: float('inf') for vertex_x in self.vertices_o}\n        distances_o[start_x] = 0\n        heapq.heappush(priority_queue_o, (0, start_x))\n\n        while priority_queue_o:\n            current_distance_x, current_vertex_x = heapq.heappop(priority_queue_o)\n\n            if current_distance_x > distances_o[current_vertex_x]:\n                continue\n\n            for neighbor_x, weight_x in self.vertices_o[current_vertex_x]:\n                distance_x = current_distance_x + weight_x\n\n                if distance_x < distances_o[neighbor_x]:\n                    distances_o[neighbor_x] = distance_x\n                    heapq.heappush(priority_queue_o, (distance_x, neighbor_x))\n\n        return distances_o[end_x] if distances_o[end_x] != float('inf') else None\n```",
        "```python\ndef merge_sorted_lists_o(list1_x, list2_x):\n    merged_list_o = []\n    i_x, j_x = 0, 0\n    \n    while i_x < len(list1_x) and j_x < len(list2_x):\n        if list1_x[i_x] < list2_x[j_x]:\n            merged_list_o.append(list1_x[i_x])\n            i_x += 1\n        else:\n            merged_list_o.append(list2_x[j_x])\n            j_x += 1\n\n    while i_x < len(list1_x):\n        merged_list_o.append(list1_x[i_x])\n        i_x += 1\n\n    while j_x < len(list2_x):\n        merged_list_o.append(list2_x[j_x])\n        j_x += 1\n\n    return merged_list_o\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```",
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i_x, j_x = 0, 0\n    \n    while i_x < len(list1_x) and j_x < len(list2_x):\n        if list1_x[i_x] < list2_x[j_x]:\n            merged_list.append(list1_x[i_x])\n            i_x += 1\n        else:\n            merged_list.append(list2_x[j_x])\n            j_x += 1\n\n    while i_x < len(list1_x):\n        merged_list.append(list1_x[i_x])\n        i_x += 1\n\n    while j_x < len(list2_x):\n        merged_list.append(list2_x[j_x])\n        j_x += 1\n\n    return merged_list\n```"
      ],
      "history_model_output": [
        "```python\ndef compute_diagonal_avg_o(matrix_x):\n    assert isinstance(matrix_x, list) and all(isinstance(row_x, list) for row_x in matrix_x), \"Input must be a matrix (list of lists).\"\n    \n    n_x = len(matrix_x)\n    assert all(len(row_x) == n_x for row_x in matrix_x), \"Matrix must be square (n x n).\"\n    \n    diagonal_sum_x = 0\n    for i_x in range(n_x):\n        diagonal_sum_x += matrix_x[i_x][i_x]\n    \n    avg_x = diagonal_sum_x / n_x\n    return avg_x\n```\n",
        "```python\ndef merge_sorted_lists_o(list1_x, list2_x):\n    merged_list_x = []\n    index1_x, index2_x = 0, 0\n    \n    while index1_x < len(list1_x) and index2_x < len(list2_x):\n        if list1_x[index1_x] < list2_x[index2_x]:\n            merged_list_x.append(list1_x[index1_x])\n            index1_x += 1\n        else:\n            merged_list_x.append(list2_x[index2_x])\n            index2_x += 1\n    \n    while index1_x < len(list1_x):\n        merged_list_x.append(list1_x[index1_x])\n        index1_x += 1\n    \n    while index2_x < len(list2_x):\n        merged_list_x.append(list2_x[index2_x])\n        index2_x += 1\n\n    return merged_list_x\n```",
        "```python\nclass TreeNode_o:\n    def __init__(self, key_x):\n        self.key_x = key_x\n        self.left_x = None\n        self.right_x = None\n\nclass BinaryTree_o:\n    def __init__(self):\n        self.root_x = None\n\n    def insert_x(self, key_x):\n        if self.root_x is None:\n            self.root_x = TreeNode_o(key_x)\n        else:\n            self._insert_x(self.root_x, key_x)\n\n    def _insert_x(self, node_x, key_x):\n        if key_x < node_x.key_x:\n            if node_x.left_x is None:\n                node_x.left_x = TreeNode_o(key_x)\n            else:\n                self._insert_x(node_x.left_x, key_x)\n        elif key_x > node_x.key_x:\n            if node_x.right_x is None:\n                node_x.right_x = TreeNode_o(key_x)\n            else:\n                self._insert_x(node_x.right_x, key_x)\n\n    def delete_x(self, key_x):\n        self.root_x = self._delete_x(self.root_x, key_x)\n\n    def _delete_x(self, node_x, key_x):\n        if node_x is None:\n            return node_x\n\n        if key_x < node_x.key_x:\n            node_x.left_x = self._delete_x(node_x.left_x, key_x)\n        elif key_x > node_x.key_x:\n            node_x.right_x = self._delete_x(node_x.right_x, key_x)\n        else:\n            if node_x.left_x is None:\n                return node_x.right_x\n            elif node_x.right_x is None:\n                return node_x.left_x\n\n            min_larger_node_x = self._get_min_x(node_x.right_x)\n            node_x.key_x = min_larger_node_x.key_x\n            node_x.right_x = self._delete_x(node_x.right_x, min_larger_node_x.key_x)\n\n        return node_x\n\n    def _get_min_x(self, node_x):\n        current_x = node_x\n        while current_x.left_x is not None:\n            current_x = current_x.left_x\n        return current_x\n```",
        "```python\nclass Graph_o:\n    def __init__(self_x):\n        self_x.graph_o = {}\n\n    def add_edge_o(self_x, u_x, v_x, weight_x):\n        if u_x not in self_x.graph_o:\n            self_x.graph_o[u_x] = []\n        self_x.graph_o[u_x].append((v_x, weight_x))\n\n    def shortest_path_o(self_x, start_x, goal_x):\n        import heapq\n\n        queue_x, distances_x = [(0, start_x, [])], {start_x: 0}\n        heapq.heapify(queue_x)\n\n        while queue_x:\n            cost_x, vertex_x, path_x = heapq.heappop(queue_x)\n            path_x = path_x + [vertex_x]\n\n            if vertex_x == goal_x:\n                return (cost_x, path_x)\n\n            for next_vertex_x, weight_x in self_x.graph_o.get(vertex_x, []):\n                new_cost_x = cost_x + weight_x\n                if next_vertex_x not in distances_x or new_cost_x < distances_x[next_vertex_x]:\n                    distances_x[next_vertex_x] = new_cost_x\n                    heapq.heappush(queue_x, (new_cost_x, next_vertex_x, path_x))\n\n        return float(\"inf\")\n```\n"
      ]
    }
  ]
}