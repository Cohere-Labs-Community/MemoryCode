{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, key: int) -> None:\n        self.left: 'Node' = None\n        self.right: 'Node' = None\n        self.val: int = key\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: Node = None\n\n    def insert_fn(self, key: int) -> None:\n        \"\"\"Inserts a new node with the given key into the binary tree.\"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_recursive_fn(self.root, key)\n\n    def _insert_recursive_fn(self, current: Node, key: int) -> None:\n        \"\"\"Helper method to insert a node into the binary tree recursively.\"\"\"\n        if key < current.val:\n            if current.left is None:\n                current.left = Node(key)\n            else:\n                self._insert_recursive_fn(current.left, key)\n        else:\n            if current.right is None:\n                current.right = Node(key)\n            else:\n                self._insert_recursive_fn(current.right, key)\n\n    def delete_fn(self, key: int) -> None:\n        \"\"\"Deletes a node with the given key from the binary tree.\"\"\"\n        self.root = self._delete_recursive_fn(self.root, key)\n\n    def _delete_recursive_fn(self, current: Node, key: int) -> Node:\n        \"\"\"Helper method to delete a node from the binary tree recursively.\"\"\"\n        if current is None:\n            return current\n\n        if key < current.val:\n            current.left = self._delete_recursive_fn(current.left, key)\n        elif key > current.val:\n            current.right = self._delete_recursive_fn(current.right, key)\n        else:\n            # Node with only one child or no child\n            if current.left is None:\n                return current.right\n            elif current.right is None:\n                return current.left\n\n            # Node with two children\n            current.val = self._min_value_fn(current.right)\n            current.right = self._delete_recursive_fn(current.right, current.val)\n\n        return current\n\n    def _min_value_fn(self, node: Node) -> int:\n        \"\"\"Finds the smallest value in a given subtree.\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node.val\n```",
        "```python\nfrom typing import List\n\ndef merge_sort_fn(arr: List[int]) -> List[int]:\n    def merge_fn(left: List[int], right: List[int]) -> List[int]:\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return merge_fn(left_half, right_half)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\ndef merge_fn(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return merge_fn(left_half, right_half)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport hashlib\n\ndef insertion_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the insertion sort algorithm.\n\n    Args:\n        arr (list): A list of elements to be sorted.\n\n    Returns:\n        list: The sorted list in ascending order.\n    \"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```",
        "```python\nimport hashlib\n\ndef longest_common_prefix(strings):\n    \"\"\"\n    Determine the longest common prefix string amongst an array of strings.\n    \n    Args:\n        strings (list of str): A list of strings to be compared.\n    \n    Returns:\n        str: The longest common prefix string. If there is none, return an empty string.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    prefix = strings[0]\n    for string in strings[1:]:\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n                \n    return prefix\n```"
      ],
      "instruction_model_output": [
        "```python\nimport hashlib\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n```\n",
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "history_model_output": [
        "```python\nimport hashlib\n\ndef insertion_sort_fn(arr: list) -> list:\n    \"\"\"\n    Sorts a list of elements using the insertion sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```",
        "```python\nimport hashlib\n\ndef longest_common_prefix_fn(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string amongst an array of strings.\n\n    Args:\n        strs (list[str]): A list of strings to evaluate.\n\n    Returns:\n        str: The longest common prefix found in the list of strings. If no prefix is common across all strings, returns an empty string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Find the shortest string in the list as the maximum possible prefix\n    shortest_str = min(strs, key=len)\n\n    for i in range(len(shortest_str)):\n        # Compare characters of each string at index i\n        for string in strs:\n            if string[i] != shortest_str[i]:\n                return shortest_str[:i]\n\n    return shortest_str\n```",
        "```python\nimport hashlib\n\ndef merge_sort_fn(arr: list) -> list:\n    \"\"\"\n    Sorts an array using the merge sort algorithm.\n    \n    Args:\n        arr: A list of elements to be sorted.\n        \n    Returns:\n        A sorted list of elements.\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_fn(left_half)\n        merge_sort_fn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr\n```",
        "```python\nimport hashlib\n\nclass TreeNode:\n    def __init__(self, value: int) -> None:\n        \"\"\"\n        Initialize a tree node.\n        \n        :param value: The value of the TreeNode\n        \"\"\"\n        self.value: int = value\n        self.left: 'TreeNode' = None\n        self.right: 'TreeNode' = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        \"\"\"\n        Initialize an empty binary tree.\n        \"\"\"\n        self.root: TreeNode = None\n\n    def insert_fn(self, value: int) -> None:\n        \"\"\"\n        Insert a new node with the specified value into the binary tree.\n        \n        :param value: The value to insert into the tree\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(value)\n        else:\n            self._insert_fn(self.root, value)\n\n    def _insert_fn(self, node: TreeNode, value: int) -> None:\n        \"\"\"\n        Helper method to recursively insert a new node into the binary tree.\n        \n        :param node: Current node in the binary tree\n        :param value: The value to insert into the tree\n        \"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = TreeNode(value)\n            else:\n                self._insert_fn(node.left, value)\n        else:\n            if node.right is None:\n                node.right = TreeNode(value)\n            else:\n                self._insert_fn(node.right, value)\n\n    def delete_fn(self, value: int) -> None:\n        \"\"\"\n        Delete a node with the specified value from the binary tree.\n        \n        :param value: The value of the node to delete\n        \"\"\"\n        self.root = self._delete_fn(self.root, value)\n\n    def _delete_fn(self, node: TreeNode, value: int) -> TreeNode:\n        \"\"\"\n        Helper method to recursively delete a node from the binary tree.\n        \n        :param node: Current node in the binary tree\n        :param value: The value of the node to delete\n        :returns: The root of the modified subtree\n        \"\"\"\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete_fn(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_fn(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            temp = self._min_value_node_fn(node.right)\n            node.value = temp.value\n            node.right = self._delete_fn(node.right, temp.value)\n\n        return node\n\n    def _min_value_node_fn(self, node: TreeNode) -> TreeNode:\n        \"\"\"\n        Get the node with the lowest value in the given subtree.\n        \n        :param node: The root of the subtree\n        :returns: The node with the minimum value\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ]
    }
  ]
}