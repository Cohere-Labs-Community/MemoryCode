{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_book(self, book: str) -> None:\n        self.books.append(book)\n\n    @validate\n    def remove_book(self, book: str) -> None:\n        if book in self.books:\n            self.books.remove(book)\n\n    def list_books(self) -> list:\n        return self.books\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    merged_x = []\n    i_x, j_x = 0, 0\n\n    while i_x < len(list1_x) and j_x < len(list2_x):\n        if list1_x[i_x] < list2_x[j_x]:\n            merged_x.append(list1_x[i_x])\n            i_x += 1\n        else:\n            merged_x.append(list2_x[j_x])\n            j_x += 1\n\n    merged_x.extend(list1_x[i_x:])\n    merged_x.extend(list2_x[j_x:])\n    \n    return merged_x\n```",
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BINARY_IMAGE_CLASSIFIER(nn.Module):\n    def __init__(self, input_size_x, hidden_size_x, output_size_x):\n        super(BINARY_IMAGE_CLASSIFIER, self).__init__()\n        self.fc1_x = nn.Linear(input_size_x, hidden_size_x)\n        self.fc2_x = nn.Linear(hidden_size_x, output_size_x)\n\n    def forward(self, x):\n        x = F.relu(self.fc1_x(x))\n        x = torch.sigmoid(self.fc2_x(x))\n        return x\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i_x, j_x = 0, 0\n    \n    while i_x < len(list1_x) and j_x < len(list2_x):\n        if list1_x[i_x] < list2_x[j_x]:\n            merged_list.append(list1_x[i_x])\n            i_x += 1\n        else:\n            merged_list.append(list2_x[j_x])\n            j_x += 1\n\n    while i_x < len(list1_x):\n        merged_list.append(list1_x[i_x])\n        i_x += 1\n\n    while j_x < len(list2_x):\n        merged_list.append(list2_x[j_x])\n        j_x += 1\n\n    return merged_list\n```",
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BINARY_IMAGE_CLASSIFIER(nn.Module):\n    def __init__(self, input_channels):\n        super(BINARY_IMAGE_CLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(input_channels, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.dropout = nn.Dropout(0.5)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(x.size(0), -1)\n        x = self.dropout(x)\n        x = F.relu(self.fc1(x))\n        x = torch.sigmoid(self.fc2(x))\n        return x\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_md(list1_f, list2_f):\n    merged_list_f = []\n    i_f, j_f = 0, 0\n\n    while i_f < len(list1_f) and j_f < len(list2_f):\n        if list1_f[i_f] < list2_f[j_f]:\n            merged_list_f.append(list1_f[i_f])\n            i_f += 1\n        else:\n            merged_list_f.append(list2_f[j_f])\n            j_f += 1\n\n    while i_f < len(list1_f):\n        merged_list_f.append(list1_f[i_f])\n        i_f += 1\n\n    while j_f < len(list2_f):\n        merged_list_f.append(list2_f[j_f])\n        j_f += 1\n\n    return merged_list_f\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_md(self, start_node_f, end_node_f, weight_f):\n        if start_node_f not in self.adjacency_list:\n            self.adjacency_list[start_node_f] = []\n        if end_node_f not in self.adjacency_list:\n            self.adjacency_list[end_node_f] = []\n        self.adjacency_list[start_node_f].append((end_node_f, weight_f))\n\n    def shortest_path_md(self, start_node_f, end_node_f):\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start_node_f] = 0\n        priority_queue = [(0, start_node_f)]\n        \n        while priority_queue:\n            current_distance_f, current_node_f = heapq.heappop(priority_queue)\n            \n            if current_distance_f > distances[current_node_f]:\n                continue\n            \n            for neighbor_f, weight_f in self.adjacency_list[current_node_f]:\n                distance = current_distance_f + weight_f\n                if distance < distances[neighbor_f]:\n                    distances[neighbor_f] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor_f))\n        \n        return distances[end_node_f] if distances[end_node_f] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    merged_list.extend(list1_f[i:])\n    merged_list.extend(list2_f[j:])\n    return merged_list\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adj_list = {}\n\n    def add_edge_ud(self, src, dest, weight):\n        if src not in self.adj_list:\n            self.adj_list[src] = []\n        if dest not in self.adj_list:\n            self.adj_list[dest] = []\n        self.adj_list[src].append((dest, weight))\n        self.adj_list[dest].append((src, weight))\n\n    def shortest_path_ud(self, start, end):\n        queue = [(0, start)]\n        distances = {node: float('infinity') for node in self.adj_list}\n        distances[start] = 0\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node == end:\n                return current_distance\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.adj_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n        return float('infinity')\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix_a(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n\n    :param strs: List[str] - A list of strings\n    :return: str - The longest common prefix\n\n    Example:\n    >>> longest_common_prefix_a([\"flower\", \"flow\", \"flight\"])\n    'fl'\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]\n    \n    return prefix\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_a(self, node_a, node_b, weight):\n        \"\"\"\n        Adds an edge between node_a and node_b with the given weight.\n\n        Args:\n            node_a: The starting node of the edge.\n            node_b: The ending node of the edge.\n            weight: The weight of the edge.\n        \"\"\"\n        if node_a not in self.adjacency_list:\n            self.adjacency_list[node_a] = []\n        if node_b not in self.adjacency_list:\n            self.adjacency_list[node_b] = []\n        self.adjacency_list[node_a].append((node_b, weight))\n        self.adjacency_list[node_b].append((node_a, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        \"\"\"\n        Computes the shortest path from start_node to end_node using Dijkstra's algorithm.\n\n        Args:\n            start_node: The node from which to start the path.\n            end_node: The node at which to end the path.\n\n        Returns:\n            A tuple containing the total weight of the shortest path \n            and a list of nodes representing the path.\n        \"\"\"\n        queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        previous_nodes = {node: None for node in self.adjacency_list}\n        distances[start_node] = 0\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_node == end_node:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = previous_nodes[current_node]\n                return current_distance, path[::-1]\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return float('inf'), []\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        \n    def add_node_a(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        import heapq\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        visited = set()\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('infinity') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom pedantic import validate\n\nclass LIBRARY:\n    \n    def __init__(self):\n        self.books = []\n    \n    @validate\n    def add_book_a(self, book_f):\n        \"\"\"\n        Adds a book to the library collection.\n\n        :param book_f: The book to be added to the library.\n        \"\"\"\n        self.books.append(book_f)\n    \n    @validate\n    def remove_book_a(self, book_f):\n        \"\"\"\n        Removes a book from the library collection if it exists.\n\n        :param book_f: The book to be removed from the library.\n        \"\"\"\n        if book_f in self.books:\n            self.books.remove(book_f)\n```\n",
        "```python\nfrom torch import nn\nfrom pedantic import validate\n\nclass BINARYIMAGECLASSIFIER(nn.Module):\n    @validate\n    def __init__(self):\n        super(BINARYIMAGECLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=1, padding=1)\n        self.relu = nn.ReLU()\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    @validate\n    def forward_a(self, x_f):\n        x_f = self.pool(self.relu(self.conv1(x_f)))\n        x_f = self.pool(self.relu(self.conv2(x_f)))\n        x_f = x_f.view(x_f.size(0), -1)\n        x_f = self.relu(self.fc1(x_f))\n        x_f = self.sigmoid(self.fc2(x_f))\n        return x_f\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef merge_sorted_lists_a(list1_f, list2_f):\n    \"\"\"\n    Merge two sorted lists into a single sorted list.\n    \n    Args:\n        list1_f: A sorted list of comparable elements.\n        list2_f: A sorted list of comparable elements.\n        \n    Returns:\n        A new sorted list containing all elements from list1_f and list2_f.\n    \"\"\"\n    merged_list_x = []\n    i_f, j_f = 0, 0\n    while i_f < len(list1_f) and j_f < len(list2_f):\n        if list1_f[i_f] < list2_f[j_f]:\n            merged_list_x.append(list1_f[i_f])\n            i_f += 1\n        else:\n            merged_list_x.append(list2_f[j_f])\n            j_f += 1\n    while i_f < len(list1_f):\n        merged_list_x.append(list1_f[i_f])\n        i_f += 1\n    while j_f < len(list2_f):\n        merged_list_x.append(list2_f[j_f])\n        j_f += 1\n    return merged_list_x\n```",
        "```python\nfrom pedantic import validate\n\nclass PREFIX_FINDER:\n    @validate\n    def find_longest_common_prefix_a(self, strs_f):\n        if not strs_f:\n            return \"\"\n        \n        prefix = strs_f[0]\n        for s_f in strs_f[1:]:\n            while not s_f.startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix\n```\n",
        "```python\nfrom pedantic import validate\nimport heapq\n\nclass GRAPH:\n    def __init__(self):\n        self.nodes = {}\n    \n    @validate\n    def add_node_md(self, node_f):\n        if node_f not in self.nodes:\n            self.nodes[node_f] = set()\n    \n    @validate\n    def add_edge_md(self, node1_f, node2_f, weight_f):\n        if node1_f in self.nodes and node2_f in self.nodes:\n            self.nodes[node1_f].add((node2_f, weight_f))\n            self.nodes[node2_f].add((node1_f, weight_f))\n    \n    @validate\n    def shortest_path_a(self, start_f, end_f):\n        if start_f not in self.nodes or end_f not in self.nodes:\n            return float('inf'), []\n        \n        queue_f = [(0, start_f, [])]\n        visited_f = set()\n\n        while queue_f:\n            (cost_f, node_f, path_f) = heapq.heappop(queue_f)\n            \n            if node_f in visited_f:\n                continue\n            \n            visited_f.add(node_f)\n            path_f = path_f + [node_f]\n            \n            if node_f == end_f:\n                return cost_f, path_f\n            \n            for neighbor_f, weight_f in self.nodes[node_f]:\n                if neighbor_f not in visited_f:\n                    heapq.heappush(queue_f, (cost_f + weight_f, neighbor_f, path_f))\n        \n        return float('inf'), []\n\n```"
      ]
    }
  ]
}