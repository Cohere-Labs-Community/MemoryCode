{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_b(self, source, destination, weight):\n        if source not in self.adjacency_list:\n            self.adjacency_list[source] = []\n        if destination not in self.adjacency_list:\n            self.adjacency_list[destination] = []\n        self.adjacency_list[source].append((destination, weight))\n        self.adjacency_list[destination].append((source, weight))  # For undirected graphs\n\n    def shortest_path_b(self, start, end):\n        min_heap = []\n        heapq.heappush(min_heap, (0, start))\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while min_heap:\n            current_distance, current_node = heapq.heappop(min_heap)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(min_heap, (distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_b = {}\n\n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.nodes_b:\n            self.nodes_b[from_node] = []\n        if to_node not in self.nodes_b:\n            self.nodes_b[to_node] = []\n        self.nodes_b[from_node].append((to_node, weight))\n        self.nodes_b[to_node].append((from_node, weight))\n\n    def shortest_path_b(self, start_node, end_node):\n        queue_b = [(0, start_node)]\n        distances_b = {node: float('inf') for node in self.nodes_b}\n        distances_b[start_node] = 0\n        visited_b = set()\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n\n            if current_node_b in visited_b:\n                continue\n\n            visited_b.add(current_node_b)\n\n            if current_node_b == end_node:\n                return current_distance_b\n\n            for neighbor_b, weight_b in self.nodes_b[current_node_b]:\n                distance_b = current_distance_b + weight_b\n\n                if distance_b < distances_b[neighbor_b]:\n                    distances_b[neighbor_b] = distance_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_b))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self_b):\n        self_b.nodes = {}\n\n    def add_node_b(self_b, value_b):\n        self_b.nodes[value_b] = []\n\n    def add_edge_b(self_b, from_node_b, to_node_b, weight_b):\n        if from_node_b in self_b.nodes and to_node_b in self_b.nodes:\n            self_b.nodes[from_node_b].append((to_node_b, weight_b))\n            self_b.nodes[to_node_b].append((from_node_b, weight_b))\n\n    def shortest_path_b(self_b, start_b, end_b):\n        queue_b = [(0, start_b)]\n        distances_b = {node_b: float('inf') for node_b in self_b.nodes}\n        distances_b[start_b] = 0\n        previous_nodes_b = {node_b: None for node_b in self_b.nodes}\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n\n            if current_distance_b > distances_b[current_node_b]:\n                continue\n\n            for neighbor_b, weight_b in self_b.nodes[current_node_b]:\n                distance_b = current_distance_b + weight_b\n\n                if distance_b < distances_b[neighbor_b]:\n                    distances_b[neighbor_b] = distance_b\n                    previous_nodes_b[neighbor_b] = current_node_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_b))\n\n        path_b, current_node_b = [], end_b\n        while previous_nodes_b[current_node_b] is not None:\n            path_b.append(current_node_b)\n            current_node_b = previous_nodes_b[current_node_b]\n        if path_b:\n            path_b.append(start_b)\n            path_b.reverse()\n        return path_b\n```"
      ]
    }
  ]
}