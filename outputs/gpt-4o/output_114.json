{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef d_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations, 1):\n        if citation >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef d_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, value: int) -> None:\n        self.value: int = value\n        self.left: Optional['TreeNode'] = None\n        self.right: Optional['TreeNode'] = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: Optional[TreeNode] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = TreeNode(value)\n        else:\n            self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node: TreeNode, value: int) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = TreeNode(value)\n            else:\n                self._insert_recursive(node.left, value)\n        else:\n            if node.right is None:\n                node.right = TreeNode(value)\n            else:\n                self._insert_recursive(node.right, value)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node: Optional[TreeNode], value: int) -> Optional[TreeNode]:\n        if node is None:\n            return None\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            min_larger_node = self._find_min(node.right)\n            node.value = min_larger_node.value\n            node.right = self._delete_recursive(node.right, min_larger_node.value)\n        return node\n\n    def _find_min(self, node: TreeNode) -> TreeNode:\n        while node.left:\n            node = node.left\n        return node\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom pedantic import timer\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self):\n        super(BinaryImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n        self.fc1 = nn.Linear(in_features=32 * 8 * 8, out_features=128)\n        self.fc2 = nn.Linear(in_features=128, out_features=1)\n\n    @timer()\n    def forward(self, x):\n        x = self.conv1(x)\n        x = F.relu(x)\n        x = F.max_pool2d(x, 2)\n        x = self.conv2(x)\n        x = F.relu(x)\n        x = F.max_pool2d(x, 2)\n        x = x.view(x.size(0), -1)\n        x = self.fc1(x)\n        x = F.relu(x)\n        x = self.fc2(x)\n        x = torch.sigmoid(x)\n        return x\n```",
        "```python\nfrom pedantic import timer\n\nclass ListNode:\n    def __init__(self, value=0, next_node=None):\n        self.value = value\n        self.next = next_node\n\n@timer\ndef hasCycle(head: ListNode) -> bool:\n    slow_pointer = head\n    fast_pointer = head\n\n    while fast_pointer and fast_pointer.next:\n        slow_pointer = slow_pointer.next\n        fast_pointer = fast_pointer.next.next\n        if slow_pointer == fast_pointer:\n            return True\n\n    return False\n```"
      ],
      "instruction_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self, num_channels):\n        super(BinaryImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(x.size(0), -1)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        x = self.sigmoid(x)\n        return x\n```",
        "```python\nfrom pedantic import timer\n\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\n@timer\ndef has_cycle(head: ListNode) -> bool:\n    slow, fast = head, head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n\n    return False\n```"
      ],
      "history_model_output": [
        "```python\nfrom pedantic import timer\n\nclass BinaryTreeNode:\n    def __init__(self, value: int) -> None:\n        self.value: int = value\n        self.left: BinaryTreeNode | None = None\n        self.right: BinaryTreeNode | None = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: BinaryTreeNode | None = None\n\n    @timer\n    def d_insert(self, value: int) -> None:\n        if self.root is None:\n            self.root = BinaryTreeNode(value)\n        else:\n            self._d_insert_recursively(self.root, value)\n\n    def _d_insert_recursively(self, node: BinaryTreeNode, value: int) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = BinaryTreeNode(value)\n            else:\n                self._d_insert_recursively(node.left, value)\n        else:\n            if node.right is None:\n                node.right = BinaryTreeNode(value)\n            else:\n                self._d_insert_recursively(node.right, value)\n\n    @timer\n    def d_delete(self, value: int) -> None:\n        self.root = self._d_delete_recursively(self.root, value)\n\n    def _d_delete_recursively(self, node: BinaryTreeNode | None, value: int) -> BinaryTreeNode | None:\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._d_delete_recursively(node.left, value)\n        elif value > node.value:\n            node.right = self._d_delete_recursively(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._get_min(node.right)\n            node.value = min_larger_node.value\n            node.right = self._d_delete_recursively(node.right, min_larger_node.value)\n\n        return node\n\n    def _get_min(self, node: BinaryTreeNode) -> BinaryTreeNode:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nimport torch\nimport torch.nn as nn\nfrom pedantic import timer\n\nclass DImageClassifier(nn.Module):\n    def __init__(self):\n        super(DImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1)\n        self.relu = nn.ReLU()\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n        self.fc1 = nn.Linear(32 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    @timer\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.conv1(x)\n        x = self.relu(x)\n        x = self.pool(x)\n        x = self.conv2(x)\n        x = self.relu(x)\n        x = self.pool(x)\n        x = x.view(x.size(0), -1)\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return self.sigmoid(x)\n```",
        "```python\nfrom typing import Optional\n\n# Assuming 'pedantic' module and '@timer' decorator are available in the project environment\nfrom pedantic import timer\n\nclass ListNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.next: Optional['ListNode'] = None\n\n@timer\ndef d_has_cycle(head: Optional[ListNode]) -> bool:\n    slow_pointer = head\n    fast_pointer = head\n\n    while fast_pointer and fast_pointer.next:\n        slow_pointer = slow_pointer.next\n        fast_pointer = fast_pointer.next.next\n\n        if slow_pointer == fast_pointer:\n            return True\n\n    return False\n```",
        "```python\nfrom typing import List\nfrom pedantic import timer\n\n@timer\ndef d_computeHIndex(citations: List[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ]
    }
  ]
}