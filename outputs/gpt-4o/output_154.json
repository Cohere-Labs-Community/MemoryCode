{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, q_capacity: int):\n        self.q_capacity = q_capacity\n        self.q_cache = OrderedDict()\n\n    def get(self, q_key: int) -> int:\n        if q_key not in self.q_cache:\n            return -1\n        self.q_cache.move_to_end(q_key)\n        return self.q_cache[q_key]\n\n    def put(self, q_key: int, q_value: int) -> None:\n        if q_key in self.q_cache:\n            self.q_cache.move_to_end(q_key)\n        self.q_cache[q_key] = q_value\n        if len(self.q_cache) > self.q_capacity:\n            self.q_cache.popitem(last=False)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n            self.q_order.append(key)\n            return self.q_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n        elif len(self.q_cache) >= self.q_capacity:\n            lru_key = self.q_order.pop(0)\n            del self.q_cache[lru_key]\n        self.q_cache[key] = value\n        self.q_order.append(key)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, xt_key=None, xt_value=None):\n        self.xt_key = xt_key\n        self.xt_value = xt_value\n        self.xt_prev = None\n        self.xt_next = None\n\nclass LRUCache:\n    def __init__(self, xt_capacity: int):\n        self.xt_capacity = xt_capacity\n        self.xt_cache = {}\n        self.xt_head = Node()\n        self.xt_tail = Node()\n        self.xt_head.xt_next = self.xt_tail\n        self.xt_tail.xt_prev = self.xt_head\n\n    def _remove(self, xt_node: Node):\n        xt_prev_node = xt_node.xt_prev\n        xt_next_node = xt_node.xt_next\n        xt_prev_node.xt_next = xt_next_node\n        xt_next_node.xt_prev = xt_prev_node\n\n    def _add_to_head(self, xt_node: Node):\n        xt_node.xt_next = self.xt_head.xt_next\n        xt_node.xt_prev = self.xt_head\n        self.xt_head.xt_next.xt_prev = xt_node\n        self.xt_head.xt_next = xt_node\n\n    def get(self, xt_key: int) -> int:\n        xt_node = self.xt_cache.get(xt_key)\n        if not xt_node:\n            return -1\n        self._remove(xt_node)\n        self._add_to_head(xt_node)\n        return xt_node.xt_value\n\n    def put(self, xt_key: int, xt_value: int):\n        if xt_key in self.xt_cache:\n            self._remove(self.xt_cache[xt_key])\n        new_node = Node(xt_key, xt_value)\n        self._add_to_head(new_node)\n        self.xt_cache[xt_key] = new_node\n        if len(self.xt_cache) > self.xt_capacity:\n            lru_node = self.xt_tail.xt_prev\n            self._remove(lru_node)\n            del self.xt_cache[lru_node.xt_key]\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = {}\n        self.xt_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.xt_cache:\n            self.xt_order.remove(key)\n            self.xt_order.append(key)\n            return self.xt_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_order.remove(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            lru_key = self.xt_order.pop(0)\n            del self.xt_cache[lru_key]\n        \n        self.xt_cache[key] = value\n        self.xt_order.append(key)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, i_key: int, i_value: int):\n        self.i_key = i_key\n        self.i_value = i_value\n        self.i_prev = None\n        self.i_next = None\n\nclass LRUCache:\n    def __init__(self, i_capacity: int):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_head = Node(0, 0)\n        self.i_tail = Node(0, 0)\n        self.i_head.i_next = self.i_tail\n        self.i_tail.i_prev = self.i_head\n\n    def get(self, i_key: int) -> int:\n        node = self.i_cache.get(i_key, None)\n        if not node:\n            return -1\n        self._remove(node)\n        self._add(node)\n        return node.i_value\n\n    def put(self, i_key: int, i_value: int) -> None:\n        node = self.i_cache.get(i_key)\n        if node:\n            self._remove(node)\n        node = Node(i_key, i_value)\n        self._add(node)\n        self.i_cache[i_key] = node\n        if len(self.i_cache) > self.i_capacity:\n            lru = self.i_head.i_next\n            self._remove(lru)\n            del self.i_cache[lru.i_key]\n\n    def _remove(self, node: Node):\n        i_prev = node.i_prev\n        i_next = node.i_next\n        i_prev.i_next = i_next\n        i_next.i_prev = i_prev\n\n    def _add(self, node: Node):\n        i_prev = self.i_tail.i_prev\n        i_prev.i_next = node\n        node.i_prev = i_prev\n        node.i_next = self.i_tail\n        self.i_tail.i_prev = node\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, i_capacity: int):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_order = []\n\n    def get(self, i_key: int) -> int:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n            self.i_order.append(i_key)\n            return self.i_cache[i_key]\n        return -1\n\n    def put(self, i_key: int, i_value: int) -> None:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n        elif len(self.i_cache) == self.i_capacity:\n            oldest_key = self.i_order.pop(0)\n            del self.i_cache[oldest_key]\n        \n        self.i_cache[i_key] = i_value\n        self.i_order.append(i_key)\n```\n"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport mailbox\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, s_capacity: int):\n        self.s_capacity = s_capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, s_key: int) -> int:\n        if s_key in self.s_cache:\n            self.s_cache.move_to_end(s_key)\n            return self.s_cache[s_key]\n        return -1\n\n    def put(self, s_key: int, s_value: int) -> None:\n        if s_key in self.s_cache:\n            self.s_cache.move_to_end(s_key)\n        self.s_cache[s_key] = s_value\n        if len(self.s_cache) > self.s_capacity:\n            self.s_cache.popitem(last=False)\n```",
        "```python\nimport mailbox\n\nclass TreeNode:\n    def __init__(self, s_value=0, s_left=None, s_right=None):\n        self.s_value = s_value\n        self.s_left = s_left\n        self.s_right = s_right\n\ndef deleteNode(s_root, s_key):\n    if not s_root:\n        return s_root\n\n    if s_key < s_root.s_value:\n        s_root.s_left = deleteNode(s_root.s_left, s_key)\n    elif s_key > s_root.s_value:\n        s_root.s_right = deleteNode(s_root.s_right, s_key)\n    else:\n        if not s_root.s_left:\n            return s_root.s_right\n        elif not s_root.s_right:\n            return s_root.s_left\n      \n        temp_val = findMinValue(s_root.s_right)\n        s_root.s_value = temp_val\n        s_root.s_right = deleteNode(s_root.s_right, s_root.s_value)\n    \n    return s_root\n\ndef findMinValue(s_node):\n    current = s_node\n    while current.s_left:\n        current = current.s_left\n    return current.s_value\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = {}\n        self.s_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n            self.s_order.append(key)\n            return self.s_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            oldest_key = self.s_order.pop(0)\n            del self.s_cache[oldest_key]\n        self.s_cache[key] = value\n        self.s_order.append(key)\n```",
        "```python\nimport mailbox\n\nclass TreeNode:\n    def __init__(self, key, left=None, right=None):\n        self.key = key\n        self.left = left\n        self.right = right\n\ndef delete_node(root, key):\n    if not root:\n        return root\n    \n    if key < root.key:\n        root.left = delete_node(root.left, key)\n    elif key > root.key:\n        root.right = delete_node(root.right, key)\n    else:\n        if not root.left:\n            return root.right\n        elif not root.right:\n            return root.left\n\n        min_larger_node = find_min(root.right)\n        root.key = min_larger_node.key\n        root.right = delete_node(root.right, min_larger_node.key)\n    \n    return root\n\ndef find_min(node):\n    current = node\n    while current.left:\n        current = current.left\n    return current\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman(r_num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    Parameters:\n    - r_num: int - The integer to be converted to a Roman numeral.\n\n    Returns:\n    - str: The Roman numeral representation of the integer.\n    \"\"\"\n    # Dictionary mapping integer values to their corresponding Roman numeral symbols\n    r_val_maps = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\")\n    ]\n\n    # Construct the Roman numeral from the given number\n    r_num_result = []\n    for r_value, r_symbol in r_val_maps:\n        r_count = r_num // r_value\n        r_num_result.append(r_symbol * r_count)\n        r_num -= r_value * r_count\n\n    return ''.join(r_num_result)\n```\n",
        "```python\nclass Node:\n    def __init__(self, key, value):\n        self.r_key = key\n        self.r_value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, r_capacity: int):\n        self.r_capacity = r_capacity\n        self.r_cache = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, r_key: int) -> int:\n        if r_key in self.r_cache:\n            node = self.r_cache[r_key]\n            self._remove(node)\n            self._add(node)\n            return node.r_value\n        return -1\n\n    def put(self, r_key: int, r_value: int) -> None:\n        if r_key in self.r_cache:\n            self._remove(self.r_cache[r_key])\n        node = Node(r_key, r_value)\n        self._add(node)\n        self.r_cache[r_key] = node\n        if len(self.r_cache) > self.r_capacity:\n            lru = self.head.next\n            self._remove(lru)\n            del self.r_cache[lru.r_key]\n\n    def _remove(self, node: Node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add(self, node: Node):\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.prev = prev_node\n        node.next = self.tail\n        self.tail.prev = node\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, r_capacity: int):\n        self.r_cache = OrderedDict()\n        self.r_capacity = r_capacity\n\n    def get(self, r_key: int) -> int:\n        if r_key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(r_key)\n        return self.r_cache[r_key]\n\n    def put(self, r_key: int, r_value: int) -> None:\n        if r_key in self.r_cache:\n            self.r_cache.move_to_end(r_key)\n        self.r_cache[r_key] = r_value\n        if len(self.r_cache) > self.r_capacity:\n            self.r_cache.popitem(last=False)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_book(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_book(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "history_model_output": [
        "```python\nimport mailbox\nfrom collections import OrderedDict\nfrom pedantic import validate\n\nclass LRUCache:\n    def __init__(self, s_capacity: int):\n        self.s_capacity = s_capacity\n        self.s_cache = OrderedDict()\n\n    @validate\n    def get(self, r_key: int) -> int:\n        if r_key not in self.s_cache:\n            return -1\n        self.s_cache.move_to_end(r_key)\n        return self.s_cache[r_key]\n\n    @validate\n    def put(self, r_key: int, r_value: int) -> None:\n        if r_key in self.s_cache:\n            self.s_cache.move_to_end(r_key)\n        self.s_cache[r_key] = r_value\n        if len(self.s_cache) > self.s_capacity:\n            self.s_cache.popitem(last=False)\n```",
        "```python\nimport mailbox\nfrom pedantic import validate\n\n@validate\nclass TreeNode:\n    def __init__(self, r_value: int = 0, r_left: 'TreeNode' = None, r_right: 'TreeNode' = None):\n        self.r_value = r_value\n        self.r_left = r_left\n        self.r_right = r_right\n\n@validate\ndef delete_node(root: TreeNode, r_key: int) -> TreeNode:\n    if root is None:\n        return root\n\n    if r_key < root.r_value:\n        root.r_left = delete_node(root.r_left, r_key)\n    elif r_key > root.r_value:\n        root.r_right = delete_node(root.r_right, r_key)\n    else:\n        if root.r_left is None:\n            return root.r_right\n        elif root.r_right is None:\n            return root.r_left\n\n        # Node with two children: Get the inorder successor (smallest in the right subtree).\n        temp = min_value_node(root.r_right)\n\n        root.r_value = temp.r_value\n\n        root.r_right = delete_node(root.r_right, temp.r_value)\n\n    return root\n\n@validate\ndef min_value_node(node: TreeNode) -> TreeNode:\n    current = node\n    while current.r_left is not None:\n        current = current.r_left\n    return current\n```",
        "```python\nimport mailbox\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.r_books = []\n\n    @validate\n    def add_books(self, s_book: str) -> None:\n        self.r_books.append(s_book)\n\n    @validate\n    def remove_books(self, s_book: str) -> None:\n        if s_book in self.r_books:\n            self.r_books.remove(s_book)\n```\n",
        "```python\nimport mailbox\nfrom pedantic import validate\n\nclass IntegerToRomanConverter:\n    @validate\n    def r_int_to_roman(self, i_num: int) -> str:\n        i_val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        r_sym = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        r_roman_num = ''\n        r_i = 0\n        while i_num > 0:\n            i_for = i_num // i_val[r_i]\n            r_roman_num += r_sym[r_i] * i_for\n            i_num %= i_val[r_i]\n            r_i += 1\n        return r_roman_num\n```\n"
      ]
    }
  ]
}