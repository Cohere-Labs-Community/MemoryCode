{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nfrom scipy.spatial import distance\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, k=3):\n        assert k > 0, \"Number of neighbors k must be a positive integer.\"\n        self.k = k\n        self.training_data = None\n        self.training_labels = None\n\n    def train(self, data, labels):\n        assert isinstance(data, np.ndarray), \"Training data should be a NumPy array.\"\n        assert isinstance(labels, np.ndarray), \"Training labels should be a NumPy array.\"\n        assert len(data) == len(labels), \"The number of data points and labels must be the same.\"\n        self.training_data = data\n        self.training_labels = labels\n\n    def predict(self, point):\n        assert self.training_data is not None and self.training_labels is not None, \"Model must be trained before making predictions.\"\n        assert isinstance(point, np.ndarray), \"Input point should be a NumPy array.\"\n        \n        distances = []\n        for i, data_point in enumerate(self.training_data):\n            dist = distance.euclidean(point, data_point)\n            distances.append((dist, self.training_labels[i]))\n        \n        sorted_distances = sorted(distances, key=lambda x: x[0])\n        nearest_neighbors_labels = [label for _, label in sorted_distances[:self.k]]\n        most_common_label, _ = Counter(nearest_neighbors_labels).most_common(1)[0]\n        \n        return most_common_label\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.t_w1 = None\n        self.t_b1 = None\n\n    def fit(self, t_X1, t_y1):\n        n_samples, n_features = t_X1.shape\n        t_X1_b1 = np.c_[np.ones((n_samples, 1)), t_X1]\n        t_theta1_best = np.linalg.inv(t_X1_b1.T.dot(t_X1_b1)).dot(t_X1_b1.T).dot(t_y1)\n        self.t_b1 = t_theta1_best[0]\n        self.t_w1 = t_theta1_best[1:]\n\n    def predict(self, t_X1):\n        n_samples = t_X1.shape[0]\n        t_X1_b1 = np.c_[np.ones((n_samples, 1)), t_X1]\n        return t_X1_b1.dot(np.r_[self.t_b1, self.t_w1])\n\n    def coefficients(self):\n        return self.t_w1, self.t_b1\n```",
        "```python\nclass Node:\n    def __init__(self, t_k1, t_v1):\n        self.t_k1 = t_k1\n        self.t_v1 = t_v1\n        self.t_prev2 = None\n        self.t_next3 = None\n\nclass LRUCache:\n    def __init__(self, t_capacity1):\n        self.t_capacity1 = t_capacity1\n        self.t_cache3 = {}\n        self.t_head1 = Node(0, 0)\n        self.t_tail2 = Node(0, 0)\n        self.t_head1.t_next3 = self.t_tail2\n        self.t_tail2.t_prev2 = self.t_head1\n\n    def _remove(self, t_node1):\n        t_prev1 = t_node1.t_prev2\n        t_next1 = t_node1.t_next3\n        t_prev1.t_next3 = t_next1\n        t_next1.t_prev2 = t_prev1\n\n    def _add(self, t_node1):\n        t_prev1 = self.t_tail2.t_prev2\n        t_prev1.t_next3 = t_node1\n        t_node1.t_prev2 = t_prev1\n        t_node1.t_next3 = self.t_tail2\n        self.t_tail2.t_prev2 = t_node1\n\n    def get(self, t_k1):\n        if t_k1 in self.t_cache3:\n            t_node1 = self.t_cache3[t_k1]\n            self._remove(t_node1)\n            self._add(t_node1)\n            return t_node1.t_v1\n        return -1\n\n    def put(self, t_k1, t_v1):\n        if t_k1 in self.t_cache3:\n            self._remove(self.t_cache3[t_k1])\n        t_node1 = Node(t_k1, t_v1)\n        self._add(t_node1)\n        self.t_cache3[t_k1] = t_node1\n        if len(self.t_cache3) > self.t_capacity1:\n            t_node1 = self.t_head1.t_next3\n            self._remove(t_node1)\n            del self.t_cache3[t_node1.t_k1]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LinRegNumpy:\n    def __init__(self):\n        self.coef1_ = None\n        self.intercept1_ = 0\n        self.fit1_intercept = True\n    \n    def fit(self, X1, y1):\n        if self.fit1_intercept:\n            X1 = np.c_[np.ones(X1.shape[0]), X1]\n        \n        X1_transpose = X1.T\n        beta1 = np.linalg.inv(X1_transpose.dot(X1)).dot(X1_transpose).dot(y1)\n        \n        if self.fit1_intercept:\n            self.intercept1_ = beta1[0]\n            self.coef1_ = beta1[1:]\n        else:\n            self.coef1_ = beta1\n    \n    def predict(self, X1):\n        if self.fit1_intercept:\n            X1 = np.c_[np.ones(X1.shape[0]), X1]\n            return X1.dot(np.r_[self.intercept1_, self.coef1_])\n        else:\n            return X1.dot(self.coef1_)\n```\n",
        "```python\nclass LRUCache:\n    def __init__(self, t_capacity: int):\n        self.t_capacity = t_capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, t_key: int) -> int:\n        if t_key not in self.t_cache:\n            return -1\n        self.t_order.remove(t_key)\n        self.t_order.append(t_key)\n        return self.t_cache[t_key]\n\n    def put(self, t_key: int, t_value: int) -> None:\n        if t_key in self.t_cache:\n            self.t_order.remove(t_key)\n        elif len(self.t_cache) >= self.t_capacity:\n            oldest_key = self.t_order.pop(0)\n            del self.t_cache[oldest_key]\n        self.t_cache[t_key] = t_value\n        self.t_order.append(t_key)\n```"
      ],
      "cumulative_model_output": [
        "```python\nclass Node:\n    def __init__(self, t_key, t_value):\n        self.t_key = t_key\n        self.t_value = t_value\n        self.t_prev = None\n        self.t_next = None\n\n\nclass LRUCache:\n    def __init__(self, t_capacity1):\n        assert isinstance(t_capacity1, int) and t_capacity1 > 0\n        self.t_capacity1 = t_capacity1\n        self.t_map1 = {}\n        self.t_head = Node(0, 0)\n        self.t_tail = Node(0, 0)\n        self.t_head.t_next = self.t_tail\n        self.t_tail.t_prev = self.t_head\n\n    def get(self, t_key1):\n        assert isinstance(t_key1, int)\n        if t_key1 in self.t_map1:\n            node = self.t_map1[t_key1]\n            self._remove(node)\n            self._add(node)\n            return node.t_value\n        return -1\n\n    def put(self, t_key1, t_value1):\n        assert isinstance(t_key1, int) and isinstance(t_value1, int)\n        if t_key1 in self.t_map1:\n            self._remove(self.t_map1[t_key1])\n        node = Node(t_key1, t_value1)\n        self._add(node)\n        self.t_map1[t_key1] = node\n        if len(self.t_map1) > self.t_capacity1:\n            lru = self.t_head.t_next\n            self._remove(lru)\n            del self.t_map1[lru.t_key]\n\n    def _remove(self, node):\n        t_prev1 = node.t_prev\n        t_next1 = node.t_next\n        t_prev1.t_next = t_next1\n        t_next1.t_prev = t_prev1\n\n    def _add(self, node):\n        t_prev1 = self.t_tail.t_prev\n        t_prev1.t_next = node\n        node.t_prev = t_prev1\n        node.t_next = self.t_tail\n        self.t_tail.t_prev = node\n```",
        "```python\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.t_w1 = None\n        self.t_b1 = None\n    \n    def fit(self, t_X1, t_y1):\n        assert len(t_X1) == len(t_y1), \"The number of samples in X and y must be equal.\"\n        n_samples, n_features = t_X1.shape\n        X_b = np.c_[np.ones((n_samples, 1)), t_X1]  # add bias term\n        theta_best = np.linalg.pinv(X_b.T.dot(X_b)).dot(X_b.T).dot(t_y1)\n        self.t_w1 = theta_best[1:]\n        self.t_b1 = theta_best[0]\n    \n    def predict(self, t_X1):\n        assert self.t_w1 is not None and self.t_b1 is not None, \"Model is not fitted yet.\"\n        return t_X1.dot(self.t_w1) + self.t_b1\n    \n    def score(self, t_X1, t_y1):\n        assert len(t_X1) == len(t_y1), \"The number of samples in X and y must be equal.\"\n        t_y_pred1 = self.predict(t_X1)\n        u = np.sum((t_y1 - t_y_pred1) ** 2)\n        v = np.sum((t_y1 - np.mean(t_y1)) ** 2)\n        return 1 - u / v\n```",
        "```python\nimport numpy as np\nfrom collections import Counter\n\nclass NearestNeighborsModel:\n    def __init__(self, t_k1=3):\n        assert t_k1 > 0, \"t_k1 must be a positive integer\"\n        self.t_k1 = t_k1\n        self.t_data1 = None\n        self.t_labels1 = None\n    \n    def train(self, t_data2, t_labels2):\n        assert isinstance(t_data2, np.ndarray), \"t_data2 must be a numpy array\"\n        assert isinstance(t_labels2, np.ndarray), \"t_labels2 must be a numpy array\"\n        assert t_data2.shape[0] == t_labels2.shape[0], \"Number of samples in t_data2 and t_labels2 must be equal\"\n        \n        self.t_data1 = t_data2\n        self.t_labels1 = t_labels2\n    \n    def predict(self, t_data3):\n        assert self.t_data1 is not None and self.t_labels1 is not None, \"Model must be trained before predicting\"\n        assert isinstance(t_data3, np.ndarray), \"t_data3 must be a numpy array\"\n        \n        predictions = []\n        for point in t_data3:\n            distances = np.linalg.norm(self.t_data1 - point, axis=1)\n            nearest_indices = np.argsort(distances)[:self.t_k1]\n            nearest_labels = self.t_labels1[nearest_indices]\n            most_common_count = Counter(nearest_labels).most_common(1)\n            predictions.append(most_common_count[0][0])\n        \n        return np.array(predictions)\n```"
      ]
    }
  ]
}