{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef merge_sort_gn(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_half = array[:mid]\n        right_half = array[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                array[k] = left_half[i]\n                i += 1\n            else:\n                array[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            array[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            array[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_gn(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_b(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_b(self, start, end):\n        distances = {node: float('infinity') for node in self.adjacency_list}\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        came_from = {start: None}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    came_from[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path, current = [], end\n        while current is not None:\n            path.append(current)\n            current = came_from[current]\n        path.reverse()\n\n        if distances[end] == float('infinity'):\n            return None  # No path found\n\n        return path, distances[end]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_b = {}\n\n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.nodes_b:\n            self.nodes_b[from_node] = []\n        if to_node not in self.nodes_b:\n            self.nodes_b[to_node] = []\n        self.nodes_b[from_node].append((to_node, weight))\n        self.nodes_b[to_node].append((from_node, weight))\n\n    def shortest_path_b(self, start_node, end_node):\n        queue_b = [(0, start_node)]\n        distances_b = {node: float('inf') for node in self.nodes_b}\n        distances_b[start_node] = 0\n        visited_b = set()\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n\n            if current_node_b in visited_b:\n                continue\n\n            visited_b.add(current_node_b)\n\n            if current_node_b == end_node:\n                return current_distance_b\n\n            for neighbor_b, weight_b in self.nodes_b[current_node_b]:\n                distance_b = current_distance_b + weight_b\n\n                if distance_b < distances_b[neighbor_b]:\n                    distances_b[neighbor_b] = distance_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_b))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with the given key.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert_a(self, key):\n        \"\"\"Insert a node with the given key into the binary tree.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_a(self.root, key)\n    \n    def _insert_a(self, node, key):\n        \"\"\"Helper method to insert a node with the given key.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_a(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_a(node.right, key)\n\n    def delete_a(self, key):\n        \"\"\"Delete a node with the given key from the binary tree.\"\"\"\n        self.root = self._delete_a(self.root, key)\n\n    def _delete_a(self, node, key):\n        \"\"\"Helper method to delete a node with the given key.\"\"\"\n        if node is None:\n            return node\n        \n        if key < node.val:\n            node.left = self._delete_a(node.left, key)\n        elif key > node.val:\n            node.right = self._delete_a(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            \n            min_larger_node = self._min_value_node_a(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete_a(node.right, min_larger_node.val)\n        \n        return node\n\n    def _min_value_node_a(self, node):\n        \"\"\"Get the smallest node in the subtree rooted at the given node.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        \"\"\"Initialize an empty graph with a dictionary to store edges.\"\"\"\n        self.edges = {}\n\n    def add_edge_a(self, from_node, to_node, weight):\n        \"\"\"Add an edge with a weight to the graph.\n        \n        Args:\n            from_node: The starting node of the edge.\n            to_node: The ending node of the edge.\n            weight: The weight of the edge.\n        \"\"\"\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        self.edges[from_node].append((to_node, weight))\n        \n        if to_node not in self.edges:\n            self.edges[to_node] = []  # Ensure the to_node is in the graph as well\n\n    def shortest_path_a(self, start, end):\n        \"\"\"Compute the shortest path from the start node to the end node using Dijkstra's algorithm.\n        \n        Args:\n            start: The node to start from.\n            end: The target node where the path ends.\n        \n        Returns:\n            A tuple containing the total cost to reach the end node and the path as a list of nodes.\n            Returns (float('inf'), []) if no path exists.\n        \"\"\"\n        heap = [(0, start, [])]\n        visited = set()\n\n        while heap:\n            (cost, node, path) = heapq.heappop(heap)\n\n            if node in visited:\n                continue\n\n            visited.add(node)\n            path = path + [node]\n\n            if node == end:\n                return (cost, path)\n\n            for next_node, weight in self.edges.get(node, []):\n                if next_node not in visited:\n                    heapq.heappush(heap, (cost + weight, next_node, path))\n\n        return (float('inf'), [])\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        \n    def add_node_a(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        import heapq\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        visited = set()\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('infinity') else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport hashlib\n\ndef int_to_roman(num):\n    # Define a mapping of integer values to Roman numeral symbols\n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    \n    # Initialize an empty string to hold the resulting Roman numeral\n    result = ''\n    \n    # Iterate over the mapping, starting with the largest value\n    for (value, symbol) in roman_numerals:\n        # Continue adding symbols while the number is larger or equal to current value\n        while num >= value:\n            result += symbol\n            num -= value  # Subtract the current value from the number\n    \n    return result\n```",
        "```python\nimport hashlib\n\ndef insertion_sort(arr):\n    \"\"\"\n    Sorts an array using the insertion sort algorithm.\n    \n    Parameters:\n    arr (list): A list of elements to be sorted.\n    \n    \"\"\"\n    # Iterate through each element in the array starting from the second element\n    for i in range(1, len(arr)):\n        # Store the current element as it's the key that will be compared and inserted\n        key = arr[i]\n        # Initialize j to be one position before the current element\n        j = i - 1\n        # Move elements that are greater than the key to one position ahead of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        # Insert the key at the correct position\n        arr[j + 1] = key\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```",
        "```python\nimport hashlib\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n```\n"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    sorted_nums: List[int] = sorted(nums, reverse=True)\n    return sorted_nums[k - 1]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_fn(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n    return merge_fn(left_half, right_half)\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_ud(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_ud(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances[end_node]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_fn(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return merge_fn(left_half, right_half)\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nimport hashlib\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, key: int):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert_fn(self, key: int) -> None:\n        \"\"\"Insert a new node with the specified key into the binary tree.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_ud(self.root, key)\n\n    def _insert_ud(self, node: TreeNode, key: int) -> None:\n        \"\"\"Helper method to insert a node into the binary tree.\"\"\"\n        if key < node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_ud(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_ud(node.right, key)\n\n    def delete_fn(self, key: int) -> None:\n        \"\"\"Delete a node with the specified key from the binary tree.\"\"\"\n        self.root = self._delete_ud(self.root, key)\n\n    def _delete_ud(self, node: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        \"\"\"Helper method to delete a node from the binary tree.\"\"\"\n        if node is None:\n            return None\n\n        if key < node.key:\n            node.left = self._delete_ud(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_ud(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._get_min_ud(node.right)\n            node.key = min_larger_node.key\n            node.right = self._delete_ud(node.right, min_larger_node.key)\n        return node\n\n    def _get_min_ud(self, node: TreeNode) -> TreeNode:\n        \"\"\"Helper method to find the node with the smallest key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nimport hashlib\n\ndef insertion_sort_fn(arr: list) -> list:\n    \"\"\"\n    Sorts an array of integers using the insertion sort algorithm.\n\n    :param arr: List of integers to sort.\n    :return: A new list with the integers sorted in ascending order.\n    \"\"\"\n    # Iterate from the second element to the end of the array\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # Move elements that are greater than the key to one position ahead\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        # Place the key after the element just smaller than it.\n        arr[j + 1] = key\n    return arr\n```",
        "```python\nimport hashlib\n\ndef merge_fn(left, right):\n    \"\"\"Merge two sorted sublists into a single sorted list.\"\"\"\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    result.extend(left if left else right)\n    return result\n\ndef merge_sort_fn(collection: list) -> list:\n    \"\"\"Perform a merge sort on the input list.\"\"\"\n    if len(collection) <= 1:\n        return collection\n    mid = len(collection) // 2\n    left = merge_sort_fn(collection[:mid])\n    right = merge_sort_fn(collection[mid:])\n    return merge_fn(left, right)\n```",
        "```python\nimport hashlib\nfrom collections import defaultdict\nimport heapq\nfrom typing import Dict, List, Tuple\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = defaultdict(list)\n\n    def add_edge_fn(self, start: str, end: str, weight: int) -> None:\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))  # Assuming the graph is undirected\n\n    def dijkstra_ud(self, start: str, end: str) -> Tuple[int, List[str]]:\n        # Initialize distances and priority queue\n        distances: Dict[str, int] = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        priority_queue: List[Tuple[int, str]] = [(0, start)]\n        \n        # Initialize paths\n        previous_nodes: Dict[str, str] = {node: None for node in self.adjacency_list}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            # If we have reached the destination node\n            if current_node == end:\n                break\n\n            # If a node's distance is greater than the recorded shortest distance, continue\n            if current_distance > distances[current_node]:\n                continue\n\n            # Visit neighbors\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                # Only consider this new path if it's better\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        # Recover the shortest path\n        path: List[str] = []\n        current_step = end\n        while previous_nodes[current_step] is not None:\n            path.insert(0, current_step)\n            current_step = previous_nodes[current_step]\n        if path:\n            path.insert(0, current_step)\n        \n        return distances[end], path\n```\n",
        "```python\nimport hashlib\nfrom typing import List\n\ndef find_kth_largest_fn(nums: List[int], k: int) -> int:\n    \"\"\"\n    Finds the kth largest element in an array.\n\n    :param nums: A list of integers from which to find the kth largest element.\n    :param k: The order of the largest element to find.\n    :return: The kth largest element in the list.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k - 1]\n```",
        "```python\nimport hashlib\n\ndef int_to_roman_fn(number: int) -> str:\n    \"\"\"\n    Convert an integer to a Roman numeral.\n    \n    :param number: An integer to convert.\n    :return: A string representing the Roman numeral.\n    \"\"\"\n    # Define the mapping of integer values to Roman numeral strings\n    val_map = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    roman_numeral = ''  # Initialize the variable to store the resulting Roman numeral\n\n    # Loop through each integer-Roman numeral pair\n    for value, numeral in val_map:\n        while number >= value:\n            roman_numeral += numeral  # Append the Roman numeral to the result\n            number -= value  # Subtract the value from the number\n            \n            # Add comments to explain the process of conversion\n            # This loop continuously subtracts the largest possible value and concatenates\n            # the corresponding Roman numeral symbol until the number is reduced to zero.\n    \n    return roman_numeral  # Return the final Roman numeral string\n```\n"
      ]
    }
  ]
}