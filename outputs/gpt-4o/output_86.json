{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.model = Lasso(alpha=self.alpha)\n    \n    def train(self, X, y):\n        try:\n            self.model.fit(X, y)\n        except Exception as e:\n            print(f\"Error while training Lasso model: {e}\")\n    \n    def predict(self, X):\n        try:\n            return self.model.predict(X)\n        except Exception as e:\n            print(f\"Error while predicting with Lasso model: {e}\")\n            return np.array([])\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n    \n    def add_edge_n(self, from_node, to_node, weight):\n        assert isinstance(from_node, int), \"from_node must be an integer\"\n        assert isinstance(to_node, int), \"to_node must be an integer\"\n        assert isinstance(weight, (int, float)) and weight > 0, \"weight must be a positive number\"\n        \n        if from_node not in self.nodes:\n            self.nodes[from_node] = []\n        if to_node not in self.nodes:\n            self.nodes[to_node] = []\n\n        self.nodes[from_node].append((to_node, weight))\n    \n    def shortest_path_n(self, start_node, end_node):\n        assert isinstance(start_node, int), \"start_node must be an integer\"\n        assert isinstance(end_node, int), \"end_node must be an integer\"\n        \n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n            \n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        \n        return distances[end_node]\n```",
        "```python\ndef compute_diagonal_average_n(matrix):\n    assert isinstance(matrix, list), \"Input should be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row in the matrix should be a list.\"\n    n = len(matrix)\n    assert all(len(row) == n for row in matrix), \"Matrix should be square.\"\n\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum / n\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```",
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef compute_diagonal_average_n(matrix):\n    try:\n        assert isinstance(matrix, list), \"Input must be a list of lists.\"\n        assert all(isinstance(row, list) for row in matrix), \"Each row must be a list.\"\n        assert len(matrix) == len(matrix[0]), \"Matrix must be square.\"\n        \n        total = 0\n        for i in range(len(matrix)):\n            total += matrix[i][i]\n        \n        return total / len(matrix)\n    except AssertionError as e:\n        print(f\"AssertionError: {e}\")\n        return None\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression_n:\n    def __init__(self, alpha=1.0, tol=0.0001, max_iter=1000):\n        self.alpha = alpha\n        self.tol = tol\n        self.max_iter = max_iter\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train_n(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray)\n        assert X.ndim == 2 and y.ndim == 1\n        n_samples, n_features = X.shape\n        self.coef_ = np.zeros(n_features)\n        self.intercept_ = 0.0\n\n        for _ in range(self.max_iter):\n            y_pred = np.dot(X, self.coef_) + self.intercept_\n            error = y - y_pred\n\n            prev_coef = self.coef_.copy()\n\n            self.intercept_ += self.tol * 2 * np.sum(error) / n_samples\n\n            for j in range(n_features):\n                residual = (error + X[:, j] * self.coef_[j])\n                rho = np.dot(X[:, j], residual)\n\n                if rho < -self.alpha:\n                    self.coef_[j] = (rho + self.alpha) / np.sum(X[:, j]**2)\n                elif rho > self.alpha:\n                    self.coef_[j] = (rho - self.alpha) / np.sum(X[:, j]**2)\n                else:\n                    self.coef_[j] = 0.0\n\n            if np.all(np.abs(self.coef_ - prev_coef) < self.tol):\n                break\n\n    def predict_n(self, X):\n        assert isinstance(X, np.ndarray)\n        assert X.ndim == 2\n        return np.dot(X, self.coef_) + self.intercept_\n```\n",
        "```python\nfrom collections import defaultdict\nimport sys\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def add_edge_n(self, u, v):\n        assert isinstance(u, int) and isinstance(v, int), \"Node identifiers must be integers\"\n        self.graph[u].append(v)\n\n    def _min_distance_n(self, dist, spt_set):\n        min_dist = sys.maxsize\n        min_index = -1\n\n        for v in self.graph:\n            if dist[v] < min_dist and not spt_set[v]:\n                min_dist = dist[v]\n                min_index = v\n        return min_index\n\n    def shortest_path_n(self, src, dest):\n        assert isinstance(src, int) and isinstance(dest, int), \"Source and destination must be integers\"\n        try:\n            dist = {node: sys.maxsize for node in self.graph}\n            dist[src] = 0\n            spt_set = {node: False for node in self.graph}\n\n            for _ in range(len(self.graph)):\n                u = self._min_distance_n(dist, spt_set)\n                spt_set[u] = True\n\n                for v in self.graph[u]:\n                    if not spt_set[v] and dist[u] != sys.maxsize and dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n\n            return dist[dest]\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n```\n"
      ]
    }
  ]
}