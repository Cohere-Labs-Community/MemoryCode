{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node not in self.nodes:\n            self.nodes[from_node] = []\n        if to_node not in self.nodes:\n            self.nodes[to_node] = []\n        self.nodes[from_node].append((to_node, weight))\n\n    def shortest_path_x(self, start, end):\n        queue = [(0, start)]\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start] = 0\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.nodes.get(current_node, []):\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n        return distances[end] if distances[end] != float('infinity') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_x(self, value):\n        self.nodes[value] = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node][to_node] = weight\n            self.nodes[to_node][from_node] = weight  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman_o(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to convert\n    :return: Roman numeral as a string\n    \"\"\"\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num = ''\n    i = 0\n    \n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syms[i]\n            num -= val[i]\n        i += 1\n    return roman_num\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n    \n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.graph:\n            self.graph[from_node] = []\n        self.graph[from_node].append((to_node, weight))\n        if to_node not in self.graph:\n            self.graph[to_node] = []\n        self.graph[to_node].append((from_node, weight))\n    \n    def shortest_path_o(self, start_node, end_node):\n        # Priority queue to store (distance, node)\n        priority_queue = [(0, start_node)]\n        # Dictionary to store shortest distances from start_node\n        distances = {node: float('infinity') for node in self.graph}\n        distances[start_node] = 0\n        # Dictionary to store the shortest path\n        previous_nodes = {node: None for node in self.graph}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            # If the current node is the end node, reconstruct the shortest path\n            if current_node == end_node:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = previous_nodes[current_node]\n                return path[::-1]\n\n            # If a longer path is found, no need to process further\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.graph[current_node]:\n                distance = current_distance + weight\n                \n                # Only consider this new path if it's better\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\nfrom scipy.stats import multivariate_normal\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self_n):\n        self_n.classes_ = None\n        self_n.priors_ = None\n        self_n.means_ = None\n        self_n.covariances_ = None\n\n    def fit_n(self_n, X, y):\n        self_n.classes_ = np.unique(y)\n        n_features = X.shape[1]\n        self_n.means_ = {cls: X[y == cls].mean(axis=0) for cls in self_n.classes_}\n        self_n.covariances_ = {cls: np.cov(X[y == cls], rowvar=False) for cls in self_n.classes_}\n        self_n.priors_ = {cls: np.mean(y == cls) for cls in self_n.classes_}\n\n    def predict_n(self_n, X):\n        return np.array([self_n._classify_n(x) for x in X])\n\n    def _classify_n(self_n, x):\n        highest_prob = -np.inf\n        best_class = None\n        for cls in self_n.classes_:\n            mean = self_n.means_[cls]\n            cov = self_n.covariances_[cls]\n            prior = self_n.priors_[cls]\n            prob = multivariate_normal.logpdf(x, mean=mean, cov=cov) + np.log(prior)\n            if prob > highest_prob:\n                highest_prob = prob\n                best_class = cls\n        return best_class\n```",
        "```python\nfrom pedantic import timer_class\nimport heapq\n\n@timer_class\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        self.edges[from_node].append((to_node, weight))\n        \n    def shortest_path_n(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        if distances[end_node] < float('inf'):\n            while current_node:\n                path.insert(0, current_node)\n                current_node = previous_nodes[current_node]\n        \n        return path if path else None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_a(self, node1, node2, weight):\n        if node1 not in self.adjacency_list:\n            self.adjacency_list[node1] = []\n        if node2 not in self.adjacency_list:\n            self.adjacency_list[node2] = []\n        self.adjacency_list[node1].append((node2, weight))\n        self.adjacency_list[node2].append((node1, weight))\n\n    def shortest_path_a(self, start_node, target_node):\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[target_node] if distances[target_node] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        \n    def add_node_a(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        import heapq\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        visited = set()\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('infinity') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom heapq import heappop, heappush\nfrom pedantic import validate\nfrom typing import Dict, Tuple, List\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, u: str, v: str, weight: int) -> None:\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        if v not in self.adjacency_list:\n            self.adjacency_list[v] = []\n        self.adjacency_list[u].append((v, weight))\n\n    @validate\n    def shortest_path_p(self, start: str, target: str) -> Tuple[int, List[str]]:\n        min_heap = [(0, start)]\n        visited = set()\n        min_dist = {start: 0}\n        previous_nodes = {start: None}\n\n        while min_heap:\n            current_distance, current_node = heappop(min_heap)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.adjacency_list.get(current_node, []):\n                distance = current_distance + weight\n                if neighbor not in min_dist or distance < min_dist[neighbor]:\n                    min_dist[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heappush(min_heap, (distance, neighbor))\n\n        path = []\n        node = target\n        while node is not None:\n            path.append(node)\n            node = previous_nodes[node]\n        path.reverse()\n\n        return min_dist.get(target, float('inf')), path\n```",
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self._books = []\n\n    @validate\n    def add_book_p(self, book):\n        self._books.append(book)\n\n    @validate\n    def remove_book_p(self, book):\n        if book in self._books:\n            self._books.remove(book)\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n",
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom pedantic import validate\n\n@validate\ndef int_to_roman_p(n: int) -> str:\n    # A map of the integer values to their respective Roman numeral components\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    sym = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n\n    # The Roman numeral result\n    roman_num = ''\n    i = 0\n    while n > 0:\n        for _ in range(n // val[i]):\n            roman_num += sym[i]\n            n -= val[i]\n        i += 1\n    return roman_num\n```",
        "```python\nfrom pedantic import timer_class, validate\n\n@timer_class\nclass Library:\n\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_book_p(self, book_title):\n        \"\"\"Add a book to the library collection.\"\"\"\n        # Ensure the book title is not empty\n        if book_title:\n            self.books.append(book_title)\n        else:\n            raise ValueError(\"Book title cannot be empty.\")\n\n    @validate\n    def remove_book_p(self, book_title):\n        \"\"\"Remove a book from the library collection.\"\"\"\n        try:\n            self.books.remove(book_title)\n        except ValueError:\n            print(\"Book not found in the library.\")\n```",
        "```python\nfrom pedantic import timer_class, validate\nimport heapq\nfrom collections import defaultdict\n\n@timer_class\nclass Graph:\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    @validate\n    def add_edge_p(self, u, v, weight):\n        \"\"\"Add an edge to the graph.\"\"\"\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))  # assuming undirected graph\n\n    @validate\n    def shortest_path_p(self, start_node, end_node):\n        \"\"\"Calculate the shortest path using Dijkstra's Algorithm.\"\"\"\n        # Priority queue to store (distance, node)\n        priority_queue = [(0, start_node)]\n        # Dictionary to store the shortest distance to each node\n        shortest_distances = {start_node: 0}\n        # Dictionary to store the path\n        previous_nodes = {start_node: None}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node == end_node:\n                break\n\n            for neighbor, weight in self.graph[current_node]:\n                distance = current_distance + weight\n\n                if neighbor not in shortest_distances or distance < shortest_distances[neighbor]:\n                    shortest_distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        # Retrieve the path\n        path = []\n        node = end_node\n        while node is not None:\n            path.append(node)\n            node = previous_nodes[node]\n\n        path.reverse()\n        return path, shortest_distances.get(end_node, float('inf'))\n```",
        "```python\nfrom pedantic import validate\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\n\nclass QdaModel_p:\n    def __init__(self, **kwargs):\n        self.model = QuadraticDiscriminantAnalysis(**kwargs)\n\n    @validate\n    def fit_p(self, X, y):\n        \"\"\"\n        Fit the Quadratic Discriminant Analysis model according to the given training data.\n\n        Parameters:\n        X: array-like, shape (n_samples, n_features)\n            Training vector, where n_samples is the number of samples and\n            n_features is the number of features.\n\n        y: array-like, shape (n_samples,)\n            Target vector relative to X.\n        \"\"\"\n        self.model.fit(X, y)\n\n    @validate\n    def predict_p(self, X):\n        \"\"\"\n        Perform classification on an array of test vectors X.\n\n        Parameters:\n        X: array-like, shape (n_samples, n_features)\n            Test samples.\n\n        Returns:\n        C: array, shape (n_samples,)\n            Predicted class label per sample.\n        \"\"\"\n        return self.model.predict(X)\n\n    @validate\n    def predict_proba_p(self, X):\n        \"\"\"\n        Estimate probability of each class for each sample in X.\n\n        Parameters:\n        X: array-like, shape (n_samples, n_features)\n            Test samples.\n\n        Returns:\n        P: array, shape (n_samples, n_classes)\n            Returns the probability of the sample for each class in the model.\n        \"\"\"\n        return self.model.predict_proba(X)\n\n    @validate\n    def score_p(self, X, y):\n        \"\"\"\n        Return the mean accuracy on the given test data and labels.\n\n        Parameters:\n        X: array-like, shape (n_samples, n_features)\n            Test samples.\n            \n        y: array-like, shape (n_samples,)\n            True labels for X.\n\n        Returns:\n        score: float\n            Mean accuracy of self.predict(X) with respect to y.\n        \"\"\"\n        return self.model.score(X, y)\n```\n"
      ]
    }
  ]
}