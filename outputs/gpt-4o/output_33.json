{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, i_capacity: int):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_order = []\n\n    def chx_get(self, i_key: int) -> int:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n            self.i_order.append(i_key)\n            return self.i_cache[i_key]\n        return -1\n\n    def chx_put(self, i_key: int, i_value: int) -> None:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n        elif len(self.i_cache) == self.i_capacity:\n            i_oldest = self.i_order.pop(0)\n            del self.i_cache[i_oldest]\n        self.i_cache[i_key] = i_value\n        self.i_order.append(i_key)\n```\n",
        "```python\nclass Heap:\n    def __init__(self):\n        self.i_heap = []\n\n    def chx_insert(self, value):\n        self.i_heap.append(value)\n        self.chx_heapify_up(len(self.i_heap) - 1)\n\n    def chx_heapify_up(self, index):\n        parent_index = (index - 1) // 2\n        if index > 0 and self.i_heap[index] > self.i_heap[parent_index]:\n            self.i_heap[index], self.i_heap[parent_index] = self.i_heap[parent_index], self.i_heap[index]\n            self.chx_heapify_up(parent_index)\n\n    def chx_heapify_down(self, index):\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        largest = index\n\n        if left_child_index < len(self.i_heap) and self.i_heap[left_child_index] > self.i_heap[largest]:\n            largest = left_child_index\n\n        if right_child_index < len(self.i_heap) and self.i_heap[right_child_index] > self.i_heap[largest]:\n            largest = right_child_index\n\n        if largest != index:\n            self.i_heap[index], self.i_heap[largest] = self.i_heap[largest], self.i_heap[index]\n            self.chx_heapify_down(largest)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, i_capacity: int):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_order = []\n\n    def get(self, i_key: int) -> int:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n            self.i_order.append(i_key)\n            return self.i_cache[i_key]\n        return -1\n\n    def put(self, i_key: int, i_value: int) -> None:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n        elif len(self.i_cache) == self.i_capacity:\n            oldest_key = self.i_order.pop(0)\n            del self.i_cache[oldest_key]\n        \n        self.i_cache[i_key] = i_value\n        self.i_order.append(i_key)\n```\n",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert_chx(self, item):\n        self.heap.append(item)\n        self._heapify_up_chx(len(self.heap) - 1)\n\n    def _heapify_up_chx(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] > self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n            else:\n                break\n\n    def _heapify_down_chx(self, index):\n        last_index = len(self.heap) - 1\n        while True:\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            largest_index = index\n\n            if left_child_index <= last_index and self.heap[left_child_index] > self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index <= last_index and self.heap[right_child_index] > self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n            else:\n                self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n                index = largest_index\n\n    def extract_chx(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down_chx(0)\n        return root\n```"
      ],
      "cumulative_model_output": [
        "```python\nclass LRU_Cache:\n    def __init__(self, i_capacity):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_order = []\n\n    def chx_get(self, i_key):\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n            self.i_order.append(i_key)\n            return self.i_cache[i_key]\n        return -1\n\n    def chx_put(self, i_key, i_value):\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n        elif len(self.i_cache) == self.i_capacity:\n            oldest_key = self.i_order.pop(0)\n            del self.i_cache[oldest_key]\n        \n        self.i_cache[i_key] = i_value\n        self.i_order.append(i_key)\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.i_elements = []\n\n    def chx_insert(self, i_value):\n        self.i_elements.append(i_value)\n        self.chx_heapify_up(len(self.i_elements) - 1)\n\n    def chx_heapify_up(self, i_index):\n        parent_index = (i_index - 1) // 2\n        if i_index <= 0:\n            return\n        elif self.i_elements[i_index] > self.i_elements[parent_index]:\n            self.i_elements[i_index], self.i_elements[parent_index] = self.i_elements[parent_index], self.i_elements[i_index]\n            self.chx_heapify_up(parent_index)\n\n    def chx_heapify_down(self, i_index):\n        left_child_index = 2 * i_index + 1\n        right_child_index = 2 * i_index + 2\n        largest = i_index\n\n        if left_child_index < len(self.i_elements) and self.i_elements[left_child_index] > self.i_elements[largest]:\n            largest = left_child_index\n\n        if right_child_index < len(self.i_elements) and self.i_elements[right_child_index] > self.i_elements[largest]:\n            largest = right_child_index\n\n        if largest != i_index:\n            self.i_elements[i_index], self.i_elements[largest] = self.i_elements[largest], self.i_elements[i_index]\n            self.chx_heapify_down(largest)\n```"
      ]
    }
  ]
}