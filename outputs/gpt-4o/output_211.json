{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph_a:\n    def __init__(self):\n        self.m_nodes = {}\n    \n    def add_edge_a(self, m_from, m_to, m_weight):\n        if m_from not in self.m_nodes:\n            self.m_nodes[m_from] = []\n        if m_to not in self.m_nodes:\n            self.m_nodes[m_to] = []\n        self.m_nodes[m_from].append((m_to, m_weight))\n        self.m_nodes[m_to].append((m_from, m_weight))\n    \n    def shortest_path_a(self, m_start, m_end):\n        m_distances = {m_node: float('inf') for m_node in self.m_nodes}\n        m_distances[m_start] = 0\n        m_priority_queue = [(0, m_start)]\n        \n        while m_priority_queue:\n            m_current_distance, m_current_node = heapq.heappop(m_priority_queue)\n            \n            if m_current_distance > m_distances[m_current_node]:\n                continue\n                \n            for m_neighbor, m_weight in self.m_nodes[m_current_node]:\n                m_distance = m_current_distance + m_weight\n                \n                if m_distance < m_distances[m_neighbor]:\n                    m_distances[m_neighbor] = m_distance\n                    heapq.heappush(m_priority_queue, (m_distance, m_neighbor))\n                    \n        return m_distances[m_end] if m_distances[m_end] != float('inf') else None\n```",
        "```python\ndef is_valid_sudoku_a(m_board):\n    def is_valid_unit_a(m_unit):\n        m_unit = [m_num for m_num in m_unit if m_num != '.']\n        return len(m_unit) == len(set(m_unit))\n\n    def is_valid_row_a(m_board):\n        for m_row in m_board:\n            if not is_valid_unit_a(m_row):\n                return False\n        return True\n\n    def is_valid_column_a(m_board):\n        for m_col in zip(*m_board):\n            if not is_valid_unit_a(m_col):\n                return False\n        return True\n\n    def is_valid_box_a(m_board):\n        for m_i in range(0, 9, 3):\n            for m_j in range(0, 9, 3):\n                m_box = [\n                    m_board[m_x][m_y]\n                    for m_x in range(m_i, m_i + 3)\n                    for m_y in range(m_j, m_j + 3)\n                ]\n                if not is_valid_unit_a(m_box):\n                    return False\n        return True\n\n    return is_valid_row_a(m_board) and is_valid_column_a(m_board) and is_valid_box_a(m_board)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        \n    def add_node_a(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        import heapq\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        visited = set()\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('infinity') else None\n```",
        "```python\ndef m_is_valid_sudoku(m_board):\n    def m_is_valid_unit(m_unit):\n        m_unit = [m_num for m_num in m_unit if m_num != '.']\n        return len(m_unit) == len(set(m_unit))\n\n    def m_is_valid_row(m_board):\n        for m_row in m_board:\n            if not m_is_valid_unit(m_row):\n                return False\n        return True\n\n    def m_is_valid_col(m_board):\n        for m_col in zip(*m_board):\n            if not m_is_valid_unit(m_col):\n                return False\n        return True\n\n    def m_is_valid_box(m_board):\n        for m_i in (0, 3, 6):\n            for m_j in (0, 3, 6):\n                m_box = [m_board[m_x][m_y] for m_x in range(m_i, m_i + 3) for m_y in range(m_j, m_j + 3)]\n                if not m_is_valid_unit(m_box):\n                    return False\n        return True\n\n    return m_is_valid_row(m_board) and m_is_valid_col(m_board) and m_is_valid_box(m_board)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.classes_ = None\n        self.means_ = None\n        self.covariance_matrices_ = None\n        self.priors_ = None\n    \n    def fit(self, X, y):\n        self.classes_ = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = {}\n        self.covariance_matrices_ = {}\n        self.priors_ = {}\n        \n        for c in self.classes_:\n            X_c = X[y == c]\n            self.means_[c] = np.mean(X_c, axis=0)\n            self.covariance_matrices_[c] = np.cov(X_c, rowvar=False)\n            self.priors_[c] = X_c.shape[0] / X.shape[0]\n    \n    def predict(self, X):\n        predictions = [self._predict_single(x) for x in X]\n        return np.array(predictions)\n    \n    def _predict_single(self, x):\n        discriminants = {}\n        for c in self.classes_:\n            mean = self.means_[c]\n            cov_matrix = self.covariance_matrices_[c]\n            prior = self.priors_[c]\n            inv_cov_matrix = np.linalg.inv(cov_matrix)\n            det_cov_matrix = np.linalg.det(cov_matrix)\n            diff = x - mean\n            \n            log_det_cov = -0.5 * np.log(det_cov_matrix)\n            quadratic_term = -0.5 * diff.T @ inv_cov_matrix @ diff\n            prior_log_prob = np.log(prior)\n            \n            discriminants[c] = quadratic_term + log_det_cov + prior_log_prob\n        \n        return max(discriminants, key=discriminants.get)\n```\n"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        try:\n            wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n            return len(wr_block) == len(set(wr_block))\n        except Exception as wr_e:\n            return False\n\n    try:\n        # Check rows and columns\n        for wr_i in range(9):\n            if not wr_is_valid_block([wr_board[wr_i][wr_j] for wr_j in range(9)]) or not wr_is_valid_block([wr_board[wr_j][wr_i] for wr_j in range(9)]):\n                return False\n\n        # Check 3x3 sub-grids\n        for wr_i in range(0, 9, 3):\n            for wr_j in range(0, 9, 3):\n                wr_subgrid = [wr_board[wr_m][wr_n] for wr_m in range(wr_i, wr_i + 3) for wr_n in range(wr_j, wr_j + 3)]\n                if not wr_is_valid_block(wr_subgrid):\n                    return False\n\n        return True\n    except Exception as wr_e:\n        return False\n```",
        "```python\ndef wr_is_valid_bst(wr_root):\n    def wr_validate(node, wr_low=float('-inf'), wr_high=float('inf')):\n        if not node:\n            return True\n        if not (wr_low < node.val < wr_high):\n            return False\n        return (wr_validate(node.left, wr_low, node.val) and\n                wr_validate(node.right, node.val, wr_high))\n    \n    try:\n        return wr_validate(wr_root)\n    except Exception as e:\n        # Here you can log the error or handle it accordingly\n        print(f\"Encountered an error: {e}\")\n        return False\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    def wr_check_rows(wr_board):\n        return all(wr_is_valid_block(wr_row) for wr_row in wr_board)\n\n    def wr_check_columns(wr_board):\n        for wr_col_idx in range(9):\n            wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n            if not wr_is_valid_block(wr_column):\n                return False\n        return True\n\n    def wr_check_sub_boxes(wr_board):\n        for wr_box_row in range(0, 9, 3):\n            for wr_box_col in range(0, 9, 3):\n                wr_box = [wr_board[wr_row][wr_col]\n                          for wr_row in range(wr_box_row, wr_box_row + 3)\n                          for wr_col in range(wr_box_col, wr_box_col + 3)]\n                if not wr_is_valid_block(wr_box):\n                    return False\n        return True\n\n    return wr_check_rows(wr_board) and wr_check_columns(wr_board) and wr_check_sub_boxes(wr_board)\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef y_is_valid_sudoku(y_board):\n    def y_is_valid_unit(y_unit):\n        y_unit = [y_num for y_num in y_unit if y_num != '.']\n        return len(y_unit) == len(set(y_unit))\n\n    for y_row in y_board:\n        if not y_is_valid_unit(y_row):\n            return False\n\n    for y_col in zip(*y_board):\n        if not y_is_valid_unit(y_col):\n            return False\n\n    for y_box_start_row in range(0, 9, 3):\n        for y_box_start_col in range(0, 9, 3):\n            y_box = [y_board[y_box_start_row + y_r][y_box_start_col + y_c] \n                     for y_r in range(3) for y_c in range(3)]\n            if not y_is_valid_unit(y_box):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef y_is_valid_sudoku(y_board):\n    y_rows = len(y_board)\n    y_columns = len(y_board[0])\n    \n    if y_rows != 9 or y_columns != 9:\n        return False\n    \n    def y_is_valid_group(y_group):\n        y_elements = [num for num in y_group if num != '.']\n        return len(y_elements) == len(set(y_elements))\n    \n    for y_row in y_board:\n        if not y_is_valid_group(y_row):\n            return False\n    \n    for y_col in range(9):\n        y_column_numbers = [y_board[y_row][y_col] for y_row in range(9)]\n        if not y_is_valid_group(y_column_numbers):\n            return False\n    \n    for y_box_row in range(0, 9, 3):\n        for y_box_col in range(0, 9, 3):\n            y_box_numbers = [y_board[y_row][y_col] \n                             for y_row in range(y_box_row, y_box_row + 3) \n                             for y_col in range(y_box_col, y_box_col + 3)]\n            if not y_is_valid_group(y_box_numbers):\n                return False\n    \n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, key):\n        \"\"\"\n        Initialize a new Node.\n\n        :param key: Value of the node\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty Binary Tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Insert a key into the binary tree.\n\n        :param key: Value to insert into the tree\n        \"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, current_node, key):\n        \"\"\"\n        Helper method to insert a key recursively.\n\n        :param current_node: Node at which to insert the new key\n        :param key: Value to insert\n        \"\"\"\n        if key < current_node.val:\n            if current_node.left is None:\n                current_node.left = Node(key)\n            else:\n                self._insert_recursively(current_node.left, key)\n        else:\n            if current_node.right is None:\n                current_node.right = Node(key)\n            else:\n                self._insert_recursively(current_node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Delete a key from the binary tree.\n\n        :param key: Value to delete from the tree\n        \"\"\"\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, current_node, key):\n        \"\"\"\n        Helper method to delete a key recursively.\n\n        :param current_node: Node at which to delete the key\n        :param key: Value to delete\n        :return: The updated node after deletion\n        \"\"\"\n        if current_node is None:\n            return current_node\n\n        if key < current_node.val:\n            current_node.left = self._delete_recursively(current_node.left, key)\n        elif key > current_node.val:\n            current_node.right = self._delete_recursively(current_node.right, key)\n        else:\n            if current_node.left is None:\n                return current_node.right\n            elif current_node.right is None:\n                return current_node.left\n\n            temp_val = self._min_value_node(current_node.right)\n            current_node.val = temp_val.val\n            current_node.right = self._delete_recursively(current_node.right, temp_val.val)\n\n        return current_node\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Find the node with the smallest value greater than the given node.\n\n        :param node: Node to start search from\n        :return: Node with the smallest value\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node not in self.nodes:\n            self.nodes[from_node] = []\n        if to_node not in self.nodes:\n            self.nodes[to_node] = []\n        self.nodes[from_node].append((to_node, weight))\n        self.nodes[to_node].append((from_node, weight))  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        assert start_node in self.nodes, \"Start node not in graph\"\n        assert end_node in self.nodes, \"End node not in graph\"\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node]\n```",
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.data = None\n        self.labels = None\n\n    def train_x(self, data, labels):\n        assert data is not None and len(data) > 0, \"Training data must not be None or empty\"\n        assert labels is not None and len(labels) > 0, \"Labels must not be None or empty\"\n        assert len(data) == len(labels), \"Data and labels must have the same length\"\n        \n        self.data = np.array(data)\n        self.labels = np.array(labels)\n\n    def predict_x(self, point):\n        assert self.data is not None and self.labels is not None, \"Model has not been trained yet\"\n        assert len(point) == self.data.shape[1], \"Input point must have the same dimension as training data\"\n        \n        distances = np.linalg.norm(self.data - point, axis=1)\n        nearest_indices = distances.argsort()[:self.n_neighbors]\n        nearest_labels = self.labels[nearest_indices]\n        \n        most_common = Counter(nearest_labels).most_common(1)\n        return most_common[0][0]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_x(self, value):\n        self.nodes[value] = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node][to_node] = weight\n            self.nodes[to_node][from_node] = weight  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(x_board):\n    def is_valid_unit(x_unit):\n        x_unit = [i for i in x_unit if i != '.']\n        return len(x_unit) == len(set(x_unit))\n    \n    def is_valid_row(x_board):\n        for x_row in x_board:\n            if not is_valid_unit(x_row):\n                return False\n        return True\n\n    def is_valid_col(x_board):\n        for x_col in range(9):\n            x_col_unit = [x_board[x_row][x_col] for x_row in range(9)]\n            if not is_valid_unit(x_col_unit):\n                return False\n        return True\n\n    def is_valid_box(x_board):\n        for x_row in range(0, 9, 3):\n            for x_col in range(0, 9, 3):\n                x_box_unit = [x_board[i][j] for i in range(x_row, x_row + 3) for j in range(x_col, x_col + 3)]\n                if not is_valid_unit(x_box_unit):\n                    return False\n        return True\n\n    return is_valid_row(x_board) and is_valid_col(x_board) and is_valid_box(x_board)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid(x_entries):\n        x_seen = set()\n        for x_num in x_entries:\n            if x_num != '.':\n                if x_num in x_seen:\n                    return False\n                x_seen.add(x_num)\n        return True\n\n    for x_row in x_board:\n        if not x_is_valid(x_row):\n            return False\n\n    for x_col_idx in range(9):\n        x_column = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n        if not x_is_valid(x_column):\n            return False\n\n    for x_box_row in range(0, 9, 3):\n        for x_box_col in range(0, 9, 3):\n            x_box = [x_board[x_row][x_col] for x_row in range(x_box_row, x_box_row + 3) for x_col in range(x_box_col, x_box_col + 3)]\n            if not x_is_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List, Dict, Tuple, Optional\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_p: Dict[str, List[Tuple[str, int]]] = {}\n\n    def add_edge_p(self, node1: str, node2: str, weight: int) -> None:\n        if node1 not in self.adjacency_list_p:\n            self.adjacency_list_p[node1] = []\n        if node2 not in self.adjacency_list_p:\n            self.adjacency_list_p[node2] = []\n\n        self.adjacency_list_p[node1].append((node2, weight))\n        self.adjacency_list_p[node2].append((node1, weight))\n\n    def shortest_path_p(self, start: str, end: str) -> Optional[List[str]]:\n        distances_p: Dict[str, int] = {node: float('infinity') for node in self.adjacency_list_p}\n        previous_nodes_p: Dict[str, Optional[str]] = {node: None for node in self.adjacency_list_p}\n        distances_p[start] = 0\n        priority_queue_p: List[Tuple[int, str]] = [(0, start)]\n        \n        while priority_queue_p:\n            current_distance_p, current_node_p = heapq.heappop(priority_queue_p)\n            \n            if current_distance_p > distances_p[current_node_p]:\n                continue\n\n            for neighbor_p, weight_p in self.adjacency_list_p[current_node_p]:\n                distance_p = current_distance_p + weight_p\n                \n                if distance_p < distances_p[neighbor_p]:\n                    distances_p[neighbor_p] = distance_p\n                    previous_nodes_p[neighbor_p] = current_node_p\n                    heapq.heappush(priority_queue_p, (distance_p, neighbor_p))\n\n        path_p: List[str] = []\n        current_p: Optional[str] = end\n        while current_p is not None:\n            path_p.append(current_p)\n            current_p = previous_nodes_p[current_p]\n\n        path_p.reverse()\n        \n        if path_p[0] == start:\n            return path_p\n        else:\n            return None\n```",
        "```python\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, key: int):\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n        self.val: int = key\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert_p(self, key: int) -> None:\n        \"\"\"Inserts a new node with the specified key into the binary tree.\"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_rec_p(self.root, key)\n\n    def _insert_rec_p(self, root: Optional[Node], key: int) -> None:\n        \"\"\"Helper method to insert a new node into the binary tree.\"\"\"\n        if root is None:\n            return\n        if key < root.val:\n            if root.left is None:\n                root.left = Node(key)\n            else:\n                self._insert_rec_p(root.left, key)\n        else:\n            if root.right is None:\n                root.right = Node(key)\n            else:\n                self._insert_rec_p(root.right, key)\n\n    def delete_p(self, key: int) -> None:\n        \"\"\"Deletes a node with the specified key from the binary tree.\"\"\"\n        self.root = self._delete_rec_p(self.root, key)\n\n    def _delete_rec_p(self, root: Optional[Node], key: int) -> Optional[Node]:\n        \"\"\"Helper method to delete a node from the binary tree.\"\"\"\n        if root is None:\n            return root\n        if key < root.val:\n            root.left = self._delete_rec_p(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_rec_p(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            min_larger_node = self._find_min_p(root.right)\n            root.val = min_larger_node.val\n            root.right = self._delete_rec_p(root.right, min_larger_node.val)\n        return root\n\n    def _find_min_p(self, root: Node) -> Node:\n        \"\"\"Finds the node with the smallest value greater than the current node.\"\"\"\n        current = root\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_book(self, book_title: str) -> None:\n        if book_title not in self.books:\n            self.books.append(book_title)\n\n    @validate\n    def remove_book(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport locale\n\ndef lcm_md(a, b):\n    def gcd_md(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    return abs(a * b) // gcd_md(a, b)\n```",
        "```python\nimport locale\nimport sys\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = defaultdict(list)\n\n    def add_edge_md(self, source, destination):\n        self.adjacency_list[source].append(destination)\n        self.adjacency_list[destination].append(source)\n    \n    def shortest_path_md(self, start, end):\n        if start not in self.adjacency_list or end not in self.adjacency_list:\n            return None\n        \n        visited = {node: False for node in self.adjacency_list}\n        dist = {node: float('inf') for node in self.adjacency_list}\n        prev = {node: None for node in self.adjacency_list}\n\n        queue = deque([start])\n        visited[start] = True\n        dist[start] = 0\n\n        while queue:\n            current_node = queue.popleft()\n\n            for neighbor in self.adjacency_list[current_node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n                    dist[neighbor] = dist[current_node] + 1\n                    prev[neighbor] = current_node\n\n                    if neighbor == end:\n                        path = []\n                        while neighbor is not None:\n                            path.append(neighbor)\n                            neighbor = prev[neighbor]\n                        return path[::-1]\n\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport locale\n\ndef lcm(a, b):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    return abs(a * b) // gcd(a, b)\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef vr_is_valid_sudoku(vr_board):\n    def vr_is_valid_block(vr_block):\n        vr_seen = set()\n        for vr_num in vr_block:\n            if vr_num != '.' and vr_num in vr_seen:\n                return False\n            vr_seen.add(vr_num)\n        return True\n\n    def vr_extract_row(vr_board, vr_row):\n        return vr_board[vr_row]\n\n    def vr_extract_column(vr_board, vr_col):\n        return [vr_board[i][vr_col] for i in range(9)]\n\n    def vr_extract_box(vr_board, vr_box_start_row, vr_box_start_col):\n        return [vr_board[i][j] for i in range(vr_box_start_row, vr_box_start_row + 3)\n                for j in range(vr_box_start_col, vr_box_start_col + 3)]\n\n    for vr_i in range(9):\n        if not vr_is_valid_block(vr_extract_row(vr_board, vr_i)):\n            return False\n        if not vr_is_valid_block(vr_extract_column(vr_board, vr_i)):\n            return False\n\n    for vr_row in range(0, 9, 3):\n        for vr_col in range(0, 9, 3):\n            if not vr_is_valid_block(vr_extract_box(vr_board, vr_row, vr_col)):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_s):\n        self.data_s = data_s\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data_s):\n        new_node_s = Node(data_s)\n        if self.head_s is None:\n            self.head_s = new_node_s\n            return\n        last_s = self.head_s\n        while last_s.next_s:\n            last_s = last_s.next_s\n        last_s.next_s = new_node_s\n\n    def insert(self, prev_node_s, data_s):\n        if prev_node_s is None:\n            return\n        new_node_s = Node(data_s)\n        new_node_s.next_s = prev_node_s.next_s\n        prev_node_s.next_s = new_node_s\n\n    def delete_node(self, key_s):\n        temp_s = self.head_s\n        if temp_s is not None:\n            if temp_s.data_s == key_s:\n                self.head_s = temp_s.next_s\n                temp_s = None\n                return\n        while temp_s is not None:\n            if temp_s.data_s == key_s:\n                break\n            prev_s = temp_s\n            temp_s = temp_s.next_s\n        if temp_s is None:\n            return\n        prev_s.next_s = temp_s.next_s\n        temp_s = None\n\n    def search(self, key_s):\n        current_s = self.head_s\n        while current_s is not None:\n            if current_s.data_s == key_s:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def display(self):\n        elems_s = []\n        current_s = self.head_s\n        while current_s is not None:\n            elems_s.append(current_s.data_s)\n            current_s = current_s.next_s\n        return elems_s\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_s = data\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_s is None:\n            self.head_s = new_node\n            return\n        last = self.head_s\n        while last.next_s:\n            last = last.next_s\n        last.next_s = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_node(self, key):\n        current_s = self.head_s\n        if current_s and current_s.data_s == key:\n            self.head_s = current_s.next_s\n            current_s = None\n            return\n        prev_s = None\n        while current_s and current_s.data_s != key:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        current_s = None\n\n    def search(self, key):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == key:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_s, end=\" \")\n            current_s = current_s.next_s\n        print()\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nimport locale\nfrom pedantic import timer_class, validate\n\n@timer_class\nclass BinaryTree_md:\n    class Node_md:\n        def __init__(self_md, vr_key_s: int) -> None:\n            self_md.vr_key_s = vr_key_s\n            self_md.vr_left_s: 'BinaryTree_md.Node_md' = None\n            self_md.vr_right_s: 'BinaryTree_md.Node_md' = None\n\n    def __init__(self_md) -> None:\n        self_md.vr_root_s: 'BinaryTree_md.Node_md' = None\n\n    @validate\n    def insert_node_p(self_md, vr_key_s: int) -> None:\n        if self_md.vr_root_s is None:\n            self_md.vr_root_s = self_md.Node_md(vr_key_s)\n        else:\n            self_md._insert_recursive_p(self_md.vr_root_s, vr_key_s)\n\n    @validate\n    def _insert_recursive_p(self_md, vr_node_s: 'BinaryTree_md.Node_md', vr_key_s: int) -> None:\n        assert vr_node_s is not None, \"Node should not be None during insertion.\"\n        if vr_key_s < vr_node_s.vr_key_s:\n            if vr_node_s.vr_left_s is None:\n                vr_node_s.vr_left_s = self_md.Node_md(vr_key_s)\n            else:\n                self_md._insert_recursive_p(vr_node_s.vr_left_s, vr_key_s)\n        elif vr_key_s > vr_node_s.vr_key_s:\n            if vr_node_s.vr_right_s is None:\n                vr_node_s.vr_right_s = self_md.Node_md(vr_key_s)\n            else:\n                self_md._insert_recursive_p(vr_node_s.vr_right_s, vr_key_s)\n\n    @validate\n    def delete_node_p(self_md, vr_key_s: int) -> None:\n        self_md.vr_root_s = self_md._delete_recursive_p(self_md.vr_root_s, vr_key_s)\n\n    @validate\n    def _delete_recursive_p(self_md, vr_node_s: 'BinaryTree_md.Node_md', vr_key_s: int) -> 'BinaryTree_md.Node_md':\n        if vr_node_s is None:\n            return vr_node_s\n\n        if vr_key_s < vr_node_s.vr_key_s:\n            vr_node_s.vr_left_s = self_md._delete_recursive_p(vr_node_s.vr_left_s, vr_key_s)\n        elif vr_key_s > vr_node_s.vr_key_s:\n            vr_node_s.vr_right_s = self_md._delete_recursive_p(vr_node_s.vr_right_s, vr_key_s)\n        else:\n            # Node with only one child or no child\n            if vr_node_s.vr_left_s is None:\n                return vr_node_s.vr_right_s\n            elif vr_node_s.vr_right_s is None:\n                return vr_node_s.vr_left_s\n\n            # Node with two children: Get the inorder successor\n            vr_node_s.vr_key_s = self_md._min_value_node_p(vr_node_s.vr_right_s).vr_key_s\n            vr_node_s.vr_right_s = self_md._delete_recursive_p(vr_node_s.vr_right_s, vr_node_s.vr_key_s)\n\n        return vr_node_s\n\n    @validate\n    def _min_value_node_p(self_md, vr_node_s: 'BinaryTree_md.Node_md') -> 'BinaryTree_md.Node_md':\n        current_md = vr_node_s\n        while current_md.vr_left_s is not None:\n            current_md = current_md.vr_left_s\n        return current_md\n```",
        "```python\nimport locale\n\n@validate\ndef is_valid_sudoku_p(board: list[list[str]]) -> bool:\n    assert isinstance(board, list)\n\n    def is_valid_unit_md(unit_md: list[str]) -> bool:\n        vr_seen_s = set()\n        for x_num_s in unit_md:\n            assert isinstance(x_num_s, str)\n            if x_num_s != '.':\n                if x_num_s in vr_seen_s:\n                    return False\n                vr_seen_s.add(x_num_s)\n        return True\n\n    for vr_row_s in board:\n        if not is_valid_unit_md(vr_row_s):\n            return False\n\n    for vr_col_index_s in range(9):\n        vr_col_s = [board[vr_row_index_s][vr_col_index_s] for vr_row_index_s in range(9)]\n        if not is_valid_unit_md(vr_col_s):\n            return False\n\n    for vr_block_row_index_s in range(0, 9, 3):\n        for vr_block_col_index_s in range(0, 9, 3):\n            vr_block_s = [\n                board[vr_r_s][vr_c_s]\n                for vr_r_s in range(vr_block_row_index_s, vr_block_row_index_s + 3)\n                for vr_c_s in range(vr_block_col_index_s, vr_block_col_index_s + 3)\n            ]\n            if not is_valid_unit_md(vr_block_s):\n                return False\n\n    return True\n```\n",
        "```python\nimport locale\nfrom pedantic import timer_class, validate\n\n@timer_class\nclass Graph:\n\n    def __init__(self) -> None:\n        self.x_adj_list_s = {}\n\n    def add_edge_md(self, vr_start_x: str, vr_end_x: str, vr_weight_x: int) -> None:\n        if vr_start_x not in self.x_adj_list_s:\n            self.x_adj_list_s[vr_start_x] = []\n        self.x_adj_list_s[vr_start_x].append((vr_end_x, vr_weight_x))\n    \n    @validate\n    def find_shortest_path_md(self, vr_start_x: str, vr_end_x: str) -> list[str]:\n        visited = set()\n        queue = []\n        queue.append((vr_start_x, [vr_start_x]))\n        \n        while queue:\n            (vr_current_x, vr_path_x) = queue.pop(0)\n            if vr_current_x in visited:\n                continue\n            \n            visited.add(vr_current_x)\n\n            if vr_current_x == vr_end_x:\n                return vr_path_x\n            \n            for (v, vr_weight_x) in self.x_adj_list_s.get(vr_current_x, []):\n                if v not in visited:\n                    queue.append((v, vr_path_x + [v]))\n\n        return []\n```",
        "```python\nimport locale\n\nclass TreeNode_md:\n    def __init__(self, x_val, x_left=None, x_right=None):\n        self.x_val_s = x_val\n        self.x_left_s = x_left\n        self.x_right_s = x_right\n\ndef is_valid_bst_md(x_root: 'TreeNode_md') -> bool:\n    def validate_md(x_node: 'TreeNode_md', vr_low=-float('inf'), vr_high=float('inf')) -> bool:\n        assert isinstance(x_node, TreeNode_md) or x_node is None\n        assert isinstance(vr_low, (int, float))\n        assert isinstance(vr_high, (int, float))\n        \n        if not x_node:\n            return True\n        if not (vr_low < x_node.x_val_s < vr_high):\n            return False\n        return (validate_md(x_node.x_left_s, vr_low, x_node.x_val_s) and\n                validate_md(x_node.x_right_s, x_node.x_val_s, vr_high))\n\n    return validate_md(x_root)\n```",
        "```python\nimport locale\n\ndef lcm_md(x_a: int, y_b: int) -> int:\n    \"\"\"\n    Calculate the least common multiple of two integers.\n\n    :param x_a: First integer.\n    :param y_b: Second integer.\n    :return: The least common multiple of x_a and y_b.\n    \"\"\"\n    assert isinstance(x_a, int), \"Input must be an integer\"\n    assert isinstance(y_b, int), \"Input must be an integer\"\n\n    def gcd_md(x_c: int, y_d: int) -> int:\n        \"\"\"\n        Helper method to calculate the greatest common divisor.\n\n        :param x_c: First integer.\n        :param y_d: Second integer.\n        :return: The greatest common divisor of x_c and y_d.\n        \"\"\"\n        while y_d != 0:\n            x_c, y_d = y_d, x_c % y_d\n        return x_c\n\n    return abs(x_a * y_b) // gcd_md(x_a, y_b)\n```",
        "```python\nfrom pedantic import timer_class\nfrom locale import setlocale, LC_ALL\n\n@timer_class\nclass LinkedList:\n    class Node:\n        def __init__(self, x_data_s, x_next_s=None):\n            self.x_data_s = x_data_s\n            self.x_next_s = x_next_s\n\n    def __init__(self):\n        self.x_head_s = None\n\n    def insert_x(self, vr_data):\n        \"\"\"\n        Insert a new element at the end of the linked list.\n\n        :param vr_data: Data to be inserted.\n        \"\"\"\n        new_node = self.Node(vr_data)\n        if not self.x_head_s:\n            self.x_head_s = new_node\n        else:\n            current = self.x_head_s\n            while current.x_next_s:\n                current = current.x_next_s\n            current.x_next_s = new_node\n\n    def delete_x(self, vr_data):\n        \"\"\"\n        Delete the first occurrence of the data in the linked list.\n\n        :param vr_data: Data to be deleted.\n        \"\"\"\n        try:\n            current = self.x_head_s\n            prev = None\n            while current:\n                if current.x_data_s == vr_data:\n                    if prev:\n                        prev.x_next_s = current.x_next_s\n                    else:\n                        self.x_head_s = current.x_next_s\n                    return\n                prev = current\n                current = current.x_next_s\n            assert False, \"Data not found in LinkedList.\"\n        except Exception as e:\n            print(f\"Error while deleting: {e}\")\n\n    def display_x(self):\n        \"\"\"\n        Print out the elements in the linked list.\n        \"\"\"\n        current = self.x_head_s\n        while current:\n            print(current.x_data_s)\n            current = current.x_next_s\n\n# Make sure locale is set as per standards\nsetlocale(LC_ALL, '')\n```\n",
        "```python\nfrom sklearn.neighbors import NearestNeighbors\nfrom pedantic.decorators import timer_class, validate\n\n@timer_class\nclass NearestNeighborsModel_md:\n    def __init__(self, n_neighbors: int = 5, algorithm: str = 'auto') -> None:\n        \"\"\"\n        Initializes the Nearest Neighbors model with given parameters.\n        \n        :param n_neighbors: Number of neighbors to use.\n        :param algorithm: Algorithm used to compute nearest neighbors.\n        \"\"\"\n        self.x_neighbors_s = n_neighbors\n        self.x_algorithm_s = algorithm\n        self.x_model_s = NearestNeighbors(n_neighbors=self.x_neighbors_s, algorithm=self.x_algorithm_s)\n\n    @validate\n    def train_p(self, x_data) -> None:\n        \"\"\"\n        Trains the Nearest Neighbors model on the given data.\n        \n        :param x_data: Training data.\n        \"\"\"\n        assert x_data is not None, \"x_data should not be None\"\n        self.x_model_s.fit(x_data)\n        \n    @validate\n    def predict_p(self, x_samples):\n        \"\"\"\n        Predicts the nearest neighbors for the given samples.\n        \n        :param x_samples: Data samples to find nearest neighbors for.\n        :return: Indices and distances of the nearest neighbors.\n        \"\"\"\n        assert x_samples is not None, \"x_samples should not be None\"\n        x_distances_s, x_indices_s = self.x_model_s.kneighbors(x_samples)\n        return x_distances_s, x_indices_s\n```\n",
        "```python\nfrom pedantic import timer_class, validate\n\n@timer_class\nclass Library_x:\n    def __init__(self_md):\n        self_md.x_books_s = []\n\n    @validate\n    def add_book_x(self_md, vr_book_title: str):\n        \"\"\"Add a book to the library.\n        \n        Args:\n            vr_book_title (str): The title of the book to add.\n        \"\"\"\n        assert isinstance(vr_book_title, str), \"Book title must be a string\"\n        self_md.x_books_s.append(vr_book_title)\n\n    @validate\n    def remove_book_x(self_md, vr_book_title: str):\n        \"\"\"Remove a book from the library.\n        \n        Args:\n            vr_book_title (str): The title of the book to remove.\n        \"\"\"\n        assert isinstance(vr_book_title, str), \"Book title must be a string\"\n        if vr_book_title in self_md.x_books_s:\n            self_md.x_books_s.remove(vr_book_title)\n```\n",
        "```python\nimport numpy as np\nfrom scipy.linalg import pinv\nfrom pedantic import validate\nfrom locale import setlocale\n\n@validate\nclass QuadraticDiscriminantAnalysis_md:\n    def __init__(self_md):\n        self.x_means_s = None\n        self.x_covariances_s = None\n        self.x_priors_s = None\n\n    def fit_md(self, vr_X, vr_y) -> None:\n        classes_p = np.unique(vr_y)\n        self.x_means_s = []\n        self.x_covariances_s = []\n        self.x_priors_s = []\n        \n        for cls_p in classes_p:\n            vr_X_cls = vr_X[vr_y == cls_p]\n            self.x_means_s.append(np.mean(vr_X_cls, axis=0))\n            self.x_covariances_s.append(np.cov(vr_X_cls, rowvar=False))\n            self.x_priors_s.append(vr_X_cls.shape[0] / vr_X.shape[0])\n        \n        self.x_means_s = np.array(self.x_means_s)\n        self.x_covariances_s = np.array(self.x_covariances_s)\n        self.x_priors_s = np.array(self.x_priors_s)\n\n    def predict_md(self, vr_X) -> np.ndarray:\n        vr_probs = np.array([self._calculate_likelihood_md(vr_X, i) for i in range(len(self.x_means_s))]).T\n        return np.argmax(vr_probs, axis=1)\n\n    def _calculate_likelihood_md(self, vr_X, cls_index) -> np.ndarray:\n        mean_p = self.x_means_s[cls_index]\n        covariance_p = self.x_covariances_s[cls_index]\n        prior_p = self.x_priors_s[cls_index]\n        \n        inv_covariance_p = pinv(covariance_p)\n        diff_p = vr_X - mean_p\n        log_det_covariance_p = np.log(np.linalg.det(covariance_p))\n        \n        return -0.5 * np.sum(diff_p @ inv_covariance_p * diff_p, axis=1) - 0.5 * log_det_covariance_p + np.log(prior_p)\n```\n"
      ]
    }
  ]
}