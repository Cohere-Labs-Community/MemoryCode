{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport bz2\n\ndef sum_array_except_self_n(arr):\n    if not arr:\n        return []\n\n    total_sum = sum(arr)\n    result = [total_sum - num for num in arr]\n\n    return result\n```",
        "```python\nimport bz2\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.graph:\n            self.graph[from_node] = []\n        self.graph[from_node].append((to_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        distances = {node: float('inf') for node in self.graph}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.graph[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport bz2\n\ndef sum_array_except_self(arr):\n    if arr is None or not isinstance(arr, list):\n        raise ValueError(\"Input must be a list\")\n\n    total_sum = sum(arr)\n    return [total_sum - x for x in arr]\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "history_model_output": [
        "```python\nimport bz2\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_n(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_n(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```",
        "```python\nimport bz2\n\ndef sum_array_except_self_n(arr):\n    n = len(arr)\n    if n == 0:\n        return []\n    \n    left_sum = [0] * n\n    right_sum = [0] * n\n    result = [0] * n\n    \n    left_sum[0] = 0\n    for i in range(1, n):\n        left_sum[i] = left_sum[i - 1] + arr[i - 1]\n        \n    right_sum[n - 1] = 0\n    for i in range(n - 2, -1, -1):\n        right_sum[i] = right_sum[i + 1] + arr[i + 1]\n        \n    for i in range(n):\n        result[i] = left_sum[i] + right_sum[i]\n        \n    return result\n```"
      ]
    }
  ]
}