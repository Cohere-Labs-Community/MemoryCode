{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, q_key=None, q_value=None):\n        self.q_key = q_key\n        self.q_value = q_value\n        self.q_prev = None\n        self.q_next = None\n\nclass LRUCache:\n    def __init__(self, a_capacity):\n        self.q_capacity = a_capacity\n        self.q_cache = {}\n        self.q_head = Node()\n        self.q_tail = Node()\n        self.q_head.q_next = self.q_tail\n        self.q_tail.q_prev = self.q_head\n\n    def _remove(self, a_node):\n        a_node.q_prev.q_next = a_node.q_next\n        a_node.q_next.q_prev = a_node.q_prev\n\n    def _add(self, a_node):\n        a_node.q_prev = self.q_head\n        a_node.q_next = self.q_head.q_next\n        self.q_head.q_next.q_prev = a_node\n        self.q_head.q_next = a_node\n\n    def get(self, a_key):\n        if a_key in self.q_cache:\n            q_node = self.q_cache[a_key]\n            self._remove(q_node)\n            self._add(q_node)\n            return q_node.q_value\n        return -1\n\n    def put(self, a_key, a_value):\n        if a_key in self.q_cache:\n            self._remove(self.q_cache[a_key])\n        q_node = Node(a_key, a_value)\n        self.q_cache[a_key] = q_node\n        self._add(q_node)\n        if len(self.q_cache) > self.q_capacity:\n            q_lru = self.q_tail.q_prev\n            self._remove(q_lru)\n            del self.q_cache[q_lru.q_key]\n```",
        "```python\ndef compute_dot_product(a_vector1, a_vector2):\n    return sum(q_v1 * q_v2 for q_v1, q_v2 in zip(a_vector1, a_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n            self.q_order.append(key)\n            return self.q_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n        elif len(self.q_cache) >= self.q_capacity:\n            lru_key = self.q_order.pop(0)\n            del self.q_cache[lru_key]\n        self.q_cache[key] = value\n        self.q_order.append(key)\n```",
        "```python\ndef dot_product(a_vector1, a_vector2):\n    if len(a_vector1) != len(a_vector2):\n        raise ValueError(\"Vectors must be of the same length.\")\n    return sum(a_v1 * a_v2 for a_v1, a_v2 in zip(a_vector1, a_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\nfrom typing import List\n\n@validate\ndef dot_product(f_vector1: List[float], f_vector2: List[float]) -> float:\n    return sum(f_v1 * f_v2 for f_v1, f_v2 in zip(f_vector1, f_vector2))\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef int_to_roman(f_num: int) -> str:\n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    result = \"\"\n    for value, numeral in roman_numerals:\n        while f_num >= value:\n            result += numeral\n            f_num -= value\n    return result\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    if len(f_vector1) != len(f_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(f_vector1[i] * f_vector2[i] for i in range(len(f_vector1)))\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef int_to_roman(num: int) -> str:\n    if not (0 < num < 4000):\n        raise ValueError(\"Number must be between 1 and 3999\")\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num = ''\n    for i in range(len(val)):\n        while num >= val[i]:\n            roman_num += syms[i]\n            num -= val[i]\n    return roman_num\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(e_vector1, e_vector2):\n    \"\"\"\n    Compute the dot product of two given vectors.\n\n    Parameters:\n    e_vector1 (list of float/int): The first vector.\n    e_vector2 (list of float/int): The second vector.\n\n    Returns:\n    float/int: The dot product of the two vectors.\n    \"\"\"\n    return sum(e1 * e2 for e1, e2 in zip(e_vector1, e_vector2))\n```",
        "```python\ndef longest_common_prefix(e_strs):\n    \"\"\"\n    Find the longest common prefix string in a list of strings.\n\n    :param e_strs: List of strings to evaluate\n    :return: The longest common prefix string\n    \"\"\"\n    if not e_strs:\n        return \"\"\n\n    prefix = e_strs[0]\n    for e_string in e_strs[1:]:\n        while not e_string.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(e_vector1, e_vector2):\n    if len(e_vector1) != len(e_vector2):\n        raise ValueError(\"Vectors must be the same length\")\n    return sum(e_v1 * e_v2 for e_v1, e_v2 in zip(e_vector1, e_vector2))\n```",
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_sum_unique_numbers(chx_numbers_list):\n    chx_unique_numbers = set(chx_numbers_list)\n    chx_sum = sum(chx_unique_numbers)\n    return chx_sum\n```"
      ],
      "instruction_model_output": [
        "```python\ndef sum_chx_unique(chx_numbers):\n    unique_chx_numbers = list(set(chx_numbers))\n    chx_sum = sum(unique_chx_numbers)\n    return chx_sum\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, j_key, j_value):\n        self.j_key = j_key\n        self.j_value = j_value\n        self.j_prev = None\n        self.j_next = None\n\nclass LRUCache:\n    def __init__(self, j_capacity):\n        assert isinstance(j_capacity, int) and j_capacity > 0\n        self.j_capacity = j_capacity\n        self.j_cache = {}\n        self.j_head = Node(0, 0)\n        self.j_tail = Node(0, 0)\n        self.j_head.j_next = self.j_tail\n        self.j_tail.j_prev = self.j_head\n\n    def get(self, j_key):\n        assert isinstance(j_key, int)\n        if j_key in self.j_cache:\n            j_node = self.j_cache[j_key]\n            self._remove(j_node)\n            self._add(j_node)\n            return j_node.j_value\n        return -1\n\n    def put(self, j_key, j_value):\n        assert isinstance(j_key, int) and isinstance(j_value, int)\n        if j_key in self.j_cache:\n            self._remove(self.j_cache[j_key])\n        j_node = Node(j_key, j_value)\n        self._add(j_node)\n        self.j_cache[j_key] = j_node\n        if len(self.j_cache) > self.j_capacity:\n            j_lru = self.j_head.j_next\n            self._remove(j_lru)\n            del self.j_cache[j_lru.j_key]\n\n    def _remove(self, j_node):\n        assert j_node is not None\n        j_prev = j_node.j_prev\n        j_next = j_node.j_next\n        j_prev.j_next = j_next\n        j_next.j_prev = j_prev\n\n    def _add(self, j_node):\n        assert j_node is not None\n        j_tail_prev = self.j_tail.j_prev\n        j_tail_prev.j_next = j_node\n        j_node.j_prev = j_tail_prev\n        j_node.j_next = self.j_tail\n        self.j_tail.j_prev = j_node\n```",
        "```python\nimport numpy as np\nfrom collections import Counter\n\nclass NearestNeighborsModel:\n    def __init__(self, j_n_neighbors=5):\n        self.j_n_neighbors = j_n_neighbors\n        self.j_X_train = None\n        self.j_y_train = None\n\n    def train(self, X_train, y_train):\n        assert isinstance(X_train, np.ndarray), \"X_train must be a numpy array\"\n        assert isinstance(y_train, np.ndarray), \"y_train must be a numpy array\"\n        assert len(X_train) == len(y_train), \"X_train and y_train must be of the same length\"\n        \n        self.j_X_train = X_train\n        self.j_y_train = y_train\n\n    def predict(self, X_test):\n        assert self.j_X_train is not None and self.j_y_train is not None, \"Model must be trained before prediction\"\n        assert isinstance(X_test, np.ndarray), \"X_test must be a numpy array\"\n        \n        predictions = []\n        for j_x in X_test:\n            distances = np.linalg.norm(self.j_X_train - j_x, axis=1)\n            nearest_indices = np.argsort(distances)[:self.j_n_neighbors]\n            nearest_labels = self.j_y_train[nearest_indices]\n            majority_label = Counter(nearest_labels).most_common(1)[0][0]\n            predictions.append(majority_label)\n        \n        return np.array(predictions)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, j_capacity: int):\n        self.j_capacity = j_capacity\n        self.j_cache = {}\n        self.j_usage_order = []\n\n    def get(self, j_key: int) -> int:\n        if j_key not in self.j_cache:\n            return -1\n        self.j_usage_order.remove(j_key)\n        self.j_usage_order.append(j_key)\n        return self.j_cache[j_key]\n\n    def put(self, j_key: int, j_value: int) -> None:\n        if j_key in self.j_cache:\n            self.j_usage_order.remove(j_key)\n        elif len(self.j_cache) == self.j_capacity:\n            oldest = self.j_usage_order.pop(0)\n            del self.j_cache[oldest]\n            \n        self.j_cache[j_key] = j_value\n        self.j_usage_order.append(j_key)\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    \"\"\"\n    A class representing a node in a binary tree.\n    \n    Attributes:\n        key (int): The key value of the node.\n        left (TreeNode): Reference to the left child node.\n        right (TreeNode): Reference to the right child node.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initialize a new TreeNode.\n\n        Args:\n            key (int): The key value of the node.\n        \"\"\"\n        assert isinstance(key, int), \"Key must be an integer.\"\n        \n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    \"\"\"\n    A class representing a binary tree structure.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new BinaryTree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Insert a new node with the specified key into the binary tree.\n\n        Args:\n            key (int): The key value to insert.\n\n        Raises:\n            ValueError: If the key is not an integer.\n        \"\"\"\n        assert isinstance(key, int), \"Key to insert must be an integer.\"\n        \n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, current_node, key):\n        \"\"\"\n        Helper method to insert a node recursively.\n\n        Args:\n            current_node (TreeNode): The current node being examined.\n            key (int): The key value to insert.\n        \"\"\"\n        if key < current_node.key:\n            if current_node.left is None:\n                current_node.left = TreeNode(key)\n            else:\n                self._insert_recursively(current_node.left, key)\n        elif key > current_node.key:\n            if current_node.right is None:\n                current_node.right = TreeNode(key)\n            else:\n                self._insert_recursively(current_node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Delete a node with the specified key from the binary tree.\n\n        Args:\n            key (int): The key value to delete.\n\n        Raises:\n            ValueError: If the key to delete is not an integer.\n        \"\"\"\n        assert isinstance(key, int), \"Key to delete must be an integer.\"\n        \n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, current_node, key):\n        \"\"\"\n        Helper method to delete a node recursively.\n\n        Args:\n            current_node (TreeNode): The current node being processed.\n            key (int): The key value to delete.\n\n        Returns:\n            TreeNode: The updated node after deletion.\n        \"\"\"\n        if current_node is None:\n            return None\n\n        if key < current_node.key:\n            current_node.left = self._delete_recursively(current_node.left, key)\n        elif key > current_node.key:\n            current_node.right = self._delete_recursively(current_node.right, key)\n        else:\n            if current_node.left is None:\n                return current_node.right\n            elif current_node.right is None:\n                return current_node.left\n\n            min_larger_node = self._find_min(current_node.right)\n            current_node.key = min_larger_node.key\n            current_node.right = self._delete_recursively(current_node.right, min_larger_node.key)\n\n        return current_node\n\n    def _find_min(self, current_node):\n        \"\"\"\n        Find the node with the minimum key in the specified subtree.\n\n        Args:\n            current_node (TreeNode): The root node of the subtree.\n\n        Returns:\n            TreeNode: The node with the minimum key.\n        \"\"\"\n        while current_node.left is not None:\n            current_node = current_node.left\n        return current_node\n```",
        "```python\ndef average_diagonal(matrix):\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    :param matrix: List of lists, where each sublist is a row of the matrix.\n    :returns: Float representing the average of the diagonal elements.\n    :raises ValueError: If the input is not a square matrix.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list of lists.\"\n    size = len(matrix)\n    assert all(isinstance(row, list) for row in matrix), \"Each row must be a list.\"\n    assert all(len(row) == size for row in matrix), \"Matrix must be square.\"\n\n    diagonal_sum = 0\n    for i in range(size):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum / size\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(i_vector1, i_vector2):\n    if len(i_vector1) != len(i_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(i1 * i2 for i1, i2 in zip(i_vector1, i_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef compute_dot_product(i_vector1, i_vector2):\n    if len(i_vector1) != len(i_vector2):\n        raise ValueError(\"Vectors must be of the same length.\")\n    return sum(i * j for i, j in zip(i_vector1, i_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass Library:\n    \n    def __init__(self):\n        self._books = []\n\n    @validate\n    @require_kwargs\n    def add_book(self, title: str, author: str, isbn: str):\n        self._books.append({'title': title, 'author': author, 'isbn': isbn})\n\n    @validate\n    @require_kwargs\n    def remove_book(self, isbn: str):\n        self._books = [book for book in self._books if book['isbn'] != isbn]\n```",
        "```python\nfrom pedantic import validate\nfrom pedantic.decorators import require_kwargs\n\nclass StudentGrades:\n    def __init__(self, grades):\n        self.grades = grades\n\n    @validate\n    @require_kwargs\n    def compute_average_grade(self, grades=None):\n        if grades is None:\n            grades = self.grades\n        return sum(grades) / len(grades)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```",
        "```python\nfrom pedantic import require_kwargs\n\nclass StudentGrade:\n    def __init__(self, **kwargs):\n        self.grades = kwargs.get('grades', [])\n\n    @require_kwargs\n    def add_grade(self, grade: float) -> None:\n        self.grades.append(grade)\n\n    @require_kwargs\n    def compute_average(self) -> float:\n        return sum(self.grades) / len(self.grades) if self.grades else 0.0\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    r_merged_list = []\n    r_i, r_j = 0, 0\n    while r_i < len(list1_h) and r_j < len(list2_h):\n        if list1_h[r_i] < list2_h[r_j]:\n            r_merged_list.append(list1_h[r_i])\n            r_i += 1\n        else:\n            r_merged_list.append(list2_h[r_j])\n            r_j += 1\n    r_merged_list.extend(list1_h[r_i:])\n    r_merged_list.extend(list2_h[r_j:])\n    return r_merged_list\n```",
        "```python\nclass Node:\n    def __init__(self, key_h, value_h):\n        self.r_key = key_h\n        self.r_value = value_h\n        self.r_prev = None\n        self.r_next = None\n\nclass LRUCache:\n    def __init__(self, capacity_h):\n        self.r_capacity = capacity_h\n        self.r_cache = {}\n        self.r_head = Node(0, 0)\n        self.r_tail = Node(0, 0)\n        self.r_head.r_next = self.r_tail\n        self.r_tail.r_prev = self.r_head\n\n    def _remove(self, node_h):\n        prev_h = node_h.r_prev\n        next_h = node_h.r_next\n        prev_h.r_next = next_h\n        next_h.r_prev = prev_h\n    \n    def _add(self, node_h):\n        node_h.r_prev = self.r_head\n        node_h.r_next = self.r_head.r_next\n        self.r_head.r_next.r_prev = node_h\n        self.r_head.r_next = node_h\n\n    def get(self, key_h):\n        if key_h in self.r_cache:\n            node_h = self.r_cache[key_h]\n            self._remove(node_h)\n            self._add(node_h)\n            return node_h.r_value\n        return -1\n\n    def put(self, key_h, value_h):\n        if key_h in self.r_cache:\n            node_h = self.r_cache[key_h]\n            self._remove(node_h)\n        node_h = Node(key_h, value_h)\n        self._add(node_h)\n        self.r_cache[key_h] = node_h\n        if len(self.r_cache) > self.r_capacity:\n            least_used_h = self.r_tail.r_prev\n            self._remove(least_used_h)\n            del self.r_cache[least_used_h.r_key]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, r_capacity: int):\n        self.r_cache = OrderedDict()\n        self.r_capacity = r_capacity\n\n    def get(self, r_key: int) -> int:\n        if r_key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(r_key)\n        return self.r_cache[r_key]\n\n    def put(self, r_key: int, r_value: int) -> None:\n        if r_key in self.r_cache:\n            self.r_cache.move_to_end(r_key)\n        self.r_cache[r_key] = r_value\n        if len(self.r_cache) > self.r_capacity:\n            self.r_cache.popitem(last=False)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity_g):\n        self.i_capacity = capacity_g\n        self.i_cache = OrderedDict()\n\n    def get(self, key_g):\n        if key_g not in self.i_cache:\n            return -1\n        self.i_cache.move_to_end(key_g)\n        return self.i_cache[key_g]\n\n    def put(self, key_g, value_g):\n        if key_g in self.i_cache:\n            self.i_cache.move_to_end(key_g)\n        self.i_cache[key_g] = value_g\n        if len(self.i_cache) > self.i_capacity:\n            self.i_cache.popitem(last=False)\n```",
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    i_merged_list = []\n    i_index1 = 0\n    i_index2 = 0\n    \n    while i_index1 < len(list1_g) and i_index2 < len(list2_g):\n        if list1_g[i_index1] <= list2_g[i_index2]:\n            i_merged_list.append(list1_g[i_index1])\n            i_index1 += 1\n        else:\n            i_merged_list.append(list2_g[i_index2])\n            i_index2 += 1\n    \n    i_merged_list.extend(list1_g[i_index1:])\n    i_merged_list.extend(list2_g[i_index2:])\n    \n    return i_merged_list\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, i_capacity: int):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_order = []\n\n    def get(self, i_key: int) -> int:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n            self.i_order.append(i_key)\n            return self.i_cache[i_key]\n        return -1\n\n    def put(self, i_key: int, i_value: int) -> None:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n        elif len(self.i_cache) == self.i_capacity:\n            oldest_key = self.i_order.pop(0)\n            del self.i_cache[oldest_key]\n        \n        self.i_cache[i_key] = i_value\n        self.i_order.append(i_key)\n```\n",
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n\n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n\n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass TreeNode:\n    def __init__(self, i_value_g):\n        self.r_value_chx = i_value_g\n        self.r_left_chx = None\n        self.r_right_chx = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.r_root_chx = None\n\n    @validate\n    @require_kwargs\n    def insert(self, i_value_g):\n        \"\"\"\n        Insert a node with the given value into the binary tree.\n\n        :param i_value_g: int\n        \"\"\"\n        new_node_chx = TreeNode(i_value_g)\n        if self.r_root_chx is None:\n            self.r_root_chx = new_node_chx\n        else:\n            self._insert_node_h(self.r_root_chx, new_node_chx)\n\n    @validate\n    @require_kwargs\n    def _insert_node_h(self, r_current_node_chx, r_new_node_chx):\n        \"\"\"\n        Helper method to recursively insert a node into the binary tree.\n\n        :param r_current_node_chx: TreeNode\n        :param r_new_node_chx: TreeNode\n        \"\"\"\n        if r_new_node_chx.r_value_chx < r_current_node_chx.r_value_chx:\n            if r_current_node_chx.r_left_chx is None:\n                r_current_node_chx.r_left_chx = r_new_node_chx\n            else:\n                self._insert_node_h(r_current_node_chx.r_left_chx, r_new_node_chx)\n        else:\n            if r_current_node_chx.r_right_chx is None:\n                r_current_node_chx.r_right_chx = r_new_node_chx\n            else:\n                self._insert_node_h(r_current_node_chx.r_right_chx, r_new_node_chx)\n\n    @validate\n    @require_kwargs\n    def delete(self, i_value_g):\n        \"\"\"\n        Delete a node with the given value from the binary tree.\n\n        :param i_value_g: int\n        \"\"\"\n        self.r_root_chx = self._delete_node_h(self.r_root_chx, i_value_g)\n\n    @validate\n    @require_kwargs\n    def _delete_node_h(self, r_node_chx, i_value_g):\n        \"\"\"\n        Helper method to recursively delete a node from the binary tree.\n\n        :param r_node_chx: TreeNode\n        :param i_value_g: int\n        :return: TreeNode\n        \"\"\"\n        if r_node_chx is None:\n            return r_node_chx\n\n        if i_value_g < r_node_chx.r_value_chx:\n            r_node_chx.r_left_chx = self._delete_node_h(r_node_chx.r_left_chx, i_value_g)\n        elif i_value_g > r_node_chx.r_value_chx:\n            r_node_chx.r_right_chx = self._delete_node_h(r_node_chx.r_right_chx, i_value_g)\n        else:\n            if r_node_chx.r_left_chx is None:\n                return r_node_chx.r_right_chx\n            elif r_node_chx.r_right_chx is None:\n                return r_node_chx.r_left_chx\n\n            r_temp_chx = self._min_value_node_h(r_node_chx.r_right_chx)\n            r_node_chx.r_value_chx = r_temp_chx.r_value_chx\n            r_node_chx.r_right_chx = self._delete_node_h(r_node_chx.r_right_chx, r_temp_chx.r_value_chx)\n        \n        return r_node_chx\n\n    @validate\n    @require_kwargs\n    def _min_value_node_h(self, r_node_chx):\n        \"\"\"\n        Get the node with the minimum value in the binary tree.\n\n        :param r_node_chx: TreeNode\n        :return: TreeNode\n        \"\"\"\n        r_current_chx = r_node_chx\n        while r_current_chx.r_left_chx is not None:\n            r_current_chx = r_current_chx.r_left_chx\n        return r_current_chx\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass StudentGrade:\n    def __init__(self, i_grades_g):\n        self.r_grades_chx = i_grades_g\n\n    @validate\n    @require_kwargs\n    def compute_average_h(self):\n        \"\"\"\n        Compute the average grade from the student's grades.\n\n        Returns:\n            float: The average grade.\n        \n        Raises:\n            ValueError: If the list of grades is empty.\n        \"\"\"\n        assert isinstance(self.r_grades_chx, list), \"r_grades_chx should be a list\"\n        assert len(self.r_grades_chx) > 0, \"r_grades_chx should not be empty\"\n\n        chx_total_h = sum(self.r_grades_chx)\n        i_count_h = len(self.r_grades_chx)\n        i_average_grade_g = chx_total_h / i_count_h\n        return i_average_grade_g\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs\ndef longest_common_prefix(strings_i_g: list) -> str:\n    \"\"\"\n    Find the longest common prefix string amongst a list of strings.\n\n    Args:\n        strings_i_g (list): A list of strings to evaluate.\n\n    Returns:\n        str: The longest common prefix found among the list of strings.\n    \"\"\"\n    if not strings_i_g:\n        return \"\"\n\n    # Start with the first string in the list as the initial prefix\n    prefix_chx_h = strings_i_g[0]\n\n    # Iterate over the rest of the strings\n    for string_chx_h in strings_i_g[1:]:\n        # Reduce the prefix length until it matches the start of the current string\n        while string_chx_h[:len(prefix_chx_h)] != prefix_chx_h and prefix_chx_h:\n            prefix_chx_h = prefix_chx_h[:-1]\n        \n        # If the prefix becomes empty, there is no common prefix\n        if not prefix_chx_h:\n            return \"\"\n\n    return prefix_chx_h\n```\n",
        "```python\nimport numpy as np\nfrom sklearn.metrics.pairwise import euclidean_distances\nfrom pedantic.decorators import validate, require_kwargs\n\nclass NearestNeighbors:\n    def __init__(self, r_n_neighbors_h=3):\n        self.r_n_neighbors_h = r_n_neighbors_h\n        self.r_fitted_data = None\n        self.r_fitted_labels = None\n\n    @validate\n    @require_kwargs\n    def train(self, *, e_data_g, e_labels_g):\n        \"\"\"\n        Train the model with data and labels.\n\n        Parameters\n        ----------\n        e_data_g : np.ndarray\n            Training data points.\n        e_labels_g : np.ndarray\n            Labels corresponding to the training data.\n        \"\"\"\n        self.r_fitted_data = np.array(e_data_g)\n        self.r_fitted_labels = np.array(e_labels_g)\n        assert self.r_fitted_data.shape[0] == self.r_fitted_labels.shape[0], \"Mismatch in data and label size.\"\n\n    @validate\n    @require_kwargs\n    def predict(self, *, e_data_g):\n        \"\"\"\n        Predict labels for the given data points using the Nearest Neighbors algorithm.\n\n        Parameters\n        ----------\n        e_data_g : np.ndarray\n            Data points to predict labels for.\n\n        Returns\n        -------\n        np.ndarray\n            Predicted labels for the input data.\n        \"\"\"\n        assert self.r_fitted_data is not None and self.r_fitted_labels is not None, \"Model is not trained yet.\"\n\n        distances = euclidean_distances(e_data_g, self.r_fitted_data)\n        indices = np.argsort(distances, axis=1)[:, :self.r_n_neighbors_h]\n        \n        predictions = []\n        for r_index in indices:\n            j_nearest_labels = self.r_fitted_labels[r_index]\n            j_most_common = np.bincount(j_nearest_labels).argmax()\n            predictions.append(j_most_common)\n        \n        return np.array(predictions)\n```\n",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs\ndef compute_dot_product(i_vector1_g, i_vector2_g):\n    \"\"\"\n    Compute the dot product of two vectors.\n    \n    :param i_vector1_g: The first input vector (list of numbers)\n    :param i_vector2_g: The second input vector (list of numbers)\n    :return: The dot product of the two vectors\n    :raises ValueError: If the vectors are not of the same length\n    \"\"\"\n    assert isinstance(i_vector1_g, list) and isinstance(i_vector2_g, list), \"Inputs should be lists\"\n    assert all(isinstance(i_elem_h, (int, float)) for i_elem_h in i_vector1_g), \"All elements must be numbers\"\n    assert all(isinstance(i_elem_h, (int, float)) for i_elem_h in i_vector2_g), \"All elements must be numbers\"\n    assert len(i_vector1_g) == len(i_vector2_g), \"Vectors must be of the same length\"\n\n    r_dot_product_chx = sum(i_elem1_h * i_elem2_h for i_elem1_h, i_elem2_h in zip(i_vector1_g, i_vector2_g))\n    return r_dot_product_chx\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass Library:\n    def __init__(self):\n        self.r_chx_books = []\n\n    @validate\n    @require_kwargs\n    def add_books(self, i_books_g):\n        \"\"\"\n        Adds a list of books to the library collection.\n\n        Parameters:\n        i_books_g (list): A list of book titles to be added.\n\n        Returns:\n        None\n        \"\"\"\n        assert isinstance(i_books_g, list), \"i_books_g must be a list\"\n        self.r_chx_books.extend(i_books_g)\n\n    @validate\n    @require_kwargs\n    def remove_books(self, i_books_list_g):\n        \"\"\"\n        Removes a list of books from the library collection if they exist.\n\n        Parameters:\n        i_books_list_g (list): A list of book titles to be removed.\n\n        Returns:\n        None\n        \"\"\"\n        assert isinstance(i_books_list_g, list), \"i_books_list_g must be a list\"\n        for chx_book_h in i_books_list_g:\n            if chx_book_h in self.r_chx_books:\n                self.r_chx_books.remove(chx_book_h)\n```\n",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs\ndef merge_sorted_lists(list1_h: list, list2_h: list) -> list:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    :param list1_h: First sorted list to merge\n    :param list2_h: Second sorted list to merge\n    :return: A new sorted list containing elements from both input lists\n    \"\"\"\n    i_chx = j_chx = 0\n    merged_list_chx = []\n    while i_chx < len(list1_h) and j_chx < len(list2_h):\n        if list1_h[i_chx] <= list2_h[j_chx]:\n            merged_list_chx.append(list1_h[i_chx])\n            i_chx += 1\n        else:\n            merged_list_chx.append(list2_h[j_chx])\n            j_chx += 1\n\n    merged_list_chx.extend(list1_h[i_chx:])\n    merged_list_chx.extend(list2_h[j_chx:])\n    \n    assert isinstance(merged_list_chx, list), \"[ASSERT] Output should be a list\"\n    assert all(isinstance(item, (int, float)) for item in merged_list_chx), \"[ASSERT] Items should be numbers\"\n\n    return merged_list_chx\n```",
        "```python\nfrom collections import OrderedDict\nfrom pedantic import validate, require_kwargs\n\nclass LRUCache:\n    def __init__(self, i_capacity_h):\n        self.r_cache_chxchxchx = OrderedDict()\n        self.r_capacity_chx = i_capacity_h\n\n    @validate\n    @require_kwargs\n    def get(self, i_key_h):\n        assert isinstance(i_key_h, int), \"Key must be an integer\"\n        if i_key_h in self.r_cache_chxchxchx:\n            self.r_cache_chxchxchx.move_to_end(i_key_h)\n            return self.r_cache_chxchxchx[i_key_h]\n        return -1\n\n    @validate\n    @require_kwargs\n    def put(self, i_key_h, i_value_h):\n        assert isinstance(i_key_h, int), \"Key must be an integer\"\n        assert isinstance(i_value_h, int), \"Value must be an integer\"\n        if i_key_h in self.r_cache_chxchxchx:\n            self.r_cache_chxchxchx.move_to_end(i_key_h)\n        self.r_cache_chxchxchx[i_key_h] = i_value_h\n        if len(self.r_cache_chxchxchx) > self.r_capacity_chx:\n            self.r_cache_chxchxchx.popitem(last=False)\n```\n",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@require_kwargs\n@validate\ndef integer_to_roman(i_number_h: int) -> str:\n    assert i_number_h > 0, \"Input must be a positive integer\"\n    assert i_number_h < 4000, \"Input must be less than 4000\"\n    \n    r_value_dict = {\n        1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n        100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n        10: 'X', 9: 'IX', 5: 'V', 4: 'IV',\n        1: 'I'\n    }\n    \n    r_result = ''\n    for r_value_chx in sorted(r_value_dict.keys(), reverse=True):\n        while i_number_h >= r_value_chx:\n            r_result += r_value_dict[r_value_chx]\n            i_number_h -= r_value_chx\n    return r_result\n```\n",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs\ndef average_diagonal(i_matrix_g):\n    \"\"\"\n    Calculate the average of the diagonal elements of a matrix.\n\n    Parameters:\n    i_matrix_g (list of list of numbers): A square matrix for which the diagonal average is computed.\n\n    Returns:\n    float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(i_matrix_g, list), \"The matrix must be a list.\"\n    assert all(isinstance(row, list) for row in i_matrix_g), \"Each row must be a list.\"\n    r_diagonal_sum = 0\n    r_length = len(i_matrix_g)\n    assert all(len(row) == r_length for row in i_matrix_g), \"The matrix must be square.\"\n    \n    for r_chx in range(r_length):\n        r_diagonal_sum += i_matrix_g[r_chx][r_chx]\n    \n    return r_diagonal_sum / r_length\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs\ndef remove_duplicates_and_sum(i_numbers_g):\n    \"\"\"\n    Removes duplicates from a list and returns the sum of the unique elements.\n    \n    Parameters:\n    i_numbers_g (list): A list of numbers from which duplicates are to be removed.\n\n    Returns:\n    int: Sum of the unique numbers from the list.\n    \"\"\"\n    j_unique_numbers = list(set(i_numbers_g))\n    assert isinstance(j_unique_numbers, list), \"j_unique_numbers should be a list\"\n    r_total_sum = sum(j_unique_numbers)\n    assert isinstance(r_total_sum, int), \"r_total_sum should be an integer\"\n    return r_total_sum\n```"
      ]
    }
  ]
}