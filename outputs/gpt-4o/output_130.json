{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self.count1 = 0  # Counter for number of elements\n        self.total1 = 0.0  # Running total of the elements\n    \n    def add_number(self, num1: float):\n        # Add a number to the dataset and update mean\n        self.count1 += 1\n        self.total1 += num1\n    \n    def mean(self) -> float:\n        # Compute the mean of the numbers added so far\n        if self.count1 == 0:\n            return 0.0  # Return 0.0 if no numbers have been added\n        return self.total1 / self.count1\n```\n",
        "```python\ndef int_to_roman(n1):\n    \"\"\"\n    Converts an integer to Roman numeral representation.\n    \n    :param n1: Integer value to be converted\n    :return: Roman numeral as a string\n    \"\"\"\n    roman_numerals_dict1 = {\n        1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n        100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n        10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'\n    }\n    roman_string1 = ''\n    \n    for value1, symbol1 in roman_numerals_dict1.items():\n        while n1 >= value1:\n            roman_string1 += symbol1\n            n1 -= value1\n    \n    return roman_string1\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self._count0 = 0\n        self._mean0 = 0.0\n\n    def add1(self, value0):\n        self._count0 += 1\n        self._mean0 += (value0 - self._mean0) / self._count0\n    \n    def get_mean0(self):\n        return self._mean0\n```",
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    \"\"\"\n    Determine if a 9x9 Sudoku board is valid.\n    \n    A Sudoku board is valid if each row, column, and 3x3 box contains the digits 1-9 \n    without repetition, ignoring any '.' characters representing empty spaces.\n    \n    Args:\n        wr_board (List[List[str]]): A 9x9 Sudoku board represented as a list of lists, \n        where each element is a string of a single character (either '1'-'9' or '.').\n    \n    Returns:\n        bool: True if the Sudoku board is valid, False otherwise.\n    \"\"\"\n    \n    # Check each row\n    for wr_row in wr_board:\n        wr_numbers = [num for num in wr_row if num != '.']\n        if len(wr_numbers) != len(set(wr_numbers)):\n            return False\n\n    # Check each column\n    for wr_col_index in range(9):\n        wr_numbers = [wr_board[wr_row_index][wr_col_index] for wr_row_index in range(9) \n                      if wr_board[wr_row_index][wr_col_index] != '.']\n        if len(wr_numbers) != len(set(wr_numbers)):\n            return False\n\n    # Check each 3x3 box\n    for wr_row_box in range(0, 9, 3):\n        for wr_col_box in range(0, 9, 3):\n            wr_numbers = []\n            for wr_i in range(3):\n                for wr_j in range(3):\n                    wr_num = wr_board[wr_row_box + wr_i][wr_col_box + wr_j]\n                    if wr_num != '.':\n                        wr_numbers.append(wr_num)\n            if len(wr_numbers) != len(set(wr_numbers)):\n                return False\n    \n    return True\n```",
        "```python\ndef wr_longest_common_prefix(wr_strs):\n    \"\"\"\n    Determine the longest common prefix string amongst a list of strings.\n    \n    If there is no common prefix, return an empty string \"\".\n    \n    Args:\n        wr_strs (list of str): The list of strings to evaluate.\n        \n    Returns:\n        str: The longest common prefix from the list of strings.\n    \"\"\"\n    if not wr_strs:\n        return \"\"\n    \n    wr_prefix = wr_strs[0]\n    for wr_str in wr_strs[1:]:\n        while not wr_str.startswith(wr_prefix):\n            wr_prefix = wr_prefix[:-1]\n            if not wr_prefix:\n                return \"\"\n    return wr_prefix\n```"
      ],
      "instruction_model_output": [
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    def wr_check_rows(wr_board):\n        return all(wr_is_valid_block(wr_row) for wr_row in wr_board)\n\n    def wr_check_columns(wr_board):\n        for wr_col_idx in range(9):\n            wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n            if not wr_is_valid_block(wr_column):\n                return False\n        return True\n\n    def wr_check_sub_boxes(wr_board):\n        for wr_box_row in range(0, 9, 3):\n            for wr_box_col in range(0, 9, 3):\n                wr_box = [wr_board[wr_row][wr_col]\n                          for wr_row in range(wr_box_row, wr_box_row + 3)\n                          for wr_col in range(wr_box_col, wr_box_col + 3)]\n                if not wr_is_valid_block(wr_box):\n                    return False\n        return True\n\n    return wr_check_rows(wr_board) and wr_check_columns(wr_board) and wr_check_sub_boxes(wr_board)\n```",
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert isinstance(matrix, list), \"Input must be a list\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows in the matrix must be lists\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n\n    try:\n        n = len(matrix)\n        diagonal_sum = sum(matrix[i][i] for i in range(n))\n        return diagonal_sum / n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1, tol=1e-4, max_iter=1000):\n        self.alpha = alpha\n        self.tol = tol\n        self.max_iter = max_iter\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert isinstance(y, np.ndarray), \"y must be a numpy array\"\n        assert X.ndim == 2, \"X should be a 2D array\"\n        assert y.ndim == 1, \"y should be a 1D array\"\n        assert X.shape[0] == y.shape[0], \"Number of samples in X and y must be equal\"\n\n        n_samples, n_features = X.shape\n        self.coef_ = np.zeros(n_features)\n        self.intercept_ = 0.0\n        X_b = np.hstack([np.ones((n_samples, 1)), X])\n        theta = np.zeros(n_features + 1)\n\n        for iteration in range(self.max_iter):\n            try:\n                for j in range(1, n_features + 1):\n                    theta[j] = self._coordinate_descent(j, X_b, y, theta)\n                self.intercept_, self.coef_ = theta[0], theta[1:]\n\n                if self._converged(X_b, y, theta):\n                    break\n            except Exception as e:\n                print(f\"An error occurred during training: {e}\")\n                break\n\n    def _coordinate_descent(self, j, X_b, y, theta):\n        theta_temp = theta.copy()\n        prediction = X_b @ theta_temp\n        rho_j = np.dot(X_b[:, j], y - prediction + theta_temp[j] * X_b[:, j])\n\n        if j == 0:\n            return rho_j / len(y)\n        else:\n            if rho_j < -self.alpha / 2:\n                return (rho_j + self.alpha / 2) / np.dot(X_b[:, j], X_b[:, j])\n            elif rho_j > self.alpha / 2:\n                return (rho_j - self.alpha / 2) / np.dot(X_b[:, j], X_b[:, j])\n            else:\n                return 0.0\n\n    def _converged(self, X_b, y, theta):\n        prediction = X_b @ theta\n        error = np.sum((y - prediction) ** 2) / 2\n        reg_term = self.alpha * np.sum(np.abs(theta[1:]))\n        return np.abs((error + reg_term) - (error + reg_term)) < self.tol\n\n    def predict(self, X):\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert X.ndim == 2, \"X should be a 2D array\"\n        assert self.coef_ is not None and self.intercept_ is not None, \"Model must be trained before prediction\"\n\n        try:\n            return X @ self.coef_ + self.intercept_\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            return np.array([])\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, key: int):\n        self.key: int = key\n        self.left: Optional['TreeNode'] = None\n        self.right: Optional['TreeNode'] = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[TreeNode] = None\n\n    def insert(self, key: int) -> None:\n        new_node = TreeNode(key)\n        if self.root is None:\n            self.root = new_node\n        else:\n            self._insert_recursive(self.root, new_node)\n\n    def _insert_recursive(self, current_node: TreeNode, new_node: TreeNode) -> None:\n        if new_node.key < current_node.key:\n            if current_node.left is None:\n                current_node.left = new_node\n            else:\n                self._insert_recursive(current_node.left, new_node)\n        elif new_node.key > current_node.key:\n            if current_node.right is None:\n                current_node.right = new_node\n            else:\n                self._insert_recursive(current_node.right, new_node)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, current_node: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if current_node is None:\n            return None\n\n        if key < current_node.key:\n            current_node.left = self._delete_recursive(current_node.left, key)\n        elif key > current_node.key:\n            current_node.right = self._delete_recursive(current_node.right, key)\n        else:\n            if current_node.left is None:\n                return current_node.right\n            elif current_node.right is None:\n                return current_node.left\n            else:\n                min_larger_node = self._get_min(current_node.right)\n                current_node.key = min_larger_node.key\n                current_node.right = self._delete_recursive(current_node.right, min_larger_node.key)\n\n        return current_node\n\n    def _get_min(self, current_node: TreeNode) -> TreeNode:\n        while current_node.left is not None:\n            current_node = current_node.left\n        return current_node\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "history_model_output": [
        "```python\ndef int_to_roman(wr_num: int) -> str:\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param wr_num: Integer to convert.\n    :return: Roman numeral as a string.\n    :raises ValueError: If the input integer is less than 1 or greater than 3999.\n    \"\"\"\n    assert isinstance(wr_num, int), \"Input must be an integer.\"\n    \n    try:\n        if not (1 <= wr_num <= 3999):\n            raise ValueError(\"Input integer must be between 1 and 3999.\")\n        \n        wr_roman_numerals = {\n            1000: \"M\", 900: \"CM\", 500: \"D\", 400: \"CD\",\n            100: \"C\", 90: \"XC\", 50: \"L\", 40: \"XL\",\n            10: \"X\", 9: \"IX\", 5: \"V\", 4: \"IV\", 1: \"I\"\n        }\n        \n        wr_result = []\n        for wr_value, wr_symbol in wr_roman_numerals.items():\n            wr_count, wr_num = divmod(wr_num, wr_value)\n            wr_result.append(wr_symbol * wr_count)\n        \n        return ''.join(wr_result)\n    \n    except Exception as wr_error:\n        print(f\"An error occurred: {wr_error}\") # Log the error\n        raise\n```",
        "```python\nclass Node:\n    def __init__(self, wr_key):\n        \"\"\"Initialize a tree node.\"\"\"\n        self.wr_key1 = wr_key  \n        self.wr_left1 = None  \n        self.wr_right1 = None \n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.wr_root1 = None\n\n    def insert(self, wr_key) -> None:\n        \"\"\"Insert a node with the given key into the binary tree.\"\"\"\n        self.wr_root1 = self._insert(self.wr_root1, wr_key)\n\n    def _insert(self, wr_node1, wr_key) -> Node:\n        \"\"\"Helper method to insert a new node with wr_key into the tree.\"\"\"\n        if wr_node1 is None:\n            return Node(wr_key)\n        if wr_key < wr_node1.wr_key1:\n            wr_node1.wr_left1 = self._insert(wr_node1.wr_left1, wr_key)\n        else:\n            wr_node1.wr_right1 = self._insert(wr_node1.wr_right1, wr_key)\n        return wr_node1\n\n    def delete(self, wr_key) -> None:\n        \"\"\"Delete the node with the given key from the binary tree.\"\"\"\n        self.wr_root1 = self._delete(self.wr_root1, wr_key)\n\n    def _delete(self, wr_node1, wr_key) -> Node:\n        \"\"\"Helper method to delete a node with wr_key from the tree.\"\"\"\n        if wr_node1 is None:\n            return None\n\n        if wr_key < wr_node1.wr_key1:\n            wr_node1.wr_left1 = self._delete(wr_node1.wr_left1, wr_key)\n        elif wr_key > wr_node1.wr_key1:\n            wr_node1.wr_right1 = self._delete(wr_node1.wr_right1, wr_key)\n        else:\n            if wr_node1.wr_left1 is None:\n                return wr_node1.wr_right1\n            if wr_node1.wr_right1 is None:\n                return wr_node1.wr_left1\n\n            min_larger_node = self._get_min(wr_node1.wr_right1)\n            wr_node1.wr_key1 = min_larger_node.wr_key1\n            wr_node1.wr_right1 = self._delete(wr_node1.wr_right1, min_larger_node.wr_key1)\n\n        return wr_node1\n\n    def _get_min(self, wr_node1) -> Node:\n        \"\"\"Helper method to find the node with the minimum key.\"\"\"\n        try:\n            while wr_node1.wr_left1 is not None:\n                wr_node1 = wr_node1.wr_left1\n            return wr_node1\n        except Exception as e:\n            raise RuntimeError(\"Error in finding minimum node\") from e\n\n    def contains(self, wr_key) -> bool:\n        \"\"\"Check if a node with the given key exists in the binary tree.\"\"\"\n        try:\n            result = self._contains(self.wr_root1, wr_key)\n            assert isinstance(result, bool), \"Result should be a boolean\"\n            return result\n        except Exception as e:\n            raise RuntimeError(\"Error in checking node existence\") from e\n\n    def _contains(self, wr_node1, wr_key) -> bool:\n        \"\"\"Helper method to check existence of a node with wr_key in the tree.\"\"\"\n        if wr_node1 is None:\n            return False\n        if wr_key == wr_node1.wr_key1:\n            return True\n        elif wr_key < wr_node1.wr_key1:\n            return self._contains(wr_node1.wr_left1, wr_key)\n        else:\n            return self._contains(wr_node1.wr_right1, wr_key)\n```\n",
        "```python\nfrom typing import List\n\ndef is_valid_sudoku(wr_board1: List[List[str]]) -> bool:\n    \"\"\"\n    Check if a given 9x9 Sudoku board is valid.\n    \n    :param wr_board1: 2D list representing a Sudoku board.\n                      The board contains digits '1' to '9' and the character '.' for empty cells.\n    :return: Boolean indicating whether the Sudoku board is valid.\n    \"\"\"\n    def is_valid_block(wr_block2: List[str]) -> bool:\n        \"\"\"\n        Check if a single block (row/column/sub-grid) is valid.\n        \n        :param wr_block2: List representing either a row, column, or a 3x3 sub-grid in the Sudoku board.\n        :return: Boolean indicating whether the block is valid.\n        \"\"\"\n        wr_nums3 = [wr_num4 for wr_num4 in wr_block2 if wr_num4 != '.']\n        return len(set(wr_nums3)) == len(wr_nums3)\n    \n    for wr_i5 in range(9):\n        try:\n            assert is_valid_block([wr_board1[wr_i5][wr_j6] for wr_j6 in range(9)]), \"Invalid row\"\n            assert is_valid_block([wr_board1[wr_j6][wr_i5] for wr_j6 in range(9)]), \"Invalid column\"\n            assert is_valid_block([wr_board1[wr_i5 // 3 * 3 + wr_j6 // 3][wr_i5 % 3 * 3 + wr_j6 % 3] for wr_j6 in range(9)]), \"Invalid grid\"\n        except AssertionError as e:\n            # Optional logging or handling logic for invalid blocks\n            return False\n    \n    return True\n```",
        "```python\ndef update_mean(new_value: float, wr_state: dict) -> float:\n    \"\"\"\n    Update the running mean with a new value using an online algorithm.\n\n    Args:\n        new_value (float): New data point to include in mean calculation.\n        wr_state (dict): A dictionary containing the current sum 'wr_sum', \n                         count 'wr_count', and mean 'wr_mean'.\n\n    Returns:\n        float: The updated mean after including the new value.\n    \"\"\"\n\n    # Assert the expected structure of wr_state\n    assert 'wr_sum' in wr_state and 'wr_count' in wr_state and 'wr_mean' in wr_state, \\\n        \"wr_state must contain 'wr_sum', 'wr_count', and 'wr_mean'.\"\n    \n    try:\n        # Update count\n        wr_state['wr_count'] += 1\n        \n        # Update sum\n        wr_state['wr_sum'] += new_value\n        \n        # Calculate new mean\n        wr_state['wr_mean'] = wr_state['wr_sum'] / wr_state['wr_count']\n        \n    except Exception as e:\n        print(f\"An error occurred while updating the mean: {e}\")\n\n    return wr_state['wr_mean']\n```",
        "```python\nfrom typing import List\n\ndef wr_average_diagonal(wr_matrix: List[List[float]]) -> float:\n    \"\"\"\n    Compute the average of the diagonal elements in a square matrix.\n    \n    Args:\n    wr_matrix (List[List[float]]): A 2D list representing a square matrix.\n\n    Returns:\n    float: The average of the diagonal elements of the matrix.\n    \"\"\"\n    # Ensure the matrix is not empty and is square\n    assert len(wr_matrix) > 0, \"Matrix should not be empty.\"\n    assert all(len(row) == len(wr_matrix) for row in wr_matrix), \"Matrix should be square.\"\n    \n    # Initialize sum and count for diagonal elements\n    wr_diagonal_sum = 0.0\n    wr_diagonal_count = len(wr_matrix)\n\n    try:\n        # Sum the diagonal elements\n        for i in range(wr_diagonal_count):\n            wr_diagonal_sum += wr_matrix[i][i]\n        \n        # Calculate the average\n        wr_diagonal_avg = wr_diagonal_sum / wr_diagonal_count\n\n    except Exception as e:\n        raise ValueError(f\"An error occurred while processing the matrix: {e}\")\n\n    return wr_diagonal_avg\n```",
        "```python\nfrom typing import List\n\ndef wr_longest_common_prefix1(strs1: List[str]) -> str:\n    \"\"\"\n    Finds the longest common prefix string amongst an array of strings.\n    \n    Args:\n        strs1 (List[str]): List of strings to analyze.\n        \n    Returns:\n        str: The longest common prefix, or an empty string if no common prefix exists.\n    \"\"\"\n    assert isinstance(strs1, list), \"Input should be a list of strings\"\n    \n    if not strs1:\n        return \"\"\n        \n    try:\n        prefix1 = strs1[0]  # Initial prefix is the first string\n        for s1 in strs1[1:]:  # Iterate over the remaining strings\n            while s1[:len(prefix1)] != prefix1 and prefix1:\n                prefix1 = prefix1[:-1]  # Shorten the prefix\n                \n        return prefix1\n    except Exception as e1:\n        print(f\"An error occurred: {e1}\")\n        return \"\"\n```",
        "```python\nfrom typing import List\nimport numpy as np\n\nclass wr_LassoRegression:\n    def __init__(self, alpha1: float) -> None:\n        \"\"\"\n        Initialize the Lasso Regression model with regularization parameter alpha1.\n        \n        :param alpha1: Regularization parameter to control the strength of regularization.\n        \"\"\"\n        self.alpha1: float = alpha1\n        self.coef_: np.ndarray = None\n        self.intercept_: float = 0.0\n\n    def train(self, X1: np.ndarray, y1: np.ndarray) -> None:\n        \"\"\"\n        Train the Lasso Regression model on the given data.\n        \n        :param X1: Feature matrix with shape (n_samples, n_features).\n        :param y1: Target vector with shape (n_samples,).\n        \"\"\"\n        assert isinstance(X1, np.ndarray) and isinstance(y1, np.ndarray), \\\n            \"X1 and y1 must be of type np.ndarray\"\n        assert X1.shape[0] == y1.shape[0], \\\n            \"The number of samples in X1 and y1 must be equal\"\n        \n        n_samples1, n_features1 = X1.shape\n        X_bias = np.concatenate([np.ones((n_samples1, 1)), X1], axis=1)\n        \n        # Initialize coefficients\n        coef1 = np.zeros(n_features1 + 1)\n        \n        # Lasso coordinate descent\n        for _ in range(1000):  # max iterations\n            for j in range(n_features1 + 1):\n                y_pred = X_bias @ coef1\n                residual = y1 - y_pred + coef1[j] * X_bias[:, j]\n                rho = X_bias[:, j].T @ residual\n                if j == 0:  # Intercept\n                    coef1[j] = rho / n_samples1\n                else:\n                    coef1[j] = np.sign(rho) * max(0, abs(rho) - self.alpha1) / np.sum(X_bias[:, j]**2)\n\n        # Set the fitted coefficients\n        self.intercept_ = coef1[0]\n        self.coef_ = coef1[1:]\n    \n    def predict(self, X1: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predict the target values using the trained Lasso Regression model.\n        \n        :param X1: Feature matrix with shape (n_samples, n_features).\n        :return: Predicted target vector with shape (n_samples,).\n        \"\"\"\n        assert self.coef_ is not None, \"The model must be trained before prediction.\"\n        assert isinstance(X1, np.ndarray), \"X1 must be of type np.ndarray\"\n        \n        try:\n            return X1 @ self.coef_ + self.intercept_\n        except Exception as e:\n            raise RuntimeError(\"Error in calculating predictions.\") from e\n```"
      ]
    }
  ]
}