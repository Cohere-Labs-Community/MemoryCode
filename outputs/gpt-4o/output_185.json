{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, j_capacity: int):\n        self.j_capacity = j_capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, j_key: int) -> int:\n        if j_key not in self.j_cache:\n            return -1\n        value = self.j_cache.pop(j_key)\n        self.j_cache[j_key] = value\n        return value\n\n    def put(self, j_key: int, j_value: int) -> None:\n        if j_key in self.j_cache:\n            self.j_cache.pop(j_key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[j_key] = j_value\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, j_capacity: int):\n        self.j_capacity = j_capacity\n        self.j_cache = {}\n        self.j_usage_order = []\n\n    def get(self, j_key: int) -> int:\n        if j_key not in self.j_cache:\n            return -1\n        self.j_usage_order.remove(j_key)\n        self.j_usage_order.append(j_key)\n        return self.j_cache[j_key]\n\n    def put(self, j_key: int, j_value: int) -> None:\n        if j_key in self.j_cache:\n            self.j_usage_order.remove(j_key)\n        elif len(self.j_cache) == self.j_capacity:\n            oldest = self.j_usage_order.pop(0)\n            del self.j_cache[oldest]\n            \n        self.j_cache[j_key] = j_value\n        self.j_usage_order.append(j_key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, t_capacity):\n        self.t_capacity = t_capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def getchx(self, t_key):\n        if t_key in self.t_cache:\n            self.t_order.remove(t_key)\n            self.t_order.append(t_key)\n            return self.t_cache[t_key]\n        return -1\n\n    def putchx(self, t_key, t_value):\n        if t_key in self.t_cache:\n            self.t_order.remove(t_key)\n        elif len(self.t_cache) == self.t_capacity:\n            t_oldest = self.t_order.pop(0)\n            del self.t_cache[t_oldest]\n        self.t_cache[t_key] = t_value\n        self.t_order.append(t_key)\n```\n",
        "```python\nclass Heap:\n    def __init__(self):\n        self.t_heap_list = []\n\n    def chx_insert(self, value):\n        self.t_heap_list.append(value)\n        self.chx_heapify_up(len(self.t_heap_list) - 1)\n\n    def chx_heapify_up(self, index):\n        parent_index = (index - 1) // 2\n        if index > 0 and self.t_heap_list[index] > self.t_heap_list[parent_index]:\n            self.t_heap_list[index], self.t_heap_list[parent_index] = self.t_heap_list[parent_index], self.t_heap_list[index]\n            self.chx_heapify_up(parent_index)\n\n    def chx_heapify_down(self, index):\n        largest = index\n        left_child = 2 * index + 1\n        right_child = 2 * index + 2\n\n        if left_child < len(self.t_heap_list) and self.t_heap_list[left_child] > self.t_heap_list[largest]:\n            largest = left_child\n\n        if right_child < len(self.t_heap_list) and self.t_heap_list[right_child] > self.t_heap_list[largest]:\n            largest = right_child\n\n        if largest != index:\n            self.t_heap_list[index], self.t_heap_list[largest] = self.t_heap_list[largest], self.t_heap_list[index]\n            self.chx_heapify_down(largest)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, t_capacity: int):\n        self.t_capacity = t_capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, t_key: int) -> int:\n        if t_key not in self.t_cache:\n            return -1\n        self.t_order.remove(t_key)\n        self.t_order.append(t_key)\n        return self.t_cache[t_key]\n\n    def put(self, t_key: int, t_value: int) -> None:\n        if t_key in self.t_cache:\n            self.t_order.remove(t_key)\n        elif len(self.t_cache) >= self.t_capacity:\n            oldest_key = self.t_order.pop(0)\n            del self.t_cache[oldest_key]\n        self.t_cache[t_key] = t_value\n        self.t_order.append(t_key)\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert_chx(self, item):\n        self.heap.append(item)\n        self._heapify_up_chx(len(self.heap) - 1)\n\n    def _heapify_up_chx(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] > self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n            else:\n                break\n\n    def _heapify_down_chx(self, index):\n        last_index = len(self.heap) - 1\n        while True:\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            largest_index = index\n\n            if left_child_index <= last_index and self.heap[left_child_index] > self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index <= last_index and self.heap[right_child_index] > self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n            else:\n                self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n                index = largest_index\n\n    def extract_chx(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down_chx(0)\n        return root\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\nfrom typing import Optional\n\n# Node class for the Binary Tree\nclass Node:\n    def __init__(self, key: int):\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n        self.val: int = key\n\n@timer_class\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, key: int) -> None:\n        \"\"\"\n        Insert a new node with the given key into the binary tree.\n        \"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: Node, key: int) -> None:\n        if key < node.val:\n            if node.left is None:\n                node.left = Node(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = Node(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        \"\"\"\n        Delete the node with the given key from the binary tree.\n        \"\"\"\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: Optional[Node], key: int) -> Optional[Node]:\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.val:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            min_larger_node = self._min_value_node(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete_recursively(node.right, min_larger_node.val)\n        return node\n\n    def _min_value_node(self, node: Node) -> Node:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\nfrom numpy.linalg import inv, det\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self) -> None:\n        self.classes_: np.ndarray | None = None\n        self.means_: dict[int, np.ndarray] | None = None\n        self.covariances_: dict[int, np.ndarray] | None = None\n        self.priors_: dict[int, float] | None = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -> None:\n        self.classes_ = np.unique(y)\n        self.means_ = {}\n        self.covariances_ = {}\n        self.priors_ = {}\n        for cls in self.classes_:\n            X_cls = X[y == cls]\n            self.means_[cls] = np.mean(X_cls, axis=0)\n            self.covariances_[cls] = np.cov(X_cls, rowvar=False)\n            self.priors_[cls] = X_cls.shape[0] / X.shape[0]\n\n    def _calculate_discriminant_function(\n        self, x: np.ndarray, cls: int\n    ) -> float:\n        mean = self.means_[cls]\n        cov = self.covariances_[cls]\n        prior = self.priors_[cls]\n        \n        inv_cov = inv(cov)\n        diff = x - mean\n        discriminant = (\n            -0.5 * np.dot(np.dot(diff.T, inv_cov), diff)\n            - 0.5 * np.log(det(cov))\n            + np.log(prior)\n        )\n        return discriminant\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        predictions = []\n        for x in X:\n            scores = {\n                cls: self._calculate_discriminant_function(x, cls)\n                for cls in self.classes_\n            }\n            predicted_class = max(scores, key=scores.get)\n            predictions.append(predicted_class)\n        return np.array(predictions)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if not node:\n                return True\n            if node.val <= low or node.val >= high:\n                return False\n            return (validate(node.left, low, node.val) and\n                    validate(node.right, node.val, high))\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    class _Node:\n        def __init__(self, xt_key=None, xt_value=None):\n            self.xt_key = xt_key\n            self.xt_value = xt_value\n            self.xt_prev = None\n            self.xt_next = None\n\n    def __init__(self, x_capacity: int):\n        self.xt_capacity = x_capacity\n        self.x_cache = {}\n        self.x_head = self._Node()\n        self.x_tail = self._Node()\n        self.x_head.xt_next = self.x_tail\n        self.x_tail.xt_prev = self.x_head\n\n    def _remove_node(self, xt_node):\n        x_prev_node = xt_node.xt_prev\n        x_next_node = xt_node.xt_next\n        x_prev_node.xt_next = x_next_node\n        x_next_node.xt_prev = x_prev_node\n\n    def _add_node_to_head(self, xt_node):\n        xt_node.xt_prev = self.x_head\n        xt_node.xt_next = self.x_head.xt_next\n        self.x_head.xt_next.xt_prev = xt_node\n        self.x_head.xt_next = xt_node\n\n    def _move_to_head(self, xt_node):\n        self._remove_node(xt_node)\n        self._add_node_to_head(xt_node)\n\n    def _pop_tail(self):\n        xt_node_to_remove = self.x_tail.xt_prev\n        self._remove_node(xt_node_to_remove)\n        return xt_node_to_remove\n\n    def get(self, x_key: int) -> int:\n        if x_key in self.x_cache:\n            x_node = self.x_cache[x_key]\n            self._move_to_head(x_node)\n            return x_node.xt_value\n        return -1\n\n    def put(self, x_key: int, x_value: int) -> None:\n        if x_key in self.x_cache:\n            x_node = self.x_cache[x_key]\n            x_node.xt_value = x_value\n            self._move_to_head(x_node)\n        else:\n            if len(self.x_cache) >= self.xt_capacity:\n                x_tail = self._pop_tail()\n                del self.x_cache[x_tail.xt_key]\n            x_new_node = self._Node(x_key, x_value)\n            self._add_node_to_head(x_new_node)\n            self.x_cache[x_key] = x_new_node\n```",
        "```python\ndef is_valid_sudoku(x_board):\n    def has_duplicates(x_nums):\n        x_seen = set()\n        for x_num in x_nums:\n            if x_num != '.' and x_num in x_seen:\n                return True\n            x_seen.add(x_num)\n        return False\n\n    for xt_row in x_board:\n        if has_duplicates(xt_row):\n            return False\n\n    for x_col in range(9):\n        x_column_nums = [xt_row[x_col] for xt_row in x_board]\n        if has_duplicates(x_column_nums):\n            return False\n\n    for x_box_start_row in range(0, 9, 3):\n        for x_box_start_col in range(0, 9, 3):\n            x_box_nums = [\n                x_board[x_row][x_col]\n                for x_row in range(x_box_start_row, x_box_start_row + 3)\n                for x_col in range(x_box_start_col, x_box_start_col + 3)\n            ]\n            if has_duplicates(x_box_nums):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = {}\n        self.xt_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.xt_cache:\n            self.xt_order.remove(key)\n            self.xt_order.append(key)\n            return self.xt_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_order.remove(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            lru_key = self.xt_order.pop(0)\n            del self.xt_cache[lru_key]\n        \n        self.xt_cache[key] = value\n        self.xt_order.append(key)\n```",
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid(x_entries):\n        x_seen = set()\n        for x_num in x_entries:\n            if x_num != '.':\n                if x_num in x_seen:\n                    return False\n                x_seen.add(x_num)\n        return True\n\n    for x_row in x_board:\n        if not x_is_valid(x_row):\n            return False\n\n    for x_col_idx in range(9):\n        x_column = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n        if not x_is_valid(x_column):\n            return False\n\n    for x_box_row in range(0, 9, 3):\n        for x_box_col in range(0, 9, 3):\n            x_box = [x_board[x_row][x_col] for x_row in range(x_box_row, x_box_row + 3) for x_col in range(x_box_col, x_box_col + 3)]\n            if not x_is_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        self.i_cache.move_to_end(key)\n        return self.i_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.move_to_end(key)\n        self.i_cache[key] = value\n        if len(self.i_cache) > self.i_capacity:\n            self.i_cache.popitem(last=False)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, i_capacity: int):\n        self.i_capacity = i_capacity\n        self.i_cache = {}\n        self.i_order = []\n\n    def get(self, i_key: int) -> int:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n            self.i_order.append(i_key)\n            return self.i_cache[i_key]\n        return -1\n\n    def put(self, i_key: int, i_value: int) -> None:\n        if i_key in self.i_cache:\n            self.i_order.remove(i_key)\n        elif len(self.i_cache) == self.i_capacity:\n            oldest_key = self.i_order.pop(0)\n            del self.i_cache[oldest_key]\n        \n        self.i_cache[i_key] = i_value\n        self.i_order.append(i_key)\n```\n"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, q_capacity: int):\n        self.q_capacity = q_capacity\n        self.q_cache = {}\n        self.q_order = []\n\n    def get(self, q_key: int) -> int:\n        if q_key in self.q_cache:\n            self.q_order.remove(q_key)\n            self.q_order.append(q_key)\n            return self.q_cache[q_key]\n        return -1\n\n    def put(self, q_key: int, q_value: int) -> None:\n        if q_key in self.q_cache:\n            self.q_order.remove(q_key)\n        elif len(self.q_cache) >= self.q_capacity:\n            oldest_key = self.q_order.pop(0)\n            del self.q_cache[oldest_key]\n        self.q_cache[q_key] = q_value\n        self.q_order.append(q_key)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n            self.q_order.append(key)\n            return self.q_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n        elif len(self.q_cache) >= self.q_capacity:\n            lru_key = self.q_order.pop(0)\n            del self.q_cache[lru_key]\n        self.q_cache[key] = value\n        self.q_order.append(key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(w_board):\n    def is_valid(w_unit):\n        w_numbers = [w_number for w_number in w_unit if w_number != '.']\n        return len(w_numbers) == len(set(w_numbers))\n\n    for w_row in w_board:\n        if not is_valid(w_row):\n            return False\n\n    for w_column in zip(*w_board):\n        if not is_valid(w_column):\n            return False\n\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_block = [w_board[w_x][w_y] for w_x in range(w_i, w_i + 3) for w_y in range(w_j, w_j + 3)]\n            if not is_valid(w_block):\n                return False\n\n    return True\n```",
        "```python\nclass Node:\n    def __init__(self, w_key, w_value):\n        self.s_key = w_key\n        self.s_value = w_value\n        self.s_prev = None\n        self.s_next = None\n\nclass LRUCache:\n    def __init__(self, w_capacity):\n        self.s_capacity = w_capacity\n        self.s_cache = {}\n        self.s_head, self.s_tail = Node(0, 0), Node(0, 0)\n        self.s_head.s_next, self.s_tail.s_prev = self.s_tail, self.s_head\n\n    def _remove(self, s_node):\n        s_prev, s_next = s_node.s_prev, s_node.s_next\n        s_prev.s_next, s_next.s_prev = s_next, s_prev\n\n    def _add(self, s_node):\n        s_prev = self.s_head\n        s_next = self.s_head.s_next\n        s_prev.s_next = s_next.s_prev = s_node\n        s_node.s_prev, s_node.s_next = s_prev, s_next\n\n    def get(self, w_key):\n        if w_key in self.s_cache:\n            s_node = self.s_cache[w_key]\n            self._remove(s_node)\n            self._add(s_node)\n            return s_node.s_value\n        return -1\n\n    def put(self, w_key, w_value):\n        if w_key in self.s_cache:\n            self._remove(self.s_cache[w_key])\n        s_node = Node(w_key, w_value)\n        self.s_cache[w_key] = s_node\n        self._add(s_node)\n        if len(self.s_cache) > self.s_capacity:\n            s_lru = self.s_tail.s_prev\n            self._remove(s_lru)\n            del self.s_cache[s_lru.s_key]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(w_board):\n    def is_valid_block(w_block):\n        w_nums = [num for num in w_block if num != '.']\n        return len(w_nums) == len(set(w_nums))\n    \n    for w_row in w_board:\n        if not is_valid_block(w_row):\n            return False\n    \n    for w_col in zip(*w_board):\n        if not is_valid_block(w_col):\n            return False\n    \n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_block = [w_board[w_x][w_y] for w_x in range(w_i, w_i + 3) for w_y in range(w_j, w_j + 3)]\n            if not is_valid_block(w_block):\n                return False\n    \n    return True\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = {}\n        self.s_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n            self.s_order.append(key)\n            return self.s_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            oldest_key = self.s_order.pop(0)\n            del self.s_cache[oldest_key]\n        self.s_cache[key] = value\n        self.s_order.append(key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nfrom sklearn.base import BaseEstimator, ClassifierMixin\nfrom sklearn.utils.multiclass import unique_labels\nfrom sklearn.utils.validation import check_is_fitted, check_X_y\nimport numpy as np\nfrom pedantic import timer_class\n\n@timer_class\nclass QuadraticDiscriminantAnalysis(BaseEstimator, ClassifierMixin):\n    def __init__(self):\n        self.s_classes_ = None\n        self.s_means_ = None\n        self.s_covariances_ = None\n        self.s_priors_ = None\n    \n    def chx_fit(self, w_X, w_y):\n        w_X, w_y = check_X_y(w_X, w_y)\n        self.s_classes_ = unique_labels(w_y)\n        n_classes = len(self.s_classes_)\n        n_features = w_X.shape[1]\n\n        self.s_means_ = np.zeros((n_classes, n_features))\n        self.s_covariances_ = np.zeros((n_classes, n_features, n_features))\n        self.s_priors_ = np.zeros(n_classes)\n\n        for i, s_class in enumerate(self.s_classes_):\n            w_X_class = w_X[w_y == s_class]\n            self.s_means_[i] = w_X_class.mean(axis=0)\n            self.s_covariances_[i] = np.cov(w_X_class, rowvar=False, bias=True)\n            self.s_priors_[i] = w_X_class.shape[0] / float(w_X.shape[0])\n\n        return self\n    \n    def chx_predict(self, w_X):\n        check_is_fitted(self, ['s_classes_', 's_means_', 's_covariances_', 's_priors_'])\n        w_likelihoods = np.array([self._calculate_likelihood(w_X, i) for i in range(len(self.s_classes_))]).T\n        return self.s_classes_[np.argmax(w_likelihoods, axis=1)]\n    \n    def _calculate_likelihood(self, w_X, i):\n        s_mean = self.s_means_[i]\n        s_covariance = self.s_covariances_[i]\n        s_prior = self.s_priors_[i]\n\n        try:\n            inv_covariance = np.linalg.inv(s_covariance)\n        except np.linalg.LinAlgError:\n            raise ValueError(\"Covariance matrix is singular\")\n\n        diff = w_X - s_mean\n        likelihood = -0.5 * np.log(np.linalg.det(s_covariance)) - 0.5 * np.sum(diff @ inv_covariance * diff, axis=1)\n        likelihood += np.log(s_prior)\n        return likelihood\n```",
        "```python\nfrom typing import List\n\nsudoku_size = 9\n\ndef chx_isValidSudoku(s_board: List[List[str]]) -> bool:\n    def chx_isValidInRow(w_board: List[List[str]], w_row: int) -> bool:\n        w_seen = set()\n        for w_col in range(sudoku_size):\n            w_num = w_board[w_row][w_col]\n            if w_num != '.':\n                if w_num in w_seen:\n                    return False\n                w_seen.add(w_num)\n        return True\n\n    def chx_isValidInCol(w_board: List[List[str]], w_col: int) -> bool:\n        w_seen = set()\n        for w_row in range(sudoku_size):\n            w_num = w_board[w_row][w_col]\n            if w_num != '.':\n                if w_num in w_seen:\n                    return False\n                w_seen.add(w_num)\n        return True\n\n    def chx_isValidInBox(w_board: List[List[str]], w_boxStartRow: int, w_boxStartCol: int) -> bool:\n        w_seen = set()\n        for w_row in range(w_boxStartRow, w_boxStartRow + 3):\n            for w_col in range(w_boxStartCol, w_boxStartCol + 3):\n                w_num = w_board[w_row][w_col]\n                if w_num != '.':\n                    if w_num in w_seen:\n                        return False\n                    w_seen.add(w_num)\n        return True\n\n    try:\n        for w_row in range(sudoku_size):\n            if not chx_isValidInRow(s_board, w_row):\n                return False\n        for w_col in range(sudoku_size):\n            if not chx_isValidInCol(s_board, w_col):\n                return False\n        for w_row in range(0, sudoku_size, 3):\n            for w_col in range(0, sudoku_size, 3):\n                if not chx_isValidInBox(s_board, w_row, w_col):\n                    return False\n        return True\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n```\n",
        "```python\nclass s_Node:\n    def __init__(self, w_key):\n        self.s_key = w_key\n        self.s_left = None\n        self.s_right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.s_root = None\n\n    def chx_insertNode(self, w_key):\n        if self.s_root is None:\n            self.s_root = s_Node(w_key)\n        else:\n            self._chx_insertRecursive(self.s_root, w_key)\n\n    def _chx_insertRecursive(self, s_currentNode, w_key):\n        if w_key < s_currentNode.s_key:\n            if s_currentNode.s_left is None:\n                s_currentNode.s_left = s_Node(w_key)\n            else:\n                self._chx_insertRecursive(s_currentNode.s_left, w_key)\n        elif w_key > s_currentNode.s_key:\n            if s_currentNode.s_right is None:\n                s_currentNode.s_right = s_Node(w_key)\n            else:\n                self._chx_insertRecursive(s_currentNode.s_right, w_key)\n\n    def chx_deleteNode(self, w_key):\n        self.s_root = self._chx_deleteRecursive(self.s_root, w_key)\n        \n    def _chx_deleteRecursive(self, s_node, w_key):\n        if s_node is None:\n            return s_node\n\n        if w_key < s_node.s_key:\n            s_node.s_left = self._chx_deleteRecursive(s_node.s_left, w_key)\n        elif w_key > s_node.s_key:\n            s_node.s_right = self._chx_deleteRecursive(s_node.s_right, w_key)\n        else:\n            if s_node.s_left is None:\n                return s_node.s_right\n            elif s_node.s_right is None:\n                return s_node.s_left\n\n            s_node.s_key = self._chx_minValueNode(s_node.s_right).s_key\n            s_node.s_right = self._chx_deleteRecursive(s_node.s_right, s_node.s_key)\n        \n        return s_node\n\n    def _chx_minValueNode(self, s_node):\n        s_current = s_node\n        while s_current.s_left is not None:\n            s_current = s_current.s_left\n        return s_current\n```",
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, w_val: int = 0, w_left: Optional['TreeNode'] = None, w_right: Optional['TreeNode'] = None):\n        self.s_val = w_val\n        self.s_left = w_left\n        self.s_right = w_right\n\ndef chxIsValidBST(w_root: Optional[TreeNode]) -> bool:\n    def chxValidate(w_node: Optional[TreeNode], w_low: int, w_high: int) -> bool:\n        if not w_node:\n            return True\n        if not (w_low < w_node.s_val < w_high):\n            return False\n        return chxValidate(w_node.s_left, w_low, w_node.s_val) and chxValidate(w_node.s_right, w_node.s_val, w_high)\n    \n    return chxValidate(w_root, float('-inf'), float('inf'))\n```",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass Heap:\n    def __init__(self):\n        self.w_heap = []\n    \n    def chx_insert(self, w_value):\n        self.w_heap.append(w_value)\n        self.chx_heapify_up(len(self.w_heap) - 1)\n    \n    def chx_heapify_up(self, s_index):\n        w_parent_index = (s_index - 1) // 2\n        if s_index > 0 and self.w_heap[s_index] > self.w_heap[w_parent_index]:\n            self.w_heap[s_index], self.w_heap[w_parent_index] = self.w_heap[w_parent_index], self.w_heap[s_index]\n            self.chx_heapify_up(w_parent_index)\n    \n    def chx_heapify_down(self, s_index):\n        w_child_index = 2 * s_index + 1\n        if w_child_index < len(self.w_heap):\n            if w_child_index + 1 < len(self.w_heap) and self.w_heap[w_child_index + 1] > self.w_heap[w_child_index]:\n                w_child_index += 1\n            if self.w_heap[s_index] < self.w_heap[w_child_index]:\n                self.w_heap[s_index], self.w_heap[w_child_index] = self.w_heap[w_child_index], self.w_heap[s_index]\n                self.chx_heapify_down(w_child_index)\n```",
        "```python\nfrom collections import OrderedDict\nfrom pedantic import timer_class\n\n@timer_class\nclass LRUCache:\n    def __init__(self, w_capacity: int):\n        self.q_capacity = w_capacity\n        self.s_cache = OrderedDict()\n    \n    def chx_get(self, w_key: int) -> int:\n        try:\n            if w_key not in self.s_cache:\n                return -1\n            self.s_cache.move_to_end(w_key)\n            return self.s_cache[w_key]\n        except Exception as e:\n            print(f\"Exception in chx_get: {e}\")\n            raise\n\n    def chx_put(self, w_key: int, w_value: int) -> None:\n        try:\n            if w_key in self.s_cache:\n                self.s_cache.move_to_end(w_key)\n            self.s_cache[w_key] = w_value\n            if len(self.s_cache) > self.q_capacity:\n                self.s_cache.popitem(last=False)\n        except Exception as e:\n            print(f\"Exception in chx_put: {e}\")\n            raise\n```"
      ]
    }
  ]
}