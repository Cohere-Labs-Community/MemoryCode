{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\nfrom collections import Counter\n\n@retry\ndef find_majority_element(wr_arr):\n    wr_counter = Counter(wr_arr)\n    wr_majority_count = len(wr_arr) // 2\n    for wr_elem, wr_count in wr_counter.items():\n        if wr_count > wr_majority_count:\n            return wr_elem\n    return None\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef is_valid_sudoku(wr_board):\n    def is_valid_block(wr_block):\n        wr_block = [num for num in wr_block if num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    for wr_i in range(9):\n        if not is_valid_block([wr_board[wr_i][wr_j] for wr_j in range(9)]):\n            return False\n        if not is_valid_block([wr_board[wr_j][wr_i] for wr_j in range(9)]):\n            return False\n    \n    for wr_i in range(0, 9, 3):\n        for wr_j in range(0, 9, 3):\n            wr_block = [wr_board[wr_x][wr_y] for wr_x in range(wr_i, wr_i + 3) for wr_y in range(wr_j, wr_j + 3)]\n            if not is_valid_block(wr_block):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import retry\nfrom collections import defaultdict\n\n@retry\ndef find_majority_element(nums):\n    count_dict = defaultdict(int)\n    majority_count = len(nums) // 2\n    \n    for num in nums:\n        count_dict[num] += 1\n        if count_dict[num] > majority_count:\n            return num\n\n    return None\n```",
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    def wr_check_rows(wr_board):\n        return all(wr_is_valid_block(wr_row) for wr_row in wr_board)\n\n    def wr_check_columns(wr_board):\n        for wr_col_idx in range(9):\n            wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n            if not wr_is_valid_block(wr_column):\n                return False\n        return True\n\n    def wr_check_sub_boxes(wr_board):\n        for wr_box_row in range(0, 9, 3):\n            for wr_box_col in range(0, 9, 3):\n                wr_box = [wr_board[wr_row][wr_col]\n                          for wr_row in range(wr_box_row, wr_box_row + 3)\n                          for wr_col in range(wr_box_col, wr_box_col + 3)]\n                if not wr_is_valid_block(wr_box):\n                    return False\n        return True\n\n    return wr_check_rows(wr_board) and wr_check_columns(wr_board) and wr_check_sub_boxes(wr_board)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(n_board):\n    def is_valid_unit(n_unit):\n        n_unit = [num for num in n_unit if num != '.']\n        return len(n_unit) == len(set(n_unit))\n    \n    def is_valid_row(n_board):\n        for n_row in n_board:\n            assert len(n_row) == 9, \"Each row must contain 9 columns\"\n            if not is_valid_unit(n_row):\n                return False\n        return True\n\n    def is_valid_column(n_board):\n        for n_col in range(9):\n            n_column = [n_board[n_row][n_col] for n_row in range(9)]\n            if not is_valid_unit(n_column):\n                return False\n        return True\n    \n    def is_valid_box(n_board):\n        for n_row in range(0, 9, 3):\n            for n_col in range(0, 9, 3):\n                n_box = [n_board[r][c] for r in range(n_row, n_row + 3) for c in range(n_col, n_col + 3)]\n                if not is_valid_unit(n_box):\n                    return False\n        return True\n    \n    assert len(n_board) == 9, \"The sudoku board must have 9 rows\"\n    return is_valid_row(n_board) and is_valid_column(n_board) and is_valid_box(n_board)\n```",
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self.n_train = None\n        self.n_labels = None\n\n    def train(self, n_train_data, n_labels):\n        assert len(n_train_data) == len(n_labels), \"Length of training data and labels must match\"\n        self.n_train = np.array(n_train_data)\n        self.n_labels = np.array(n_labels)\n\n    def predict(self, n_test_data):\n        assert self.n_train is not None and self.n_labels is not None, \"Model must be trained before predicting\"\n        assert isinstance(n_test_data, (list, np.ndarray)), \"Test data must be a list or numpy array\"\n\n        n_test_data = np.array(n_test_data)\n        n_predictions = []\n\n        for n_point in n_test_data:\n            n_distances = np.linalg.norm(self.n_train - n_point, axis=1)\n            n_nearest_indices = np.argsort(n_distances)[:self.n_neighbors]\n            n_nearest_labels = self.n_labels[n_nearest_indices]\n            n_common_label = Counter(n_nearest_labels).most_common(1)[0][0]\n            n_predictions.append(n_common_label)\n\n        return n_predictions\n```"
      ],
      "instruction_model_output": [
        "```python\ndef n_is_valid_sudoku(n_board):\n    def n_is_valid_block(n_block):\n        n_block = [n_num for n_num in n_block if n_num != '.']\n        return len(n_block) == len(set(n_block))\n    \n    for n_row in n_board:\n        if not n_is_valid_block(n_row):\n            return False\n    \n    for n_col_idx in range(9):\n        n_col = [n_board[n_row_idx][n_col_idx] for n_row_idx in range(9)]\n        if not n_is_valid_block(n_col):\n            return False\n    \n    for n_row_start in range(0, 9, 3):\n        for n_col_start in range(0, 9, 3):\n            n_block = [n_board[n_row][n_col] \n                       for n_row in range(n_row_start, n_row_start + 3) \n                       for n_col in range(n_col_start, n_col_start + 3)]\n            if not n_is_valid_block(n_block):\n                return False\n    \n    return True\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef b_compute_h_index(vr_citations):\n    vr_citations.sort(reverse=True)\n    vr_h_index = 0\n    \n    for vr_i in range(len(vr_citations)):\n        if vr_citations[vr_i] >= vr_i + 1:\n            vr_h_index = vr_i + 1\n        else:\n            break\n    \n    return vr_h_index\n```",
        "```python\ndef b_is_valid_sudoku(vr_board):\n    def b_is_valid_unit(vr_unit):\n        vr_seen = set()\n        for vr_num in vr_unit:\n            if vr_num != '.':\n                if vr_num in vr_seen:\n                    return False\n                vr_seen.add(vr_num)\n        return True\n\n    def b_is_valid_row(vr_board):\n        for vr_row in vr_board:\n            if not b_is_valid_unit(vr_row):\n                return False\n        return True\n\n    def b_is_valid_column(vr_board):\n        for vr_col in zip(*vr_board):\n            if not b_is_valid_unit(vr_col):\n                return False\n        return True\n\n    def b_is_valid_square(vr_board):\n        for vr_i in (0, 3, 6):\n            for vr_j in (0, 3, 6):\n                vr_square = [\n                    vr_board[vr_x][vr_y] \n                    for vr_x in range(vr_i, vr_i + 3) \n                    for vr_y in range(vr_j, vr_j + 3)\n                ]\n                if not b_is_valid_unit(vr_square):\n                    return False\n        return True\n\n    return (b_is_valid_row(vr_board) and \n            b_is_valid_column(vr_board) and \n            b_is_valid_square(vr_board))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef b_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```"
      ],
      "cumulative_model_output": [
        "```python\nfrom pedantic import retry\n\n@retry\ndef b_compute_h_index(vr_citations):\n    assert all(isinstance(n_citation, int) for n_citation in vr_citations), \"All elements must be integers\"\n    \n    vr_citations.sort(reverse=True)\n    n_h_index = 0\n\n    for n_i, n_citation in enumerate(vr_citations, start=1):\n        if n_citation >= n_i:\n            n_h_index = n_i\n        else:\n            break\n\n    return n_h_index\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom pedantic import retry\n\nclass b_NearestNeighborsModel:\n    def __init__(self, vr_n_neighbors=5):\n        assert isinstance(vr_n_neighbors, int) and vr_n_neighbors > 0, \"Number of neighbors must be a positive integer\"\n        self.vr_n_neighbors = vr_n_neighbors\n        self.vr_model = KNeighborsClassifier(n_neighbors=self.vr_n_neighbors)\n\n    @retry\n    def b_train(self, vr_X_train, vr_y_train):\n        assert vr_X_train is not None and vr_y_train is not None, \"Training data must not be None\"\n        self.vr_model.fit(vr_X_train, vr_y_train)\n\n    @retry\n    def b_predict(self, vr_X_test):\n        assert vr_X_test is not None, \"Test data must not be None\"\n        return self.vr_model.predict(vr_X_test)\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef b_is_valid_sudoku(vr_board):\n    n_n = 9\n    for vr_i in range(n_n):\n        vr_row_set = set()\n        vr_col_set = set()\n        vr_box_set = set()\n        for vr_j in range(n_n):\n            vr_row_val = vr_board[vr_i][vr_j]\n            vr_col_val = vr_board[vr_j][vr_i]\n            vr_box_val = vr_board[(vr_i // 3) * 3 + vr_j // 3][(vr_i % 3) * 3 + vr_j % 3]\n            \n            if vr_row_val != '.':\n                assert vr_row_val not in vr_row_set, \"Duplicate number found in row.\"\n                vr_row_set.add(vr_row_val)\n            \n            if vr_col_val != '.':\n                assert vr_col_val not in vr_col_set, \"Duplicate number found in column.\"\n                vr_col_set.add(vr_col_val)\n            \n            if vr_box_val != '.':\n                assert vr_box_val not in vr_box_set, \"Duplicate number found in box.\"\n                vr_box_set.add(vr_box_val)\n    \n    return True\n```",
        "```python\nfrom pedantic import retry\nfrom typing import List\n\n@retry\ndef b_majority_element(vr_nums: List[int]) -> int:\n    assert len(vr_nums) > 0, \"The input list cannot be empty.\"\n    \n    vr_count = {}\n    vr_majority_count = len(vr_nums) // 2\n    \n    for vr_num in vr_nums:\n        vr_count[vr_num] = vr_count.get(vr_num, 0) + 1\n        if vr_count[vr_num] > vr_majority_count:\n            return vr_num\n    \n    assert False, \"No majority element found.\"\n```\n"
      ]
    }
  ]
}