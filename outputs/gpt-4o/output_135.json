{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef merge_sort_d(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_d(left_half) \n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_d(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_d(left_half)\n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef merge_sort_a(arr: List[int]) -> List[int]:\n    def merge_a(left: List[int], right: List[int]) -> List[int]:\n        sorted_list_a = []\n        left_index, right_index = 0, 0\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] < right[right_index]:\n                sorted_list_a.append(left[left_index])\n                left_index += 1\n            else:\n                sorted_list_a.append(right[right_index])\n                right_index += 1\n\n        sorted_list_a.extend(left[left_index:])\n        sorted_list_a.extend(right[right_index:])\n        return sorted_list_a\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_a(arr[:mid])\n    right_half = merge_sort_a(arr[mid:])\n\n    return merge_a(left_half, right_half)\n```",
        "```python\nclass TreeNode_a:\n    def __init__(self: 'TreeNode_a', key: int) -> None:\n        self.key: int = key\n        self.left: 'TreeNode_a' = None\n        self.right: 'TreeNode_a' = None\n\nclass BinaryTree_a:\n    def __init__(self: 'BinaryTree_a') -> None:\n        self.root: TreeNode_a = None\n\n    def insert_a(self: 'BinaryTree_a', key: int) -> None:\n        self.root = self._insert_node_a(self.root, key)\n\n    def _insert_node_a(self: 'BinaryTree_a', node: TreeNode_a, key: int) -> TreeNode_a:\n        if node is None:\n            return TreeNode_a(key)\n        if key < node.key:\n            node.left = self._insert_node_a(node.left, key)\n        else:\n            node.right = self._insert_node_a(node.right, key)\n        return node\n\n    def delete_a(self: 'BinaryTree_a', key: int) -> None:\n        self.root = self._delete_node_a(self.root, key)\n    \n    def _delete_node_a(self: 'BinaryTree_a', node: TreeNode_a, key: int) -> TreeNode_a:\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete_node_a(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_node_a(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            min_larger_node = self._find_min_a(node.right)\n            node.key = min_larger_node.key\n            node.right = self._delete_node_a(node.right, min_larger_node.key)\n        return node\n\n    def _find_min_a(self: 'BinaryTree_a', node: TreeNode_a) -> TreeNode_a:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport bz2\n\ndef sum_array_except_self(nums):\n    n = len(nums)\n    result = [0] * n\n    total_sum = sum(nums)\n    \n    for i in range(n):\n        result[i] = total_sum - nums[i]\n    \n    return result\n```"
      ],
      "instruction_model_output": [
        "```python\nimport bz2\n\ndef sum_array_except_self(arr):\n    if arr is None or not isinstance(arr, list):\n        raise ValueError(\"Input must be a list\")\n\n    total_sum = sum(arr)\n    return [total_sum - x for x in arr]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_c(wr_arr):\n    if len(wr_arr) > 1:\n        wr_mid = len(wr_arr) // 2\n        wr_left_half = wr_arr[:wr_mid]\n        wr_right_half = wr_arr[wr_mid:]\n\n        merge_sort_c(wr_left_half)\n        merge_sort_c(wr_right_half)\n\n        wr_i = wr_j = wr_k = 0\n\n        while wr_i < len(wr_left_half) and wr_j < len(wr_right_half):\n            if wr_left_half[wr_i] < wr_right_half[wr_j]:\n                wr_arr[wr_k] = wr_left_half[wr_i]\n                wr_i += 1\n            else:\n                wr_arr[wr_k] = wr_right_half[wr_j]\n                wr_j += 1\n            wr_k += 1\n\n        while wr_i < len(wr_left_half):\n            wr_arr[wr_k] = wr_left_half[wr_i]\n            wr_i += 1\n            wr_k += 1\n\n        while wr_j < len(wr_right_half):\n            wr_arr[wr_k] = wr_right_half[wr_j]\n            wr_j += 1\n            wr_k += 1\n```",
        "```python\ndef is_valid_sudoku_c(wr_board):\n    def is_valid_group_c(wr_group):\n        wr_seen = set()\n        for wr_num in wr_group:\n            if wr_num != '.':\n                if wr_num in wr_seen:\n                    return False\n                wr_seen.add(wr_num)\n        return True\n\n    for wr_row in wr_board:\n        if not is_valid_group_c(wr_row):\n            return False\n\n    for wr_col in range(9):\n        wr_column = [wr_board[wr_row][wr_col] for wr_row in range(9)]\n        if not is_valid_group_c(wr_column):\n            return False\n\n    for wr_box_row in range(0, 9, 3):\n        for wr_box_col in range(0, 9, 3):\n            wr_box = [\n                wr_board[wr_row][wr_col]\n                for wr_row in range(wr_box_row, wr_box_row + 3)\n                for wr_col in range(wr_box_col, wr_box_col + 3)\n            ]\n            if not is_valid_group_c(wr_box):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```\n",
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    def wr_check_rows(wr_board):\n        return all(wr_is_valid_block(wr_row) for wr_row in wr_board)\n\n    def wr_check_columns(wr_board):\n        for wr_col_idx in range(9):\n            wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n            if not wr_is_valid_block(wr_column):\n                return False\n        return True\n\n    def wr_check_sub_boxes(wr_board):\n        for wr_box_row in range(0, 9, 3):\n            for wr_box_col in range(0, 9, 3):\n                wr_box = [wr_board[wr_row][wr_col]\n                          for wr_row in range(wr_box_row, wr_box_row + 3)\n                          for wr_col in range(wr_box_col, wr_box_col + 3)]\n                if not wr_is_valid_block(wr_box):\n                    return False\n        return True\n\n    return wr_check_rows(wr_board) and wr_check_columns(wr_board) and wr_check_sub_boxes(wr_board)\n```"
      ],
      "cumulative_model_output": [
        "```python\nimport bz2\nfrom typing import List\n\ndef is_valid_sudoku_c(wr_board: List[List[str]]) -> bool:\n    def is_valid_unit_c(wr_unit: List[str]) -> bool:\n        wr_unit = [x for x in wr_unit if x != '.']\n        return len(wr_unit) == len(set(wr_unit))\n\n    def is_valid_row_c() -> bool:\n        for wr_row in wr_board:\n            if not is_valid_unit_c(wr_row):\n                return False\n        return True\n\n    def is_valid_col_c() -> bool:\n        for wr_col in zip(*wr_board):\n            if not is_valid_unit_c(wr_col):\n                return False\n        return True\n    \n    def is_valid_box_c() -> bool:\n        for wr_i in range(0, 9, 3):\n            for wr_j in range(0, 9, 3):\n                wr_box = [wr_board[wr_x][wr_y] for wr_x in range(wr_i, wr_i + 3) for wr_y in range(wr_j, wr_j + 3)]\n                if not is_valid_unit_c(wr_box):\n                    return False\n        return True\n\n    return is_valid_row_c() and is_valid_col_c() and is_valid_box_c()\n```",
        "```python\nimport bz2\nfrom typing import List\n\ndef merge_sort_c(wr_arr: List[int]) -> List[int]:\n    if len(wr_arr) > 1:\n        wr_mid = len(wr_arr) // 2\n        wr_left_half = wr_arr[:wr_mid]\n        wr_right_half = wr_arr[wr_mid:]\n\n        merge_sort_c(wr_left_half)\n        merge_sort_c(wr_right_half)\n\n        wr_i = wr_j = wr_k = 0\n\n        while wr_i < len(wr_left_half) and wr_j < len(wr_right_half):\n            if wr_left_half[wr_i] < wr_right_half[wr_j]:\n                wr_arr[wr_k] = wr_left_half[wr_i]\n                wr_i += 1\n            else:\n                wr_arr[wr_k] = wr_right_half[wr_j]\n                wr_j += 1\n            wr_k += 1\n\n        while wr_i < len(wr_left_half):\n            wr_arr[wr_k] = wr_left_half[wr_i]\n            wr_i += 1\n            wr_k += 1\n\n        while wr_j < len(wr_right_half):\n            wr_arr[wr_k] = wr_right_half[wr_j]\n            wr_j += 1\n            wr_k += 1\n\n    return wr_arr\n```",
        "```python\nimport bz2\nfrom typing import List\n\ndef sum_except_self_c(nums: List[int]) -> List[int]:\n    wr_total_sum = sum(nums)\n    wr_result = [wr_total_sum - num for num in nums]\n    return wr_result\n```",
        "```python\nimport bz2\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, wr_key: int) -> None:\n        self.wr_key = wr_key\n        self.wr_left: Optional[TreeNode] = None\n        self.wr_right: Optional[TreeNode] = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.wr_root: Optional[TreeNode] = None\n\n    def insert_node_c(self, wr_key: int) -> None:\n        new_node = TreeNode(wr_key)\n        if not self.wr_root:\n            self.wr_root = new_node\n            return\n\n        current = self.wr_root\n        while True:\n            if wr_key < current.wr_key:\n                if current.wr_left is None:\n                    current.wr_left = new_node\n                    return\n                current = current.wr_left\n            else:\n                if current.wr_right is None:\n                    current.wr_right = new_node\n                    return\n                current = current.wr_right\n\n    def delete_node_c(self, wr_key: int) -> None:\n        self.wr_root = self._delete_node_recursive_c(self.wr_root, wr_key)\n\n    def _delete_node_recursive_c(self, wr_node: Optional[TreeNode], wr_key: int) -> Optional[TreeNode]:\n        if wr_node is None:\n            return wr_node\n\n        if wr_key < wr_node.wr_key:\n            wr_node.wr_left = self._delete_node_recursive_c(wr_node.wr_left, wr_key)\n        elif wr_key > wr_node.wr_key:\n            wr_node.wr_right = self._delete_node_recursive_c(wr_node.wr_right, wr_key)\n        else:\n            if wr_node.wr_left is None:\n                return wr_node.wr_right\n            elif wr_node.wr_right is None:\n                return wr_node.wr_left\n                \n            min_larger_node = self._get_min_value_node_c(wr_node.wr_right)\n            wr_node.wr_key = min_larger_node.wr_key\n            wr_node.wr_right = self._delete_node_recursive_c(wr_node.wr_right, min_larger_node.wr_key)\n\n        return wr_node\n\n    def _get_min_value_node_c(self, wr_node: TreeNode) -> TreeNode:\n        current = wr_node\n        while current.wr_left is not None:\n            current = current.wr_left\n        return current\n```"
      ]
    }
  ]
}