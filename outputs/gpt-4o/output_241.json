{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef is_palindrome_vr(s_vr: str) -> bool:\n    cleaned_vr = ''.join(char.lower() for char in s_vr if char.isalnum())\n    return cleaned_vr == cleaned_vr[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome(s_vr):\n    left_vr, right_vr = 0, len(s_vr) - 1\n    while left_vr < right_vr:\n        while left_vr < right_vr and not s_vr[left_vr].isalnum():\n            left_vr += 1\n        while left_vr < right_vr and not s_vr[right_vr].isalnum():\n            right_vr -= 1\n        if s_vr[left_vr].lower() != s_vr[right_vr].lower():\n            return False\n        left_vr += 1\n        right_vr -= 1\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_n(s_n):\n    try:\n        s_n = ''.join(filter(str.isalnum, s_n)).lower()\n        return s_n == s_n[::-1]\n    except Exception as e_n:\n        raise ValueError(\"An error occurred while processing the string\") from e_n\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression_n:\n    def __init__(self, alpha_n=1.0, num_iterations_n=1000, learning_rate_n=0.01):\n        self.alpha_n = alpha_n\n        self.num_iterations_n = num_iterations_n\n        self.learning_rate_n = learning_rate_n\n        self.weights_n = None\n        self.bias_n = None\n\n    def train_n(self, X_train_n, y_train_n):\n        num_samples_n, num_features_n = X_train_n.shape\n        self.weights_n = np.zeros(num_features_n)\n        self.bias_n = 0\n\n        for _ in range(self.num_iterations_n):\n            model_predictions_n = np.dot(X_train_n, self.weights_n) + self.bias_n\n            errors_n = model_predictions_n - y_train_n\n\n            dw_n = (1 / num_samples_n) * np.dot(X_train_n.T, errors_n) + self.alpha_n * np.sign(self.weights_n)\n            db_n = (1 / num_samples_n) * np.sum(errors_n)\n\n            self.weights_n -= self.learning_rate_n * dw_n\n            self.bias_n -= self.learning_rate_n * db_n\n\n    def predict_n(self, X_test_n):\n        try:\n            return np.dot(X_test_n, self.weights_n) + self.bias_n\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            return None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_n(s_n: str) -> bool:\n    s_n = ''.join(char_n.lower() for char_n in s_n if char_n.isalnum())\n    return s_n == s_n[::-1]\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_w(s_w: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid palindrome.\n    \n    A string is considered a valid palindrome if it reads the same backward as forward.\n\n    :param s_w: The string to check.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    s_w = ''.join(char_w.lower() for char_w in s_w if char_w.isalnum())\n    return s_w == s_w[::-1]\n```",
        "```python\nclass TreeNode_w:\n    def __init__(self, key_w: int):\n        self.key_w: int = key_w\n        self.left_w: TreeNode_w | None = None\n        self.right_w: TreeNode_w | None = None\n\nclass BinaryTree_w:\n    def __init__(self):\n        self.root_w: TreeNode_w | None = None\n\n    def insert_w(self, key_w: int) -> None:\n        if self.root_w is None:\n            self.root_w = TreeNode_w(key_w)\n        else:\n            self._insert_recursive_w(self.root_w, key_w)\n\n    def _insert_recursive_w(self, node_w: TreeNode_w, key_w: int) -> None:\n        if key_w < node_w.key_w:\n            if node_w.left_w is None:\n                node_w.left_w = TreeNode_w(key_w)\n            else:\n                self._insert_recursive_w(node_w.left_w, key_w)\n        else:\n            if node_w.right_w is None:\n                node_w.right_w = TreeNode_w(key_w)\n            else:\n                self._insert_recursive_w(node_w.right_w, key_w)\n    \n    def delete_w(self, key_w: int) -> None:\n        self.root_w = self._delete_recursive_w(self.root_w, key_w)\n\n    def _delete_recursive_w(self, node_w: TreeNode_w | None, key_w: int) -> TreeNode_w | None:\n        if node_w is None:\n            return node_w\n\n        if key_w < node_w.key_w:\n            node_w.left_w = self._delete_recursive_w(node_w.left_w, key_w)\n        elif key_w > node_w.key_w:\n            node_w.right_w = self._delete_recursive_w(node_w.right_w, key_w)\n        else:\n            if node_w.left_w is None:\n                return node_w.right_w\n            elif node_w.right_w is None:\n                return node_w.left_w\n\n            min_value_node_w = self._min_value_node_w(node_w.right_w)\n            node_w.key_w = min_value_node_w.key_w\n            node_w.right_w = self._delete_recursive_w(node_w.right_w, min_value_node_w.key_w)\n\n        return node_w\n\n    def _min_value_node_w(self, node_w: TreeNode_w) -> TreeNode_w:\n        current_w: TreeNode_w = node_w\n        while current_w.left_w is not None:\n            current_w = current_w.left_w\n        return current_w\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_w(input_w: str) -> bool:\n    cleaned_w = ''.join(char_w.lower() for char_w in input_w if char_w.isalnum())\n    return cleaned_w == cleaned_w[::-1]\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\nimport math\n\n@rename_kwargs(a='value1', b='value2')\ndef greatest_common_divisor(value1: int, value2: int) -> int:\n    return math.gcd(value1, value2)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom math import gcd\nfrom pedantic import rename_kwargs\n\n@rename_kwargs\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(a, b)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        try:\n            left_is_valid = validate(node.left, low, node.val)\n            right_is_valid = validate(node.right, node.val, high)\n            return left_is_valid and right_is_valid\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n        \n    try:\n        return validate(root)\n    except Exception as e:\n        print(f\"An error occurred during validation: {e}\")\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef count1_non_zero_elements(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of non-zero elements in the given matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix.\n\n    Returns:\n    int: The count of non-zero elements in the matrix.\n    \"\"\"\n    non_zero_count: int = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                non_zero_count += 1\n    return non_zero_count\n```",
        "```python\nfrom typing import List\n\ndef find_kth_largest1(nums: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth largest element in an array.\n    \n    :param nums: List of integers\n    :param k: An integer representing the kth position\n    :return: The kth largest element in the sorted array\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef c1ount_non_zero(matrix):\n    non_zero_c1ount = 0\n    for r1ow in matrix:\n        for e1lement in r1ow:\n            if e1lement != 0:\n                non_zero_c1ount += 1\n    return non_zero_c1ount\n```",
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\n@validate\ndef is_palindrome_m(s_m: str) -> bool:\n    s_m = ''.join(char_m.lower() for char_m in s_m if char_m.isalnum())\n    return s_m == s_m[::-1]\n```",
        "```python\nfrom pedantic import validate\n\nclass Library_m:\n    def __init__(self):\n        self.books_m = []\n\n    @validate\n    def add_book(self, book_m: str) -> None:\n        self.books_m.append(book_m)\n\n    @validate\n    def remove_book(self, book_m: str) -> bool:\n        if book_m in self.books_m:\n            self.books_m.remove(book_m)\n            return True\n        return False\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_palindrome(check_str_m):\n    clean_str_m = ''.join(char_m.lower() for char_m in check_str_m if char_m.isalnum())\n    return clean_str_m == clean_str_m[::-1]\n```",
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n    \n    Args:\n        num (int): The integer to be converted. Must be between 1 and 3999 inclusive.\n    \n    Returns:\n        str: The Roman numeral representation of the given integer.\n    \n    Raises:\n        ValueError: If the input integer is not within the valid range of 1 to 3999.\n    \"\"\"\n    \n    if not 1 <= num <= 3999:\n        raise ValueError(\"Input integer must be between 1 and 3999\")\n    \n    # Define the Roman numeral mappings\n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'),\n        (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'),\n        (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    \n    # Initialize the result as an empty string\n    result = \"\"\n    \n    # Convert the integer to a Roman numeral\n    for value, symbol in roman_numerals:\n        # Determine how many times the Roman symbol fits into the remaining number\n        while num >= value:\n            # Append the Roman symbol to the result\n            result += symbol\n            # Decrease the number by the Roman value\n            num -= value\n    \n    return result\n```"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\" \n        Initializes a tree node with a given key.\n        \n        Parameters:\n            key (any): The value to be stored in the node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty binary tree.\n        \"\"\"\n        self.root = None\n        \n    def insert(self, key):\n        \"\"\"\n        Inserts a new node with the specified key into the binary tree.\n        \n        Parameters:\n            key (any): The value to be inserted into the tree.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node, key):\n        \"\"\"\n        Recursively inserts a new key starting from the given node.\n        \n        Parameters:\n            node (TreeNode): The current node during recursion.\n            key (any): The value to be inserted into the tree.\n        \"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n                \n    def delete(self, key):\n        \"\"\"\n        Deletes a node with the specified key from the binary tree.\n        \n        Parameters:\n            key (any): The value of the node to be deleted from the tree.\n        \"\"\"\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, root, key):\n        \"\"\"\n        Recursively deletes a key starting from the given node.\n        \n        Parameters:\n            root (TreeNode): The current node during recursion.\n            key (any): The value to be deleted from the tree.\n            \n        Returns:\n            TreeNode: The root of the modified subtree.\n        \"\"\"\n        if root is None:\n            return root\n        \n        if key < root.val:\n            root.left = self._delete_recursively(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursively(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            \n            temp_val = self._min_value_node(root.right).val\n            root.val = temp_val\n            root.right = self._delete_recursively(root.right, temp_val)\n        \n        return root\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Finds the node with the smallest value greater than or equal to the given node.\n        \n        Parameters:\n            node (TreeNode): The current node to find the minimum value node.\n            \n        Returns:\n            TreeNode: The node with the smallest value in the subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_x(s_x):\n    s_x = ''.join(c_x.lower() for c_x in s_x if c_x.isalnum())\n    return s_x == s_x[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome(s_x):\n    s_x = ''.join(char_x.lower() for char_x in s_x if char_x.isalnum())\n    return s_x == s_x[::-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass MeanCalculator:\n    def __init__(self):\n        self.count1 = 0\n        self.sum1 = 0.0\n\n    def b_update(self, value3):\n        self.count1 += 1\n        self.sum1 += value3\n\n    def b_get_mean(self):\n        if self.count1 == 0:\n            return 0\n        return self.sum1 / self.count1\n```",
        "```python\ndef b_compute_h_index(citat1ions):\n    citat1ions.sort(reverse=True)\n    h_ind3ex = 0\n    for i, c in enumerate(citat1ions):\n        if c >= i + 1:\n            h_ind3ex = i + 1\n        else:\n            break\n    return h_ind3ex\n```"
      ],
      "instruction_model_output": [
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self._count0 = 0\n        self._mean0 = 0.0\n\n    def add1(self, value0):\n        self._count0 += 1\n        self._mean0 += (value0 - self._mean0) / self._count0\n    \n    def get_mean0(self):\n        return self._mean0\n```",
        "```python\ndef b_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef d_average_diagonal(matrix):\n    assert isinstance(matrix, list), \"Input should be a list of lists\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row should be a list\"\n    assert all(isinstance(element, (int, float)) for row in matrix for element in row), \"Matrix should contain numeric values\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix should be square\"\n\n    n = len(matrix)\n    diag_sum = sum(matrix[i][i] for i in range(n))\n    return diag_sum / n\n```",
        "```python\ndef d_compute_h_index(citations):\n    assert isinstance(citations, list), \"Citations should be a list.\"\n    assert all(isinstance(c, int) for c in citations), \"All elements in citations should be integers.\"\n    \n    citations.sort(reverse=True)\n    h_index = 0\n    \n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```",
        "```python\ndef d_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_z(s_z: str) -> bool:\n    cleaned_z = ''.join(char_z.lower() for char_z in s_z if char_z.isalnum())\n    return cleaned_z == cleaned_z[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_z(string_z):\n    cleaned_z = ''.join(char_z.lower() for char_z in string_z if char_z.isalnum())\n    return cleaned_z == cleaned_z[::-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n        else:\n            raise ValueError(\"Cannot remove more stock than available\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n            return True\n        return False\n\n    def a_get_stock(self, item):\n        return self._stock.get(item, 0)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations, start=1):\n        if c >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n        self.classes_ = None\n\n    def fit(self, X, y):\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert isinstance(y, np.ndarray), \"y must be a numpy array\"\n        assert X.ndim == 2, \"X must be a 2D array\"\n        assert y.ndim == 1, \"y must be a 1D array\"\n        assert X.shape[0] == y.shape[0], \"X and y must have the same number of samples\"\n\n        self.classes_ = np.unique(y)\n        self.means_ = {cls: X[y == cls].mean(axis=0) for cls in self.classes_}\n        self.covariances_ = {cls: np.cov(X[y == cls], rowvar=False) for cls in self.classes_}\n        self.priors_ = {cls: np.mean(y == cls) for cls in self.classes_}\n\n    def predict(self, X):\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert X.ndim == 2, \"X must be a 2D array\"\n\n        inv_covariances = {cls: np.linalg.inv(self.covariances_[cls]) for cls in self.classes_}\n        det_covariances = {cls: np.linalg.det(self.covariances_[cls]) for cls in self.classes_}\n\n        def discriminant_function(x, cls):\n            mean_diff = x - self.means_[cls]\n            return -0.5 * np.log(det_covariances[cls]) \\\n                   - 0.5 * mean_diff.T @ inv_covariances[cls] @ mean_diff \\\n                   + np.log(self.priors_[cls])\n\n        result = [self.classes_[np.argmax([discriminant_function(x, cls) for cls in self.classes_])] for x in X]\n        return np.array(result)\n```",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\nfrom collections import Counter\n\n@timer_class\nclass NearestNeighborsModel:\n    def __init__(self, k=3):\n        assert isinstance(k, int) and k > 0, \"k must be a positive integer\"\n        self.k = k\n        self._train_features = None\n        self._train_labels = None\n\n    def train(self, features, labels):\n        assert isinstance(features, np.ndarray), \"Features must be a numpy array\"\n        assert isinstance(labels, np.ndarray), \"Labels must be a numpy array\"\n        assert features.shape[0] == labels.shape[0], \"Number of features must match number of labels\"\n        self._train_features = features\n        self._train_labels = labels\n\n    def predict(self, features):\n        assert isinstance(features, np.ndarray), \"Features must be a numpy array\"\n        assert self._train_features is not None and self._train_labels is not None, \"Model has not been trained yet\"\n        \n        predictions = []\n\n        for feature in features:\n            distances = np.linalg.norm(self._train_features - feature, axis=1)\n            nearest_neighbor_ids = distances.argsort()[:self.k]\n            nearest_neighbor_labels = self._train_labels[nearest_neighbor_ids]\n            most_common = Counter(nearest_neighbor_labels).most_common(1)\n            predictions.append(most_common[0][0])\n\n        return np.array(predictions)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\nfrom typing import List\n\nclass Solution:\n    \n    @rename_kwargs\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        current_sum = max_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import rename_kwargs\nfrom typing import List\n\nclass Solution:\n    \n    @rename_kwargs\n    def maxSubArray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        current_sum = max_sum = nums[0]\n        \n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, s_key, s_value):\n        self.s_key = s_key\n        self.s_value = s_value\n        self.s_prev = None\n        self.s_next = None\n\nclass LRUCache:\n    def __init__(self, s_capacity):\n        self.s_capacity = s_capacity\n        self.s_cache = {}\n        self.s_head = Node(0, 0)\n        self.s_tail = Node(0, 0)\n        self.s_head.s_next = self.s_tail\n        self.s_tail.s_prev = self.s_head\n\n    def _remove(self, s_node):\n        s_prev = s_node.s_prev\n        s_next = s_node.s_next\n        s_prev.s_next = s_next\n        s_next.s_prev = s_prev\n\n    def _add(self, s_node):\n        s_prev = self.s_tail.s_prev\n        s_prev.s_next = s_node\n        s_node.s_prev = s_prev\n        s_node.s_next = self.s_tail\n        self.s_tail.s_prev = s_node\n\n    def get(self, s_key):\n        s_node = self.s_cache.get(s_key)\n        if not s_node:\n            return -1\n        self._remove(s_node)\n        self._add(s_node)\n        return s_node.s_value\n\n    def put(self, s_key, s_value):\n        s_node = self.s_cache.get(s_key)\n        if s_node:\n            self._remove(s_node)\n        s_node = Node(s_key, s_value)\n        self.s_cache[s_key] = s_node\n        self._add(s_node)\n        if len(self.s_cache) > self.s_capacity:\n            s_lru = self.s_head.s_next\n            self._remove(s_lru)\n            del self.s_cache[s_lru.s_key]\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = {}\n        self.s_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n            self.s_order.append(key)\n            return self.s_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            oldest_key = self.s_order.pop(0)\n            del self.s_cache[oldest_key]\n        self.s_cache[key] = value\n        self.s_order.append(key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\nfrom collections import defaultdict\n\n@retry\ndef find_majority_element(arr):\n    element_count = defaultdict(int)\n    for element in arr:\n        element_count[element] += 1\n        if element_count[element] > len(arr) // 2:\n            return element\n    return None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import retry\nfrom collections import defaultdict\n\n@retry\ndef find_majority_element(nums):\n    count_dict = defaultdict(int)\n    majority_count = len(nums) // 2\n    \n    for num in nums:\n        count_dict[num] += 1\n        if count_dict[num] > majority_count:\n            return num\n\n    return None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        if song not in self.songs:\n            self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        if song in self.songs:\n            self.songs.remove(song)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)\n```"
      ],
      "cumulative_model_output": [
        "```python\nfrom typing import List\nfrom heapq import nlargest\nfrom pedantic.decorators import rename_kwargs, retry\n\n@rename_kwargs\n@retry\ndef a_find_kth_largest_z(arr_x: List[int], k_x: int) -> int:\n    try:\n        res_s_1 = nlargest(k_x, arr_x)[-1]\n        assert isinstance(res_s_1, int), \"Result should be an integer\"\n        return res_s_1\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        raise\n```\n",
        "```python\nfrom pedantic import retry\n\n@retry\ndef b_int_to_roman_x(num_x: int) -> str:\n    int_values_s_ = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4, 1\n    ]\n    roman_numerals_s_ = [\n        'M', 'CM', 'D', 'CD',\n        'C', 'XC', 'L', 'XL',\n        'X', 'IX', 'V', 'IV', 'I'\n    ]\n    \n    result_s_ = []\n\n    i_x = 0\n    while num_x > 0:\n        assert num_x >= 0, \"Input number must be non-negative.\"\n        for _ in range(num_x // int_values_s_[i_x]):\n            result_s_.append(roman_numerals_s_[i_x])\n            num_x -= int_values_s_[i_x]\n        i_x += 1\n\n    return ''.join(result_s_)\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef compute_h_index1(citations_z: list) -> int:\n    citations_z.sort(reverse=True)\n    h_index_s_ = 0\n    for i_s_, citation_s_ in enumerate(citations_z):\n        if citation_s_ >= i_s_ + 1:\n            h_index_s_ = i_s_ + 1\n        else:\n            break\n    return h_index_s_\n```",
        "```python\nfrom pedantic import @retry\nimport numpy as np\nfrom scipy.linalg import inv\n\n@retry\nclass x_QuadraticDiscriminantAnalysis:\n    def __init__(self, priors_z=None, reg_param_z=0.0, store_covariance_z=False):\n        self.s_priors_z = priors_z\n        self.s_reg_param_z = reg_param_z\n        self.s_store_covariance_z = store_covariance_z\n        self.s_means_z = None\n        self.s_covariance_z = None\n        self.s_classes_z = None\n\n    def x_fit(self, X_z, y_z):\n        self.s_classes_z = np.unique(y_z)\n        self.s_means_z = {cls_x: np.mean(X_z[y_z == cls_x], axis=0) for cls_x in self.s_classes_z}\n        if self.s_store_covariance_z:\n            self.s_covariance_z = {}\n\n        cov_z = {}\n        for cls_x in self.s_classes_z:\n            subset_z = X_z[y_z == cls_x]\n            cov_matrix_z = np.cov(subset_z, rowvar=False) + self.s_reg_param_z * np.eye(subset_z.shape[1])\n            cov_z[cls_x] = cov_matrix_z\n            if self.s_store_covariance_z:\n                self.s_covariance_z[cls_x] = cov_matrix_z\n        \n        self.s_covariance_z = cov_z\n        return self\n\n    def x_decision_function(self, X_z):\n        decision_function_z = []\n        for cls_x in self.s_classes_z:\n            mean_diff_z = X_z - self.s_means_z[cls_x]\n            cov_inv_z = inv(self.s_covariance_z[cls_x])\n            dist_z = np.einsum('ij,jk,ik->i', mean_diff_z, cov_inv_z, mean_diff_z)\n            decision_function_z.append(-0.5 * dist_z + np.log(self.s_priors_z[cls_x] if self.s_priors_z is not None else 1.0))\n\n        return np.stack(decision_function_z).T\n\n    def x_predict(self, X_z):\n        decision_z = self.x_decision_function(X_z)\n        return self.s_classes_z[np.argmax(decision_z, axis=1)]\n```",
        "```python\nfrom pedantic import retry\n\nclass TreeNode:\n    def __init__(self, val_z):\n        self.s_val_z = val_z\n        self.s_left_z = None\n        self.s_right_z = None\n\nclass BinaryTree:\n    \n    def __init__(self):\n        self.s_root_z = None\n\n    @retry\n    def d_insert_x(self, val_z):\n        new_node_x = TreeNode(val_z)\n        if self.s_root_z is None:\n            self.s_root_z = new_node_x\n        else:\n            self._a_insert_recursive_x(self.s_root_z, new_node_x)\n\n    def _a_insert_recursive_x(self, current_node_x, new_node_x):\n        assert isinstance(current_node_x, TreeNode), \"Current node must be of type TreeNode.\"\n        assert isinstance(new_node_x, TreeNode), \"New node must be of type TreeNode.\"\n        \n        if new_node_x.s_val_z < current_node_x.s_val_z:\n            if current_node_x.s_left_z is None:\n                current_node_x.s_left_z = new_node_x\n            else:\n                self._a_insert_recursive_x(current_node_x.s_left_z, new_node_x)\n        else:\n            if current_node_x.s_right_z is None:\n                current_node_x.s_right_z = new_node_x\n            else:\n                self._a_insert_recursive_x(current_node_x.s_right_z, new_node_x)\n\n    @retry\n    def d_delete_x(self, val_z):\n        self.s_root_z = self._a_delete_recursive_x(self.s_root_z, val_z)\n\n    def _a_delete_recursive_x(self, current_node_x, val_z):\n        assert current_node_x is None or isinstance(current_node_x, TreeNode), \"Current node must be of type TreeNode or None.\"\n\n        if current_node_x is None:\n            return current_node_x\n        \n        if val_z < current_node_x.s_val_z:\n            current_node_x.s_left_z = self._a_delete_recursive_x(current_node_x.s_left_z, val_z)\n        elif val_z > current_node_x.s_val_z:\n            current_node_x.s_right_z = self._a_delete_recursive_x(current_node_x.s_right_z, val_z)\n        else:\n            if current_node_x.s_left_z is None:\n                return current_node_x.s_right_z\n            elif current_node_x.s_right_z is None:\n                return current_node_x.s_left_z\n\n            min_larger_node_x = self._x_find_min_x(current_node_x.s_right_z)\n            current_node_x.s_val_z = min_larger_node_x.s_val_z\n            current_node_x.s_right_z = self._a_delete_recursive_x(current_node_x.s_right_z, min_larger_node_x.s_val_z)\n        \n        return current_node_x\n\n    def _x_find_min_x(self, node_x):\n        assert isinstance(node_x, TreeNode), \"Node must be of type TreeNode.\"\n        \n        current_x = node_x\n        while current_x.s_left_z is not None:\n            current_x = current_x.s_left_z\n        return current_x\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom pedantic import retry\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_x: int = 5_z):\n        self.knn_model_s_ = KNeighborsClassifier(n_neighbors=n_neighbors_x)\n\n    @retry\n    def train_s_(self, X_train_z, y_train_z):\n        assert isinstance(X_train_z, list)\n        assert isinstance(y_train_z, list)\n        self.knn_model_s_.fit(X_train_z, y_train_z)\n\n    @retry\n    def predict_s_(self, X_test_z):\n        assert isinstance(X_test_z, list)\n        return self.knn_model_s_.predict(X_test_z)\n```\n",
        "```python\nfrom pedantic import retry\n\nclass Solution:\n    @retry\n    def a_max_subarray_sum_x(self, nums_z: list) -> int:\n        s_current_sum_z = nums_z[0]\n        s_max_sum_z = nums_z[0]\n        \n        for b_1n in range(1, len(nums_z)):\n            s_current_sum_z = max(nums_z[b_1n], s_current_sum_z + nums_z[b_1n])\n            s_max_sum_z = max(s_max_sum_z, s_current_sum_z)\n\n        return s_max_sum_z\n```",
        "```python\nfrom collections import OrderedDict\nfrom pedantic import retry\n\nclass LRUCache:\n    def __init__(self, s_capacity_z: int) -> None:\n        self._cache_z = OrderedDict()\n        self._s_capacity_z = s_capacity_z\n\n    @retry\n    def get(self, s_key_z: int) -> int:\n        if s_key_z not in self._cache_z:\n            return -1\n        self._cache_z.move_to_end(s_key_z)\n        return self._cache_z[s_key_z]\n\n    @retry\n    def put(self, s_key_z: int, s_value_z: int) -> None:\n        if s_key_z in self._cache_z:\n            self._cache_z.move_to_end(s_key_z)\n        self._cache_z[s_key_z] = s_value_z\n        if len(self._cache_z) > self._s_capacity_z:\n            self._cache_z.popitem(last=False)\n```\n",
        "```python\nfrom pedantic import retry\n\nclass Inventory:\n    \n    def __init__(self):\n        self.s_stock_z = {}\n\n    @retry\n    def add_stock(self, item_name_z: str, quantity_z: int) -> None:\n        if item_name_z in self.s_stock_z:\n            self.s_stock_z[item_name_z] += quantity_z\n        else:\n            self.s_stock_z[item_name_z] = quantity_z\n\n    @retry\n    def remove_stock(self, item_name_z: str, quantity_z: int) -> None:\n        if item_name_z in self.s_stock_z and self.s_stock_z[item_name_z] >= quantity_z:\n            self.s_stock_z[item_name_z] -= quantity_z\n            if self.s_stock_z[item_name_z] == 0:\n                del self.s_stock_z[item_name_z]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist.\")\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef a_is_palindrome_z(s_1z: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid palindrome.\n\n    Args:\n        s_1z (str): The string to check.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    s_2z = ''.join(s_3z.lower() for s_3z in s_1z if s_3z.isalnum())\n    return s_2z == s_2z[::-1]\n```",
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.exceptions import NotFittedError\nfrom pedantic import retry\n\n@retry\nclass LassoRegression:\n    def __init__(self, alpha_x: float = 1.0, max_iter_x: int = 1000):\n        self.model_s_ = Lasso(alpha=alpha_x, max_iter=max_iter_x)\n        self.is_fitted_s_ = False\n\n    @retry\n    def a_train(self, X_z, y_z):\n        try:\n            self.model_s_.fit(X_z, y_z)\n            self.is_fitted_s_ = True\n        except ValueError:\n            raise ValueError(\"Invalid input data or parameters during fitting.\")\n\n    @retry\n    def a_predict(self, X_z):\n        assert self.is_fitted_s_, \"Model must be fitted before prediction.\"\n        try:\n            return self.model_s_.predict(X_z)\n        except NotFittedError:\n            raise NotFittedError(\"The model instance is not fitted yet.\")\n```\n",
        "```python\nfrom pedantic import rename_kwargs, retry\nimport numpy as np\n\n@retry\n@rename_kwargs\ndef a_average_diagonal_x(matrix_z: np.ndarray) -> float:\n    assert isinstance(matrix_z, np.ndarray), \"matrix_z must be a numpy array\"\n    assert matrix_z.ndim == 2 and matrix_z.shape[0] == matrix_z.shape[1], \"matrix_z must be a square matrix\"\n    diagonal_sum_s_ = np.trace(matrix_z)\n    num_elements_s_ = matrix_z.shape[0]\n    return diagonal_sum_s_ / num_elements_s_\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef x_count_non_zero_elements(matrix):\n    count_x = 0\n    for row_s_ in matrix:\n        for element_s_ in row_s_:\n            if element_s_ != 0:\n                count_x += 1\n    return count_x\n```",
        "```python\nfrom typing import Optional\n\n@retry\ndef a_is_valid_bst_x(root_z: Optional['TreeNode']) -> bool:\n    def s_validate_s_node_x(s_node_m: Optional['TreeNode'], s_low_m: Optional[int], s_high_m: Optional[int]) -> bool:\n        if s_node_m is None:\n            return True\n        \n        if (s_low_m is not None and s_node_m.val_x <= s_low_m) or (s_high_m is not None and s_node_m.val_x >= s_high_m):\n            return False\n        \n        return (s_validate_s_node_x(s_node_m.left_x, s_low_m, s_node_m.val_x) and\n                s_validate_s_node_x(s_node_m.right_x, s_node_m.val_x, s_high_m))\n    \n    return s_validate_s_node_x(root_z, None, None)\n\nclass TreeNode:\n    def __init__(self, val_x: int, left_x: Optional['TreeNode'] = None, right_x: Optional['TreeNode'] = None):\n        self.val_x = val_x\n        self.left_x = left_x\n        self.right_x = right_x\n```",
        "```python\nfrom pedantic import retry\n\nclass Library:\n    def __init__(self):\n        self.s_books_collection = {}\n\n    @retry\n    def add_books(self, books_z: dict):\n        for title_1, quantity_2 in books_z.items():\n            if title_1 in self.s_books_collection:\n                self.s_books_collection[title_1] += quantity_2\n            else:\n                self.s_books_collection[title_1] = quantity_2\n\n    @retry\n    def remove_books(self, books_z: dict):\n        for title_1, quantity_2 in books_z.items():\n            if title_1 in self.s_books_collection:\n                if self.s_books_collection[title_1] >= quantity_2:\n                    self.s_books_collection[title_1] -= quantity_2\n                    if self.s_books_collection[title_1] == 0:\n                        del self.s_books_collection[title_1]\n                else:\n                    raise ValueError(f\"Not enough copies of {title_1} to remove\")\n            else:\n                raise KeyError(f\"{title_1} not found in the collection\")\n```",
        "```python\nfrom pedantic import retry\n\n@retry\nclass Playlist:\n    def __init__(self):\n        self.s_songs_z = []\n\n    def a_add_song_z(self, song_x):\n        assert isinstance(song_x, str), \"Input must be a string\"\n        self.s_songs_z.append(song_x)\n\n    def a_remove_song_z(self, song_x):\n        assert isinstance(song_x, str), \"Input must be a string\"\n        try:\n            self.s_songs_z.remove(song_x)\n        except ValueError:\n            print(f\"Song '{song_x}' not found in the playlist.\")\n```",
        "```python\nfrom typing import List\nfrom pedantic import rename_kwargs, retry\n\n@retry\n@rename_kwargs\ndef a_majority_element_x_z(arr_x_z: List[int]) -> int:\n    candidate_s_ = None\n    count_s_ = 0\n    for num_s_ in arr_x_z:\n        if count_s_ == 0:\n            candidate_s_ = num_s_\n        count_s_ += 1 if num_s_ == candidate_s_ else -1\n\n    assert count_s_ > 0, \"There must be a majority element\"\n    \n    return candidate_s_\n```\n",
        "```python\nfrom pedantic import rename_kwargs, retry\n\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self.s_total_x = 0.0\n        self.s_count_x = 0\n\n    @retry\n    @rename_kwargs\n    def a_add_number(self, value_z: float) -> None:\n        assert isinstance(value_z, float), 'Value must be a float'\n        self.s_total_x += value_z\n        self.s_count_x += 1\n\n    @rename_kwargs\n    def a_get_mean(self) -> float:\n        assert self.s_count_x > 0, 'No numbers added; division by zero'\n        return self.s_total_x / self.s_count_x\n```\n",
        "```python\nfrom pedantic import retry\n\n@retry\ndef d_gcd_x(a_s: int, b_s: int) -> int:\n    while b_s != 0:\n        a_s, b_s = b_s, a_s % b_s\n    return a_s\n```"
      ]
    }
  ]
}