{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.neighbors import NearestNeighbors\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5, algorithm='auto'):\n        self.n_neighbors = n_neighbors\n        self.algorithm = algorithm\n        self.model = NearestNeighbors(n_neighbors=self.n_neighbors, algorithm=self.algorithm)\n    \n    def train1_model(self, X: np.ndarray):\n        assert X.ndim == 2, \"Input data X must be a 2D array.\"\n        self.model.fit(X)\n    \n    def predict1_neighbors(self, X: np.ndarray):\n        assert X.ndim == 2, \"Input data X must be a 2D array.\"\n        distances, indices = self.model.kneighbors(X)\n        return distances, indices\n```",
        "```python\nclass DirectedGraph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge8(self, start, end):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        self.adjacency_list[start].append(end)\n\n    def _is_cyclic_util2(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n        \n        if v in self.adjacency_list:\n            for neighbor in self.adjacency_list[v]:\n                assert neighbor is not None, \"Neighbor must not be None\"\n                if not visited[neighbor]:\n                    if self._is_cyclic_util2(neighbor, visited, rec_stack):\n                        return True\n                elif rec_stack[neighbor]:\n                    return True\n\n        rec_stack[v] = False\n        return False\n\n    def has_cycle9(self):\n        visited = {node: False for node in self.adjacency_list}\n        rec_stack = {node: False for node in self.adjacency_list}\n        \n        for node in self.adjacency_list:\n            if not visited[node]:\n                if self._is_cyclic_util2(node, visited, rec_stack):\n                    return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```",
        "```python\nclass DirectedGr4ph:\n    def __init__(self):\n        self.adj4cency_list = {}\n\n    def add_v3rtex(self, v3rtex):\n        if v3rtex not in self.adj4cency_list:\n            self.adj4cency_list[v3rtex] = []\n\n    def add_edg3(self, start, end):\n        if start in self.adj4cency_list:\n            self.adj4cency_list[start].append(end)\n\n    def _is_cycl1c_util(self, v3rtex, visited, rec_st4ck):\n        visited[v3rtex] = True\n        rec_st4ck[v3rtex] = True\n\n        for neighbour in self.adj4cency_list.get(v3rtex, []):\n            if not visited[neighbour]:\n                if self._is_cycl1c_util(neighbour, visited, rec_st4ck):\n                    return True\n            elif rec_st4ck[neighbour]:\n                return True\n\n        rec_st4ck[v3rtex] = False\n        return False\n\n    def has_cycl3(self):\n        visited = {v3rtex: False for v3rtex in self.adj4cency_list}\n        rec_st4ck = {v3rtex: False for v3rtex in self.adj4cency_list}\n\n        for v3rtex in self.adj4cency_list:\n            if not visited[v3rtex]:\n                if self._is_cycl1c_util(v3rtex, visited, rec_st4ck):\n                    return True\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def b_chx_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def b_chx_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n            return True\n        return False\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self._heap = []\n\n    def b_insert_chx(self, value):\n        self._heap.append(value)\n        self._b_heapify_up_chx(len(self._heap) - 1)\n\n    def _b_heapify_up_chx(self, index):\n        parent_index = (index - 1) // 2\n        if index > 0 and self._heap[index] > self._heap[parent_index]:\n            self._heap[index], self._heap[parent_index] = self._heap[parent_index], self._heap[index]\n            self._b_heapify_up_chx(parent_index)\n\n    def b_heapify_chx(self, arr):\n        self._heap = arr\n        for i in range((len(self._heap) // 2) - 1, -1, -1):\n            self._b_heapify_down_chx(i)\n\n    def _b_heapify_down_chx(self, index):\n        largest = index\n        left_child = 2 * index + 1\n        right_child = 2 * index + 2\n        if left_child < len(self._heap) and self._heap[left_child] > self._heap[largest]:\n            largest = left_child\n        if right_child < len(self._heap) and self._heap[right_child] > self._heap[largest]:\n            largest = right_child\n        if largest != index:\n            self._heap[index], self._heap[largest] = self._heap[largest], self._heap[index]\n            self._b_heapify_down_chx(largest)\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def b_add_stock(self, item, quantity):\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        if item in self.items:\n            if self.items[item] >= quantity:\n                self.items[item] -= quantity\n                if self.items[item] == 0:\n                    del self.items[item]\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert_chx(self, item):\n        self.heap.append(item)\n        self._heapify_up_chx(len(self.heap) - 1)\n\n    def _heapify_up_chx(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] > self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n            else:\n                break\n\n    def _heapify_down_chx(self, index):\n        last_index = len(self.heap) - 1\n        while True:\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            largest_index = index\n\n            if left_child_index <= last_index and self.heap[left_child_index] > self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index <= last_index and self.heap[right_child_index] > self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n            else:\n                self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n                index = largest_index\n\n    def extract_chx(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down_chx(0)\n        return root\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def b_add_chx_stock1(self, item, quantity):\n        assert isinstance(item, str), \"Item must be a string\"\n        assert isinstance(quantity, int) and quantity > 0, \"Quantity must be a positive integer\"\n\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def b_remove_chx_stock2(self, item, quantity):\n        assert isinstance(item, str), \"Item must be a string\"\n        assert isinstance(quantity, int) and quantity > 0, \"Quantity must be a positive integer\"\n        assert item in self.stock, \"Item must exist in stock\"\n        assert self.stock[item] >= quantity, \"Not enough stock to remove\"\n\n        self.stock[item] -= quantity\n\n        if self.stock[item] == 0:\n            del self.stock[item]\n```",
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, b_name1):\n        self.b_name1 = b_name1\n        self.data_chx = None\n        self.labels_chx = None\n    \n    def b_train_chx(self, data_chx, labels_chx):\n        assert isinstance(data_chx, np.ndarray), \"Data must be a numpy array.\"\n        assert isinstance(labels_chx, np.ndarray), \"Labels must be a numpy array.\"\n        assert len(data_chx) == len(labels_chx), \"Data and labels must be of the same length.\"\n        self.data_chx = data_chx\n        self.labels_chx = labels_chx\n    \n    def b_predict_chx(self, new_data_chx, k_chx=3):\n        assert self.data_chx is not None, \"Model has not been trained.\"\n        assert isinstance(new_data_chx, np.ndarray), \"New data must be a numpy array.\"\n        assert k_chx > 0, \"k_chx must be greater than zero.\"\n        \n        predictions_chx = []\n        for point_chx in new_data_chx:\n            distances_chx = np.linalg.norm(self.data_chx - point_chx, axis=1)\n            nearest_chx_indices = np.argsort(distances_chx)[:k_chx]\n            nearest_chx_labels = self.labels_chx[nearest_chx_indices]\n            common_chx_label = Counter(nearest_chx_labels).most_common(1)[0][0]\n            predictions_chx.append(common_chx_label)\n\n        return np.array(predictions_chx)\n```\n",
        "```python\nclass Heap:\n    def __init__(self):\n        self.data = []\n\n    def b_chx0_insert(self, value):\n        self.data.append(value)\n        self.b_chx1_heapify_up(len(self.data) - 1)\n\n    def b_chx1_heapify_up(self, index):\n        assert 0 <= index < len(self.data)\n        parent_index = (index - 1) // 2\n        if index > 0 and self.data[index] > self.data[parent_index]:\n            self.data[index], self.data[parent_index] = self.data[parent_index], self.data[index]\n            self.b_chx1_heapify_up(parent_index)\n\n    def b_chx2_heapify_down(self, index):\n        assert 0 <= index < len(self.data)\n        largest = index\n        left_index = 2 * index + 1\n        right_index = 2 * index + 2\n\n        if left_index < len(self.data) and self.data[left_index] > self.data[largest]:\n            largest = left_index\n        if right_index < len(self.data) and self.data[right_index] > self.data[largest]:\n            largest = right_index\n        if largest != index:\n            self.data[index], self.data[largest] = self.data[largest], self.data[index]\n            self.b_chx2_heapify_down(largest)\n```",
        "```python\nclass DirectedGraph:\n    def __init__(self):\n        self.b_chx5graph = {}\n\n    def b_chx8add_edge(self, start, end):\n        if start not in self.b_chx5graph:\n            self.b_chx5graph[start] = []\n        self.b_chx5graph[start].append(end)\n        assert self.b_chx5graph[start] is not None\n\n    def b_chx2is_cyclic(self):\n        visited = set()\n        rec_stack = set()\n\n        def cycle_util(v):\n            visited.add(v)\n            rec_stack.add(v)\n\n            for neighbor in self.b_chx5graph.get(v, []):\n                if neighbor not in visited:\n                    if cycle_util(neighbor):\n                        return True\n                elif neighbor in rec_stack:\n                    return True\n\n            rec_stack.remove(v)\n            return False\n\n        for node in self.b_chx5graph:\n            if node not in visited:\n                if cycle_util(node):\n                    return True\n        \n        return False\n```\n"
      ]
    }
  ]
}