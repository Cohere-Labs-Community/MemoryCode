{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, q_capacity: int):\n        self.q_capacity = q_capacity\n        self.q_cache = OrderedDict()\n\n    def q_get(self, q_key: int) -> int:\n        if q_key not in self.q_cache:\n            return -1\n        self.q_cache.move_to_end(q_key)\n        return self.q_cache[q_key]\n\n    def q_put(self, q_key: int, q_value: int) -> None:\n        if q_key in self.q_cache:\n            self.q_cache.move_to_end(q_key)\n        self.q_cache[q_key] = q_value\n        if len(self.q_cache) > self.q_capacity:\n            self.q_cache.popitem(last=False)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n            self.q_order.append(key)\n            return self.q_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n        elif len(self.q_cache) >= self.q_capacity:\n            lru_key = self.q_order.pop(0)\n            del self.q_cache[lru_key]\n        self.q_cache[key] = value\n        self.q_order.append(key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, xt_key_t=None, xt_value_t=None):\n        self.xt_key_t = xt_key_t\n        self.xt_value_t = xt_value_t\n        self.xt_prev_t = None\n        self.xt_next_t = None\n\nclass LRUCache:\n    def __init__(self, xt_capacity_t):\n        self.xt_capacity_t = xt_capacity_t\n        self.xt_cache_t = {}\n        self.xt_head_t = Node()\n        self.xt_tail_t = Node()\n        self.xt_head_t.xt_next_t = self.xt_tail_t\n        self.xt_tail_t.xt_prev_t = self.xt_head_t\n\n    def _remove(self, xt_node_t):\n        xt_prev_t = xt_node_t.xt_prev_t\n        xt_next_t = xt_node_t.xt_next_t\n        xt_prev_t.xt_next_t = xt_next_t\n        xt_next_t.xt_prev_t = xt_prev_t\n\n    def _add(self, xt_node_t):\n        xt_prev_t = self.xt_tail_t.xt_prev_t\n        xt_prev_t.xt_next_t = xt_node_t\n        xt_node_t.xt_prev_t = xt_prev_t\n        xt_node_t.xt_next_t = self.xt_tail_t\n        self.xt_tail_t.xt_prev_t = xt_node_t\n\n    def get(self, xt_key_t):\n        xt_node_t = self.xt_cache_t.get(xt_key_t)\n        if not xt_node_t:\n            return -1\n        self._remove(xt_node_t)\n        self._add(xt_node_t)\n        return xt_node_t.xt_value_t\n\n    def put(self, xt_key_t, xt_value_t):\n        if xt_key_t in self.xt_cache_t:\n            self._remove(self.xt_cache_t[xt_key_t])\n        xt_node_t = Node(xt_key_t, xt_value_t)\n        self._add(xt_node_t)\n        self.xt_cache_t[xt_key_t] = xt_node_t\n        if len(self.xt_cache_t) > self.xt_capacity_t:\n            xt_lru_t = self.xt_head_t.xt_next_t\n            self._remove(xt_lru_t)\n            del self.xt_cache_t[xt_lru_t.xt_key_t]\n```",
        "```python\nclass Node:\n    def __init__(self, xt_data_t=None):\n        self.xt_data_t = xt_data_t\n        self.xt_next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.xt_head_t = None\n\n    def append(self, xt_data_t):\n        new_node = Node(xt_data_t)\n        if self.xt_head_t is None:\n            self.xt_head_t = new_node\n            return\n        last = self.xt_head_t\n        while last.xt_next_t:\n            last = last.xt_next_t\n        last.xt_next_t = new_node\n\n    def prepend(self, xt_data_t):\n        new_node = Node(xt_data_t)\n        new_node.xt_next_t = self.xt_head_t\n        self.xt_head_t = new_node\n\n    def delete_with_value(self, xt_data_t):\n        if self.xt_head_t is None:\n            return\n        if self.xt_head_t.xt_data_t == xt_data_t:\n            self.xt_head_t = self.xt_head_t.xt_next_t\n            return\n        current = self.xt_head_t\n        while current.xt_next_t:\n            if current.xt_next_t.xt_data_t == xt_data_t:\n                current.xt_next_t = current.xt_next_t.xt_next_t\n                return\n            current = current.xt_next_t\n\n    def find(self, xt_data_t):\n        current = self.xt_head_t\n        while current:\n            if current.xt_data_t == xt_data_t:\n                return True\n            current = current.xt_next_t\n        return False\n\n    def is_empty(self):\n        return self.xt_head_t is None\n\n    def display(self):\n        elements = []\n        current = self.xt_head_t\n        while current:\n            elements.append(current.xt_data_t)\n            current = current.xt_next_t\n        return elements\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = {}\n        self.xt_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.xt_cache:\n            self.xt_order.remove(key)\n            self.xt_order.append(key)\n            return self.xt_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_order.remove(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            lru_key = self.xt_order.pop(0)\n            del self.xt_cache[lru_key]\n        \n        self.xt_cache[key] = value\n        self.xt_order.append(key)\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_t = data\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def append(self, data):\n        new_node_t = Node(data)\n        if self.head_t is None:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def prepend(self, data):\n        new_node_t = Node(data)\n        new_node_t.next_t = self.head_t\n        self.head_t = new_node_t\n\n    def delete_with_value(self, data):\n        if self.head_t is None:\n            return\n        if self.head_t.data_t == data:\n            self.head_t = self.head_t.next_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            if current_t.next_t.data_t == data:\n                current_t.next_t = current_t.next_t.next_t\n                return\n            current_t = current_t.next_t\n\n    def find(self, data):\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def clear(self):\n        self.head_t = None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, r_data_s):\n        self.r_data_s = r_data_s\n        self.r_next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.r_head_s = None\n\n    def append(self, r_data_s):\n        new_node = Node(r_data_s)\n        if self.r_head_s is None:\n            self.r_head_s = new_node\n            return\n        last_node = self.r_head_s\n        while last_node.r_next_s:\n            last_node = last_node.r_next_s\n        last_node.r_next_s = new_node\n\n    def display(self):\n        current_node = self.r_head_s\n        while current_node:\n            print(current_node.r_data_s)\n            current_node = current_node.r_next_s\n```",
        "```python\nclass Node:\n    def __init__(self, r_key_s, r_value_s):\n        self.r_key_s = r_key_s\n        self.r_value_s = r_value_s\n        self.r_prev_s = None\n        self.r_next_s = None\n\nclass LRUCache:\n    def __init__(self, r_capacity_s):\n        self.r_capacity_s = r_capacity_s\n        self.r_cache_s = {}\n        self.r_head_s = Node(0, 0)\n        self.r_tail_s = Node(0, 0)\n        self.r_head_s.r_next_s = self.r_tail_s\n        self.r_tail_s.r_prev_s = self.r_head_s\n\n    def _remove(self, r_node_s):\n        r_prev_s = r_node_s.r_prev_s\n        r_next_s = r_node_s.r_next_s\n        r_prev_s.r_next_s = r_next_s\n        r_next_s.r_prev_s = r_prev_s\n\n    def _add(self, r_node_s):\n        r_node_s.r_prev_s = self.r_head_s\n        r_node_s.r_next_s = self.r_head_s.r_next_s\n        self.r_head_s.r_next_s.r_prev_s = r_node_s\n        self.r_head_s.r_next_s = r_node_s\n\n    def get(self, r_key_s):\n        if r_key_s in self.r_cache_s:\n            r_node_s = self.r_cache_s[r_key_s]\n            self._remove(r_node_s)\n            self._add(r_node_s)\n            return r_node_s.r_value_s\n        return -1\n\n    def put(self, r_key_s, r_value_s):\n        if r_key_s in self.r_cache_s:\n            self._remove(self.r_cache_s[r_key_s])\n        r_node_s = Node(r_key_s, r_value_s)\n        self._add(r_node_s)\n        self.r_cache_s[r_key_s] = r_node_s\n        if len(self.r_cache_s) > self.r_capacity_s:\n            r_lru_s = self.r_tail_s.r_prev_s\n            self._remove(r_lru_s)\n            del self.r_cache_s[r_lru_s.r_key_s]\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_s = data\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_s is None:\n            self.head_s = new_node\n            return\n        last = self.head_s\n        while last.next_s:\n            last = last.next_s\n        last.next_s = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_node(self, key):\n        current_s = self.head_s\n        if current_s and current_s.data_s == key:\n            self.head_s = current_s.next_s\n            current_s = None\n            return\n        prev_s = None\n        while current_s and current_s.data_s != key:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        current_s = None\n\n    def search(self, key):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == key:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_s, end=\" \")\n            current_s = current_s.next_s\n        print()\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, r_capacity: int):\n        self.r_cache = OrderedDict()\n        self.r_capacity = r_capacity\n\n    def get(self, r_key: int) -> int:\n        if r_key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(r_key)\n        return self.r_cache[r_key]\n\n    def put(self, r_key: int, r_value: int) -> None:\n        if r_key in self.r_cache:\n            self.r_cache.move_to_end(r_key)\n        self.r_cache[r_key] = r_value\n        if len(self.r_cache) > self.r_capacity:\n            self.r_cache.popitem(last=False)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix(strs):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Args:\n        strs (List[str]): The list of strings to evaluate.\n\n    Returns:\n        str: The longest common prefix, or an empty string if none exists.\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Initialize prefix to the first string\n    prefix = strs[0]\n    \n    # Iterate over remaining strings\n    for s in strs[1:]:\n        # Update the prefix to the common prefix of the current string and the prefix so far\n        while s[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:len(prefix)-1]  # Shorten the prefix if necessary\n    \n    return prefix\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "cumulative_model_output": [
        "```python\ndef longest_common_prefix(r_strings_s):\n    \"\"\"\n    Finds the longest common prefix in a list of strings.\n\n    Parameters:\n    r_strings_s (list of str): A list of strings to evaluate.\n\n    Returns:\n    str: The longest common prefix or an empty string if none exists.\n    \"\"\"\n    if not r_strings_s:\n        return \"\"\n\n    r_min_str_s = min(r_strings_s)\n    r_max_str_s = max(r_strings_s)\n\n    for r_i_s, r_char_s in enumerate(r_min_str_s):\n        if r_char_s != r_max_str_s[r_i_s]:\n            return r_min_str_s[:r_i_s]\n\n    return r_min_str_s\n```",
        "```python\nclass Node:\n    \"\"\"\n    A class representing a node in a linked list.\n    \n    Attributes:\n        r_data_s: The data stored in the node.\n        r_next_s: The next node in the linked list.\n    \"\"\"\n    def __init__(self, data):\n        \"\"\"\n        Initializes a new node with the given data.\n        \n        Args:\n            data: The data to store in this node.\n        \"\"\"\n        self.r_data_s = data\n        self.r_next_s = None\n\nclass LinkedList:\n    \"\"\"\n    A class representing a singly linked list.\n    \n    Attributes:\n        r_head_s: The head node of the linked list.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes an empty linked list.\"\"\"\n        self.r_head_s = None\n\n    def append(self, data):\n        \"\"\"\n        Appends a new node with the given data to the end of the linked list.\n        \n        Args:\n            data: The data to append to the linked list.\n        \"\"\"\n        new_node = Node(data)\n        if not self.r_head_s:\n            self.r_head_s = new_node\n            return\n\n        last_node = self.r_head_s\n        while last_node.r_next_s:\n            last_node = last_node.r_next_s\n        last_node.r_next_s = new_node\n\n    def prepend(self, data):\n        \"\"\"\n        Prepends a new node with the given data to the start of the linked list.\n        \n        Args:\n            data: The data to prepend to the linked list.\n        \"\"\"\n        new_node = Node(data)\n        new_node.r_next_s = self.r_head_s\n        self.r_head_s = new_node\n\n    def delete(self, key):\n        \"\"\"\n        Deletes the first node with the specified key from the linked list.\n        \n        Args:\n            key: The key of the node to delete.\n        \"\"\"\n        current_node = self.r_head_s\n\n        if current_node and current_node.r_data_s == key:\n            self.r_head_s = current_node.r_next_s\n            current_node = None\n            return\n\n        prev_node = None\n        while current_node and current_node.r_data_s != key:\n            prev_node = current_node\n            current_node = current_node.r_next_s\n\n        if not current_node:\n            return\n\n        prev_node.r_next_s = current_node.r_next_s\n        current_node = None\n\n    def find(self, key):\n        \"\"\"\n        Searches for a node with the specified key in the linked list.\n        \n        Args:\n            key: The key of the node to find.\n        \n        Returns:\n            bool: True if a node with the key exists, False otherwise.\n        \"\"\"\n        current_node = self.r_head_s\n        while current_node:\n            if current_node.r_data_s == key:\n                return True\n            current_node = current_node.r_next_s\n        return False\n\n    def print_list(self):\n        \"\"\"Prints the contents of the linked list.\"\"\"\n        current_node = self.r_head_s\n        while current_node:\n            print(current_node.r_data_s)\n            current_node = current_node.r_next_s\n```",
        "```python\nclass LRUCache:\n    def __init__(self, r_capacity_s):\n        \"\"\"\n        Initialize the LRUCache with a given capacity.\n        \n        :param r_capacity_s: The maximum number of items that the cache can hold.\n        \"\"\"\n        self.r_cache_s = {}\n        self.r_capacity_s = r_capacity_s\n        self.r_order_s = []\n\n    def get(self, r_key_s):\n        \"\"\"\n        Retrieve the value associated with the given key in the cache.\n        \n        :param r_key_s: The key to look up in the cache.\n        :return: The value associated with the key, or -1 if the key is not found.\n        \"\"\"\n        if r_key_s in self.r_cache_s:\n            self.r_order_s.remove(r_key_s)\n            self.r_order_s.append(r_key_s)\n            return self.r_cache_s[r_key_s]\n        return -1\n\n    def put(self, r_key_s, r_value_s):\n        \"\"\"\n        Add a key-value pair to the cache. If the cache exceeds its capacity,\n        the least recently used item is removed.\n        \n        :param r_key_s: The key to add to the cache.\n        :param r_value_s: The value to be associated with the key.\n        \"\"\"\n        if r_key_s in self.r_cache_s:\n            self.r_order_s.remove(r_key_s)\n        elif len(self.r_cache_s) >= self.r_capacity_s:\n            r_lru_key_s = self.r_order_s.pop(0)\n            del self.r_cache_s[r_lru_key_s]\n\n        self.r_cache_s[r_key_s] = r_value_s\n        self.r_order_s.append(r_key_s)\n```"
      ]
    }
  ]
}