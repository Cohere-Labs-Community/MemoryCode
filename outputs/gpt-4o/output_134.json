{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport locale\n\ndef least_common_multiple(a, b):\n    assert isinstance(a, int), \"Input must be an integer\"\n    assert isinstance(b, int), \"Input must be an integer\"\n    assert a > 0 and b > 0, \"Input integers must be positive\"\n    \n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    return abs(a * b) // gcd(a, b)\n```",
        "```python\nimport locale\n\ndef average_diagonal(matrix):\n    assert isinstance(matrix, list), \"Input must be a list\"\n    assert all(isinstance(row, list) for row in matrix), \"All elements of matrix must be lists\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n    \n    n = len(matrix)\n    diagonal_sum = 0\n\n    for i in range(n):\n        assert isinstance(matrix[i][i], (int, float)), \"Matrix diagonal elements must be of type int or float\"\n        diagonal_sum += matrix[i][i]\n\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "instruction_model_output": [
        "```python\nimport locale\n\ndef lcm(a, b):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    return abs(a * b) // gcd(a, b)\n```",
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_wr(s_wr: str) -> bool:\n    assert isinstance(s_wr, str), \"Input must be a string\"\n    left_wr, right_wr = 0, len(s_wr) - 1\n    while left_wr < right_wr:\n        while left_wr < right_wr and not s_wr[left_wr].isalnum():\n            left_wr += 1\n        while left_wr < right_wr and not s_wr[right_wr].isalnum():\n            right_wr -= 1\n        if s_wr[left_wr].lower() != s_wr[right_wr].lower():\n            return False\n        left_wr += 1\n        right_wr -= 1\n    return True\n```",
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_wr=3):\n        self.n_neighbors_wr = n_neighbors_wr\n        self.data_wr = None\n        self.labels_wr = None\n    \n    def train(self, data_wr, labels_wr):\n        assert isinstance(data_wr, np.ndarray), \"Training data must be a numpy array.\"\n        assert isinstance(labels_wr, np.ndarray), \"Labels must be a numpy array.\"\n        assert len(data_wr) == len(labels_wr), \"Data and labels must be of the same length.\"\n        \n        self.data_wr = data_wr\n        self.labels_wr = labels_wr\n\n    def predict(self, points_wr):\n        assert isinstance(points_wr, np.ndarray), \"Prediction points must be a numpy array.\"\n\n        predictions_wr = []\n        for point_wr in points_wr:\n            distances_wr = np.linalg.norm(self.data_wr - point_wr, axis=1)\n            nearest_indices_wr = np.argsort(distances_wr)[:self.n_neighbors_wr]\n            nearest_labels_wr = self.labels_wr[nearest_indices_wr]\n            most_common_wr = Counter(nearest_labels_wr).most_common(1)[0][0]\n            predictions_wr.append(most_common_wr)\n        \n        return np.array(predictions_wr)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_wr(s_wr):\n    cleaned_wr = ''.join(char_wr.lower() for char_wr in s_wr if char_wr.isalnum())\n    return cleaned_wr == cleaned_wr[::-1]\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    \"\"\"\n    A class representing a node in a binary tree.\n\n    Attributes:\n        key (int): The value of the node.\n        left (TreeNode): Reference to the left child node.\n        right (TreeNode): Reference to the right child node.\n    \"\"\"\n    def __init__(self, key):\n        \"\"\"\n        Initializes a TreeNode with a given key.\n\n        Parameters:\n            key (int): The value to be stored in the node.\n        \"\"\"\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    \"\"\"\n    A class representing a binary tree.\n\n    Methods:\n        insert(key): Inserts a node with the given key into the binary tree.\n        delete(key): Deletes a node with the given key from the binary tree.\n        _delete_node(root, key): Helper method to delete a node.\n        _find_min(node): Finds the node with the minimum key.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initializes an empty binary tree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Inserts a node with the given key into the binary tree.\n\n        Parameters:\n            key (int): The value to be inserted into the tree.\n        \"\"\"\n        if not self.root:\n            self.root = TreeNode(key)\n        else:\n            self._insert_node(self.root, key)\n\n    def _insert_node(self, node, key):\n        \"\"\"\n        Helper method to insert a node in the tree.\n\n        Parameters:\n            node (TreeNode): The current node in the traversal.\n            key (int): The value to be inserted.\n        \"\"\"\n        if key < node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_node(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_node(node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Deletes a node with the given key from the binary tree.\n\n        Parameters:\n            key (int): The value to be deleted from the tree.\n        \"\"\"\n        self.root = self._delete_node(self.root, key)\n\n    def _delete_node(self, root, key):\n        \"\"\"\n        Helper method to delete a node with the specified key.\n\n        Parameters:\n            root (TreeNode): The current node during traversal.\n            key (int): The value of the node to be deleted.\n\n        Returns:\n            TreeNode: The new root of the subtree.\n        \"\"\"\n        if root is None:\n            return root\n\n        if key < root.key:\n            root.left = self._delete_node(root.left, key)\n        elif key > root.key:\n            root.right = self._delete_node(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            temp = self._find_min(root.right)\n            root.key = temp.key\n            root.right = self._delete_node(root.right, temp.key)\n\n        return root\n\n    def _find_min(self, node):\n        \"\"\"\n        Finds the node with the minimum key in a subtree.\n\n        Parameters:\n            node (TreeNode): The root node of the subtree.\n\n        Returns:\n            TreeNode: The node with the minimum key.\n        \"\"\"\n        current = node\n        while current and current.left:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nimport locale\n\ndef average_diagonal(matrix_wr):\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n    \n    :param matrix_wr: List of lists where each sublist represents a row of the matrix.\n    :return: Float representing the average of the diagonal elements.\n    :raises AssertionError: If the matrix is not square.\n    \"\"\"\n    assert isinstance(matrix_wr, list) and all(isinstance(row_wr, list) for row_wr in matrix_wr), \"Input must be a list of lists.\"\n    num_rows_wr = len(matrix_wr)\n    num_columns_wr = len(matrix_wr[0]) if num_rows_wr > 0 else 0\n    assert num_rows_wr == num_columns_wr, \"Matrix must be square.\"\n\n    diagonal_sum_wr = 0\n    for i_wr in range(num_rows_wr):\n        diagonal_sum_wr += matrix_wr[i_wr][i_wr]\n\n    return diagonal_sum_wr / num_rows_wr\n```\n",
        "```python\nimport locale\n\nclass TreeNode:\n    def __init__(self, key_wr):\n        self.key_wr = key_wr\n        self.left_wr = None\n        self.right_wr = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root_wr = None\n\n    def insert(self, key_wr):\n        if self.root_wr is None:\n            self.root_wr = TreeNode(key_wr)\n        else:\n            self._insert_recursively(self.root_wr, key_wr)\n\n    def _insert_recursively(self, current_node_wr, key_wr):\n        assert current_node_wr is not None, \"Current node must not be None during insert\"\n        if key_wr < current_node_wr.key_wr:\n            if current_node_wr.left_wr is None:\n                current_node_wr.left_wr = TreeNode(key_wr)\n            else:\n                self._insert_recursively(current_node_wr.left_wr, key_wr)\n        else:\n            if current_node_wr.right_wr is None:\n                current_node_wr.right_wr = TreeNode(key_wr)\n            else:\n                self._insert_recursively(current_node_wr.right_wr, key_wr)\n\n    def delete(self, key_wr):\n        assert self.root_wr is not None, \"Tree must not be empty during delete\"\n        self.root_wr = self._delete_recursively(self.root_wr, key_wr)\n\n    def _delete_recursively(self, current_node_wr, key_wr):\n        assert current_node_wr is not None, \"Current node must not be None during delete\"\n\n        if key_wr < current_node_wr.key_wr:\n            current_node_wr.left_wr = self._delete_recursively(current_node_wr.left_wr, key_wr)\n        elif key_wr > current_node_wr.key_wr:\n            current_node_wr.right_wr = self._delete_recursively(current_node_wr.right_wr, key_wr)\n        else:\n            if current_node_wr.left_wr is None:\n                return current_node_wr.right_wr\n            elif current_node_wr.right_wr is None:\n                return current_node_wr.left_wr\n            temp_wr = self._find_min(current_node_wr.right_wr)\n            current_node_wr.key_wr = temp_wr.key_wr\n            current_node_wr.right_wr = self._delete_recursively(current_node_wr.right_wr, temp_wr.key_wr)\n        return current_node_wr\n\n    def _find_min(self, node_wr):\n        current_wr = node_wr\n        while current_wr.left_wr is not None:\n            current_wr = current_wr.left_wr\n        return current_wr\n```",
        "```python\nimport locale\n\ndef least_common_multiple_wr(a_wr, b_wr):\n    \"\"\"\n    Calculate the least common multiple of two integers.\n\n    :param a_wr: first integer\n    :param b_wr: second integer\n    :return: least common multiple of the two integers\n    \"\"\"\n    assert isinstance(a_wr, int), \"a_wr must be an integer\"\n    assert isinstance(b_wr, int), \"b_wr must be an integer\"\n\n    def gcd_wr(x_wr, y_wr):\n        \"\"\"\n        Calculate the greatest common divisor using Euclid's algorithm.\n\n        :param x_wr: first integer\n        :param y_wr: second integer\n        :return: greatest common divisor of the two integers\n        \"\"\"\n        assert isinstance(x_wr, int), \"x_wr must be an integer\"\n        assert isinstance(y_wr, int), \"y_wr must be an integer\"\n\n        while y_wr:\n            x_wr, y_wr = y_wr, x_wr % y_wr\n        return x_wr\n\n    gcd_value_wr = gcd_wr(a_wr, b_wr)\n\n    # Calculate lcm using the formula: lcm(a, b) = abs(a * b) // gcd(a, b)\n    lcm_value_wr = abs(a_wr * b_wr) // gcd_value_wr\n    assert lcm_value_wr >= 0, \"lcm_value_wr must be non-negative\"\n\n    return lcm_value_wr\n```",
        "```python\nimport locale\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_wr=5):\n        \"\"\"\n        Initialize the Nearest Neighbors model.\n\n        Parameters:\n        n_neighbors_wr (int): Number of neighbors to use for predictions.\n        \"\"\"\n        assert isinstance(n_neighbors_wr, int) and n_neighbors_wr > 0, \"n_neighbors_wr must be a positive integer.\"\n        self.n_neighbors_wr = n_neighbors_wr\n        self.train_data_wr = None\n        self.train_labels_wr = None\n\n    def train(self, train_data_wr, train_labels_wr):\n        \"\"\"\n        Train the model using the provided data and labels.\n\n        Parameters:\n        train_data_wr (np.ndarray): Training data features.\n        train_labels_wr (np.ndarray): Training data labels.\n        \"\"\"\n        assert isinstance(train_data_wr, np.ndarray), \"train_data_wr must be a numpy ndarray.\"\n        assert isinstance(train_labels_wr, np.ndarray), \"train_labels_wr must be a numpy ndarray.\"\n        assert train_data_wr.shape[0] == train_labels_wr.shape[0], \"train_data_wr and train_labels_wr must have the same length.\"\n\n        self.train_data_wr = train_data_wr\n        self.train_labels_wr = train_labels_wr\n\n    def predict(self, test_data_wr):\n        \"\"\"\n        Predict labels for the provided test data.\n\n        Parameters:\n        test_data_wr (np.ndarray): Test data features.\n\n        Returns:\n        np.ndarray: Predicted labels.\n        \"\"\"\n        assert isinstance(test_data_wr, np.ndarray), \"test_data_wr must be a numpy ndarray.\"\n        assert self.train_data_wr is not None and self.train_labels_wr is not None, \"Model must be trained before predicting.\"\n\n        predicted_labels_wr = np.zeros(test_data_wr.shape[0])\n\n        for i_wr, test_instance_wr in enumerate(test_data_wr):\n            distances_wr = np.linalg.norm(self.train_data_wr - test_instance_wr, axis=1)\n            neighbors_indices_wr = np.argsort(distances_wr)[:self.n_neighbors_wr]\n            neighbor_labels_wr = self.train_labels_wr[neighbors_indices_wr]\n            predicted_labels_wr[i_wr] = np.argmax(np.bincount(neighbor_labels_wr))\n        \n        return predicted_labels_wr\n```",
        "```python\nimport locale\n\ndef is_palindrome_wr(input_string_wr):\n    \"\"\"\n    Check if the given string is a valid palindrome.\n    \n    A palindrome is a word, phrase, number, or other sequences of characters \n    that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\n    Args:\n        input_string_wr (str): The string to check for palindrome properties.\n\n    Returns:\n        bool: True if input_string_wr is a palindrome, False otherwise.\n    \"\"\"\n    assert isinstance(input_string_wr, str), \"Input must be a string.\"\n    \n    # Process the string: remove non-alphanumeric characters and convert to lowercase\n    filtered_string_wr = ''.join(char for char in input_string_wr if char.isalnum()).lower()\n    \n    # Check if the processed string is the same forward and backward\n    is_palindrome_wr = filtered_string_wr == filtered_string_wr[::-1]\n    \n    return is_palindrome_wr\n```"
      ]
    }
  ]
}