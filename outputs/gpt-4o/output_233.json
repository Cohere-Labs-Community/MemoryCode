{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value_i = value\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, value):\n        new_node_i = Node(value)\n        if not self.head_i:\n            self.head_i = new_node_i\n            return\n        last_node_i = self.head_i\n        while last_node_i.next_i:\n            last_node_i = last_node_i.next_i\n        last_node_i.next_i = new_node_i\n\n    def prepend(self, value):\n        new_node_i = Node(value)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def delete_with_value(self, value):\n        if not self.head_i:\n            return\n        if self.head_i.value_i == value:\n            self.head_i = self.head_i.next_i\n            return\n        current_node_i = self.head_i\n        while current_node_i.next_i:\n            if current_node_i.next_i.value_i == value:\n                current_node_i.next_i = current_node_i.next_i.next_i\n                return\n            current_node_i = current_node_i.next_i\n\n    def find(self, value):\n        current_node_i = self.head_i\n        while current_node_i:\n            if current_node_i.value_i == value:\n                return True\n            current_node_i = current_node_i.next_i\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        new_node_i = Node(data_i)\n        if self.head_i is None:\n            self.head_i = new_node_i\n            return\n        last_i = self.head_i\n        while last_i.next_i:\n            last_i = last_i.next_i\n        last_i.next_i = new_node_i\n\n    def prepend(self, data_i):\n        new_node_i = Node(data_i)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def delete(self, key_i):\n        temp_i = self.head_i\n        if temp_i and temp_i.data_i == key_i:\n            self.head_i = temp_i.next_i\n            temp_i = None\n            return\n\n        prev_i = None\n        while temp_i and temp_i.data_i != key_i:\n            prev_i = temp_i\n            temp_i = temp_i.next_i\n\n        if temp_i is None:\n            return\n\n        prev_i.next_i = temp_i.next_i\n        temp_i = None\n\n    def search(self, key_i):\n        current_i = self.head_i\n        while current_i and current_i.data_i != key_i:\n            current_i = current_i.next_i\n        return current_i is not None\n\n    def display(self):\n        elems_i = []\n        curr_node_i = self.head_i\n        while curr_node_i:\n            elems_i.append(curr_node_i.data_i)\n            curr_node_i = curr_node_i.next_i\n        return elems_i\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def n_insert_r(self, data_r):\n        new_node_r = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def n_delete_r(self, key_r):\n        temp_r = self.head_r\n        prev_r = None\n\n        if temp_r is not None and temp_r.data_r == key_r:\n            self.head_r = temp_r.next_r\n            temp_r = None\n            return\n\n        while temp_r is not None:\n            if temp_r.data_r == key_r:\n                break\n            prev_r = temp_r\n            temp_r = temp_r.next_r\n\n        if temp_r is None:\n            return\n\n        prev_r.next_r = temp_r.next_r\n        temp_r = None\n\n    def n_search_r(self, key_r):\n        current_r = self.head_r\n        while current_r is not None:\n            if current_r.data_r == key_r:\n                return True\n            current_r = current_r.next_r\n        return False\n\n    def n_get_all_r(self):\n        elements_r = []\n        current_r = self.head_r\n        while current_r is not None:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock_r = {}\n\n    def n_add_stock(self, item_r, quantity_r):\n        if item_r in self.stock_r:\n            self.stock_r[item_r] += quantity_r\n        else:\n            self.stock_r[item_r] = quantity_r\n\n    def n_remove_stock(self, item_r, quantity_r):\n        if item_r in self.stock_r and self.stock_r[item_r] >= quantity_r:\n            self.stock_r[item_r] -= quantity_r\n            if self.stock_r[item_r] == 0:\n                del self.stock_r[item_r]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data_r):\n        new_node_r = Node(data_r)\n        if self.head_r is None:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r):\n        new_node_r = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r):\n        if self.head_r is None:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def find(self, data_r):\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return current_r\n            current_r = current_r.next_r\n        return None\n\n    def display(self):\n        current_r = self.head_r\n        elements_r = []\n        while current_r:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def n_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def n_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock or item not available\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def a_addStock(self, item, quantity):\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    def a_removeStock(self, item, quantity):\n        if item in self.items:\n            if self.items[item] >= quantity:\n                self.items[item] -= quantity\n            else:\n                raise ValueError(\"Not enough stock available to remove the requested quantity.\")\n        else:\n            raise ValueError(\"Item not found in inventory.\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n            return True\n        return False\n\n    def a_get_stock(self, item):\n        return self._stock.get(item, 0)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, key: int):\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n        self.val: int = key\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def md_insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._md_insert(self.root, key)\n\n    def _md_insert(self, node: Node, key: int) -> None:\n        if key < node.val:\n            if node.left is None:\n                node.left = Node(key)\n            else:\n                self._md_insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = Node(key)\n            else:\n                self._md_insert(node.right, key)\n\n    def md_delete(self, key: int) -> None:\n        self.root = self._md_delete(self.root, key)\n\n    def _md_delete(self, node: Optional[Node], key: int) -> Optional[Node]:\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._md_delete(node.left, key)\n        elif key > node.val:\n            node.right = self._md_delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.val = self._md_min_value(node.right)\n            node.right = self._md_delete(node.right, node.val)\n\n        return node\n\n    def _md_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.val\n```",
        "```python\nfrom typing import Dict\n\nclass Inventory:\n    def __init__(self) -> None:\n        self.stock: Dict[str, int] = {}\n\n    def md_add_stock(self, item: str, quantity: int) -> None:\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock(self, item: str, quantity: int) -> bool:\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n        \n    def md_add_stock(self, item, quantity):\n        if item not in self.stock:\n            self.stock[item] = 0\n        self.stock[item] += quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_s):\n        self.data_s = data_s\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data_s):\n        new_node = Node(data_s)\n        if not self.head_s:\n            self.head_s = new_node\n            return\n        last_s = self.head_s\n        while last_s.next_s:\n            last_s = last_s.next_s\n        last_s.next_s = new_node\n\n    def prepend(self, data_s):\n        new_node = Node(data_s)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_with_value(self, data_s):\n        if not self.head_s:\n            return\n        if self.head_s.data_s == data_s:\n            self.head_s = self.head_s.next_s\n            return\n        current_s = self.head_s\n        while current_s.next_s:\n            if current_s.next_s.data_s == data_s:\n                current_s.next_s = current_s.next_s.next_s\n                return\n            current_s = current_s.next_s\n\n    def find(self, data_s):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == data_s:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def display(self):\n        elements_s = []\n        current_s = self.head_s\n        while current_s:\n            elements_s.append(current_s.data_s)\n            current_s = current_s.next_s\n        return elements_s\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_s = data\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_s is None:\n            self.head_s = new_node\n            return\n        last = self.head_s\n        while last.next_s:\n            last = last.next_s\n        last.next_s = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_node(self, key):\n        current_s = self.head_s\n        if current_s and current_s.data_s == key:\n            self.head_s = current_s.next_s\n            current_s = None\n            return\n        prev_s = None\n        while current_s and current_s.data_s != key:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        current_s = None\n\n    def search(self, key):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == key:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_s, end=\" \")\n            current_s = current_s.next_s\n        print()\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix(strs):\n    \"\"\"\n    Returns the longest common prefix string amongst a list of strings.\n\n    :param strs: List of strings to evaluate.\n    :type strs: List[str]\n    :return: The longest common prefix.\n    :rtype: str\n    :raises ValueError: If the input list is empty.\n    \n    The function finds the common prefix by comparing characters of each string.\n    If no common prefix exists, it returns an empty string.\n    \"\"\"\n    if not strs:\n        raise ValueError(\"Input list must not be empty.\")\n\n    prefix = strs[0]\n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]\n    \n    return prefix\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport bz2\n\ndef sum_array_except_self(arr):\n    if not arr or len(arr) < 2:\n        return []\n\n    total_sum_q = sum(arr)\n    result_q = [total_sum_q - x for x in arr]\n    \n    return result_q\n```",
        "```python\nimport bz2\n\nclass Node:\n    def __init__(self, data_q=None):\n        self.data_q = data_q\n        self.next_q = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append(self, data_q):\n        new_node_q = Node(data_q)\n        if not self.head_q:\n            self.head_q = new_node_q\n            return\n        last_q = self.head_q\n        while last_q.next_q:\n            last_q = last_q.next_q\n        last_q.next_q = new_node_q\n\n    def display(self):\n        current_q = self.head_q\n        while current_q:\n            print(current_q.data_q)\n            current_q = current_q.next_q\n```"
      ],
      "instruction_model_output": [
        "```python\nimport bz2\n\ndef sum_array_except_self(arr):\n    if arr is None or not isinstance(arr, list):\n        raise ValueError(\"Input must be a list\")\n\n    total_sum = sum(arr)\n    return [total_sum - x for x in arr]\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_q = data\n        self.next_q = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append(self, data):\n        new_node_q = Node(data)\n        if not self.head_q:\n            self.head_q = new_node_q\n            return\n        last_q = self.head_q\n        while last_q.next_q:\n            last_q = last_q.next_q\n        last_q.next_q = new_node_q\n\n    def prepend(self, data):\n        new_node_q = Node(data)\n        new_node_q.next_q = self.head_q\n        self.head_q = new_node_q\n\n    def delete(self, key):\n        temp_q = self.head_q\n        if temp_q and temp_q.data_q == key:\n            self.head_q = temp_q.next_q\n            temp_q = None\n            return\n        prev_q = None\n        while temp_q and temp_q.data_q != key:\n            prev_q = temp_q\n            temp_q = temp_q.next_q\n        if not temp_q:\n            return\n        prev_q.next_q = temp_q.next_q\n        temp_q = None\n\n    def search(self, key):\n        current_q = self.head_q\n        while current_q:\n            if current_q.data_q == key:\n                return True\n            current_q = current_q.next_q\n        return False\n\n    def display(self):\n        elems = []\n        current_q = self.head_q\n        while current_q:\n            elems.append(current_q.data_q)\n            current_q = current_q.next_q\n        return elems\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def x_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def x_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found.\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def x_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def x_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            if self._items[item_name] >= quantity:\n                self._items[item_name] -= quantity\n                if self._items[item_name] == 0:\n                    del self._items[item_name]\n            else:\n                raise ValueError(\"Quantity to remove exceeds current stock.\")\n        else:\n            raise KeyError(f\"Item '{item_name}' not found in inventory.\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\n\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self.training_data = None\n        self.training_labels = None\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray), \"Training data X must be a numpy array\"\n        assert isinstance(y, np.ndarray), \"Labels y must be a numpy array\"\n        assert X.shape[0] == y.shape[0], \"Number of samples in X must match number of samples in y\"\n        self.training_data = X\n        self.training_labels = y\n\n    def predict(self, X):\n        assert self.training_data is not None and self.training_labels is not None, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"Prediction data X must be a numpy array\"\n        predictions = []\n\n        for x in X:\n            distances = np.linalg.norm(self.training_data - x, axis=1)\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.training_labels[nearest_indices]\n            predicted_label = np.bincount(nearest_labels).argmax()\n            predictions.append(predicted_label)\n\n        return np.array(predictions)\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nimport bz2\nfrom typing import List\n\ndef x_findKthLargest_q(nums_s: List[int], k_s: int) -> int:\n    \"\"\"\n    Finds and returns the kth largest element in the list.\n\n    :param nums_s: A list of integers.\n    :param k_s: The position of the largest element to find, e.g., k=1 means the largest.\n    :return: The kth largest element in the list.\n    \"\"\"\n    assert k_s > 0, \"k must be a positive integer\"\n    nums_s.sort(reverse=True)\n    return nums_s[k_s - 1]\n```\n",
        "```python\nimport bz2\n\nclass TreeNode:\n    def __init__(self, value_q):\n        self.value_q = value_q\n        self.left_q = None\n        self.right_q = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root_q = None\n\n    def x_insert(self, value_q):\n        if not self.root_q:\n            self.root_q = TreeNode(value_q)\n        else:\n            self._insert_recursively(self.root_q, value_q)\n\n    def _insert_recursively(self, node_q, value_q):\n        assert isinstance(node_q, TreeNode)\n        if value_q < node_q.value_q:\n            if node_q.left_q is None:\n                node_q.left_q = TreeNode(value_q)\n            else:\n                self._insert_recursively(node_q.left_q, value_q)\n        else:\n            if node_q.right_q is None:\n                node_q.right_q = TreeNode(value_q)\n            else:\n                self._insert_recursively(node_q.right_q, value_q)\n\n    def x_delete(self, value_q):\n        self.root_q = self._delete_recursively(self.root_q, value_q)\n\n    def _delete_recursively(self, node_q, value_q):\n        assert node_q is None or isinstance(node_q, TreeNode)\n        if not node_q:\n            return node_q\n\n        if value_q < node_q.value_q:\n            node_q.left_q = self._delete_recursively(node_q.left_q, value_q)\n        elif value_q > node_q.value_q:\n            node_q.right_q = self._delete_recursively(node_q.right_q, value_q)\n        else:\n            if not node_q.left_q:\n                return node_q.right_q\n            elif not node_q.right_q:\n                return node_q.left_q\n\n            temp_q = self._min_value_node(node_q.right_q)\n            node_q.value_q = temp_q.value_q\n            node_q.right_q = self._delete_recursively(node_q.right_q, temp_q.value_q)\n\n        return node_q\n\n    def _min_value_node(self, node_q):\n        assert isinstance(node_q, TreeNode)\n        current_q = node_q\n        while current_q.left_q is not None:\n            current_q = current_q.left_q\n        return current_q\n```",
        "```python\nimport bz2\nfrom typing import List\n\ndef x_sum_except_self_q(nums_q: List[int]) -> List[int]:\n    \"\"\"\n    Calculate the sum of the array elements except the element itself for each position.\n\n    Args:\n    nums_q (List[int]): A list of integers for which the sum excluding itself needs to be found.\n\n    Returns:\n    List[int]: A list where each element at index i is the sum of all numbers in the input list except nums_q[i].\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    \"\"\"\n    assert isinstance(nums_q, list), \"Input must be a list.\"\n    assert all(isinstance(n_i, int) for n_i in nums_q), \"All elements must be integers.\"\n\n    length_q = len(nums_q)\n    if length_q == 0:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    total_sum_q = sum(nums_q)\n    result_q = [total_sum_q - n for n in nums_q]\n    \n    return result_q\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\nimport bz2\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_q=5):\n        self.n_neighbors_q = n_neighbors_q\n        self.features_q = None\n        self.labels_q = None\n    \n    def x_train(self, features_q: np.ndarray, labels_q: np.ndarray) -> None:\n        \"\"\"\n        Trains the Nearest Neighbors model.\n\n        :param features_q: Training data features, an array of shape (n_samples, n_features)\n        :param labels_q: Training data labels, an array of shape (n_samples,)\n        \"\"\"\n        assert isinstance(features_q, np.ndarray), \"Features should be a numpy array.\"\n        assert isinstance(labels_q, np.ndarray), \"Labels should be a numpy array.\"\n        assert len(features_q) == len(labels_q), \"Features and labels must have the same length.\"\n\n        self.features_q = features_q\n        self.labels_q = labels_q\n    \n    def x_predict(self, query_point_q: np.ndarray) -> any:\n        \"\"\"\n        Predicts the label of a query point.\n\n        :param query_point_q: Query point features, an array of shape (n_features,)\n        :return: Predicted label for the query point\n        \"\"\"\n        assert isinstance(query_point_q, np.ndarray), \"Query point should be a numpy array.\"\n        assert self.features_q is not None and self.labels_q is not None, \"Model needs to be trained first.\"\n\n        distances_q = distance.cdist([query_point_q], self.features_q)\n        nearest_indices_q = np.argsort(distances_q)[0][:self.n_neighbors_q]\n        nearest_labels_q = self.labels_q[nearest_indices_q]\n        prediction_q = np.bincount(nearest_labels_q).argmax()\n\n        return prediction_q\n```\n",
        "```python\nimport bz2\n\ndef x_get_longest_common_prefix_s(strings_q: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix from a list of strings.\n    \n    Args:\n        strings_q (list): The list of strings to evaluate.\n    \n    Returns:\n        str: The longest common prefix, or an empty string if there is none.\n    \"\"\"\n    assert isinstance(strings_q, list), \"Expected a list of strings\"\n    if not strings_q:\n        return \"\"\n\n    prefix_s = strings_q[0]\n    for string_s in strings_q[1:]:\n        while not string_s.startswith(prefix_s):\n            prefix_s = prefix_s[:-1]\n            if not prefix_s:\n                return \"\"\n    return prefix_s\n```\n",
        "```python\nimport bz2\n\nclass Node:\n    def __init__(self, value_q=None, next_q=None):\n        self.value_q = value_q\n        self.next_q = next_q\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def x_add_q(self, value_q):\n        new_node_q = Node(value_q=value_q)\n        if not self.head_q:\n            self.head_q = new_node_q\n        else:\n            current_q = self.head_q\n            while current_q.next_q:\n                current_q = current_q.next_q\n            current_q.next_q = new_node_q\n    \n    def x_remove_q(self, value_q):\n        assert self.head_q is not None, \"Cannot remove from an empty list.\"\n        if self.head_q.value_q == value_q:\n            self.head_q = self.head_q.next_q\n            return\n\n        current_q = self.head_q\n        while current_q.next_q:\n            if current_q.next_q.value_q == value_q:\n                current_q.next_q = current_q.next_q.next_q\n                return\n            current_q = current_q.next_q\n            \n    def x_search_q(self, value_q):\n        current_q = self.head_q\n        while current_q:\n            if current_q.value_q == value_q:\n                return current_q\n            current_q = current_q.next_q\n        return None\n    \n    def x_display_q(self):\n        values_q = []\n        current_q = self.head_q\n        while current_q:\n            values_q.append(current_q.value_q)\n            current_q = current_q.next_q\n        return values_q\n\n    def x_length_q(self):\n        current_q = self.head_q\n        count_q = 0\n        while current_q:\n            count_q += 1\n            current_q = current_q.next_q\n        return count_q\n```\n",
        "```python\nimport bz2\n\nclass Inventory:\n    def __init__(self):\n        self.items_q = {}\n\n    def x_add_stock(self, item_name_s: str, quantity_s: int) -> None:\n        \"\"\"\n        Adds stock to the inventory for a specific item.\n\n        :param item_name_s: The name of the item to add stock for.\n        :param quantity_s: The quantity of the item to add.\n        \"\"\"\n        assert isinstance(item_name_s, str), \"item_name_s must be a string\"\n        assert isinstance(quantity_s, int), \"quantity_s must be an integer\"\n        assert quantity_s > 0, \"quantity_s must be positive\"\n\n        if item_name_s in self.items_q:\n            self.items_q[item_name_s] += quantity_s\n        else:\n            self.items_q[item_name_s] = quantity_s\n\n    def x_remove_stock(self, item_name_s: str, quantity_s: int) -> None:\n        \"\"\"\n        Removes stock from the inventory for a specific item.\n\n        :param item_name_s: The name of the item to remove stock from.\n        :param quantity_s: The quantity of the item to remove.\n        \"\"\"\n        assert isinstance(item_name_s, str), \"item_name_s must be a string\"\n        assert isinstance(quantity_s, int), \"quantity_s must be an integer\"\n        assert quantity_s > 0, \"quantity_s must be positive\"\n        assert item_name_s in self.items_q, \"item_name_s must exist in inventory\"\n        assert self.items_q[item_name_s] >= quantity_s, \"Not enough stock to remove\"\n\n        self.items_q[item_name_s] -= quantity_s\n\n        if self.items_q[item_name_s] == 0:\n            del self.items_q[item_name_s]\n```\n"
      ]
    }
  ]
}