{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self.train_data = None\n        self.train_labels = None\n\n    def train(self, data, labels):\n        assert len(data) == len(labels), \"Number of data points must match number of labels\"\n        self.train_data = np.array(data)\n        self.train_labels = np.array(labels)\n\n    def predict(self, data):\n        assert self.train_data is not None and self.train_labels is not None, \"Model must be trained before predictions can be made\"\n        predictions = []\n\n        for point in data:\n            assert isinstance(point, (list, np.ndarray)), \"Each data point must be a list or numpy array\"\n            distances = np.sqrt(np.sum((self.train_data - point) ** 2, axis=1))\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.train_labels[nearest_indices]\n            most_common = Counter(nearest_labels).most_common(1)[0][0]\n            predictions.append(most_common)\n\n        return predictions\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef fn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef fn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    \"\"\"\n    Returns the k-th largest element in a given list of integers.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n    k (int): The order of the largest element to find.\n\n    Returns:\n    int: The k-th largest element in the list.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k - 1]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, key):\n        \"\"\"\n        Initializes a new node with the given key.\n\n        :param key: The key of the node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty BinaryTree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Inserts a new node with the specified key into the binary tree.\n\n        :param key: The key of the node to be inserted.\n        \"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, root, key):\n        \"\"\"\n        Helper method to insert a new node with the specified key recursively.\n\n        :param root: The current node in the binary tree traversal.\n        :param key: The key of the node to be inserted.\n        \"\"\"\n        if key < root.val:\n            if root.left is None:\n                root.left = Node(key)\n            else:\n                self._insert_recursively(root.left, key)\n        else:\n            if root.right is None:\n                root.right = Node(key)\n            else:\n                self._insert_recursively(root.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Deletes a node with the specified key from the binary tree.\n\n        :param key: The key of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, root, key):\n        \"\"\"\n        Helper method to delete a node with the specified key recursively.\n\n        :param root: The current node in the binary tree traversal.\n        :param key: The key of the node to be deleted.\n        :return: The root of the modified tree.\n        \"\"\"\n        if root is None:\n            return root\n\n        if key < root.val:\n            root.left = self._delete_recursively(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursively(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            temp_val = self._min_value_node(root.right).val\n            root.val = temp_val\n            root.right = self._delete_recursively(root.right, temp_val)\n\n        return root\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Helper method to find the node with the smallest value greater than a given node.\n\n        :param node: The node to find the in-order successor of.\n        :return: The node with the smallest value greater than the given node.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.exceptions import NotFittedError\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.model = Lasso(alpha=self.alpha)\n\n    def gn_train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def gn_predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except NotFittedError:\n            print(\"The model is not fitted yet. Please train the model first.\")\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\ndef gn_compute_h_index(citations):\n    try:\n        citations.sort(reverse=True)\n        h_index = 0\n        for i, c in enumerate(citations):\n            if c >= i + 1:\n                h_index = i + 1\n            else:\n                break\n        return h_index\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\ndef gn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        assert n_neighbors > 0, \"Number of neighbors must be positive\"\n        self.n_neighbors = n_neighbors\n        self._training_data = None\n        self._training_labels = None\n\n    def train(self, X, y):\n        assert len(X) == len(y), \"Features and labels must have the same length\"\n        self._training_data = X\n        self._training_labels = y\n\n    def gn_predict(self, X):\n        from collections import Counter\n        import numpy as np\n        \n        assert self._training_data is not None, \"Model has not been trained yet\"\n        try:\n            predictions = []\n            for test_point in X:\n                distances = np.linalg.norm(self._training_data - test_point, axis=1)\n                nearest_indices = np.argsort(distances)[:self.n_neighbors]\n                nearest_labels = [self._training_labels[i] for i in nearest_indices]\n                most_common_label = Counter(nearest_labels).most_common(1)[0][0]\n                predictions.append(most_common_label)\n            return predictions\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            raise\n```\n",
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def gn_insert(self, key):\n        self.root = self._gn_insert(self.root, key)\n\n    def _gn_insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        try:\n            assert isinstance(key, int), \"Key must be an integer.\"\n            if key < node.key:\n                node.left = self._gn_insert(node.left, key)\n            else:\n                node.right = self._gn_insert(node.right, key)\n        except Exception as e:\n            print(f\"Insert Error: {e}\")\n        return node\n\n    def gn_delete(self, key):\n        self.root = self._gn_delete(self.root, key)\n\n    def _gn_delete(self, node, key):\n        if node is None:\n            return node\n        try:\n            assert isinstance(key, int), \"Key must be an integer.\"\n            if key < node.key:\n                node.left = self._gn_delete(node.left, key)\n            elif key > node.key:\n                node.right = self._gn_delete(node.right, key)\n            else:\n                if node.left is None:\n                    return node.right\n                elif node.right is None:\n                    return node.left\n                temp = self._gn_min_value_node(node.right)\n                node.key = temp.key\n                node.right = self._gn_delete(node.right, temp.key)\n        except Exception as e:\n            print(f\"Delete Error: {e}\")\n        return node\n\n    def _gn_min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n# The BinaryTree class now includes methods to insert and delete nodes.\n```",
        "```python\ndef gn_find_kth_largest(nums: list[int], k: int) -> int:\n    \"\"\"\n    Find and return the kth largest element in an array.\n    \n    Args:\n        nums (list[int]): The array of integers.\n        k (int): The index (1-based) for the kth largest element.\n    \n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    assert isinstance(nums, list), \"nums must be a list\"\n    assert all(isinstance(x, int) for x in nums), \"nums must contain only integers\"\n    assert isinstance(k, int), \"k must be an integer\"\n    assert 1 <= k <= len(nums), \"k must be within the bounds of nums\"\n    \n    try:\n        nums.sort(reverse=True)\n        return nums[k - 1]\n    except Exception as e:\n        raise RuntimeError(\"An error occurred while finding the kth largest element\") from e\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, learning_rate=0.01, iterations=1000, alpha=0.01):\n        assert isinstance(learning_rate, (int, float)), \"Learning rate must be a number.\"\n        assert isinstance(iterations, int), \"Iterations must be an integer.\"\n        assert isinstance(alpha, (int, float)), \"Alpha must be a number.\"\n        \n        self.learning_rate = learning_rate\n        self.iterations = iterations\n        self.alpha = alpha\n        self.weights = None\n        self.bias = None\n\n    def l1_penalty(self, weights):\n        return self.alpha * np.sign(weights)\n\n    def train(self, X, y):\n        assert X.ndim == 2, \"Input features X must be a 2D array.\"\n        assert y.ndim == 1, \"Target values y must be a 1D array.\"\n\n        samples, features = X.shape\n        self.weights = np.zeros(features)\n        self.bias = 0\n        \n        for _ in range(self.iterations):\n            y_predicted = np.dot(X, self.weights) + self.bias\n            dw = (1 / samples) * np.dot(X.T, (y_predicted - y)) + self.l1_penalty(self.weights)\n            db = (1 / samples) * np.sum(y_predicted - y)\n\n            self.weights -= self.learning_rate * dw\n            self.bias -= self.learning_rate * db\n\n    def predict(self, X):\n        assert X.ndim == 2, \"Input features X must be a 2D array.\"\n        \n        y_predicted = np.dot(X, self.weights) + self.bias\n        return y_predicted\n```",
        "```python\ndef gn_compute_h_index(citations: list[int]) -> int:\n    \"\"\"\n    Compute the h-index for a given list of citations.\n\n    Args:\n        citations (list[int]): A list of integers representing citation counts.\n\n    Returns:\n        int: The h-index computed from the citation list.\n    \"\"\"\n    assert citations is not None, \"Citations list cannot be None.\"\n\n    n = len(citations)\n    try:\n        citations.sort(reverse=True)\n        h_index = 0\n        for i, citation in enumerate(citations):\n            if citation >= i + 1:\n                h_index = i + 1\n            else:\n                break\n        return h_index\n    except Exception as e:\n        raise RuntimeError(\"An error occurred while computing the h-index.\") from e\n```"
      ]
    }
  ]
}