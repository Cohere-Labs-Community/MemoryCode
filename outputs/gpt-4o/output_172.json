{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_c(left_c, right_c):\n    result_c = []\n    i_n, j_n = 0, 0\n    while i_n < len(left_c) and j_n < len(right_c):\n        if left_c[i_n] <= right_c[j_n]:\n            result_c.append(left_c[i_n])\n            i_n += 1\n        else:\n            result_c.append(right_c[j_n])\n            j_n += 1\n    result_c.extend(left_c[i_n:])\n    result_c.extend(right_c[j_n:])\n    return result_c\n\ndef merge_sort_c(data_c):\n    if len(data_c) <= 1:\n        return data_c\n    mid_c = len(data_c) // 2\n    left_c = merge_sort_c(data_c[:mid_c])\n    right_c = merge_sort_c(data_c[mid_c:])\n    return merge_c(left_c, right_c)\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self_n):\n        self_n.adjacency_list = {}\n\n    def add_edge_n(self, u_c, v_c, weight_c):\n        if u_c not in self_n.adjacency_list:\n            self_n.adjacency_list[u_c] = []\n        if v_c not in self_n.adjacency_list:\n            self_n.adjacency_list[v_c] = []\n        self_n.adjacency_list[u_c].append((v_c, weight_c))\n        self_n.adjacency_list[v_c].append((u_c, weight_c))\n\n    def shortest_path_n(self, start_c, end_c):\n        distances_c = {vertex_c: float('infinity') for vertex_c in self_n.adjacency_list}\n        distances_c[start_c] = 0\n        priority_queue = [(0, start_c)]\n        heapq.heapify(priority_queue)\n\n        while priority_queue:\n            current_distance_c, current_vertex_c = heapq.heappop(priority_queue)\n\n            if current_distance_c > distances_c[current_vertex_c]:\n                continue\n\n            for neighbor_c, weight_c in self_n.adjacency_list[current_vertex_c]:\n                distance_c = current_distance_c + weight_c\n\n                if distance_c < distances_c[neighbor_c]:\n                    distances_c[neighbor_c] = distance_c\n                    heapq.heappush(priority_queue, (distance_c, neighbor_c))\n\n        return distances_c[end_c]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```\n",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```\n",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node not in self.vertices:\n            self.vertices[from_node] = []\n        if to_node not in self.vertices:\n            self.vertices[to_node] = []\n        self.vertices[from_node].append((to_node, weight))\n\n    def shortest_path_x(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.vertices}\n        distances[start_node] = 0\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.vertices.get(current_node, []):\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_x(self, value):\n        self.nodes[value] = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node][to_node] = weight\n            self.nodes[to_node][from_node] = weight  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_ud(self, u, v, weight):\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        if v not in self.adjacency_list:\n            self.adjacency_list[v] = []\n        self.adjacency_list[u].append((v, weight))\n        self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_x(self, start, end):\n        heap = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        while heap:\n            current_distance, current_node = heapq.heappop(heap)\n            if current_node == end:\n                return current_distance\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(heap, (distance, neighbor))\n        return float('inf')\n```",
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```",
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_edge_p(self, node1, node2, weight):\n        if node1 not in self.nodes:\n            self.nodes[node1] = []\n        if node2 not in self.nodes:\n            self.nodes[node2] = []\n        self.nodes[node1].append((node2, weight))\n        self.nodes[node2].append((node1, weight))\n\n    def shortest_path_p(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n\n        priority_queue = [(0, start_node)]\n        came_from = {start_node: None}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node == end_node:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = came_from[current_node]\n                return path[::-1]\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    came_from[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass binary_image_classifier(nn.Module):\n    def __init__(self, input_channels: int, num_classes: int = 2) -> None:\n        \"\"\"Initialize the binary image classifier.\n\n        Args:\n            input_channels (int): Number of input channels in the images.\n            num_classes (int, optional): Number of output classes. Defaults to 2.\n        \"\"\"\n        super().__init__()\n        self.conv1 = nn.Conv2d(input_channels, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)  # Assuming input images are 32x32\n        self.fc2 = nn.Linear(128, num_classes)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Forward pass for the binary classifier.\n\n        Args:\n            x (torch.Tensor): Input tensor with shape (batch_size, input_channels, height, width).\n\n        Returns:\n            torch.Tensor: Output tensor with shape (batch_size, num_classes).\n        \"\"\"\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 64 * 8 * 8)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x\n```",
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    \"\"\"\n    Returns the k-th largest element in the given list of numbers.\n    \n    Args:\n        nums (List[int]): A list of integers.\n        k (int): The k-th position to find the largest element.\n    \n    Returns:\n        int: The k-th largest element in the list.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass binary_image_classifier(nn.Module):\n    def __init__(self):\n        super(binary_image_classifier, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.conv3 = nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1)\n        self.fc1 = nn.Linear(128 * 8 * 8, 256)\n        self.fc2 = nn.Linear(256, 1)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2, 2)\n        x = F.relu(self.conv3(x))\n        x = F.max_pool2d(x, 2, 2)\n        x = x.view(x.size(0), -1)\n        x = F.relu(self.fc1(x))\n        x = torch.sigmoid(self.fc2(x))\n        return x\n```",
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "history_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass binary_image_classifier_p(nn.Module):\n    def __init__(self_x, num_classes_x=2):\n        super(binary_image_classifier_p, self_x).__init__()\n        self_x.conv1_p = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1)\n        self_x.conv2_p = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n        self_x.fc1_p = nn.Linear(32 * 8 * 8, 128)\n        self_x.fc2_p = nn.Linear(128, num_classes_x)\n\n    def forward_p(self_x, x_x):\n        x_x = F.relu(self_x.conv1_p(x_x))\n        x_x = F.max_pool2d(x_x, kernel_size=2, stride=2)\n        x_x = F.relu(self_x.conv2_p(x_x))\n        x_x = F.max_pool2d(x_x, kernel_size=2, stride=2)\n        x_x = x_x.view(x_x.size(0), -1)\n        x_x = F.relu(self_x.fc1_p(x_x))\n        x_x = self_x.fc2_p(x_x)\n        return x_x\n```",
        "```python\nfrom typing import List\n\ndef find_kth_largest_element_x(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```",
        "```python\nimport heapq\nfrom typing import Dict, Tuple, List\n\nclass graph_c:\n\n    def __init__(self: 'graph_c') -> None:\n        self.adjacency_list_x: Dict[str, List[Tuple[str, int]]] = {}\n\n    def add_edge_x(self: 'graph_c', start: str, end: str, weight: int) -> None:\n        if start not in self.adjacency_list_x:\n            self.adjacency_list_x[start] = []\n        if end not in self.adjacency_list_x:\n            self.adjacency_list_x[end] = []\n        \n        self.adjacency_list_x[start].append((end, weight))\n        self.adjacency_list_x[end].append((start, weight))  # Assuming it's an undirected graph\n\n    def shortest_path_x(self: 'graph_c', start: str, end: str) -> Tuple[int, List[str]]:\n        priority_queue_p: List[Tuple[int, str]] = [(0, start)]\n        distances_x: Dict[str, int] = {node: float('inf') for node in self.adjacency_list_x}\n        previous_nodes_x: Dict[str, str] = {node: None for node in self.adjacency_list_x}\n\n        distances_x[start] = 0\n\n        while priority_queue_p:\n            current_distance_x, current_node_x = heapq.heappop(priority_queue_p)\n\n            if current_node_x == end:\n                break\n\n            if current_distance_x > distances_x[current_node_x]:\n                continue\n\n            for neighbor, weight in self.adjacency_list_x[current_node_x]:\n                distance = current_distance_x + weight\n\n                if distance < distances_x[neighbor]:\n                    distances_x[neighbor] = distance\n                    previous_nodes_x[neighbor] = current_node_x\n                    heapq.heappush(priority_queue_p, (distance, neighbor))\n\n        path_x = []\n        if distances_x[end] != float('inf'):\n            current_x = end\n            while current_x is not None:\n                path_x.append(current_x)\n                current_x = previous_nodes_x[current_x]\n            path_x.reverse()\n\n        return (distances_x[end], path_x)\n```",
        "```python\ndef merge_sort_x(arr: list) -> list:\n    \"\"\"\n    Sorts an array using merge sort algorithm.\n\n    :param arr: List of elements to be sorted\n    :return: New sorted list\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    middle = len(arr) // 2\n    left_half = merge_sort_x(arr[:middle])\n    right_half = merge_sort_x(arr[middle:])\n    \n    return _merge_p(left_half, right_half)\n\ndef _merge_p(left: list, right: list) -> list:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    :param left: Sorted left half\n    :param right: Sorted right half\n    :return: Merged sorted list\n    \"\"\"\n    result = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n\n    return result\n```"
      ]
    }
  ]
}