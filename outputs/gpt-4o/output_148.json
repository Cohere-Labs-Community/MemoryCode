{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef y_find_common_elements(list1_a, list2_b):\n    return list(set(list1_a) & set(list2_b))\n```",
        "```python\ndef y_h_index(citations1):\n    citations1.sort(reverse=True)\n    h_index1 = 0\n    for i1, c1 in enumerate(citations1, start=1):\n        if c1 >= i1:\n            h_index1 = i1\n        else:\n            break\n    return h_index1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef find_common_elements(list1_a, list2_b):\n    return list(set(list1_a) & set(list2_b))\n```",
        "```python\ndef y_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef average_diagonal(matrix: List[List[float]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    :param matrix: A square matrix represented as a list of lists of floats.\n    :return: The average of the diagonal elements of the matrix.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list of lists.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row must be a list.\"\n    assert all(isinstance(element, (int, float)) for row in matrix for element in row), \"All elements must be integers or floats.\"\n    n = len(matrix)\n    assert all(len(row) == n for row in matrix), \"Matrix must be square.\"\n    \n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    return diagonal_sum / n\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int):\n        self.key: int = key\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        new_node = TreeNode(key)\n        if self.root is None:\n            self.root = new_node\n        else:\n            self._insert_recursive(self.root, new_node)\n\n    def _insert_recursive(self, node: TreeNode, new_node: TreeNode) -> None:\n        assert node is not None\n        if new_node.key < node.key:\n            if node.left is None:\n                node.left = new_node\n            else:\n                self._insert_recursive(node.left, new_node)\n        else:\n            if node.right is None:\n                node.right = new_node\n            else:\n                self._insert_recursive(node.right, new_node)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.key:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_recursive(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            min_larger_node = self._min_value_node(node.right)\n            node.key = min_larger_node.key\n            node.right = self._delete_recursive(node.right, min_larger_node.key)\n\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        assert node is not None\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nfrom typing import List\n\ndef y_common_elements(list1_1: List[int], list2_2: List[int]) -> List[int]:\n    assert isinstance(list1_1, list), \"list1_1 must be a list\"\n    assert isinstance(list2_2, list), \"list2_2 must be a list\"\n    return list(set(list1_1).intersection(list2_2))\n```",
        "```python\ndef y_h_index(citations1: list[int]) -> int:\n    assert isinstance(citations1, list), \"Input must be a list of integers\"\n    citations2 = sorted(citations1, reverse=True)\n    h_index1 = 0\n    for idx1, citation1 in enumerate(citations2):\n        assert isinstance(citation1, int), \"All elements must be integers\"\n        if citation1 >= idx1 + 1:\n            h_index1 = idx1 + 1\n        else:\n            break\n    return h_index1\n```",
        "```python\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass y_BinaryTree:\n    def __init__(self) -> None:\n        self.root = None\n\n    def y_insert(self, d_value: int) -> None:\n        if self.root is None:\n            self.root = Node(d_value)\n        else:\n            self._y_insert_recursively(self.root, d_value)\n\n    def _y_insert_recursively(self, n_node: Node, d_value: int) -> None:\n        assert isinstance(n_node, Node)\n        assert isinstance(d_value, int)\n\n        if d_value < n_node.data:\n            if n_node.left is None:\n                n_node.left = Node(d_value)\n            else:\n                self._y_insert_recursively(n_node.left, d_value)\n        else:\n            if n_node.right is None:\n                n_node.right = Node(d_value)\n            else:\n                self._y_insert_recursively(n_node.right, d_value)\n\n    def y_delete(self, d_value: int) -> None:\n        self.root = self._y_delete_recursively(self.root, d_value)\n\n    def _y_delete_recursively(self, n_node: Node, d_value: int) -> Node:\n        assert n_node is None or isinstance(n_node, Node)\n        assert isinstance(d_value, int)\n\n        if n_node is None:\n            return n_node\n\n        if d_value < n_node.data:\n            n_node.left = self._y_delete_recursively(n_node.left, d_value)\n        elif d_value > n_node.data:\n            n_node.right = self._y_delete_recursively(n_node.right, d_value)\n        else:\n            if n_node.left is None:\n                return n_node.right\n            elif n_node.right is None:\n                return n_node.left\n\n            min_larger_node = self._y_min_value_node(n_node.right)\n            n_node.data = min_larger_node.data\n            n_node.right = self._y_delete_recursively(n_node.right, min_larger_node.data)\n\n        return n_node\n\n    def _y_min_value_node(self, n_node: Node) -> Node:\n        assert isinstance(n_node, Node)\n\n        current = n_node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nfrom typing import List\n\ndef y_diagonal_average(matrix0: List[List[float]]) -> float:\n    assert all(len(row1) == len(matrix0) for row1 in matrix0), \"Non-square matrix provided\"\n    n2: int = len(matrix0)\n    diag_sum3: float = sum(matrix0[i4][i4] for i4 in range(n2))\n    return diag_sum3 / n2\n```\n"
      ]
    }
  ]
}