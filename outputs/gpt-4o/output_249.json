{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef b_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef b_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i = j = k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nimport sys\nfrom collections import defaultdict\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n\n    def add_edge_ud(self, from_node, to_node, weight):\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_b(self, start, end):\n        queue = [(0, start)]\n        distances = {node: float('inf') for node in self.edges}\n        distances[start] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(current_node)\n        path.reverse()\n\n        return path if distances[end] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.model = Lasso(alpha=self.alpha)\n    \n    def train(self, X, y):\n        try:\n            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n            self.model.fit(X_train, y_train)\n            train_score = self.model.score(X_train, y_train)\n            test_score = self.model.score(X_test, y_test)\n            return train_score, test_score\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            return self.model.predict(X)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            return np.array([])\n```\n"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_x(self, u, v, weight):\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        if v not in self.adjacency_list:\n            self.adjacency_list[v] = []\n        self.adjacency_list[u].append((v, weight))\n        self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_x(self, start, end):\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances[end] if distances[end] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_x(self, value):\n        self.nodes[value] = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node][to_node] = weight\n            self.nodes[to_node][from_node] = weight  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef x_compute_h_index_n(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def x_add_edge_n(self, node1, node2, weight):\n        if node1 not in self.adjacency_list:\n            self.adjacency_list[node1] = []\n        if node2 not in self.adjacency_list:\n            self.adjacency_list[node2] = []\n        self.adjacency_list[node1].append((node2, weight))\n        self.adjacency_list[node2].append((node1, weight))\n\n    def x_shortest_path_n(self, start_node, end_node):\n        distances = {node: float('infinity') for node in self.adjacency_list}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        previous_nodes = {node: None for node in self.adjacency_list}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n            if current_node == end_node:\n                break\n\n        path, current = [], end_node\n        while current is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        path.reverse()\n\n        if distances[end_node] == float('infinity'):\n            return None\n        \n        return path\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations, start=1):\n        if c >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Heap:\n    def __init__(self):\n        self.data = []\n\n    def chx_insert(self, value):\n        try:\n            self.data.append(value)\n            self._chx_heapify_up(len(self.data) - 1)\n        except Exception as e:\n            print(f\"An error occurred during insert: {e}\")\n\n    def _chx_heapify_up(self, index):\n        try:\n            parent_index = (index - 1) // 2\n            while index > 0 and self.data[index] > self.data[parent_index]:\n                self.data[index], self.data[parent_index] = self.data[parent_index], self.data[index]\n                index = parent_index\n                parent_index = (index - 1) // 2\n        except Exception as e:\n            print(f\"An error occurred during heapify up: {e}\")\n\n    def chx_heapify_down(self, index):\n        try:\n            child_index = 2 * index + 1\n            while child_index < len(self.data):\n                right_child = child_index + 1\n                if right_child < len(self.data) and self.data[right_child] > self.data[child_index]:\n                    child_index = right_child\n                if self.data[index] >= self.data[child_index]:\n                    break\n                self.data[index], self.data[child_index] = self.data[child_index], self.data[index]\n                index = child_index\n                child_index = 2 * index + 1\n        except Exception as e:\n            print(f\"An error occurred during heapify down: {e}\")\n```",
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef chx_is_valid_bst(root: TreeNode) -> bool:\n    def chx_validate(node, low, high):\n        if not node:\n            return True\n        val = node.val\n        if val <= low or val >= high:\n            return False\n        \n        try:\n            return chx_validate(node.left, low, val) and chx_validate(node.right, val, high)\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n\n    return chx_validate(root, float('-inf'), float('inf'))\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert_chx(self, item):\n        self.heap.append(item)\n        self._heapify_up_chx(len(self.heap) - 1)\n\n    def _heapify_up_chx(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] > self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n            else:\n                break\n\n    def _heapify_down_chx(self, index):\n        last_index = len(self.heap) - 1\n        while True:\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            largest_index = index\n\n            if left_child_index <= last_index and self.heap[left_child_index] > self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index <= last_index and self.heap[right_child_index] > self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n            else:\n                self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n                index = largest_index\n\n    def extract_chx(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down_chx(0)\n        return root\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic.decorators import require_kwargs\n\nclass StudentGrade:\n    def __init__(self, student_name: str, grades: list):\n        self.student_name = student_name\n        assert isinstance(grades, list), \"Grades should be a list.\"\n        assert all(isinstance(grade, (int, float)) for grade in grades), \"Each grade should be an integer or float.\"\n        self.grades = grades\n\n    @require_kwargs\n    def compute_average_grade(self) -> float:\n        assert len(self.grades) > 0, \"There should be at least one grade to compute an average.\"\n        average_grade = sum(self.grades) / len(self.grades)\n        assert isinstance(average_grade, float), \"The computed average should be of type float.\"\n        return average_grade\n```",
        "```python\nfrom pedantic import require_kwargs\n\n@require_kwargs\ndef average_diagonal(matrix):\n    assert isinstance(matrix, list), \"Matrix should be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square.\"\n\n    n = len(matrix)\n    assert n > 0, \"Matrix must not be empty.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    \n    return diagonal_sum / n\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\nclass StudentGrade:\n    def __init__(self, **kwargs):\n        self.grades = kwargs.get('grades', [])\n\n    @require_kwargs\n    def add_grade(self, grade: float) -> None:\n        self.grades.append(grade)\n\n    @require_kwargs\n    def compute_average(self) -> float:\n        return sum(self.grades) / len(self.grades) if self.grades else 0.0\n```",
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\n@require_kwargs\ndef roman_to_integer(*, roman: str) -> int:\n    roman_values = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n\n    total = 0\n    prev_value = 0\n\n    for char in reversed(roman):\n        value = roman_values.get(char, 0)\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n\n    return total\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\n@require_kwargs\ndef roman_to_integer(s: str) -> int:\n    roman_numerals = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n\n    for char in reversed(s):\n        value = roman_numerals[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n\n    return total\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef c_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef c_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef d_merge_sort_x(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_half = array[:mid]\n        right_half = array[mid:]\n\n        d_merge_sort_x(left_half)\n        d_merge_sort_x(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                array[k] = left_half[i]\n                i += 1\n            else:\n                array[k] = right_half[j]\n                j += 1\n            k += 1\n        \n        while i < len(left_half):\n            array[k] = left_half[i]\n            i += 1\n            k += 1\n        \n        while j < len(right_half):\n            array[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\ndef d_compute_h_index_x(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\ndef d_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef a_compute_h_index(citations1):\n    citations1.sort(reverse=True)\n    h_index1 = 0\n    for i1, c1 in enumerate(citations1):\n        if c1 >= i1 + 1:\n            h_index1 = i1 + 1\n        else:\n            break\n    return h_index1\n```",
        "```python\nclass a_MeanCalculator:\n    def __init__(self):\n        self._count_1 = 0\n        self._mean_2 = 0.0\n\n    def a_add_number(self, n3):\n        self._count_1 += 1\n        self._mean_2 += (n3 - self._mean_2) / self._count_1\n\n    def a_get_mean(self):\n        return self._mean_2\n```"
      ],
      "instruction_model_output": [
        "```python\ndef a_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self._count0 = 0\n        self._mean0 = 0.0\n\n    def add1(self, value0):\n        self._count0 += 1\n        self._mean0 += (value0 - self._mean0) / self._count0\n    \n    def get_mean0(self):\n        return self._mean0\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef gn_compute_h_index_p(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.gn_adj_list = {}\n\n    def gn_add_edge_p(self, start, end, weight):\n        if start not in self.gn_adj_list:\n            self.gn_adj_list[start] = []\n        if end not in self.gn_adj_list:\n            self.gn_adj_list[end] = []\n        self.gn_adj_list[start].append((end, weight))\n        self.gn_adj_list[end].append((start, weight))\n\n    def gn_shortest_path_p(self, start, end):\n        distances = {node: float('inf') for node in self.gn_adj_list}\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.gn_adj_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances[end] if distances[end] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef gn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    Parameters:\n    num (int): The integer to be converted. Must be in the range 1 to 3999 inclusive.\n\n    Returns:\n    str: The Roman numeral representation of the given integer.\n    \"\"\"\n    # Define a lookup list of tuples containing integer values and their corresponding Roman numeral symbols.\n    value_map = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize a string to build the Roman numeral result.\n    roman = ''\n    \n    # Iterate through each value and symbol in the value map.\n    for value, symbol in value_map:\n        # Determine how many times the current symbol can fit into the remaining number.\n        while num >= value:\n            # Append the corresponding symbol to the result.\n            roman += symbol\n            # Decrease the number by the value that has been converted.\n            num -= value\n\n    return roman\n```"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n    \n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.nodes:\n            self.nodes[from_node] = []\n        if to_node not in self.nodes:\n            self.nodes[to_node] = []\n        self.nodes[from_node].append((to_node, weight))\n\n    def shortest_path_gn(self, start, goal):\n        queue = [(0, start)]\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start] = 0\n        previous_nodes = {node: None for node in self.nodes}\n        \n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n            \n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n        \n        path, current_node = [], goal\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.append(start)\n        return path[::-1]\n```",
        "```python\ndef merge_sort_gn(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\ndef sort_b(arr):\n    merge_sort_gn(arr)\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_b = {}\n\n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.nodes_b:\n            self.nodes_b[from_node] = []\n        if to_node not in self.nodes_b:\n            self.nodes_b[to_node] = []\n        self.nodes_b[from_node].append((to_node, weight))\n        self.nodes_b[to_node].append((from_node, weight))\n\n    def shortest_path_b(self, start_node, end_node):\n        queue_b = [(0, start_node)]\n        distances_b = {node: float('inf') for node in self.nodes_b}\n        distances_b[start_node] = 0\n        visited_b = set()\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n\n            if current_node_b in visited_b:\n                continue\n\n            visited_b.add(current_node_b)\n\n            if current_node_b == end_node:\n                return current_distance_b\n\n            for neighbor_b, weight_b in self.nodes_b[current_node_b]:\n                distance_b = current_distance_b + weight_b\n\n                if distance_b < distances_b[neighbor_b]:\n                    distances_b[neighbor_b] = distance_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_b))\n\n        return float('inf')\n```",
        "```python\ndef merge_sort_gn(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"\n        Initialize a TreeNode with the given key.\n        \n        :param key: The value of the node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"\n        Initialize an empty BinaryTree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Insert a new node with the given key into the binary tree.\n        \n        :param key: The value to be inserted into the tree.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n            print(f\"Inserted root node with key: {key}\")\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"\n        Helper function to recursively find the correct position for a new node.\n        \n        :param node: The current node being examined.\n        :param key: The value to be inserted into the tree.\n        \"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n                print(f\"Inserted left child {key} of node {node.val}\")\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n                print(f\"Inserted right child {key} of node {node.val}\")\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Delete a node with a given key from the binary tree.\n        \n        :param key: The value to be deleted from the tree.\n        \"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"\n        Helper function to recursively find and delete the node with the given key.\n        \n        :param node: The current node being examined.\n        :param key: The value to be deleted from the tree.\n        :return: The possibly changed reference to the current node.\n        \"\"\"\n        if node is None:\n            print(f\"Key {key} not found in the tree.\")\n            return node\n        \n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            print(f\"Deleting node with key: {key}\")\n            if node.left is None:\n                temp = node.right\n                node = None\n                return temp\n            elif node.right is None:\n                temp = node.left\n                node = None\n                return temp\n            \n            temp = self._min_value_node(node.right)\n            node.val = temp.val\n            node.right = self._delete(node.right, temp.val)\n\n        return node\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Get the node with the smallest value greater than the passed node.\n        \n        :param node: The current node being examined.\n        :return: The node with the smallest value.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        print(f\"Minimum value node found with key: {current.val}\")\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self, edges):\n        self.edges = edges\n        self.graph = self.build_graph_a(edges)\n    \n    def build_graph_a(self, edges):\n        graph = {}\n        for start, end, weight in edges:\n            if start not in graph:\n                graph[start] = []\n            graph[start].append((end, weight))\n        return graph\n    \n    def shortest_path_a(self, start, end):\n        min_heap = [(0, start)]\n        shortest_paths = {start: (None, 0)}\n        \n        while min_heap:\n            current_weight, current_node = heapq.heappop(min_heap)\n            \n            if current_node == end:\n                break\n            \n            if current_node in self.graph:\n                for neighbor, weight in self.graph[current_node]:\n                    total_weight = current_weight + weight\n                    \n                    if neighbor not in shortest_paths or total_weight < shortest_paths[neighbor][1]:\n                        shortest_paths[neighbor] = (current_node, total_weight)\n                        heapq.heappush(min_heap, (total_weight, neighbor))\n        \n        path, current_node = [], end\n        while current_node is not None:\n            path.append(current_node)\n            next_node = shortest_paths[current_node][0]\n            current_node = next_node\n        path = path[::-1]\n        \n        return path if path[0] == start else None\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        \n    def add_node_a(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        import heapq\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        visited = set()\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('infinity') else None\n```"
      ],
      "history_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.model_1 = Lasso(alpha=alpha)\n\n    def train_b_a(self, X_gn: np.ndarray, y_gn: np.ndarray) -> None:\n        \"\"\"\n        Train the Lasso regression model with the provided data.\n\n        :param X_gn: np.ndarray - The input features for training.\n        :param y_gn: np.ndarray - The target values for training.\n        :return: None\n        \"\"\"\n        assert X_gn.ndim == 2, \"Input features X must be a 2D array.\"\n        assert y_gn.ndim == 1, \"Target values y must be a 1D array.\"\n        try:\n            self.model_1.fit(X_gn, y_gn)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict_b_a(self, X_gn: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predict using the Lasso regression model.\n\n        :param X_gn: np.ndarray - The input features for prediction.\n        :return: np.ndarray - The predicted values.\n        \"\"\"\n        assert X_gn.ndim == 2, \"Input features X must be a 2D array.\"\n        try:\n            predictions_1 = self.model_1.predict(X_gn)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            predictions_1 = np.array([])\n        return predictions_1\n```\n",
        "```python\ndef gn_h_index_a(citations):\n    \"\"\"\n    Calculate the h-index given a list of citations using the latest coding guidelines from CODEME.\n    \n    :param citations: List[int] - A list of citation counts for each paper.\n    :return: int - The h-index calculated from the given citation counts.\n    \"\"\"\n    citations.sort(reverse=True)\n    h_index_1 = 0\n    for i_2, citation_3 in enumerate(citations):\n        if citation_3 >= i_2 + 1:\n            h_index_1 = i_2 + 1\n        else:\n            break\n    return h_index_1\n```\n",
        "```python\ndef gn_is_valid_bst_x(root) -> bool_a:\n    \"\"\"\n    Determine if a binary tree is a valid binary search tree.\n\n    Parameters:\n    root (TreeNode): The root of the binary tree.\n\n    Returns:\n    bool_a: True if the given binary tree is a valid BST, False otherwise.\n    \"\"\"\n    def helper(node, low=-float('inf'), high=float('inf')) -> bool_a:\n        if not node:\n            return True_a\n        \n        val = node.val\n        if val <= low or val >= high:\n            return False_a\n        \n        if not helper(node.right, val, high):\n            return False_a\n        if not helper(node.left, low, val):\n            return False_a\n        return True_a\n    \n    return helper(root)\n```",
        "```python\ndef gn_integer_to_roman_b(n: int) -> str:\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    Parameters:\n    n (int): The integer to convert to a Roman numeral.\n\n    Returns:\n    str: The Roman numeral representation of the integer.\n    \"\"\"\n    numerals_chx = {\n        1000: 'M', \n        900: 'CM', \n        500: 'D', \n        400: 'CD',\n        100: 'C', \n        90: 'XC', \n        50: 'L', \n        40: 'XL',\n        10: 'X', \n        9: 'IX', \n        5: 'V', \n        4: 'IV', \n        1: 'I'\n    }\n    result_1 = []\n    try:\n        assert 0 < n < 4000, \"Number must be between 1 and 3999.\"\n    except AssertionError as ae:\n        print(f\"AssertionError: {ae}\")\n        return \"\"\n\n    for value_2, numeral_3 in numerals_chx.items():\n        while n >= value_2:\n            result_1.append(numeral_3)\n            n -= value_2\n            assert n >= 0, \"The integer should not be negative.\"\n\n    return ''.join(result_1)\n```\n",
        "```python\nfrom typing import List\n\ndef gn_online_mean_a(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean of a list of numbers using an online algorithm.\n    \n    Parameters:\n    numbers (List[float]): A list of numbers to calculate the mean.\n    \n    Returns:\n    float: The mean of the list of numbers.\n    \"\"\"\n    total = 0.0\n    count = 0\n\n    for i, number in enumerate(numbers):\n        assert isinstance(number, (float, int)), \"All numbers must be float or int\"\n        count += 1\n        total += number\n        mean = total / count\n        print(f\"After processing {i+1} numbers: Current mean is {mean}\")\n\n    return mean\n```\n",
        "```python\ndef gn_compute_diagonal_average_a(matrix):\n    \"\"\"\n    Calculate the average of the diagonal elements of a matrix.\n\n    Parameters:\n    matrix (list of list of numbers): A square matrix.\n\n    Returns:\n    float: The average of the diagonal elements.\n    \"\"\"\n    try:\n        assert isinstance(matrix, list), \"Matrix must be a list.\"\n        assert all(isinstance(row, list) for row in matrix), \"Matrix rows must be lists.\"\n        num_rows_p = len(matrix)\n        assert all(len(row) == num_rows_p for row in matrix), \"Matrix must be square.\"\n\n        diagonal_elements_p = [matrix[i][i] for i in range(num_rows_p)]\n        diagonal_sum_chx = sum(diagonal_elements_p)\n        return diagonal_sum_chx / num_rows_p\n\n    except Exception as e:\n        print(f\"Error in gn_compute_diagonal_average_a: {e}\")\n        return None\n```\n",
        "```python\ndef gn_roman_to_integer_():\n    \"\"\"\n    Converts a Roman numeral string into an integer.\n    \n    This function takes a Roman numeral as input and returns its integer equivalent.\n\n    :param roman_numeral: str - Roman numeral string to convert\n    :return: int - Integer representation of the Roman numeral\n    \"\"\"\n    def chx_roman_to_int_single_(char):\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        return roman_dict.get(char, 0)\n\n    try:\n        gn_result_ = 0\n        prev_value = 0\n        for char in reversed(roman_numeral):\n            int_value = chx_roman_to_int_single_(char)\n            gn_result_ = gn_result_ - int_value if int_value < prev_value else gn_result_ + int_value\n            prev_value = int_value\n        return gn_result_\n    except Exception as e:\n        print(f\"Error converting Roman numeral: {e}\")\n```\n",
        "```python\nfrom pedantic import require_kwargs\nimport heapq\n\nclass Graph:\n    def __init__(self, nodes_a):\n        self.nodes3 = nodes_a\n        self.edges7 = {node0: {} for node0 in nodes_a}\n\n    def add_edge_b(self, from_node3, to_node2, weight5):\n        self.edges7[from_node3][to_node2] = weight5\n        self.edges7[to_node2][from_node3] = weight5\n\n    @require_kwargs\n    def compute_shortest_path_a(self, start_node0, end_node2):\n        assert start_node0 in self.nodes3 and end_node2 in self.nodes3, \"Nodes must exist in the graph.\"\n        \n        distances7 = {node0: float('inf') for node0 in self.nodes3}\n        distances7[start_node0] = 0\n        priority_queue4 = [(0, start_node0)]\n        visited_nodes = set()\n\n        while priority_queue4:\n            current_distance7, current_node1 = heapq.heappop(priority_queue4)\n\n            if current_node1 in visited_nodes:\n                continue\n\n            visited_nodes.add(current_node1)\n\n            if current_node1 == end_node2:\n                return current_distance7\n\n            for neighbor6, weight9 in self.edges7[current_node1].items():\n                distance3 = current_distance7 + weight9\n\n                if distance3 < distances7[neighbor6]:\n                    distances7[neighbor6] = distance3\n                    heapq.heappush(priority_queue4, (distance3, neighbor6))\n\n        return float('inf')\n```\n\n",
        "```python\ndef gn_merge_sort_a(arr1):\n    \"\"\"\n    Sorts an array using the merge sort algorithm.\n    \n    :param arr1: List of elements to be sorted\n    :return: Sorted list of elements\n    \"\"\"\n    assert isinstance(arr1, list), \"Input must be a list.\"\n\n    def gn_merge_a(left1, right1):\n        \"\"\"\n        Merges two halves of an array in sorted order.\n        \n        :param left1: Left half of the array\n        :param right1: Right half of the array\n        :return: Merged and sorted list\n        \"\"\"\n        merged1 = []\n        i1 = j1 = 0\n        while i1 < len(left1) and j1 < len(right1):\n            if left1[i1] < right1[j1]:\n                merged1.append(left1[i1])\n                i1 += 1\n            else:\n                merged1.append(right1[j1])\n                j1 += 1\n        merged1.extend(left1[i1:])\n        merged1.extend(right1[j1:])\n        return merged1\n\n    if len(arr1) <= 1:\n        return arr1\n\n    mid1 = len(arr1) // 2\n    left_half1 = gn_merge_sort_a(arr1[:mid1])\n    right_half1 = gn_merge_sort_a(arr1[mid1:])\n    \n    return gn_merge_a(left_half1, right_half1)\n```\n",
        "```python\nclass StudentGrade:\n    def __init__(self, name1, grades2):\n        \"\"\"\n        Initialize a StudentGrade instance.\n        \n        :param name1: The name of the student.\n        :param grades2: A list of grades associated with the student.\n        \"\"\"\n        self.name1 = name1\n        self.grades2 = grades2\n\n    def gn_compute_average_a(self):\n        \"\"\"\n        Compute the average grade for the student.\n\n        :return: The average grade as a float.\n        \"\"\"\n        try:\n            assert self.grades2, \"Grade list cannot be empty.\"\n            return sum(self.grades2) / len(self.grades2)\n        except Exception as e:\n            print(f\"An error occurred while computing the average: {e}\")\n            return None\n```\n",
        "```python\nclass TreeNode:\n    def __init__(self_a, key_a):\n        self_a.key1 = key_a\n        self_a.left1 = None\n        self_a.right1 = None\n\nclass BinaryTree:\n    def __init__(self_a):\n        self_a.root1 = None\n\n    def c_insert_chx_a(self_a, key_a):\n        if self_a.root1 is None:\n            self_a.root1 = TreeNode(key_a)\n        else:\n            self_a._insert_gn_a(self_a.root1, key_a)\n\n    def _insert_gn_a(self_a, node_a, key_a):\n        if key_a < node_a.key1:\n            if node_a.left1 is None:\n                node_a.left1 = TreeNode(key_a)\n            else:\n                self_a._insert_gn_a(node_a.left1, key_a)\n        else:\n            if node_a.right1 is None:\n                node_a.right1 = TreeNode(key_a)\n            else:\n                self_a._insert_gn_a(node_a.right1, key_a)\n\n    def c_delete_chx_a(self_a, key_a):\n        self_a.root1 = self_a._delete_gn_a(self_a.root1, key_a)\n    \n    def _delete_gn_a(self_a, node_a, key_a):\n        if node_a is None:\n            return node_a\n\n        if key_a < node_a.key1:\n            node_a.left1 = self_a._delete_gn_a(node_a.left1, key_a)\n        elif key_a > node_a.key1:\n            node_a.right1 = self_a._delete_gn_a(node_a.right1, key_a)\n        else:\n            if node_a.left1 is None:\n                return node_a.right1\n            elif node_a.right1 is None:\n                return node_a.left1\n            \n            node_a.key1 = self_a._min_value_node_p(node_a.right1)\n            node_a.right1 = self_a._delete_gn_a(node_a.right1, node_a.key1)\n        \n        return node_a\n\n    def _min_value_node_p(self_a, node_a):\n        current1 = node_a\n        while current1.left1 is not None:\n            current1 = current1.left1\n        return current1.key1\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self._heap_data1 = []\n\n    def insert_a(self, value1):\n        \"\"\"\n        Inserts a value1 into the heap.\n\n        :param value1: The value1 to insert.\n        \"\"\"\n        self._heap_data1.append(value1)\n        self._heapify_up_a(len(self._heap_data1) - 1)\n\n    def heapify_p(self, index1):\n        \"\"\"\n        Heapifies the subtree rooted at index1.\n\n        :param index1: The index1 to heapify from.\n        \"\"\"\n        assert index1 < len(self._heap_data1), \"Index1 out of bounds\"\n        largest1 = index1\n        left1 = 2 * index1 + 1\n        right1 = 2 * index1 + 2\n\n        if (left1 < len(self._heap_data1) \n            and self._heap_data1[left1] > self._heap_data1[largest1]):\n            largest1 = left1\n\n        if (right1 < len(self._heap_data1) \n            and self._heap_data1[right1] > self._heap_data1[largest1]):\n            largest1 = right1\n\n        if largest1 != index1:\n            self._heap_data1[index1], self._heap_data1[largest1] = (\n                self._heap_data1[largest1],\n                self._heap_data1[index1]\n            )\n            self.heapify_p(largest1)\n\n    def _heapify_up_a(self, index1):\n        \"\"\"\n        Moves the element at index1 up to restore heap property.\n\n        :param index1: The index1 of the element to move up.\n        \"\"\"\n        parent1 = (index1 - 1) // 2\n        if index1 > 0 and self._heap_data1[index1] > self._heap_data1[parent1]:\n            self._heap_data1[index1], self._heap_data1[parent1] = (\n                self._heap_data1[parent1],\n                self._heap_data1[index1]\n            )\n            self._heapify_up_a(parent1)\n```\n",
        "```python\ndef a_find_kth_largest_element_gn(nums_a1, k_a2):\n    \"\"\"\n    Find the k-th largest element in the given list.\n\n    :param nums_a1: List[int] - List of integers\n    :param k_a2: int - The 'k-th' position to determine the largest element\n    :return: int - The k-th largest element\n    \"\"\"\n    try:\n        assert isinstance(nums_a1, list) and all(isinstance(num_i3, int) for num_i3 in nums_a1), \"Invalid input: nums_a1 must be a list of integers\"\n        assert isinstance(k_a2, int) and 1 <= k_a2 <= len(nums_a1), \"Invalid input: k_a2 must be a valid integer within range\"\n\n        nums_a1.sort(reverse=True)\n        return nums_a1[k_a2 - 1]\n\n    except Exception as e_i4:\n        print(f\"An error occurred: {e_i4}\")\n```"
      ]
    }
  ]
}