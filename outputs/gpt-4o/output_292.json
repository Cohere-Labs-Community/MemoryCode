{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_compute_diagonal_average(matrix):\n    assert isinstance(matrix, list), \"Input must be a list\"\n    assert all(isinstance(row, list) for row in matrix), \"All elements of the matrix must be lists\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n    \n    n = len(matrix)\n    total = 0\n    for i in range(n):\n        total += matrix[i][i]\n    \n    return total / n\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.data = []\n\n    def chx_insert(self, value):\n        self.data.append(value)\n        self._chx_heapify_up(len(self.data) - 1)\n\n    def _chx_heapify_up(self, index):\n        assert 0 <= index < len(self.data), \"Index out of range\"\n        \n        parent_index = (index - 1) // 2\n        if index > 0 and self.data[index] > self.data[parent_index]:\n            self.data[index], self.data[parent_index] = self.data[parent_index], self.data[index]\n            self._chx_heapify_up(parent_index)\n\n    def chx_heapify(self):\n        n = len(self.data)\n        assert n >= 0, \"Data should have non-negative length\"\n\n        for i in range(n // 2 - 1, -1, -1):\n            self._chx_heapify_down(i)\n\n    def _chx_heapify_down(self, index):\n        assert 0 <= index < len(self.data), \"Index out of range\"\n        \n        largest = index\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        \n        if left_child_index < len(self.data) and self.data[left_child_index] > self.data[largest]:\n            largest = left_child_index\n\n        if right_child_index < len(self.data) and self.data[right_child_index] > self.data[largest]:\n            largest = right_child_index\n\n        if largest != index:\n            self.data[index], self.data[largest] = self.data[largest], self.data[index]\n            self._chx_heapify_down(largest)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert_chx(self, item):\n        self.heap.append(item)\n        self._heapify_up_chx(len(self.heap) - 1)\n\n    def _heapify_up_chx(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] > self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n            else:\n                break\n\n    def _heapify_down_chx(self, index):\n        last_index = len(self.heap) - 1\n        while True:\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            largest_index = index\n\n            if left_child_index <= last_index and self.heap[left_child_index] > self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index <= last_index and self.heap[right_child_index] > self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n            else:\n                self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n                index = largest_index\n\n    def extract_chx(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down_chx(0)\n        return root\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def ud_remove_stock(self, item_name, quantity):\n        if item_name in self.stock and self.stock[item_name] >= quantity:\n            self.stock[item_name] -= quantity\n            if self.stock[item_name] == 0:\n                del self.stock[item_name]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n    \n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n    \n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock to remove the requested quantity.\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n    \n    Args:\n    num (int): The integer to convert. Must be between 1 and 3999 inclusive.\n    \n    Returns:\n    str: The Roman numeral representation of the input integer.\n    \n    Assumptions:\n    - Input is a valid integer within the specified range.\n    \n    Considerations:\n    - Ensures each place value (thousands, hundreds, etc.) is correctly converted.\n    - Helps in understanding legacy systems using Roman numerals.\n    \"\"\"\n    # Define a map of integer to Roman numeral equivalents.\n    # Order is crucial: from largest to smallest for correct conversion.\n    val_to_roman = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n\n    # Start with an empty result string\n    roman_numeral = \"\"\n    \n    # Iterate over the values, constructing the numeral by the highest possible matches first\n    for value, roman in val_to_roman:\n        # Determine how many times the Roman numeral will fit into the remaining number\n        while num >= value:\n            # Append the corresponding numeral for each full fit\n            roman_numeral += roman\n            # Decrease the number by the equivalent integer value\n            num -= value\n\n    return roman_numeral\n```"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LongestPrefixFinder1:\n    \"\"\"\n    Class LongestPrefixFinder1 provides a method to find the longest common prefix string\n    among a list of strings.\n    \"\"\"\n\n    def longest_common_prefix(self, strs):\n        \"\"\"\n        Finds the longest common prefix string among a list of strings.\n\n        Args:\n            strs (list of str): A list of strings to evaluate.\n\n        Returns:\n            str: The longest common prefix amongst the input strings. If no common\n                 prefix is found, an empty string is returned.\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for string in strs[1:]:\n            while string[:len(prefix)] != prefix and prefix:\n                prefix = prefix[:len(prefix) - 1]\n            if not prefix:\n                break\n        return prefix\n```",
        "```python\nimport numpy as np\n\nclass PCA1:\n    \"\"\"\n    Principal Component Analysis (PCA) class for dimensionality reduction.\n\n    Methods\n    -------\n    fit(X):\n        Compute the principal components from the given data matrix X.\n        \n    transform(X):\n        Project the data onto the principal components.\n        \n    fit_transform(X):\n        Fit the model with X and apply the dimensionality reduction on X.\n    \"\"\"\n\n    def __init__(self, n_components):\n        \"\"\"\n        Initialize the PCA with the number of components to keep.\n\n        Parameters\n        ----------\n        n_components : int\n            Number of principal components to retain.\n        \"\"\"\n        self.n_components = n_components\n        self.components = None\n        self.mean = None\n\n    def fit(self, X):\n        \"\"\"\n        Fit the PCA model with X by computing the principal components.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data to compute principal components.\n        \"\"\"\n        self.mean = np.mean(X, axis=0)\n        X_centered = X - self.mean\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        self.components = eigenvectors[:, sorted_indices[:self.n_components]]\n\n    def transform(self, X):\n        \"\"\"\n        Apply the dimensionality reduction on X using the fitted PCA model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Data to project onto principal components.\n\n        Returns\n        -------\n        X_transformed : array-like, shape (n_samples, n_components)\n            Transformed data.\n        \"\"\"\n        X_centered = X - self.mean\n        return np.dot(X_centered, self.components)\n\n    def fit_transform(self, X):\n        \"\"\"\n        Fit the model with X and apply the dimensionality reduction on X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Data to fit the model and transform.\n\n        Returns\n        -------\n        X_transformed : array-like, shape (n_samples, n_components)\n            Reduced version of X after PCA transformation.\n        \"\"\"\n        self.fit(X)\n        return self.transform(X)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\nimport numpy as np\n\nclass PCA1:\n    def __init__(self, n_components):\n        self.n_components = n_components\n        self.mean_ = None\n        self.components_ = None\n        self.explained_variance_ = None\n        self.explained_variance_ratio_ = None\n\n    def fit(self, X):\n        self.mean_ = np.mean(X, axis=0)\n        X_centered = X - self.mean_\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        eigenvalues = eigenvalues[sorted_indices]\n        eigenvectors = eigenvectors[:, sorted_indices]\n        self.components_ = eigenvectors[:, :self.n_components]\n        self.explained_variance_ = eigenvalues[:self.n_components]\n        total_variance = eigenvalues.sum()\n        self.explained_variance_ratio_ = eigenvalues[:self.n_components] / total_variance\n\n    def transform(self, X):\n        X_centered = X - self.mean_\n        return np.dot(X_centered, self.components_)\n\n    def fit_transform(self, X):\n        self.fit(X)\n        return self.transform(X)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def n_add_stock(self, item_name, quantity):\n        if item_name in self.items:\n            self.items[item_name] += quantity\n        else:\n            self.items[item_name] = quantity\n\n    def n_remove_stock(self, item_name, quantity):\n        if item_name in self.items:\n            self.items[item_name] -= quantity\n            if self.items[item_name] <= 0:\n                del self.items[item_name]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def n_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def n_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock or item not available\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n        \n    def md_add_stock(self, item, quantity):\n        if item not in self.stock:\n            self.stock[item] = 0\n        self.stock[item] += quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, key):\n        \"\"\"Initialize a node with a key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def a_insert(self, key):\n        \"\"\"Insert a new node with the given key into the binary tree.\"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._a_insert_recursively(self.root, key)\n\n    def _a_insert_recursively(self, node, key):\n        \"\"\"Helper method to insert a new node starting at the given node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = Node(key)\n            else:\n                self._a_insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = Node(key)\n            else:\n                self._a_insert_recursively(node.right, key)\n\n    def a_delete(self, key):\n        \"\"\"Delete a node with the given key from the binary tree.\"\"\"\n        self.root = self._a_delete_recursively(self.root, key)\n\n    def _a_delete_recursively(self, node, key):\n        \"\"\"Helper method to delete a node starting at the given node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._a_delete_recursively(node.left, key)\n        elif key > node.val:\n            node.right = self._a_delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.val = self._a_min_value_node(node.right).val\n            node.right = self._a_delete_recursively(node.right, node.val)\n\n        return node\n\n    def a_min_value_node(self, node):\n        \"\"\"Helper method to find node with minimum value in a tree.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```\n",
        "```python\nclass Inventory:\n    \"\"\"\n    A class to manage inventory with methods to add and remove stock.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes an Inventory instance with an empty dictionary to hold inventory items.\n        \"\"\"\n        self.items = {}\n\n    def a_add_stock(self, item_name, quantity):\n        \"\"\"\n        Adds the specified quantity of an item to the inventory.\n\n        Parameters:\n        item_name (str): The name of the item to add.\n        quantity (int): The quantity of the item to add.\n        \"\"\"\n        if item_name in self.items:\n            self.items[item_name] += quantity\n        else:\n            self.items[item_name] = quantity\n\n    def a_remove_stock(self, item_name, quantity):\n        \"\"\"\n        Removes the specified quantity of an item from the inventory.\n\n        Parameters:\n        item_name (str): The name of the item to remove.\n        quantity (int): The quantity of the item to remove.\n\n        Raises:\n        ValueError: If the item does not exist or there is not enough stock to remove.\n        \"\"\"\n        if item_name not in self.items:\n            raise ValueError(\"Item not found in inventory.\")\n        if self.items[item_name] < quantity:\n            raise ValueError(\"Not enough stock to remove.\")\n        self.items[item_name] -= quantity\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n            return True\n        return False\n\n    def a_get_stock(self, item):\n        return self._stock.get(item, 0)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef count_nonzero_1elements(matrix):\n    return sum(1 for row in matrix for element in row if element != 0)\n```",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis3:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit7(self, X, y):\n        self.classes_ = np.unique(y)\n        self.means_ = np.array([X[y == c].mean(axis=0) for c in self.classes_])\n        self.covariances_ = [np.cov(X[y == c].T) for c in self.classes_]\n        self.priors_ = np.array([np.mean(y == c) for c in self.classes_])\n\n    def predict8(self, X):\n        predictions = [self._predict_one_instance6(x) for x in X]\n        return np.array(predictions)\n\n    def _predict_one_instance6(self, x):\n        discriminants = [self._compute_discriminant4(x, c_index) for c_index in range(len(self.classes_))]\n        return self.classes_[np.argmax(discriminants)]\n\n    def _compute_discriminant4(self, x, class_index):\n        mean = self.means_[class_index]\n        covariance = self.covariances_[class_index]\n        prior = self.priors_[class_index]\n        cov_inv = np.linalg.inv(covariance)\n        diff = x - mean\n\n        discriminant_value = -0.5 * np.dot(diff.T, np.dot(cov_inv, diff))\n        discriminant_value += -0.5 * np.log(np.linalg.det(covariance))\n        discriminant_value += np.log(prior)\n\n        return discriminant_value\n```"
      ],
      "instruction_model_output": [
        "```python\ndef c1ount_non_zero(matrix):\n    non_zero_c1ount = 0\n    for r1ow in matrix:\n        for e1lement in r1ow:\n            if e1lement != 0:\n                non_zero_c1ount += 1\n    return non_zero_c1ount\n```",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, value: int):\n        self.value: int = value\n        self.left: Optional['TreeNode'] = None\n        self.right: Optional['TreeNode'] = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[TreeNode] = None\n\n    def b_insert(self, value: int) -> None:\n        self.root = self._b_insert_recursive(self.root, value)\n\n    def _b_insert_recursive(self, node: Optional[TreeNode], value: int) -> TreeNode:\n        if node is None:\n            return TreeNode(value)\n        if value < node.value:\n            node.left = self._b_insert_recursive(node.left, value)\n        else:\n            node.right = self._b_insert_recursive(node.right, value)\n        return node\n\n    def b_delete(self, value: int) -> None:\n        self.root = self._b_delete_recursive(self.root, value)\n\n    def _b_delete_recursive(self, node: Optional[TreeNode], value: int) -> Optional[TreeNode]:\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self._b_delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._b_delete_recursive(node.right, value)\n        else:\n            if not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n            temp = self._b_find_min(node.right)\n            node.value = temp.value\n            node.right = self._b_delete_recursive(node.right, temp.value)\n        return node\n\n    def _b_find_min(self, node: TreeNode) -> TreeNode:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nfrom typing import Dict\n\nclass Inventory:\n    def __init__(self):\n        self.stock: Dict[str, int] = {}\n\n    def b_add_stock(self, item: str, quantity: int) -> None:\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def b_remove_stock(self, item: str, quantity: int) -> bool:\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def b_add_stock(self, item, quantity):\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        if item in self.items:\n            if self.items[item] >= quantity:\n                self.items[item] -= quantity\n                if self.items[item] == 0:\n                    del self.items[item]\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] -= quantity\n            if self._items[item_name] <= 0:\n                del self._items[item_name]\n\n    def _get_stock(self, item_name):\n        return self._items.get(item_name, 0)\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            if self.stock[item_name] >= quantity:\n                self.stock[item_name] -= quantity\n            else:\n                raise ValueError(\"Cannot remove more stock than available\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def x_add_stock(self, item_name, quantity):\n        assert isinstance(item_name, str), \"Item name must be a string.\"\n        assert isinstance(quantity, int) and quantity > 0, \"Quantity must be a positive integer.\"\n\n        if item_name in self.items:\n            self.items[item_name] += quantity\n        else:\n            self.items[item_name] = quantity\n\n    def x_remove_stock(self, item_name, quantity):\n        assert isinstance(item_name, str), \"Item name must be a string.\"\n        assert isinstance(quantity, int) and quantity > 0, \"Quantity must be a positive integer.\"\n        assert item_name in self.items, \"Item not found in inventory.\"\n        assert self.items[item_name] >= quantity, \"Not enough stock to remove.\"\n\n        self.items[item_name] -= quantity\n        if self.items[item_name] == 0:\n            del self.items[item_name]\n```\n",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        self.n_neighbors = n_neighbors\n        self.model = KNeighborsClassifier(n_neighbors=self.n_neighbors)\n\n    def x_train(self, X_train, y_train):\n        assert isinstance(X_train, np.ndarray), \"X_train must be a numpy array\"\n        assert isinstance(y_train, np.ndarray), \"y_train must be a numpy array\"\n        assert len(X_train) == len(y_train), \"X_train and y_train must have the same length\"\n        self.model.fit(X_train, y_train)\n\n    def x_predict(self, X_test):\n        assert isinstance(X_test, np.ndarray), \"X_test must be a numpy array\"\n        predictions = self.model.predict(X_test)\n        return predictions\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def x_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def x_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            if self._items[item_name] >= quantity:\n                self._items[item_name] -= quantity\n                if self._items[item_name] == 0:\n                    del self._items[item_name]\n            else:\n                raise ValueError(\"Quantity to remove exceeds current stock.\")\n        else:\n            raise KeyError(f\"Item '{item_name}' not found in inventory.\")\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef p_compute_dot_product(g_vector1, g_vector2):\n    return sum(x * y for x, y in zip(g_vector1, g_vector2))\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def p_add_stock(self, g_item, g_quantity):\n        if g_item in self.stock:\n            self.stock[g_item] += g_quantity\n        else:\n            self.stock[g_item] = g_quantity\n\n    def p_remove_stock(self, g_item, g_quantity):\n        if g_item in self.stock and self.stock[g_item] >= g_quantity:\n            self.stock[g_item] -= g_quantity\n            if self.stock[g_item] == 0:\n                del self.stock[g_item]\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(g_vector1, g_vector2):\n    return sum(a * b for a, b in zip(g_vector1, g_vector2))\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def p_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val: int, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_valid_bst_ud(root: Optional[TreeNode]) -> bool:\n    def validate_ud(node: Optional[TreeNode], low: float, high: float) -> bool:\n        if not node:\n            return True\n        val = node.val\n        if val <= low or val >= high:\n            return False\n        try:\n            if not validate_ud(node.right, val, high):\n                return False\n            if not validate_ud(node.left, low, val):\n                return False\n        except Exception as e:\n            print(f\"Error during BST validation: {e}\")\n            return False\n        return True\n    \n    return validate_ud(root, float('-inf'), float('inf'))\n```",
        "```python\nfrom typing import Dict, List, Tuple, Any\nimport heapq\n\nclass Graph:\n    def __init__(self_ud) -> None:\n        self_ud.edges: Dict[Any, List[Tuple[Any, int]]] = {}\n    \n    def add_edge_ud(self_ud, from_node: Any, to_node: Any, weight: int) -> None:\n        if from_node not in self_ud.edges:\n            self_ud.edges[from_node] = []\n        if to_node not in self_ud.edges:\n            self_ud.edges[to_node] = []\n        self_ud.edges[from_node].append((to_node, weight))\n        self_ud.edges[to_node].append((from_node, weight))\n    \n    def shortest_path_ud(self_ud, start: Any, end: Any) -> List[Any]:\n        try:\n            queue: List[Tuple[int, Any]] = [(0, start)]\n            distances: Dict[Any, int] = {start: 0}\n            previous_nodes: Dict[Any, Any] = {start: None}\n            visited: set = set()\n\n            while queue:\n                current_distance, current_node = heapq.heappop(queue)\n                if current_node in visited:\n                    continue\n                visited.add(current_node)\n                \n                if current_node == end:\n                    break\n                \n                for neighbor, weight in self_ud.edges.get(current_node, []):\n                    distance = current_distance + weight\n                    if distance < distances.get(neighbor, float('inf')):\n                        distances[neighbor] = distance\n                        previous_nodes[neighbor] = current_node\n                        heapq.heappush(queue, (distance, neighbor))\n            \n            path = []\n            current = end\n            while current is not None:\n                path.append(current)\n                current = previous_nodes.get(current)\n            path.reverse()\n\n            return path if path[0] == start else []\n        \n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return []\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_n(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_n(self, start, goal):\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n            \n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        \n        return distances[goal] if distances[goal] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(f_vector1, f_vector2):\n    return sum(f_v1 * f_v2 for f_v1, f_v2 in zip(f_vector1, f_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    if len(f_vector1) != len(f_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(f_vector1[i] * f_vector2[i] for i in range(len(f_vector1)))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product_p(i_vector1, i_vector2):\n    if len(i_vector1) != len(i_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(i_v1 * i_v2 for i_v1, i_v2 in zip(i_vector1, i_vector2))\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, i_start_node, i_end_node, i_weight):\n        if i_start_node not in self.adjacency_list:\n            self.adjacency_list[i_start_node] = []\n        self.adjacency_list[i_start_node].append((i_end_node, i_weight))\n\n    def shortest_path_p(self, i_start_node, i_end_node):\n        priority_queue = [(0, i_start_node)]\n        distances = {i_start_node: 0}\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_node in visited:\n                continue\n            visited.add(current_node)\n            \n            if current_node == i_end_node:\n                return current_distance\n            \n            for neighbor, weight in self.adjacency_list.get(current_node, []):\n                distance = current_distance + weight\n                \n                if neighbor not in distances or distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\ndef compute_dot_product(i_vector1, i_vector2):\n    if len(i_vector1) != len(i_vector2):\n        raise ValueError(\"Vectors must be of the same length.\")\n    return sum(i * j for i, j in zip(i_vector1, i_vector2))\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(e_vector1, e_vector2):\n    return sum(e_v1 * e_v2 for e_v1, e_v2 in zip(e_vector1, e_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(e_vector1, e_vector2):\n    if len(e_vector1) != len(e_vector2):\n        raise ValueError(\"Vectors must be the same length\")\n    return sum(e_v1 * e_v2 for e_v1, e_v2 in zip(e_vector1, e_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge(self, from_node, to_node, weight):\n        if from_node not in self.adjacency_list:\n            self.adjacency_list[from_node] = []\n        self.adjacency_list[from_node].append((to_node, weight))\n        \n    def compute_shortest_path_md(self, start_node, end_node):\n        min_heap = [(0, start_node)]\n        shortest_paths = {start_node: (None, 0)}\n        visited = set()\n        \n        while min_heap:\n            current_weight, current_node = heapq.heappop(min_heap)\n            \n            if current_node in visited:\n                continue\n            \n            visited.add(current_node)\n            \n            if current_node == end_node:\n                break\n            \n            for neighbor, weight in self.adjacency_list.get(current_node, []):\n                distance = current_weight + weight\n                if neighbor not in shortest_paths or distance < shortest_paths[neighbor][1]:\n                    shortest_paths[neighbor] = (current_node, distance)\n                    heapq.heappush(min_heap, (distance, neighbor))\n        \n        path, cost = [], end_node\n        while cost is not None:\n            path.append(cost)\n            cost = shortest_paths[cost][0]\n        \n        path = path[::-1]\n        \n        if path[0] == start_node:\n            return path\n        else:\n            return None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, x_value):\n        self.x_data_t = x_value\n        self.x_next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.x_head_t = None\n\n    def append(self, x_value):\n        new_node = Node(x_value)\n        if not self.x_head_t:\n            self.x_head_t = new_node\n        else:\n            current = self.x_head_t\n            while current.x_next_t:\n                current = current.x_next_t\n            current.x_next_t = new_node\n\n    def prepend(self, x_value):\n        new_node = Node(x_value)\n        new_node.x_next_t = self.x_head_t\n        self.x_head_t = new_node\n\n    def delete_value(self, x_value):\n        if not self.x_head_t:\n            return\n\n        if self.x_head_t.x_data_t == x_value:\n            self.x_head_t = self.x_head_t.x_next_t\n            return\n\n        current = self.x_head_t\n        while current.x_next_t:\n            if current.x_next_t.x_data_t == x_value:\n                current.x_next_t = current.x_next_t.x_next_t\n                return\n            current = current.x_next_t\n\n    def find(self, x_value):\n        current = self.x_head_t\n        while current:\n            if current.x_data_t == x_value:\n                return True\n            current = current.x_next_t\n        return False\n\n    def is_empty(self):\n        return self.x_head_t is None\n```",
        "```python\ndef is_valid_sudoku(x_board):\n    def is_unit_valid(x_unit):\n        x_unit_t = [x_cell for x_cell in x_unit if x_cell != '.']\n        return len(x_unit_t) == len(set(x_unit_t))\n    \n    for x_i in range(9):\n        x_row_t = [x_board[x_i][x_j] for x_j in range(9)]\n        x_col_t = [x_board[x_j][x_i] for x_j in range(9)]\n        if not is_unit_valid(x_row_t) or not is_unit_valid(x_col_t):\n            return False\n    \n    for x_i in range(0, 9, 3):\n        for x_j in range(0, 9, 3):\n            x_block_t = [x_board[x_i + x_m][x_j + x_n] for x_m in range(3) for x_n in range(3)]\n            if not is_unit_valid(x_block_t):\n                return False\n    \n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_t = data\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def append(self, data):\n        new_node_t = Node(data)\n        if self.head_t is None:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def prepend(self, data):\n        new_node_t = Node(data)\n        new_node_t.next_t = self.head_t\n        self.head_t = new_node_t\n\n    def delete_with_value(self, data):\n        if self.head_t is None:\n            return\n        if self.head_t.data_t == data:\n            self.head_t = self.head_t.next_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            if current_t.next_t.data_t == data:\n                current_t.next_t = current_t.next_t.next_t\n                return\n            current_t = current_t.next_t\n\n    def find(self, data):\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def clear(self):\n        self.head_t = None\n```",
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid(x_entries):\n        x_seen = set()\n        for x_num in x_entries:\n            if x_num != '.':\n                if x_num in x_seen:\n                    return False\n                x_seen.add(x_num)\n        return True\n\n    for x_row in x_board:\n        if not x_is_valid(x_row):\n            return False\n\n    for x_col_idx in range(9):\n        x_column = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n        if not x_is_valid(x_column):\n            return False\n\n    for x_box_row in range(0, 9, 3):\n        for x_box_col in range(0, 9, 3):\n            x_box = [x_board[x_row][x_col] for x_row in range(x_box_row, x_box_row + 3) for x_col in range(x_box_col, x_box_col + 3)]\n            if not x_is_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, s_data_at):\n        self.s_data_at = s_data_at\n        self.s_next_at = None\n\nclass LinkedList:\n    def __init__(self):\n        self.s_head_at = None\n\n    def insert_at_end(self, s_data_at):\n        new_node = Node(s_data_at)\n        if not self.s_head_at:\n            self.s_head_at = new_node\n        else:\n            current = self.s_head_at\n            while current.s_next_at:\n                current = current.s_next_at\n            current.s_next_at = new_node\n\n    def insert_at_beginning(self, s_data_at):\n        new_node = Node(s_data_at)\n        new_node.s_next_at = self.s_head_at\n        self.s_head_at = new_node\n\n    def delete_node(self, key):\n        current = self.s_head_at\n        if current and current.s_data_at == key:\n            self.s_head_at = current.s_next_at\n            current = None\n            return\n\n        prev = None\n        while current and current.s_data_at != key:\n            prev = current\n            current = current.s_next_at\n\n        if current is None:\n            return\n\n        prev.s_next_at = current.s_next_at\n        current = None\n\n    def find_node(self, key):\n        current = self.s_head_at\n        while current:\n            if current.s_data_at == key:\n                return current\n            current = current.s_next_at\n        return None\n\n    def display(self):\n        nodes = []\n        current = self.s_head_at\n        while current:\n            nodes.append(current.s_data_at)\n            current = current.s_next_at\n        return nodes\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, s_capacity_at: int):\n        self.s_capacity_at = s_capacity_at\n        self.s_cache_at = OrderedDict()\n\n    def get(self, s_key_at: int) -> int:\n        if s_key_at not in self.s_cache_at:\n            return -1\n        else:\n            self.s_cache_at.move_to_end(s_key_at)\n            return self.s_cache_at[s_key_at]\n\n    def put(self, s_key_at: int, s_value_at: int) -> None:\n        if s_key_at in self.s_cache_at:\n            self.s_cache_at.move_to_end(s_key_at)\n        self.s_cache_at[s_key_at] = s_value_at\n        if len(self.s_cache_at) > self.s_capacity_at:\n            self.s_cache_at.popitem(last=False)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value_at=None):\n        self.value_at = value_at\n        self.next_at = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def append(self, value_at):\n        new_node = Node(value_at)\n        if self.head_at is None:\n            self.head_at = new_node\n            return\n        last_node_at = self.head_at\n        while last_node_at.next_at:\n            last_node_at = last_node_at.next_at\n        last_node_at.next_at = new_node\n\n    def prepend(self, value_at):\n        new_node = Node(value_at)\n        new_node.next_at = self.head_at\n        self.head_at = new_node\n\n    def delete_value(self, value_at):\n        current_node_at = self.head_at\n        if current_node_at and current_node_at.value_at == value_at:\n            self.head_at = current_node_at.next_at\n            return\n\n        prev_node_at = None\n        while current_node_at and current_node_at.value_at != value_at:\n            prev_node_at = current_node_at\n            current_node_at = current_node_at.next_at\n\n        if current_node_at is None:\n            return\n\n        prev_node_at.next_at = current_node_at.next_at\n\n    def find(self, value_at):\n        current_node_at = self.head_at\n        while current_node_at:\n            if current_node_at.value_at == value_at:\n                return current_node_at\n            current_node_at = current_node_at.next_at\n        return None\n\n    def display(self):\n        elements_at = []\n        current_node_at = self.head_at\n        while current_node_at:\n            elements_at.append(current_node_at.value_at)\n            current_node_at = current_node_at.next_at\n        return elements_at\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = {}\n        self.s_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n            self.s_order.append(key)\n            return self.s_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_order.remove(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            oldest_key = self.s_order.pop(0)\n            del self.s_cache[oldest_key]\n        self.s_cache[key] = value\n        self.s_order.append(key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```\n"
      ],
      "cumulative_model_output": [
        "```python\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler\n\nclass Pca1:\n    \"\"\"\n    Principal Component Analysis (PCA) implementation.\n    \n    Attributes\n    ----------\n    e_n_components : int\n        Number of principal components to retain.\n    s_mean_at : np.ndarray\n        Mean values of each feature from the training data.\n    s_components_at : np.ndarray\n        Principal axes in feature space, representing the directions of max variance.\n    s_explained_variance_at : np.ndarray\n        Amount of variance explained by each of the selected components.\n    \"\"\"\n\n    def __init__(self, e_n_components: int) -> None_p:\n        \"\"\"\n        Initialize the PCA class with the number of components.\n\n        Parameters\n        ----------\n        e_n_components : int\n            Number of principal components to retain.\n        \"\"\"\n        self.e_n_components = e_n_components\n        self.s_mean_at = None\n        self.s_components_at = None\n        self.s_explained_variance_at = None\n\n    def _standardize_data_c(self, x_data: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Standardize the dataset by removing the mean and scaling to unit variance.\n\n        Parameters\n        ----------\n        x_data : np.ndarray\n            Input data to be standardized.\n\n        Returns\n        -------\n        std_data : np.ndarray\n            Standardized data.\n        \"\"\"\n        scaler = StandardScaler()\n        return scaler.fit_transform(x_data)\n\n    def fit_c(self, x_data: np.ndarray) -> None_p:\n        \"\"\"\n        Fit the model to X by computing the mean, components, and explained variance.\n\n        Parameters\n        ----------\n        x_data : np.ndarray\n            Training data matrix.\n        \"\"\"\n        assert x_data.ndim == 2, \"Input data must be a 2D array.\"\n\n        try:\n            x_standardized = self._standardize_data_c(x_data)\n            self.s_mean_at = np.mean(x_data, axis=0)\n\n            # Compute the covariance matrix\n            covariance_matrix = np.cov(x_standardized, rowvar=False)\n\n            # Eigen decomposition\n            eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n\n            # Sort the eigenvalues and eigenvectors in descending order\n            sorted_index = np.argsort(eigenvalues)[::-1]\n            sorted_eigenvalues = eigenvalues[sorted_index]\n            sorted_eigenvectors = eigenvectors[:, sorted_index]\n\n            # Select the top n_components\n            self.s_components_at = sorted_eigenvectors[:, :self.e_n_components]\n            self.s_explained_variance_at = sorted_eigenvalues[:self.e_n_components]\n        \n        except Exception as ex_p:\n            print(f\"An error occurred during fit: {str(ex_p)}\")\n\n    def transform_c(self, x_data: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Apply the dimensionality reduction on X.\n\n        Parameters\n        ----------\n        x_data : np.ndarray\n            New data matrix to be transformed to principal component space.\n\n        Returns\n        -------\n        transformed_data : np.ndarray\n            Transformed data in principal component space.\n        \"\"\"\n        assert self.s_components_at is not None, \"The PCA model has not been fitted yet.\"\n        try:\n            x_standardized = self._standardize_data_c(x_data)\n            return np.dot(x_standardized, self.s_components_at)\n        \n        except Exception as ex_p:\n            print(f\"An error occurred during transform: {str(ex_p)}\")\n            return None\n```",
        "```python\ndef count_non_zero_c(matrix_e):\n    \"\"\"\n    Count the number of non-zero elements in a given matrix.\n\n    :param matrix_e: List of lists representing the matrix\n    :return: Integer count of non-zero elements\n    \"\"\"\n    non_zero_count_p = 0\n\n    for row_e in matrix_e:\n        for element_e in row_e:\n            if element_e != 0:\n                non_zero_count_p += 1\n\n    return non_zero_count_p\n```",
        "```python\ndef integer_to_roman_c(g_num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param g_num: integer to be converted to Roman numeral\n    :type g_num: int\n    :return: Roman numeral as a string\n    :rtype: str\n    \"\"\"\n    assert isinstance(g_num, int), \"Input must be an integer.\"\n    assert 1 <= g_num <= 3999, \"Number must be between 1 and 3999.\"\n\n    int_to_roman_map_p = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n\n    roman_numeral_t = []\n    for value, symbol in int_to_roman_map_p:\n        while g_num >= value:\n            roman_numeral_t.append(symbol)\n            g_num -= value\n\n    return ''.join(roman_numeral_t) + '_n_ud'\n```",
        "```python\ndef is_valid_sudoku_c(e_board):\n    \"\"\"\n    Determines if a 9x9 Sudoku board is valid.\n    \n    A valid Sudoku board means no number repeats in any row, column, or 3x3 subgrid.\n    \n    :param e_board: List[List[str]] - a 9x9 grid representing the Sudoku board.\n    :return: bool - True if the Sudoku board is valid, False otherwise.\n    \"\"\"\n    def is_valid_unit_c(e_unit):\n        e_seen = set()\n        for e_num in e_unit:\n            if e_num != '.':\n                if e_num in e_seen:\n                    return False\n                e_seen.add(e_num)\n        return True\n\n    # Check rows\n    for e_row in e_board:\n        if not is_valid_unit_c(e_row):\n            return False\n    \n    # Check columns\n    for e_col in range(9):\n        e_column = [e_board[e_row][e_col] for e_row in range(9)]\n        if not is_valid_unit_c(e_column):\n            return False\n\n    # Check 3x3 subgrids\n    for e_row in range(0, 9, 3):\n        for e_col in range(0, 9, 3):\n            e_subgrid = [\n                e_board[e_r][e_c] \n                for e_r in range(e_row, e_row + 3) \n                for e_c in range(e_col, e_col + 3)\n            ]\n            if not is_valid_unit_c(e_subgrid):\n                return False\n\n    return True\n```\n",
        "```python\ndef merge_sort_c(g_arr):\n    \"\"\"\n    Sorts an array using the merge sort algorithm.\n\n    Parameters:\n    e_arr (list): A list of elements to be sorted.\n\n    Returns:\n    list: Sorted list.\n    \"\"\"\n    if len(g_arr) <= 1:\n        return g_arr\n\n    mid_e = len(g_arr) // 2\n    left_half_p = merge_sort_c(g_arr[:mid_e])\n    right_half_p = merge_sort_c(g_arr[mid_e:])\n\n    return merge_c(left_half_p, right_half_p)\n\ndef merge_c(left_half_p, right_half_p):\n    \"\"\"\n    Merges two halves of an array in sorted order.\n\n    Parameters:\n    left_half_p (list): The left half of the array.\n    right_half_p (list): The right half of the array.\n\n    Returns:\n    list: Merged and sorted list.\n    \"\"\"\n    merged_p = []\n    left_i, right_i = 0, 0\n\n    while left_i < len(left_half_p) and right_i < len(right_half_p):\n        if left_half_p[left_i] < right_half_p[right_i]:\n            merged_p.append(left_half_p[left_i])\n            left_i += 1\n        else:\n            merged_p.append(right_half_p[right_i])\n            right_i += 1\n\n    merged_p.extend(left_half_p[left_i:])\n    merged_p.extend(right_half_p[right_i:])\n\n    return merged_p\n```\n",
        "```python\nclass LRUChxCache_md:\n\n    def __init_p__(self, e_capacity):\n        self.s_cache_at = {}\n        self.s_capacity_at = e_capacity\n        self.s_order_at = []\n\n    def get_c(self, e_key):\n        p_assert e_key in self.s_cache_at, \"Key not found\"\n        self.s_order_at.remove(e_key)\n        self.s_order_at.append(e_key)\n        return self.s_cache_at[e_key]\n\n    def put_c(self, e_key, e_value):\n        p_assert isinstance(e_key, int), \"Key must be an integer\"\n        p_assert isinstance(e_value, int), \"Value must be an integer\"\n        \n        if e_key in self.s_cache_at:\n            self.s_order_at.remove(e_key)\n        elif len(self.s_cache_at) >= self.s_capacity_at:\n            lru_key = self.s_order_at.pop(0)\n            del self.s_cache_at[lru_key]\n\n        self.s_cache_at[e_key] = e_value\n        self.s_order_at.append(e_key)\n```\n",
        "```python\ndef dot_product_c(e_vector1, e_vector2) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    Args:\n        e_vector1: A list of numbers representing the first vector.\n        e_vector2: A list of numbers representing the second vector.\n\n    Returns:\n        The dot product of the two vectors as a float.\n\n    Raises:\n        ValueError: If the vectors are not the same length or not lists.\n    \"\"\"\n    assert isinstance(e_vector1, list), \"First argument should be a list\"\n    assert isinstance(e_vector2, list), \"Second argument should be a list\"\n    assert len(e_vector1) == len(e_vector2), \"Vectors must be of the same length\"\n\n    try:\n        return sum(x * y for x, y in zip(e_vector1, e_vector2))\n    except Exception as exc:\n        raise ValueError(\"An error occurred while computing the dot product\") from exc\n```",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass Heap1:\n    def __init__(self):\n        self.s_data_at = []\n\n    def i_insert_e(self, i_value_e) -> None:\n        self.s_data_at.append(i_value_e)\n        self._heapify_up_c(len(self.s_data_at) - 1)\n\n    def _heapify_up_c(self, i_index_e: int) -> None:\n        i_parent_index_e = (i_index_e - 1) // 2\n        if i_index_e > 0 and self.s_data_at[i_index_e] > self.s_data_at[i_parent_index_e]:\n            self.s_data_at[i_index_e], self.s_data_at[i_parent_index_e] = \\\n                self.s_data_at[i_parent_index_e], self.s_data_at[i_index_e]\n            self._heapify_up_c(i_parent_index_e)\n```\n",
        "```python\nfrom sklearn.base import BaseEstimator, ClassifierMixin\nfrom scipy import linalg\nimport numpy as np\nimport warnings\n\nclass QDA_1(BaseEstimator, ClassifierMixin):\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) Classifier.\n\n    This implementation assumes that the classes are normally distributed and\n    estimates a separate covariance matrix for each class.\n    \"\"\"\n\n    def __init__(self, reg_param=0.0, store_covariance=False, tol=1.0e-4):\n        \"\"\"\n        Initializes QDA with regularization parameter, covariance storage option, \n        and tolerance for singular matrices.\n\n        :param reg_param: Regularization parameter (0.0 for no regularization)\n        :param store_covariance: If True, stores the covariance matrices\n        :param tol: Tolerance for singular matrices\n        \"\"\"\n        self.e_reg_param = reg_param\n        self.e_store_covariance = store_covariance\n        self.e_tol = tol\n    \n    def fit_p(self, X, y):\n        \"\"\"\n        Fits the QDA model according to the given training data and labels.\n\n        :param X: Training data\n        :param y: Target labels\n        :return: self\n        \"\"\"\n        X, y = np.asarray(X), np.asarray(y)\n        self.classes_, y_indices = np.unique(y, return_inverse=True)\n        self.means_ = np.zeros((len(self.classes_), X.shape[1]))\n        self.covariances_ = []\n        self.priors_ = np.bincount(y_indices) / float(len(y))\n\n        for ind, k in enumerate(self.classes_):\n            Xg = X[y == k, :]\n            self.means_[ind] = Xg.mean(0)\n            cov_matrix = np.cov(Xg, rowvar=False)\n            if self.e_reg_param > 0:\n                cov_matrix += self.e_reg_param * np.eye(cov_matrix.shape[0])\n            self.covariances_.append(cov_matrix)\n\n        if self.e_store_covariance:\n            self.covariance_tiles_ = [np.tile(cov, (len(y), 1, 1)) for cov in self.covariances_]\n\n        return self\n    \n    def decision_function_p(self, X):\n        \"\"\"\n        Evaluates the decision function for the samples in X.\n\n        :param X: Samples for which to predict\n        :return: Predicted class labels\n        \"\"\"\n        log_priors = np.log(self.priors_)\n        results = []\n\n        for mean, cov in zip(self.means_, self.covariances_):\n            try:\n                inv_cov = linalg.inv(cov)\n            except linalg.LinAlgError as err:\n                if 'Singular matrix' in str(err):\n                    warnings.warn('Singular matrix encountered; adding regularization', UserWarning)\n                    inv_cov = linalg.inv(cov + self.e_tol * np.eye(len(cov)))\n                else:\n                    raise\n\n            diff = X - mean\n            results.append(-0.5 * np.sum(np.dot(diff, inv_cov) * diff, axis=1) + \n                           log_priors - 0.5 * np.log(linalg.det(cov)))\n\n        return np.array(results).T\n    \n    def predict_p(self, X):\n        \"\"\"\n        Predict class labels for samples in X.\n\n        :param X: Samples for which to predict\n        :return: Predicted class labels\n        \"\"\"\n        decisions = self.decision_function_p(X)\n        return self.classes_[np.argmax(decisions, axis=1)]\n```\n",
        "```python\nfrom typing import List, Tuple\nimport numpy as np\n\nclass NearestNeighbors3:\n    \n    @staticmethod\n    def _euclidean_distance_p(x: np.ndarray, y: np.ndarray) -> float:\n        \"\"\"\n        Calculate the Euclidean distance between two points.\n        \n        :param x: First point (array-like).\n        :param y: Second point (array-like).\n        :return: Euclidean distance.\n        \"\"\"\n        return np.sqrt(np.sum((x - y) ** 2))\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initialize the Nearest Neighbors model.\n        \"\"\"\n        self.x_train_at = None\n        self.y_train_at = None\n\n    def train_p(self, x_train: List[List[float]], y_train: List) -> None:\n        \"\"\"\n        Train the model using the training data.\n        \n        :param x_train: Training data features.\n        :param y_train: Training data labels.\n        \"\"\"\n        assert isinstance(x_train, list) and isinstance(y_train, list), \"Inputs must be of type List.\"\n        self.x_train_at = np.array(x_train)\n        self.y_train_at = np.array(y_train)\n\n    def predict_p(self, x_test: List[List[float]], k: int = 1) -> List:\n        \"\"\"\n        Predict the labels for test data.\n        \n        :param x_test: Test data features.\n        :param k: Number of neighbors to consider for prediction.\n        :return: Predicted labels for the test data.\n        \"\"\"\n        e_x_test = np.array(x_test)\n        predictions = []\n        \n        for e_test_instance in e_x_test:\n            distances_t = [self._euclidean_distance_p(e_test_instance, train_instance) for train_instance in self.x_train_at]\n            neighbors_t_indices = np.argsort(distances_t)[:k]\n            neighbors_t_labels = self.y_train_at[neighbors_t_indices]\n            unique_labels, counts = np.unique(neighbors_t_labels, return_counts=True)\n            predictions.append(unique_labels[np.argmax(counts)])\n        \n        return predictions\n```",
        "```python\ndef p_longest_common_prefix_c(e_strings):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n\n    :param e_strings: List of strings for which the longest common prefix is to be found.\n    :return: The longest common prefix string.\n    \"\"\"\n    assert isinstance(e_strings, list), \"Input must be a list.\"\n    if not e_strings:\n        return \"\"\n    \n    e_min_length_ud = min(len(e_s_ud) for e_s_ud in e_strings)\n    e_common_prefix_ud = \"\"\n    \n    for i_ud in range(e_min_length_ud):\n        e_current_char_ud = e_strings[0][i_ud]\n        for e_s_ud in e_strings:\n            if e_s_ud[i_ud] != e_current_char_ud:\n                return e_common_prefix_ud\n        e_common_prefix_ud += e_current_char_ud\n    \n    return e_common_prefix_ud\n```",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass Inventory7:\n    def __init__(self, e_initial_stock=0):\n        \"\"\"\n        Initializes the inventory with an initial stock quantity.\n        \n        :param e_initial_stock: int\n            The starting stock quantity.\n        \"\"\"\n        self.s_stocks_at = e_initial_stock\n\n    def add_stock_p(self, e_quantity):\n        \"\"\"\n        Adds a specified quantity of stock to the inventory.\n        \n        :param e_quantity: int\n            The quantity of stock to add.\n        \"\"\"\n        assert isinstance(e_quantity, int) and e_quantity > 0, \"Quantity to add must be a positive integer.\"\n        try:\n            self.s_stocks_at += e_quantity\n        except Exception as _ex:\n            print(\"Error occurred while adding stock.\")\n\n    def remove_stock_p(self, e_quantity):\n        \"\"\"\n        Removes a specified quantity of stock from the inventory.\n        \n        :param e_quantity: int\n            The quantity of stock to remove.\n        \"\"\"\n        assert isinstance(e_quantity, int) and e_quantity > 0, \"Quantity to remove must be a positive integer.\"\n        assert self.s_stocks_at >= e_quantity, \"Cannot remove more stock than is available.\"\n        try:\n            self.s_stocks_at -= e_quantity\n        except Exception as _ex:\n            print(\"Error occurred while removing stock.\")\n```",
        "```python\ndef calculateDiagonalAverage_c(matrix: list[list[float]]) -> float:\n    \"\"\"\n    Calculate the average of the diagonal elements of a square matrix.\n    \n    :param matrix: A square matrix represented as a list of lists.\n    :return: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list), \"e_matrix must be a list\"\n    try:\n        diagonal_elements_c = [matrix[i][i] for i in range(len(matrix))]\n        return sum(diagonal_elements_c) / len(diagonal_elements_c)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return float('nan')\n```\n",
        "```python\nfrom pedantic.decorators import timer_class\n\n@timer_class\nclass LinkedList_1:\n    class Node_1:\n        def __init__(self, e_data_at):\n            self.s_data_at = e_data_at\n            self.s_next_at = None\n\n    def __init__(self):\n        self.s_head_at = None\n\n    def p_insert_n(self, e_value_at):\n        new_node_1 = self.Node_1(e_value_at)\n        if not self.s_head_at:\n            self.s_head_at = new_node_1\n        else:\n            current_1 = self.s_head_at\n            while current_1.s_next_at:\n                current_1 = current_1.s_next_at\n            current_1.s_next_at = new_node_1\n\n    def p_delete_n(self, e_value_at):\n        current_1 = self.s_head_at\n        previous_1 = None\n        while current_1:\n            if current_1.s_data_at == e_value_at:\n                if not previous_1:\n                    self.s_head_at = current_1.s_next_at\n                else:\n                    previous_1.s_next_at = current_1.s_next_at\n                return True\n            previous_1 = current_1\n            current_1 = current_1.s_next_at\n        return False\n\n    def p_search_n(self, e_value_at):\n        current_1 = self.s_head_at\n        while current_1:\n            if current_1.s_data_at == e_value_at:\n                return True\n            current_1 = current_1.s_next_at\n        return False\n\n    def p_display_n(self):\n        current_1 = self.s_head_at\n        while current_1:\n            print(f'x_data: {current_1.s_data_at}')\n            current_1 = current_1.s_next_at\n```",
        "```python\nfrom collections import defaultdict, deque\n\nclass Graph1:\n    \"\"\"Graph1 class to represent a graph using adjacency lists.\"\"\"\n    \n    def __init__(self):\n        self.s_graph_at = defaultdict(list)\n    \n    def p_add_edge_p(self, e_start, e_end):\n        \"\"\"Adds a directed edge from e_start to e_end.\"\"\"\n        self.s_graph_at[e_start].append(e_end)\n    \n    def p_shortest_path_md(self, e_start, e_end):\n        \"\"\"\n        Computes the shortest path from e_start to e_end using BFS.\n        \n        This method uses the Breadth-First Search algorithm to find the shortest path\n        in terms of the number of edges. It assumes that all edges have equal weight.\n        \n        :param e_start: The starting node\n        :param e_end: The target node\n        :return: A list representing the shortest path from e_start to e_end\n        \"\"\"\n        assert isinstance(e_start, (int, str)), \"Start node must be an integer or string\"\n        assert isinstance(e_end, (int, str)), \"End node must be an integer or string\"\n        \n        if e_start == e_end:\n            return [e_start]\n        \n        queue_c = deque([(e_start, [e_start])])\n        visited_c = set()\n\n        while queue_c:\n            current_c, path_c = queue_c.popleft()\n            visited_c.add(current_c)\n\n            for neighbor_c in self.s_graph_at[current_c]:\n                if neighbor_c not in visited_c:\n                    if neighbor_c == e_end:\n                        return path_c + [neighbor_c]\n                    queue_c.append((neighbor_c, path_c + [neighbor_c]))\n                    visited_c.add(neighbor_c)\n\n        return []  # Return an empty list if no path exists\n```",
        "```python\ndef is_valid_bst_c(e_root, e_min=float('-inf'), e_max=float('inf'))_c:\n    \"\"\"\n    Determine if the given binary tree is a valid binary search tree.\n\n    :param e_root: TreeNode\n    :param e_min: Minimum allowed value for current subtree\n    :param e_max: Maximum allowed value for current subtree\n    :return: True if the tree is a valid BST, False otherwise\n    \"\"\"\n    try:\n        assert e_root is not None\n        \n        if not e_root:\n            return True_ud\n        \n        if not (e_min < e_root.val < e_max):\n            return False_ud\n        \n        return (is_valid_bst_c(e_root.left, e_min, e_root.val)_c and \n                is_valid_bst_c(e_root.right, e_root.val, e_max)_c)_ud\n        \n    except Exception as error_ud:\n        print(f\"An error occurred: {error_ud}\")\n        return False_ud\n```",
        "```python\nclass BinaryTree1:\n\n    class TreeNode1:\n        def __init__(self, e_value_at=None):\n            self.s_value_at = e_value_at\n            self.s_left_at = None\n            self.s_right_at = None\n\n    def __init__(self):\n        self.s_root_at = None\n\n    def insert_a_node_c(self, e_value_at):\n        if self.s_root_at is None:\n            self.s_root_at = self.TreeNode1(e_value_at)\n        else:\n            self._insert_helper_ud(self.s_root_at, e_value_at)\n\n    def _insert_helper_ud(self, node_p, e_value_at):\n        assert node_p is not None, \"The node_p should not be None\"\n        if e_value_at < node_p.s_value_at:\n            if node_p.s_left_at is None:\n                node_p.s_left_at = self.TreeNode1(e_value_at)\n            else:\n                self._insert_helper_ud(node_p.s_left_at, e_value_at)\n        else:\n            if node_p.s_right_at is None:\n                node_p.s_right_at = self.TreeNode1(e_value_at)\n            else:\n                self._insert_helper_ud(node_p.s_right_at, e_value_at)\n\n    def delete_a_node_c(self, e_value_at):\n        self.s_root_at = self._delete_helper_ud(self.s_root_at, e_value_at)\n\n    def _delete_helper_ud(self, node_p, e_value_at):\n        if node_p is None:\n            return node_p\n\n        if e_value_at < node_p.s_value_at:\n            node_p.s_left_at = self._delete_helper_ud(node_p.s_left_at, e_value_at)\n        elif e_value_at > node_p.s_value_at:\n            node_p.s_right_at = self._delete_helper_ud(node_p.s_right_at, e_value_at)\n        else:\n            if node_p.s_left_at is None:\n                return node_p.s_right_at\n            elif node_p.s_right_at is None:\n                return node_p.s_left_at\n            \n            temp_p = self._min_value_node_ud(node_p.s_right_at)\n            node_p.s_value_at = temp_p.s_value_at\n            node_p.s_right_at = self._delete_helper_ud(node_p.s_right_at, temp_p.s_value_at)\n        \n        return node_p\n\n    def _min_value_node_ud(self, node_p):\n        current_p = node_p\n        while current_p.s_left_at is not None:\n            current_p = current_p.s_left_at\n        return current_p\n```\n"
      ]
    }
  ]
}