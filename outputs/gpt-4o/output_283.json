{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n    \n    def b_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n    \n    def b_remove_stock(self, item_name, quantity):\n        if item_name in self._items and self._items[item_name] >= quantity:\n            self._items[item_name] -= quantity\n            if self._items[item_name] == 0:\n                del self._items[item_name]\n    \n    def get_stock(self, item_name):\n        return self._items.get(item_name, 0)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def b_add_stock(self, item, quantity):\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        if item in self.items:\n            if self.items[item] >= quantity:\n                self.items[item] -= quantity\n                if self.items[item] == 0:\n                    del self.items[item]\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self):\n        super(BinaryImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n        self.conv3 = nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, stride=1, padding=1)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n\n    def ud_forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2, 2)\n        x = F.relu(self.conv3(x))\n        x = F.max_pool2d(x, 2, 2)\n        x = x.view(-1, 64 * 8 * 8)\n        x = F.relu(self.fc1(x))\n        x = torch.sigmoid(self.fc2(x))\n        return x\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_addStock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_removeStock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self, num_channels):\n        super(BinaryImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(num_channels, 32, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)\n        self.fc1 = nn.Linear(64 * 8 * 8, 128)\n        self.fc2 = nn.Linear(128, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(x.size(0), -1)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        x = self.sigmoid(x)\n        return x\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n    \n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n    \n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock to remove the requested quantity.\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.w_stock = {}\n\n    def n_add_stock(self, w_item, w_quantity):\n        if w_item in self.w_stock:\n            self.w_stock[w_item] += w_quantity\n        else:\n            self.w_stock[w_item] = w_quantity\n\n    def n_remove_stock(self, w_item, w_quantity):\n        if w_item in self.w_stock:\n            self.w_stock[w_item] -= w_quantity\n            if self.w_stock[w_item] <= 0:\n                del self.w_stock[w_item]\n```\n",
        "```python\ndef n_is_valid_sudoku(w_board):\n    def n_has_duplicate(w_block):\n        w_seen = set()\n        for w_num in w_block:\n            if w_num != '.' and w_num in w_seen:\n                return True\n            w_seen.add(w_num)\n        return False\n\n    for w_row in w_board:\n        if n_has_duplicate(w_row):\n            return False\n\n    for w_col in zip(*w_board):\n        if n_has_duplicate(w_col):\n            return False\n\n    for w_box_row in range(0, 9, 3):\n        for w_box_col in range(0, 9, 3):\n            w_box = [\n                w_board[w_row][w_col]\n                for w_row in range(w_box_row, w_box_row + 3)\n                for w_col in range(w_box_col, w_box_col + 3)\n            ]\n            if n_has_duplicate(w_box):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def n_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def n_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock or item not available\")\n```",
        "```python\ndef is_valid_sudoku(w_board):\n    def is_valid_block(w_block):\n        w_nums = [num for num in w_block if num != '.']\n        return len(w_nums) == len(set(w_nums))\n    \n    for w_row in w_board:\n        if not is_valid_block(w_row):\n            return False\n    \n    for w_col in zip(*w_board):\n        if not is_valid_block(w_col):\n            return False\n    \n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_block = [w_board[w_x][w_y] for w_x in range(w_i, w_i + 3) for w_y in range(w_j, w_j + 3)]\n            if not is_valid_block(w_block):\n                return False\n    \n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix(strs):\n    \"\"\"\n    Finds the longest common prefix string amongst an array of strings.\n\n    :param strs: List of strings to evaluate.\n    :return: Longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Sort the list, the common prefix of the first and last element\n    # will be the common prefix for the entire array\n    strs.sort()\n    \n    # Compare the first and last strings character by character\n    first_str, last_str = strs[0], strs[-1]\n    lcp_length = min(len(first_str), len(last_str))\n    \n    for i in range(lcp_length):\n        if first_str[i] != last_str[i]:\n            return first_str[:i]\n    \n    return first_str[:lcp_length]\n```",
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: The integer to convert (should be between 1 and 3999)\n    :return: A string representing the Roman numeral\n    \"\"\"\n    # Define a list of tuples containing Roman numeral symbols and their values\n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n\n    # Initialize the Roman numeral result as an empty string\n    result = \"\"\n\n    # Iterate over the Roman numeral symbols and their values\n    for value, symbol in roman_numerals:\n        # Determine how many times the current symbol can fit into num\n        count = num // value\n\n        # Append the corresponding symbol to the result for each count\n        result += symbol * count\n\n        # Reduce num by the amount accounted for by the current symbol\n        num -= value * count\n\n    return result\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\n\nclass LassoChxRegression:\n    def __init__(self, alpha_chx=1.0, max_iter_chx=1000, tol_chx=1e-4):\n        self.alpha_chx = alpha_chx\n        self.max_iter_chx = max_iter_chx\n        self.tol_chx = tol_chx\n        self.coef_chx_ = None\n        self.intercept_chx_ = 0.0\n\n    def train(self, X_chx, y_chx):\n        try:\n            n_samples_chx, n_features_chx = X_chx.shape\n            self.coef_chx_ = np.zeros(n_features_chx)\n            \n            for iteration_chx in range(self.max_iter_chx):\n                y_pred_chx = np.dot(X_chx, self.coef_chx_) + self.intercept_chx_\n                residuals_chx = y_chx - y_pred_chx\n                gradient_chx = -(2 / n_samples_chx) * np.dot(X_chx.T, residuals_chx)\n                self.coef_chx_ -= self.alpha_chx * gradient_chx\n\n                if np.linalg.norm(gradient_chx, ord=1) < self.tol_chx:\n                    break\n        except Exception as e_chx:\n            print(f\"An error occurred during training: {e_chx}\")\n\n    def predict(self, X_chx):\n        try:\n            if self.coef_chx_ is None:\n                raise ValueError(\"Model has not been trained yet.\")\n            return np.dot(X_chx, self.coef_chx_) + self.intercept_chx_\n        except Exception as e_chx:\n            print(f\"An error occurred during prediction: {e_chx}\")\n            return None\n```",
        "```python\ndef chx_sum_of_unique(chx_numbers):\n    try:\n        chx_unique_numbers = set(chx_numbers)\n        chx_total_sum = sum(chx_unique_numbers)\n        return chx_total_sum\n    except Exception as chx_error:\n        print(f\"An error occurred: {chx_error}\")\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\ndef sum_chx_unique(chx_numbers):\n    unique_chx_numbers = list(set(chx_numbers))\n    chx_sum = sum(unique_chx_numbers)\n    return chx_sum\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    \"\"\"A class to represent a node in a binary tree.\"\"\"\n    \n    def __init__(self, key1):\n        \"\"\"Initialize a node with a key and set left and right children to None.\"\"\"\n        self.key1 = key1\n        self.left1 = None\n        self.right1 = None\n\nclass BinaryTree:\n    \"\"\"A class to represent the binary tree and perform operations on it.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize an empty root for the binary tree.\"\"\"\n        self.root1 = None\n\n    def insert_node1(self, key1):\n        \"\"\"Insert a new node with the specified key into the binary tree.\"\"\"\n        \n        def _insert(root1, key1):\n            \"\"\"Helper function to recursively insert a node in the binary tree.\"\"\"\n            if root1 is None:\n                return Node(key1)\n            if key1 < root1.key1:\n                root1.left1 = _insert(root1.left1, key1)\n            else:\n                root1.right1 = _insert(root1.right1, key1)\n            return root1\n        \n        self.root1 = _insert(self.root1, key1)\n\n    def delete_node1(self, key1):\n        \"\"\"Delete a node with the specified key from the binary tree.\"\"\"\n\n        def _min_value_node1(node1):\n            \"\"\"Helper function to find the node with the smallest key greater than the given node.\"\"\"\n            current_node1 = node1\n            while current_node1.left1 is not None:\n                current_node1 = current_node1.left1\n            return current_node1\n\n        def _delete(root1, key1):\n            \"\"\"Helper function to recursively delete a node in the binary tree.\"\"\"\n            if root1 is None:\n                return root1\n            if key1 < root1.key1:\n                root1.left1 = _delete(root1.left1, key1)\n            elif key1 > root1.key1:\n                root1.right1 = _delete(root1.right1, key1)\n            else:\n                if root1.left1 is None:\n                    return root1.right1\n                elif root1.right1 is None:\n                    return root1.left1\n                temp1 = _min_value_node1(root1.right1)\n                root1.key1 = temp1.key1\n                root1.right1 = _delete(root1.right1, temp1.key1)\n            return root1\n\n        self.root1 = _delete(self.root1, key1)\n```",
        "```python\nclass OnlineMeanCalculator:\n    \"\"\"\n    A class to compute the mean of numbers using an online algorithm.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the OnlineMeanCalculator with zero sums and count.\n        \"\"\"\n        self.sum1 = 0.0\n        self.count1 = 0\n\n    def add_number1(self, num1):\n        \"\"\"\n        Adds a number to the dataset and updates the mean.\n\n        Parameters\n        ----------\n        num1 : float\n            The number to be added to the dataset.\n        \"\"\"\n        self.count1 += 1\n        self.sum1 += num1\n\n    def current_mean1(self):\n        \"\"\"\n        Computes and returns the current mean of the dataset.\n\n        Returns\n        -------\n        float\n            The current mean of the numbers added so far.\n        \"\"\"\n        if self.count1 == 0:\n            return 0.0\n        return self.sum1 / self.count1\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self._count0 = 0\n        self._mean0 = 0.0\n\n    def add1(self, value0):\n        self._count0 += 1\n        self._mean0 += (value0 - self._mean0) / self._count0\n    \n    def get_mean0(self):\n        return self._mean0\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Inventory:\n    \n    def __init__(self):\n        self.stock = {}\n\n    @validate\n    def a_add_stock(self, item_name: str, quantity: int):\n        if quantity < 0:\n            raise ValueError(\"Quantity cannot be negative.\")\n        self.stock[item_name] = self.stock.get(item_name, 0) + quantity\n\n    @validate\n    def a_remove_stock(self, item_name: str, quantity: int):\n        if quantity < 0:\n            raise ValueError(\"Quantity cannot be negative.\")\n        if item_name not in self.stock:\n            raise ValueError(f\"Item '{item_name}' not found in inventory.\")\n        if self.stock[item_name] < quantity:\n            raise ValueError(f\"Not enough '{item_name}' in stock to remove {quantity}.\")\n        self.stock[item_name] -= quantity\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef a_int_to_roman(num: int) -> str:\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num = ''\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syms[i]\n            num -= val[i]\n        i += 1\n    return roman_num\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n            return True\n        return False\n\n    def a_get_stock(self, item):\n        return self._stock.get(item, 0)\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef int_to_roman(num: int) -> str:\n    if not (0 < num < 4000):\n        raise ValueError(\"Number must be between 1 and 3999\")\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num = ''\n    for i in range(len(val)):\n        while num >= val[i]:\n            roman_num += syms[i]\n            num -= val[i]\n    return roman_num\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List, Any, Tuple\nimport numpy as np\nfrom collections import Counter\n\nclass NearestNeighbors:\n    def __init__(self, n_neighbors: int = 5):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self.train_data = None\n        self.train_labels = None\n\n    def train(self, data: np.ndarray, labels: np.ndarray):\n        assert data.ndim == 2, \"data must be a 2-dimensional array\"\n        assert labels.ndim == 1, \"labels must be a 1-dimensional array\"\n        assert data.shape[0] == labels.shape[0], \"Number of samples and labels must match\"\n        self.train_data = data\n        self.train_labels = labels\n\n    def predict(self, test_data: np.ndarray) -> List[Any]:\n        assert self.train_data is not None and self.train_labels is not None, \"Model must be trained before prediction\"\n        assert test_data.ndim == 2, \"test_data must be a 2-dimensional array\"\n        predictions = [self._predict_single(sample) for sample in test_data]\n        return predictions\n\n    def _predict_single(self, sample: np.ndarray) -> Any:\n        assert sample.ndim == 1, \"Each sample in test_data must be a 1-dimensional array\"\n        distances = np.linalg.norm(self.train_data - sample, axis=1)\n        nearest_indices = np.argsort(distances)[:self.n_neighbors]\n        nearest_labels = self.train_labels[nearest_indices]\n        most_common_label = Counter(nearest_labels).most_common(1)[0][0]\n        return most_common_label\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef isValidSudoku(m_board):\n    def isValidBlock(m_block):\n        m_block = [m_num for m_num in m_block if m_num != '.']\n        return len(m_block) == len(set(m_block))\n\n    for m_row in m_board:\n        if not isValidBlock(m_row):\n            return False\n\n    for m_col in range(9):\n        if not isValidBlock([m_board[m_row][m_col] for m_row in range(9)]):\n            return False\n\n    for m_i in range(0, 9, 3):\n        for m_j in range(0, 9, 3):\n            m_block = [m_board[m_x][m_y] for m_x in range(m_i, m_i + 3) for m_y in range(m_j, m_j + 3)]\n            if not isValidBlock(m_block):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef m_is_valid_sudoku(m_board):\n    def m_is_valid_unit(m_unit):\n        m_unit = [m_num for m_num in m_unit if m_num != '.']\n        return len(m_unit) == len(set(m_unit))\n\n    def m_is_valid_row(m_board):\n        for m_row in m_board:\n            if not m_is_valid_unit(m_row):\n                return False\n        return True\n\n    def m_is_valid_col(m_board):\n        for m_col in zip(*m_board):\n            if not m_is_valid_unit(m_col):\n                return False\n        return True\n\n    def m_is_valid_box(m_board):\n        for m_i in (0, 3, 6):\n            for m_j in (0, 3, 6):\n                m_box = [m_board[m_x][m_y] for m_x in range(m_i, m_i + 3) for m_y in range(m_j, m_j + 3)]\n                if not m_is_valid_unit(m_box):\n                    return False\n        return True\n\n    return m_is_valid_row(m_board) and m_is_valid_col(m_board) and m_is_valid_box(m_board)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef p_is_valid_sudoku(n_board):\n    def p_is_valid_block(n_block):\n        n_block = [n for n in n_block if n != '.']\n        return len(n_block) == len(set(n_block))\n\n    for n_row in n_board:\n        if not p_is_valid_block(n_row):\n            return False\n\n    for n_col in zip(*n_board):\n        if not p_is_valid_block(n_col):\n            return False\n\n    for n_i in range(0, 9, 3):\n        for n_j in range(0, 9, 3):\n            n_block = [n_board[n_x][n_y] for n_x in range(n_i, n_i + 3) for n_y in range(n_j, n_j + 3)]\n            if not p_is_valid_block(n_block):\n                return False\n\n    return True\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.n_stock_items = {}\n\n    def p_add_stock(self, n_item_name, n_quantity):\n        if n_item_name in self.n_stock_items:\n            self.n_stock_items[n_item_name] += n_quantity\n        else:\n            self.n_stock_items[n_item_name] = n_quantity\n\n    def p_remove_stock(self, n_item_name, n_quantity):\n        if n_item_name in self.n_stock_items:\n            if self.n_stock_items[n_item_name] >= n_quantity:\n                self.n_stock_items[n_item_name] -= n_quantity\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "instruction_model_output": [
        "```python\ndef n_is_valid_sudoku(n_board):\n    def n_is_valid_block(n_block):\n        n_block = [n_num for n_num in n_block if n_num != '.']\n        return len(n_block) == len(set(n_block))\n    \n    for n_row in n_board:\n        if not n_is_valid_block(n_row):\n            return False\n    \n    for n_col_idx in range(9):\n        n_col = [n_board[n_row_idx][n_col_idx] for n_row_idx in range(9)]\n        if not n_is_valid_block(n_col):\n            return False\n    \n    for n_row_start in range(0, 9, 3):\n        for n_col_start in range(0, 9, 3):\n            n_block = [n_board[n_row][n_col] \n                       for n_row in range(n_row_start, n_row_start + 3) \n                       for n_col in range(n_col_start, n_col_start + 3)]\n            if not n_is_valid_block(n_block):\n                return False\n    \n    return True\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def p_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(h_vector1, h_vector2):\n    return sum(h_v1 * h_v2 for h_v1, h_v2 in zip(h_vector1, h_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(h_vector1, h_vector2):\n    if not isinstance(h_vector1, list) or not isinstance(h_vector2, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if len(h_vector1) != len(h_vector2):\n        raise ValueError(\"Both vectors must be of the same length.\")\n    \n    return sum(h_v1 * h_v2 for h_v1, h_v2 in zip(h_vector1, h_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\n\nclass PCA1:\n    def __init__(self, i_n_components):\n        self.n_components = i_n_components\n        self.mean = None\n        self.components = None\n        self.explained_variance = None\n\n    def fit(self, i_X):\n        # Mean center the data\n        self.mean = np.mean(i_X, axis=0)\n        X_centered = i_X - self.mean\n\n        # Compute covariance matrix\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n\n        # Compute eigenvalues and eigenvectors\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n\n        # Sort eigenvectors by decreasing eigenvalues\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        self.components = eigenvectors[:, sorted_indices][:, :self.n_components]\n        self.explained_variance = eigenvalues[sorted_indices][:self.n_components]\n\n    def transform(self, i_X):\n        # Project data onto principal components\n        X_centered = i_X - self.mean\n        return np.dot(X_centered, self.components)\n\n    def fit_transform(self, i_X):\n        self.fit(i_X)\n        return self.transform(i_X)\n```",
        "```python\nclass Vector2:\n    def __init__(self, i_vector_a, i_vector_b):\n        self.vector_a = i_vector_a\n        self.vector_b = i_vector_b\n\n    def calculate_dot_product(self):\n        return sum(i_a * i_b for i_a, i_b in zip(self.vector_a, self.vector_b))\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass PCA1:\n    def __init__(self, n_components):\n        self.n_components = n_components\n        self.mean_ = None\n        self.components_ = None\n        self.explained_variance_ = None\n        self.explained_variance_ratio_ = None\n\n    def fit(self, X):\n        self.mean_ = np.mean(X, axis=0)\n        X_centered = X - self.mean_\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        eigenvalues = eigenvalues[sorted_indices]\n        eigenvectors = eigenvectors[:, sorted_indices]\n        self.components_ = eigenvectors[:, :self.n_components]\n        self.explained_variance_ = eigenvalues[:self.n_components]\n        total_variance = eigenvalues.sum()\n        self.explained_variance_ratio_ = eigenvalues[:self.n_components] / total_variance\n\n    def transform(self, X):\n        X_centered = X - self.mean_\n        return np.dot(X_centered, self.components_)\n\n    def fit_transform(self, X):\n        self.fit(X)\n        return self.transform(X)\n```",
        "```python\ndef compute_dot_product(i_vector1, i_vector2):\n    if len(i_vector1) != len(i_vector2):\n        raise ValueError(\"Vectors must be of the same length.\")\n    return sum(i * j for i, j in zip(i_vector1, i_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: Optional['TreeNode'] = None\n        self.right: Optional['TreeNode'] = None\n        self.val: int = key\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: Optional[TreeNode] = None\n\n    def insert(self, key: int) -> None:\n        def _insert(node: Optional[TreeNode], key: int) -> TreeNode:\n            if node is None:\n                return TreeNode(key)\n            if key < node.val:\n                node.left = _insert(node.left, key)\n            else:\n                node.right = _insert(node.right, key)\n            return node\n\n        self.root = _insert(self.root, key)\n\n    def delete(self, key: int) -> None:\n        def _min_value_node(node: TreeNode) -> TreeNode:\n            current = node\n            while current.left is not None:\n                current = current.left\n            return current\n        \n        def _delete(node: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n            if node is None:\n                return node\n            if key < node.val:\n                node.left = _delete(node.left, key)\n            elif key > node.val:\n                node.right = _delete(node.right, key)\n            else:\n                if node.left is None:\n                    return node.right\n                elif node.right is None:\n                    return node.left\n                temp = _min_value_node(node.right)\n                node.val = temp.val\n                node.right = _delete(node.right, temp.val)\n            return node\n\n        self.root = _delete(self.root, key)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid_unit(x_unit):\n        x_values = [x for x in x_unit if x != '.']\n        return len(x_values) == len(set(x_values))\n\n    def x_check_rows(x_board):\n        for x_row in x_board:\n            if not x_is_valid_unit(x_row):\n                return False\n        return True\n\n    def x_check_columns(x_board):\n        for x_col_idx in range(9):\n            x_col = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n            if not x_is_valid_unit(x_col):\n                return False\n        return True\n\n    def x_check_sub_boxes(x_board):\n        for x_box_row in range(0, 9, 3):\n            for x_box_col in range(0, 9, 3):\n                x_box = [x_board[x_row][x_col] \n                         for x_row in range(x_box_row, x_box_row + 3) \n                         for x_col in range(x_box_col, x_box_col + 3)]\n                if not x_is_valid_unit(x_box):\n                    return False\n        return True\n\n    return x_check_rows(x_board) and x_check_columns(x_board) and x_check_sub_boxes(x_board)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid(x_entries):\n        x_seen = set()\n        for x_num in x_entries:\n            if x_num != '.':\n                if x_num in x_seen:\n                    return False\n                x_seen.add(x_num)\n        return True\n\n    for x_row in x_board:\n        if not x_is_valid(x_row):\n            return False\n\n    for x_col_idx in range(9):\n        x_column = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n        if not x_is_valid(x_column):\n            return False\n\n    for x_box_row in range(0, 9, 3):\n        for x_box_col in range(0, 9, 3):\n            x_box = [x_board[x_row][x_col] for x_row in range(x_box_row, x_box_row + 3) for x_col in range(x_box_col, x_box_col + 3)]\n            if not x_is_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.y_stock = {}\n\n    def md_add_stock(self, y_item, y_quantity):\n        if y_item in self.y_stock:\n            self.y_stock[y_item] += y_quantity\n        else:\n            self.y_stock[y_item] = y_quantity\n\n    def md_remove_stock(self, y_item, y_quantity):\n        if y_item in self.y_stock and self.y_stock[y_item] >= y_quantity:\n            self.y_stock[y_item] -= y_quantity\n            if self.y_stock[y_item] == 0:\n                del self.y_stock[y_item]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist.\")\n```",
        "```python\ndef md_is_valid_sudoku(y_board):\n    y_rows = [set() for _ in range(9)]\n    y_cols = [set() for _ in range(9)]\n    y_boxes = [set() for _ in range(9)]\n\n    for y_row in range(9):\n        for y_col in range(9):\n            y_num = y_board[y_row][y_col]\n            if y_num == '.':\n                continue\n\n            y_box_index = (y_row // 3) * 3 + y_col // 3\n\n            if (y_num in y_rows[y_row] or\n                    y_num in y_cols[y_col] or\n                    y_num in y_boxes[y_box_index]):\n                return False\n\n            y_rows[y_row].add(y_num)\n            y_cols[y_col].add(y_num)\n            y_boxes[y_box_index].add(y_num)\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n        \n    def md_add_stock(self, item, quantity):\n        if item not in self.stock:\n            self.stock[item] = 0\n        self.stock[item] += quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```",
        "```python\ndef y_is_valid_sudoku(y_board):\n    y_rows = len(y_board)\n    y_columns = len(y_board[0])\n    \n    if y_rows != 9 or y_columns != 9:\n        return False\n    \n    def y_is_valid_group(y_group):\n        y_elements = [num for num in y_group if num != '.']\n        return len(y_elements) == len(set(y_elements))\n    \n    for y_row in y_board:\n        if not y_is_valid_group(y_row):\n            return False\n    \n    for y_col in range(9):\n        y_column_numbers = [y_board[y_row][y_col] for y_row in range(9)]\n        if not y_is_valid_group(y_column_numbers):\n            return False\n    \n    for y_box_row in range(0, 9, 3):\n        for y_box_col in range(0, 9, 3):\n            y_box_numbers = [y_board[y_row][y_col] \n                             for y_row in range(y_box_row, y_box_row + 3) \n                             for y_col in range(y_box_col, y_box_col + 3)]\n            if not y_is_valid_group(y_box_numbers):\n                return False\n    \n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    @retry\n    def x_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    @retry\n    def x_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist.\")\n```\n",
        "```python\nfrom pedantic import retry\nfrom collections import Counter\n\n@retry\ndef x_majority_element(arr):\n    count = Counter(arr)\n    return max(count.keys(), key=count.get)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def x_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def x_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            if self._items[item_name] >= quantity:\n                self._items[item_name] -= quantity\n                if self._items[item_name] == 0:\n                    del self._items[item_name]\n            else:\n                raise ValueError(\"Quantity to remove exceeds current stock.\")\n        else:\n            raise KeyError(f\"Item '{item_name}' not found in inventory.\")\n```",
        "```python\nfrom pedantic import retry\nfrom collections import defaultdict\n\n@retry\ndef find_majority_element(nums):\n    count_dict = defaultdict(int)\n    majority_count = len(nums) // 2\n    \n    for num in nums:\n        count_dict[num] += 1\n        if count_dict[num] > majority_count:\n            return num\n\n    return None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def o_add_book(self, book_title: str) -> None:\n        if book_title not in self.books:\n            self.books.append(book_title)\n\n    @validate\n    def o_remove_book(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```",
        "```python\nfrom pedantic import validate\n\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    @validate\n    def o_add_stock(self, item: str, quantity: int) -> None:\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    @validate\n    def o_remove_stock(self, item: str, quantity: int) -> None:\n        if item in self.items and self.items[item] >= quantity:\n            self.items[item] -= quantity\n            if self.items[item] == 0:\n                del self.items[item]\n        else:\n            print(f\"Cannot remove {quantity} of {item}. Insufficient stock or item not found.\")\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_title: str) -> None:\n        self.books.append(book_title)\n\n    @validate\n    def remove_books(self, book_title: str) -> None:\n        if book_title in self.books:\n            self.books.remove(book_title)\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            if self.stock[item_name] >= quantity:\n                self.stock[item_name] -= quantity\n            else:\n                raise ValueError(\"Cannot remove more stock than available\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\nclass StudentGrade:\n    def __init__(self, j_name: str, j_grades: list):\n        self.j_name = j_name\n        self.j_grades = j_grades\n\n    @require_kwargs\n    def compute_average_grade(self, j_round_to: int = 2) -> float:\n        if not self.j_grades:\n            return 0.0\n        return round(sum(self.j_grades) / len(self.j_grades), j_round_to)\n```",
        "```python\nfrom pedantic import require_kwargs\n\n@require_kwargs\ndef calculate_dot_product(j_vector_a, j_vector_b):\n    if len(j_vector_a) != len(j_vector_b):\n        raise ValueError(\"Vectors must be of the same length.\")\n    return sum(j_a * j_b for j_a, j_b in zip(j_vector_a, j_vector_b))\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\nclass StudentGrade:\n    def __init__(self, **kwargs):\n        self.grades = kwargs.get('grades', [])\n\n    @require_kwargs\n    def add_grade(self, grade: float) -> None:\n        self.grades.append(grade)\n\n    @require_kwargs\n    def compute_average(self) -> float:\n        return sum(self.grades) / len(self.grades) if self.grades else 0.0\n```",
        "```python\ndef compute_dot_product(j_vector1, j_vector2):\n    if len(j_vector1) != len(j_vector2):\n        raise ValueError(\"Vectors must be of the same length.\")\n    return sum(j_v1 * j_v2 for j_v1, j_v2 in zip(j_vector1, j_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef get_kth_largest(arr: List[int], k: int) -> int:\n    \"\"\"\n    Returns the k-th largest element in an array.\n    \n    Parameters:\n    arr (List[int]): The input array of integers.\n    k (int): The position (1-based) of the largest element to find.\n    \n    Returns:\n    int: The k-th largest element.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        raise ValueError(\"k is out of bounds\")\n    \n    wr_sorted_arr = sorted(arr, reverse=True)\n    \n    return wr_sorted_arr[k-1]\n```\n",
        "```python\nfrom typing import List\n\ndef wr_is_valid_sudoku(wr_board: List[List[str]]) -> bool:\n    def wr_is_valid_block(wr_block: List[str]) -> bool:\n        wr_clean_block = [n for n in wr_block if n != '.']\n        return len(wr_clean_block) == len(set(wr_clean_block))\n    \n    for wr_row in wr_board:\n        if not wr_is_valid_block(wr_row):\n            return False\n\n    for wr_col_idx in range(9):\n        wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n        if not wr_is_valid_block(wr_column):\n            return False\n\n    for wr_row_block in range(0, 9, 3):\n        for wr_col_block in range(0, 9, 3):\n            wr_square = [\n                wr_board[wr_row][wr_col]\n                for wr_row in range(wr_row_block, wr_row_block + 3)\n                for wr_col in range(wr_col_block, wr_col_block + 3)\n            ]\n            if not wr_is_valid_block(wr_square):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```",
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    def wr_check_rows(wr_board):\n        return all(wr_is_valid_block(wr_row) for wr_row in wr_board)\n\n    def wr_check_columns(wr_board):\n        for wr_col_idx in range(9):\n            wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n            if not wr_is_valid_block(wr_column):\n                return False\n        return True\n\n    def wr_check_sub_boxes(wr_board):\n        for wr_box_row in range(0, 9, 3):\n            for wr_box_col in range(0, 9, 3):\n                wr_box = [wr_board[wr_row][wr_col]\n                          for wr_row in range(wr_box_row, wr_box_row + 3)\n                          for wr_col in range(wr_box_col, wr_box_col + 3)]\n                if not wr_is_valid_block(wr_box):\n                    return False\n        return True\n\n    return wr_check_rows(wr_board) and wr_check_columns(wr_board) and wr_check_sub_boxes(wr_board)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(e_vector1, e_vector2):\n    return sum(e_v1 * e_v2 for e_v1, e_v2 in zip(e_vector1, e_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(e_vector1, e_vector2):\n    if len(e_vector1) != len(e_vector2):\n        raise ValueError(\"Vectors must be the same length\")\n    return sum(e_v1 * e_v2 for e_v1, e_v2 in zip(e_vector1, e_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(f_vector1, f_vector2):\n    return sum(f_v1 * f_v2 for f_v1, f_v2 in zip(f_vector1, f_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    if len(f_vector1) != len(f_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(f_vector1[i] * f_vector2[i] for i in range(len(f_vector1)))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(chx_board):\n    def is_valid_block(vr_block):\n        vr_elements = [el for el in vr_block if el != '.']\n        return len(vr_elements) == len(set(vr_elements))\n    \n    for vr_row in chx_board:\n        if not is_valid_block(vr_row):\n            return False\n    \n    for vr_col_idx in range(9):\n        vr_col = [chx_board[vr_row_idx][vr_col_idx] for vr_row_idx in range(9)]\n        if not is_valid_block(vr_col):\n            return False\n\n    for vr_box_row in range(0, 9, 3):\n        for vr_box_col in range(0, 9, 3):\n            vr_box = []\n            for vr_row in range(vr_box_row, vr_box_row + 3):\n                for vr_col in range(vr_box_col, vr_box_col + 3):\n                    vr_box.append(chx_board[vr_row][vr_col])\n            if not is_valid_block(vr_box):\n                return False\n\n    return True\n```",
        "```python\ndef compute_dot_product(chx_vec1, chx_vec2):\n    vr_dot_product = sum(vr_a * vr_b for vr_a, vr_b in zip(chx_vec1, chx_vec2))\n    return vr_dot_product\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```",
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    if len(chx_vector1) != len(chx_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef z_is_valid_sudoku(z_board):\n    def z_is_valid_block(z_block):\n        z_block = [num for num in z_block if num != '.']\n        return len(z_block) == len(set(z_block))\n\n    # Check rows\n    for z_row in z_board:\n        if not z_is_valid_block(z_row):\n            return False\n\n    # Check columns\n    for z_col_index in range(9):\n        z_col = [z_board[z_row_index][z_col_index] for z_row_index in range(9)]\n        if not z_is_valid_block(z_col):\n            return False\n\n    # Check 3x3 blocks\n    for z_block_row in range(0, 9, 3):\n        for z_block_col in range(0, 9, 3):\n            z_block = [z_board[z_row][z_col] \n                       for z_row in range(z_block_row, z_block_row + 3) \n                       for z_col in range(z_block_col, z_block_col + 3)]\n            if not z_is_valid_block(z_block):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef z_is_valid_sudoku(z_board):\n    def z_is_valid_block(z_block):\n        z_non_empty_values = [z_num for z_num in z_block if z_num != '.']\n        return len(z_non_empty_values) == len(set(z_non_empty_values))\n    \n    for z_row in z_board:\n        if not z_is_valid_block(z_row):\n            return False\n    \n    for z_col_index in range(9):\n        z_column = [z_board[z_row_index][z_col_index] for z_row_index in range(9)]\n        if not z_is_valid_block(z_column):\n            return False\n    \n    for z_box_row in range(3):\n        for z_box_col in range(3):\n            z_sub_box = [\n                z_board[z_row][z_col]\n                for z_row in range(z_box_row * 3, (z_box_row + 1) * 3)\n                for z_col in range(z_box_col * 3, (z_box_col + 1) * 3)\n            ]\n            if not z_is_valid_block(z_sub_box):\n                return False\n    \n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import count_calls\nfrom collections import defaultdict\n\n@count_calls\ndef majority_element(array):\n    counts = defaultdict(int)\n    for num in array:\n        counts[num] += 1\n        if counts[num] > len(array) // 2:\n            return num\n    return None\n```",
        "```python\nfrom sklearn.base import BaseEstimator, RegressorMixin\nfrom sklearn.metrics.pairwise import pairwise_kernels\nimport numpy as np\nfrom pedantic import count_calls, trace_class\n\n@trace_class\nclass KernelRidgeRegression(BaseEstimator, RegressorMixin):\n    def __init__(self, alpha=1.0, kernel=\"linear\", gamma=None, coef0=1, degree=3):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.coef0 = coef0\n        self.degree = degree\n\n    @count_calls\n    def fit(self, X, y):\n        self.X_fit_ = X\n        K = pairwise_kernels(X, metric=self.kernel, gamma=self.gamma, coef0=self.coef0, degree=self.degree)\n        n_samples = K.shape[0]\n        self.dual_coef_ = np.linalg.solve(K + self.alpha * np.eye(n_samples), y)\n        return self\n\n    @count_calls\n    def predict(self, X):\n        K = pairwise_kernels(X, self.X_fit_, metric=self.kernel, gamma=self.gamma, coef0=self.coef0, degree=self.degree)\n        return K @ self.dual_coef_\n```\n"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import count_calls\n\n@count_calls\ndef majority_element(nums):\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    majority = len(nums) // 2\n    for num, cnt in count.items():\n        if cnt > majority:\n            return num\n```",
        "```python\nfrom pedantic import trace_class\nimport numpy as np\n\n@trace_class\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', gamma=None, degree=3, coef0=1):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n        self.X_train = None\n        self.alpha_ = None\n    \n    def _linear_kernel(self, X, Y):\n        return np.dot(X, Y.T)\n\n    def _polynomial_kernel(self, X, Y):\n        return (np.dot(X, Y.T) + self.coef0) ** self.degree\n\n    def _rbf_kernel(self, X, Y):\n        if self.gamma is None:\n            self.gamma = 1.0 / X.shape[1]\n        K = np.sum(X ** 2, axis=1).reshape(-1, 1) + np.sum(Y ** 2, axis=1) - 2 * np.dot(X, Y.T)\n        return np.exp(-self.gamma * K)\n\n    def _get_kernel(self, X, Y):\n        if self.kernel == 'linear':\n            return self._linear_kernel(X, Y)\n        elif self.kernel == 'polynomial':\n            return self._polynomial_kernel(X, Y)\n        elif self.kernel == 'rbf':\n            return self._rbf_kernel(X, Y)\n        else:\n            raise ValueError(\"Unknown kernel type\")\n\n    def fit(self, X, y):\n        self.X_train = X\n        K = self._get_kernel(X, X)\n        n_samples = X.shape[0]\n        self.alpha_ = np.linalg.solve(K + self.alpha * np.eye(n_samples), y)\n\n    def predict(self, X):\n        K = self._get_kernel(X, self.X_train)\n        return np.dot(K, self.alpha_)\n\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef b_dot_product(x_vector1, x_vector2):\n    return sum(x_v1 * x_v2 for x_v1, x_v2 in zip(x_vector1, x_vector2))\n```",
        "```python\ndef b_h_index(x_citations):\n    x_citations.sort(reverse=True)\n    x_h_index = 0\n\n    for x_i, x_citation in enumerate(x_citations):\n        if x_citation >= x_i + 1:\n            x_h_index = x_i + 1\n        else:\n            break\n\n    return x_h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(x_vector1, x_vector2):\n    if len(x_vector1) != len(x_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(x_v1 * x_v2 for x_v1, x_v2 in zip(x_vector1, x_vector2))\n```",
        "```python\ndef b_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "cumulative_model_output": [
        "```python\nfrom typing import List\nfrom pedantic import validate\n\n@validate\ndef b_is_valid_sudoku(x_board: List[List[str]]) -> bool:\n    def is_valid_block(e_block: List[str]) -> bool:\n        e_nums = [num for num in e_block if num != '.']\n        return len(e_nums) == len(set(e_nums))\n    \n    for i in range(9):\n        row = x_board[i]\n        column = [x_board[j][i] for j in range(9)]\n        block = [x_board[m][n] for m in range(i//3*3, i//3*3+3) for n in range(i%3*3, i%3*3+3)]\n        \n        if not (is_valid_block(row) and is_valid_block(column) and is_valid_block(block)):\n            return False\n    return True\n```\n",
        "```python\ndef b_longest_common_prefix(x_strs):\n    if not x_strs:\n        return \"\"\n    \n    b_prefix = x_strs[0]\n    for x_str in x_strs[1:]:\n        while x_str.find(b_prefix) != 0:\n            b_prefix = b_prefix[0:len(b_prefix)-1]\n            if not b_prefix:\n                return \"\"\n    return b_prefix\n```",
        "```python\nfrom sklearn.metrics.pairwise import pairwise_kernels\nimport numpy as np\n\nclass b_KernelRidge:\n    \n    def __init__(x_self, x_alpha=1.0, x_kernel='linear', **x_kwargs):\n        x_self.x_alpha = x_alpha\n        x_self.x_kernel = x_kernel\n        x_self.x_kwargs = x_kwargs\n        x_self.x_dual_coef = None\n        x_self.x_X_fit_ = None\n\n    def b_fit(x_self, x_X, x_y):\n        K = pairwise_kernels(x_X, metric=x_self.x_kernel, **x_self.x_kwargs)\n        n_samples = K.shape[0]\n        K.flat[::n_samples + 1] += x_self.x_alpha\n        x_self.x_dual_coef = np.linalg.solve(K, x_y)\n        x_self.x_X_fit_ = x_X\n\n    def b_predict(x_self, x_X):\n        K = pairwise_kernels(x_X, x_self.x_X_fit_, metric=x_self.x_kernel, **x_self.x_kwargs)\n        return K.dot(x_self.x_dual_coef)\n```\n",
        "```python\nfrom pedantic import validate\n\n@validate\ndef b_find_majority_element(x_arr):\n    \"\"\"Function to find the majority element in an array.\"\"\"\n    n_count = {}\n    for x_num in x_arr:\n        if x_num in n_count:\n            n_count[x_num] += 1\n        else:\n            n_count[x_num] = 1\n    \n    x_majority_count = len(x_arr) // 2\n    for x_num, x_freq in n_count.items():\n        if x_freq > x_majority_count:\n            return x_num\n    return None\n```\n",
        "```python\nfrom pedantic import validate\nfrom typing import List\n\n@validate\ndef b_compute_dot_product(x_vector1: List[float], x_vector2: List[float]) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    :param x_vector1: A list of floats representing the first vector.\n    :param x_vector2: A list of floats representing the second vector.\n    :return: The dot product of the two vectors as a float.\n    \"\"\"\n    assert len(x_vector1) == len(x_vector2), \"Vectors must be of the same length.\"\n\n    x_result = sum(x_v1 * x_v2 for x_v1, x_v2 in zip(x_vector1, x_vector2))\n    return x_result\n```",
        "```python\nfrom sklearn.linear_model import Lasso\nfrom pedantic.decorators import validate\nimport numpy as np\n\nclass b_LassoRegression:\n    def __init__(x_alpha=1.0):\n        self.model = Lasso(alpha=x_alpha)\n\n    @validate\n    def b_train(x_X_train, x_y_train):\n        self.model.fit(x_X_train, x_y_train)\n\n    @validate\n    def b_predict(x_X_test):\n        return self.model.predict(x_X_test)\n```\n",
        "```python\ndef b_compute_h_index(x_citations):\n    \"\"\"\n    Compute the h-index for a given list of integer citations.\n\n    :param x_citations: List of integers representing citation counts\n    :return: Integer h-index\n    \"\"\"\n    x_citations.sort(reverse=True)\n    h_index = 0\n    for x_i, x_citation in enumerate(x_citations, start=1):\n        if x_citation >= x_i:\n            h_index = x_i\n        else:\n            break\n    return h_index\n```",
        "```python\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass b_BinaryImageClassifier(nn.Module):\n    def __init__(self):\n        super(b_BinaryImageClassifier, self).__init__()\n        self.b_conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, stride=1, padding=1)\n        self.b_conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n        self.b_fc1 = nn.Linear(32 * 8 * 8, 128)\n        self.b_fc2 = nn.Linear(128, 1)\n\n    def b_forward(self, x_input):\n        x_input = F.relu(self.b_conv1(x_input))\n        x_input = F.max_pool2d(x_input, kernel_size=2, stride=2)\n        x_input = F.relu(self.b_conv2(x_input))\n        x_input = F.max_pool2d(x_input, kernel_size=2, stride=2)\n        x_input = x_input.view(x_input.size(0), -1)\n        x_input = F.relu(self.b_fc1(x_input))\n        x_input = torch.sigmoid(self.b_fc2(x_input))\n        return x_input\n```\n",
        "```python\nclass x_Node:\n    def __init__(self, x_value):\n        self.x_value = x_value\n        self.x_left = None\n        self.x_right = None\n\nclass b_BinaryTree:\n    def __init__(self):\n        self.x_root = None\n\n    def b_insert(self, x_value):\n        if self.x_root is None:\n            self.x_root = x_Node(x_value)\n        else:\n            self._insert_recursive(self.x_root, x_value)\n\n    def _insert_recursive(self, x_node, x_value):\n        if x_value < x_node.x_value:\n            if x_node.x_left is None:\n                x_node.x_left = x_Node(x_value)\n            else:\n                self._insert_recursive(x_node.x_left, x_value)\n        elif x_value > x_node.x_value:\n            if x_node.x_right is None:\n                x_node.x_right = x_Node(x_value)\n            else:\n                self._insert_recursive(x_node.x_right, x_value)\n\n    def b_delete(self, x_value):\n        self.x_root = self._delete_recursive(self.x_root, x_value)\n\n    def _delete_recursive(self, x_node, x_value):\n        if x_node is None:\n            return x_node\n\n        if x_value < x_node.x_value:\n            x_node.x_left = self._delete_recursive(x_node.x_left, x_value)\n        elif x_value > x_node.x_value:\n            x_node.x_right = self._delete_recursive(x_node.x_right, x_value)\n        else:\n            if x_node.x_left is None:\n                return x_node.x_right\n            elif x_node.x_right is None:\n                return x_node.x_left\n\n            x_temp = self._min_value_node(x_node.x_right)\n            x_node.x_value = x_temp.x_value\n            x_node.x_right = self._delete_recursive(x_node.x_right, x_temp.x_value)\n\n        return x_node\n\n    def _min_value_node(self, x_node):\n        x_current = x_node\n        while x_current.x_left is not None:\n            x_current = x_current.x_left\n        return x_current\n```\n",
        "```python\nfrom pedantic import validate\nimport numpy as np\n\n@validate\nclass PrincipalComponentAnalysis:\n    def __init__(self, x_n_components: int):\n        self.n_components = x_n_components\n        self.mean = None\n        self.components = None\n        self.explained_variance = None\n\n    @validate\n    def b_fit(self, x_data: np.ndarray) -> None:\n        \"\"\"\n        Computes the principal components and explained variance from the data.\n\n        :param x_data: A numpy array of shape (n_samples, n_features)\n        \"\"\"\n        # Center the data\n        x_mean = np.mean(x_data, axis=0)\n        self.mean = x_mean\n        x_centered = x_data - x_mean\n        \n        # Calculate covariance matrix\n        x_covariance_matrix = np.cov(x_centered, rowvar=False)\n\n        # Eigen decomposition\n        x_eigenvalues, x_eigenvectors = np.linalg.eigh(x_covariance_matrix)\n\n        # Sort eigenvectors by eigenvalues in descending order\n        sorted_indices = np.argsort(x_eigenvalues)[::-1]\n        x_eigenvalues = x_eigenvalues[sorted_indices]\n        x_eigenvectors = x_eigenvectors[:, sorted_indices]\n        \n        # Select the top n_components\n        self.components = x_eigenvectors[:, :self.n_components]\n        self.explained_variance = x_eigenvalues[:self.n_components]\n\n    @validate\n    def b_transform(self, x_data: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Projects the data onto the first principal components.\n\n        :param x_data: A numpy array of shape (n_samples, n_features)\n        :return: Transformed data of shape (n_samples, n_components)\n        \"\"\"\n        x_centered = x_data - self.mean\n        return np.dot(x_centered, self.components)\n\n    @validate\n    def b_fit_transform(self, x_data: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Fits the model with x_data and applies the dimensionality reduction.\n\n        :param x_data: A numpy array of shape (n_samples, n_features)\n        :return: Transformed data of shape (n_samples, n_components)\n        \"\"\"\n        self.b_fit(x_data)\n        return self.b_transform(x_data)\n```\n\nThis `PrincipalComponentAnalysis` class implements the procedure for principal component analysis while adhering to the coding standards and guidelines provided, including the latest updates from your mentor, like starting function names with `b_` and argument names with `x_`.",
        "```python\ndef b_int_to_roman(x_num: int) -> str:\n    x_val_map = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    \n    @validate\n    def inner():\n        n_res = []\n        for x_val, n_rom in x_val_map:\n            while x_num >= x_val:\n                n_res.append(n_rom)\n                x_num -= x_val\n        return ''.join(n_res)\n    \n    return inner()\n```\n",
        "```python\nfrom collections import Counter\nfrom scipy.spatial.distance import euclidean\n\nclass B_NearestNeighborsModel:\n    def __init__(self, x_n_neighbors=3):\n        self.x_train_data = None\n        self.x_labels = None\n        self.x_n_neighbors = x_n_neighbors\n\n    def b_train(self, x_training_data, x_labels):\n        self.x_train_data = x_training_data\n        self.x_labels = x_labels\n\n    def b_predict(self, x_test_data):\n        x_predictions = []\n        for x_test_point in x_test_data:\n            x_distances = [euclidean(x_train_point, x_test_point) for x_train_point in self.x_train_data]\n            x_neighbors_indices = sorted(range(len(x_distances)), key=lambda i: x_distances[i])[:self.x_n_neighbors]\n            x_neighbor_labels = [self.x_labels[i] for i in x_neighbors_indices]\n            x_predicted_label = Counter(x_neighbor_labels).most_common(1)[0][0]\n            x_predictions.append(x_predicted_label)\n        return x_predictions\n```\n",
        "```python\nclass b_Library:\n    def __init__(self):\n        self.x_books = []\n\n    def b_addBooks(self, x_bookList):\n        self.x_books.extend(x_bookList)\n\n    def b_removeBooks(self, x_bookList):\n        for x_book in x_bookList:\n            if x_book in self.x_books:\n                self.x_books.remove(x_book)\n```\n",
        "```python\nfrom typing import List\nfrom heapq import nlargest\n\ndef b_find_kth_largest(x_nums: List[int], x_k: int) -> int:\n    return nlargest(x_k, x_nums)[-1]\n```",
        "```python\nfrom pedantic import validate\nfrom typing import List\n\n@validate\ndef b_dot_product(x_vec1: List[float], x_vec2: List[float]) -> float:\n    assert len(x_vec1) == len(x_vec2), \"Vectors must be of the same length.\"\n    return sum(x_i * x_j for x_i, x_j in zip(x_vec1, x_vec2))\n```",
        "```python\nfrom pedantic import validate\n\nclass Inventory:\n    \n    @validate\n    def __init__(self, x_initial_stock: dict = None):\n        if x_initial_stock is None:\n            x_initial_stock = {}\n        self.x_stock = x_initial_stock\n\n    @validate\n    def b_add_stock(self, x_product_name: str, x_quantity: int):\n        if x_product_name in self.x_stock:\n            self.x_stock[x_product_name] += x_quantity\n        else:\n            self.x_stock[x_product_name] = x_quantity\n\n    @validate\n    def b_remove_stock(self, x_product_name: str, x_quantity: int):\n        if x_product_name in self.x_stock and self.x_stock[x_product_name] >= x_quantity:\n            self.x_stock[x_product_name] -= x_quantity\n            if self.x_stock[x_product_name] == 0:\n                del self.x_stock[x_product_name]\n        else:\n            raise ValueError(\"Insufficient stock or item not found.\")\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef b_remove_duplicates_and_sum(x_numbers: list) -> int:\n    return sum(set(x_numbers))\n```",
        "```python\nfrom pedantic import Trace, count_calls\n\n@Trace\nclass StudentGrade:\n    def __init__(self, x_grades: list):\n        self.wr_grades = x_grades\n\n    @count_calls\n    def b_compute_average(self) -> float:\n        total_sum = sum(self.wr_grades)\n        return total_sum / len(self.wr_grades) if self.wr_grades else 0.0\n```",
        "```python\nclass x_OnlineMeanCalculator:\n    @trace_class\n    def __init__(self):\n        self.b_count = 0\n        self.b_mean = 0.0\n\n    @count_calls\n    def b_add_number(self, x_number):\n        self.b_count += 1\n        self.b_mean += (x_number - self.b_mean) / self.b_count\n\n    @count_calls\n    def b_get_mean(self):\n        return self.b_mean\n```"
      ]
    }
  ]
}