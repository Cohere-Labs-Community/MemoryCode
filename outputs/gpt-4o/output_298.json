{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_x(arr_i):\n    if len(arr_i) > 1:\n        mid_i = len(arr_i) // 2\n        L_i = arr_i[:mid_i]\n        R_i = arr_i[mid_i:]\n\n        merge_sort_x(L_i)\n        merge_sort_x(R_i)\n\n        i_i = j_i = k_i = 0\n\n        while i_i < len(L_i) and j_i < len(R_i):\n            if L_i[i_i] < R_i[j_i]:\n                arr_i[k_i] = L_i[i_i]\n                i_i += 1\n            else:\n                arr_i[k_i] = R_i[j_i]\n                j_i += 1\n            k_i += 1\n\n        while i_i < len(L_i):\n            arr_i[k_i] = L_i[i_i]\n            i_i += 1\n            k_i += 1\n\n        while j_i < len(R_i):\n            arr_i[k_i] = R_i[j_i]\n            j_i += 1\n            k_i += 1\n```",
        "```python\nclass Node_x:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList_x:\n    def __init__(self):\n        self.head_i = None\n\n    def append_x(self, data_i):\n        new_node_i = Node_x(data_i)\n        if not self.head_i:\n            self.head_i = new_node_i\n            return\n        last_node_i = self.head_i\n        while last_node_i.next_i:\n            last_node_i = last_node_i.next_i\n        last_node_i.next_i = new_node_i\n\n    def prepend_x(self, data_i):\n        new_node_i = Node_x(data_i)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def delete_x(self, key_i):\n        current_node_i = self.head_i\n        if current_node_i and current_node_i.data_i == key_i:\n            self.head_i = current_node_i.next_i\n            current_node_i = None\n            return\n        prev_i = None\n        while current_node_i and current_node_i.data_i != key_i:\n            prev_i = current_node_i\n            current_node_i = current_node_i.next_i\n        if current_node_i is None:\n            return\n        prev_i.next_i = current_node_i.next_i\n        current_node_i = None\n\n    def display_x(self):\n        elems_i = []\n        current_node_i = self.head_i\n        while current_node_i:\n            elems_i.append(current_node_i.data_i)\n            current_node_i = current_node_i.next_i\n        return elems_i\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        new_node_i = Node(data_i)\n        if self.head_i is None:\n            self.head_i = new_node_i\n            return\n        last_i = self.head_i\n        while last_i.next_i:\n            last_i = last_i.next_i\n        last_i.next_i = new_node_i\n\n    def prepend(self, data_i):\n        new_node_i = Node(data_i)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def delete(self, key_i):\n        temp_i = self.head_i\n        if temp_i and temp_i.data_i == key_i:\n            self.head_i = temp_i.next_i\n            temp_i = None\n            return\n\n        prev_i = None\n        while temp_i and temp_i.data_i != key_i:\n            prev_i = temp_i\n            temp_i = temp_i.next_i\n\n        if temp_i is None:\n            return\n\n        prev_i.next_i = temp_i.next_i\n        temp_i = None\n\n    def search(self, key_i):\n        current_i = self.head_i\n        while current_i and current_i.data_i != key_i:\n            current_i = current_i.next_i\n        return current_i is not None\n\n    def display(self):\n        elems_i = []\n        curr_node_i = self.head_i\n        while curr_node_i:\n            elems_i.append(curr_node_i.data_i)\n            curr_node_i = curr_node_i.next_i\n        return elems_i\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node_q:\n    def __init__(self, data_q):\n        self.data_q = data_q\n        self.next_q = None\n\nclass LinkedList_q:\n    def __init__(self):\n        self.head_q = None\n\n    def append_b(self, data_q):\n        new_node_q = Node_q(data_q)\n        if not self.head_q:\n            self.head_q = new_node_q\n            return\n        last_q = self.head_q\n        while last_q.next_q:\n            last_q = last_q.next_q\n        last_q.next_q = new_node_q\n\n    def prepend_b(self, data_q):\n        new_node_q = Node_q(data_q)\n        new_node_q.next_q = self.head_q\n        self.head_q = new_node_q\n\n    def delete_with_value_b(self, data_q):\n        if not self.head_q:\n            return\n        if self.head_q.data_q == data_q:\n            self.head_q = self.head_q.next_q\n            return\n        current_q = self.head_q\n        while current_q.next_q:\n            if current_q.next_q.data_q == data_q:\n                current_q.next_q = current_q.next_q.next_q\n                return\n            current_q = current_q.next_q\n\n    def display_b(self):\n        elements_q = []\n        current_q = self.head_q\n        while current_q:\n            elements_q.append(current_q.data_q)\n            current_q = current_q.next_q\n        return elements_q\n```",
        "```python\ndef merge_sort_b(arr_q):\n    if len(arr_q) > 1:\n        mid_q = len(arr_q) // 2\n        left_half_q = arr_q[:mid_q]\n        right_half_q = arr_q[mid_q:]\n\n        merge_sort_b(left_half_q)\n        merge_sort_b(right_half_q)\n\n        i_q = j_q = k_q = 0\n\n        while i_q < len(left_half_q) and j_q < len(right_half_q):\n            if left_half_q[i_q] < right_half_q[j_q]:\n                arr_q[k_q] = left_half_q[i_q]\n                i_q += 1\n            else:\n                arr_q[k_q] = right_half_q[j_q]\n                j_q += 1\n            k_q += 1\n\n        while i_q < len(left_half_q):\n            arr_q[k_q] = left_half_q[i_q]\n            i_q += 1\n            k_q += 1\n\n        while j_q < len(right_half_q):\n            arr_q[k_q] = right_half_q[j_q]\n            j_q += 1\n            k_q += 1\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_q = data\n        self.next_q = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append(self, data):\n        new_node_q = Node(data)\n        if not self.head_q:\n            self.head_q = new_node_q\n            return\n        last_q = self.head_q\n        while last_q.next_q:\n            last_q = last_q.next_q\n        last_q.next_q = new_node_q\n\n    def prepend(self, data):\n        new_node_q = Node(data)\n        new_node_q.next_q = self.head_q\n        self.head_q = new_node_q\n\n    def delete(self, key):\n        temp_q = self.head_q\n        if temp_q and temp_q.data_q == key:\n            self.head_q = temp_q.next_q\n            temp_q = None\n            return\n        prev_q = None\n        while temp_q and temp_q.data_q != key:\n            prev_q = temp_q\n            temp_q = temp_q.next_q\n        if not temp_q:\n            return\n        prev_q.next_q = temp_q.next_q\n        temp_q = None\n\n    def search(self, key):\n        current_q = self.head_q\n        while current_q:\n            if current_q.data_q == key:\n                return True\n            current_q = current_q.next_q\n        return False\n\n    def display(self):\n        elems = []\n        current_q = self.head_q\n        while current_q:\n            elems.append(current_q.data_q)\n            current_q = current_q.next_q\n        return elems\n```",
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_r=None):\n        self.data_r = data_r\n        self.next_r = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data_r):\n        new_node_r = Node(data_r)\n        if not self.head_r:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r):\n        new_node_r = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r):\n        if not self.head_r:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def search(self, data_r):\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return True\n            current_r = current_r.next_r\n        return False\n\n    def display(self):\n        elements_r = []\n        current_r = self.head_r\n        while current_r:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data_r):\n        new_node_r = Node(data_r)\n        if self.head_r is None:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r):\n        new_node_r = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r):\n        if self.head_r is None:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def find(self, data_r):\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return current_r\n            current_r = current_r.next_r\n        return None\n\n    def display(self):\n        current_r = self.head_r\n        elements_r = []\n        while current_r:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef merge_sort_fn(arr: List[int]) -> List[int]:\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return _merge_fn(left_half, right_half)\n\ndef _merge_fn(left: List[int], right: List[int]) -> List[int]:\n    sorted_arr = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_arr.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_arr.append(right[right_index])\n            right_index += 1\n\n    sorted_arr.extend(left[left_index:])\n    sorted_arr.extend(right[right_index:])\n\n    return sorted_arr\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value: int):\n        self.value: int = value\n        self.left: TreeNode | None = None\n        self.right: TreeNode | None = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: TreeNode | None = None\n\n    def insert_fn(self, value: int) -> None:\n        if not self.root:\n            self.root = TreeNode(value)\n        else:\n            self._insert_recursive_fn(self.root, value)\n\n    def _insert_recursive_fn(self, node: TreeNode, value: int) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = TreeNode(value)\n            else:\n                self._insert_recursive_fn(node.left, value)\n        else:\n            if node.right is None:\n                node.right = TreeNode(value)\n            else:\n                self._insert_recursive_fn(node.right, value)\n\n    def delete_fn(self, value: int) -> None:\n        self.root = self._delete_recursive_fn(self.root, value)\n\n    def _delete_recursive_fn(self, node: TreeNode | None, value: int) -> TreeNode | None:\n        if node is None:\n            return node\n        \n        if value < node.value:\n            node.left = self._delete_recursive_fn(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive_fn(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                temp = self._find_min_fn(node.right)\n                node.value = temp.value\n                node.right = self._delete_recursive_fn(node.right, temp.value)\n\n        return node\n\n    def _find_min_fn(self, node: TreeNode) -> TreeNode:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_fn(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return merge_fn(left_half, right_half)\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_gn(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n        \n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n        \n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n        \n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_gn(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_xt=None):\n        self.data_xt = data_xt\n        self.next_xt = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def insert_d(self, data_xt):\n        new_node_xt = Node(data_xt)\n        if not self.head_xt:\n            self.head_xt = new_node_xt\n        else:\n            last_xt = self.head_xt\n            while last_xt.next_xt:\n                last_xt = last_xt.next_xt\n            last_xt.next_xt = new_node_xt\n\n    def delete_d(self, key_xt):\n        current_xt = self.head_xt\n        prev_xt = None\n        while current_xt and current_xt.data_xt != key_xt:\n            prev_xt = current_xt\n            current_xt = current_xt.next_xt\n        if prev_xt is None:\n            self.head_xt = current_xt.next_xt\n        elif current_xt:\n            prev_xt.next_xt = current_xt.next_xt\n\n    def search_d(self, key_xt):\n        current_xt = self.head_xt\n        while current_xt:\n            if current_xt.data_xt == key_xt:\n                return True\n            current_xt = current_xt.next_xt\n        return False\n\n    def traverse_d(self):\n        elements_xt = []\n        current_xt = self.head_xt\n        while current_xt:\n            elements_xt.append(current_xt.data_xt)\n            current_xt = current_xt.next_xt\n        return elements_xt\n```",
        "```python\ndef merge_sort_d(arr_xt):\n    if len(arr_xt) > 1:\n        mid_xt = len(arr_xt) // 2\n        left_half_xt = arr_xt[:mid_xt]\n        right_half_xt = arr_xt[mid_xt:]\n\n        merge_sort_d(left_half_xt)\n        merge_sort_d(right_half_xt)\n\n        i_xt, j_xt, k_xt = 0, 0, 0\n\n        while i_xt < len(left_half_xt) and j_xt < len(right_half_xt):\n            if left_half_xt[i_xt] < right_half_xt[j_xt]:\n                arr_xt[k_xt] = left_half_xt[i_xt]\n                i_xt += 1\n            else:\n                arr_xt[k_xt] = right_half_xt[j_xt]\n                j_xt += 1\n            k_xt += 1\n\n        while i_xt < len(left_half_xt):\n            arr_xt[k_xt] = left_half_xt[i_xt]\n            i_xt += 1\n            k_xt += 1\n\n        while j_xt < len(right_half_xt):\n            arr_xt[k_xt] = right_half_xt[j_xt]\n            j_xt += 1\n            k_xt += 1\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_xt):\n        self.data_xt = data_xt\n        self.next_xt = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data_xt):\n        new_node_xt = Node(data_xt)\n        if not self.head_xt:\n            self.head_xt = new_node_xt\n            return\n        last_xt = self.head_xt\n        while last_xt.next_xt:\n            last_xt = last_xt.next_xt\n        last_xt.next_xt = new_node_xt\n\n    def prepend(self, data_xt):\n        new_node_xt = Node(data_xt)\n        new_node_xt.next_xt = self.head_xt\n        self.head_xt = new_node_xt\n\n    def delete_with_value(self, data_xt):\n        if not self.head_xt:\n            return\n        if self.head_xt.data_xt == data_xt:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current_xt = self.head_xt\n        while current_xt.next_xt:\n            if current_xt.next_xt.data_xt == data_xt:\n                current_xt.next_xt = current_xt.next_xt.next_xt\n                return\n            current_xt = current_xt.next_xt\n\n    def find(self, data_xt):\n        current_xt = self.head_xt\n        while current_xt:\n            if current_xt.data_xt == data_xt:\n                return True\n            current_xt = current_xt.next_xt\n        return False\n\n    def __iter__(self):\n        current_xt = self.head_xt\n        while current_xt:\n            yield current_xt.data_xt\n            current_xt = current_xt.next_xt\n```",
        "```python\ndef merge_sort_d(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_d(left_half)\n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_j):\n        self.data_j = data_j\n        self.next_j = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data_j):\n        new_node_j = Node(data_j)\n        if self.head_j is None:\n            self.head_j = new_node_j\n        else:\n            last_node_j = self.head_j\n            while last_node_j.next_j:\n                last_node_j = last_node_j.next_j\n            last_node_j.next_j = new_node_j\n\n    def prepend(self, data_j):\n        new_node_j = Node(data_j)\n        new_node_j.next_j = self.head_j\n        self.head_j = new_node_j\n\n    def delete(self, key_j):\n        current_j = self.head_j\n        if current_j and current_j.data_j == key_j:\n            self.head_j = current_j.next_j\n            current_j = None\n            return\n\n        prev_j = None\n        while current_j and current_j.data_j != key_j:\n            prev_j = current_j\n            current_j = current_j.next_j\n\n        if current_j is None:\n            return\n\n        prev_j.next_j = current_j.next_j\n        current_j = None\n\n    def search(self, key_j):\n        current_j = self.head_j\n        while current_j:\n            if current_j.data_j == key_j:\n                return True\n            current_j = current_j.next_j\n        return False\n\n    def print_list(self):\n        current_j = self.head_j\n        while current_j:\n            print(current_j.data_j)\n            current_j = current_j.next_j\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_j = data\n        self.next_j = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_j is None:\n            self.head_j = new_node\n            return\n        last_j = self.head_j\n        while last_j.next_j:\n            last_j = last_j.next_j\n        last_j.next_j = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_j = self.head_j\n        self.head_j = new_node\n\n    def delete_with_value(self, data):\n        if self.head_j is None:\n            return\n        if self.head_j.data_j == data:\n            self.head_j = self.head_j.next_j\n            return\n        current_j = self.head_j\n        while current_j.next_j:\n            if current_j.next_j.data_j == data:\n                current_j.next_j = current_j.next_j.next_j\n                return\n            current_j = current_j.next_j\n\n    def find(self, data):\n        current_j = self.head_j\n        while current_j:\n            if current_j.data_j == data:\n                return True\n            current_j = current_j.next_j\n        return False\n\n    def print_list(self):\n        current_j = self.head_j\n        while current_j:\n            print(current_j.data_j, end=\" -> \")\n            current_j = current_j.next_j\n        print(\"None\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef count1_nonzero_elements(matrix_t):\n    count_t = 0\n    for row_t in matrix_t:\n        for element_t in row_t:\n            if element_t != 0:\n                count_t += 1\n    return count_t\n```",
        "```python\nclass Node:\n    def __init__(self, data_t):\n        self.data_t = data_t\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def insert1_at_end(self, data_t):\n        new_node_t = Node(data_t)\n        if self.head_t is None:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def delete1_node(self, key_t):\n        temp_t = self.head_t\n        if temp_t is not None:\n            if temp_t.data_t == key_t:\n                self.head_t = temp_t.next_t\n                temp_t = None\n                return\n        while temp_t is not None:\n            if temp_t.data_t == key_t:\n                break\n            prev_t = temp_t\n            temp_t = temp_t.next_t\n        if temp_t is None:\n            return\n        prev_t.next_t = temp_t.next_t\n        temp_t = None\n\n    def search1_element(self, key_t):\n        current_t = self.head_t\n        while current_t is not None:\n            if current_t.data_t == key_t:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def display1_list(self):\n        elements_t = []\n        current_t = self.head_t\n        while current_t:\n            elements_t.append(current_t.data_t)\n            current_t = current_t.next_t\n        return elements_t\n```"
      ],
      "instruction_model_output": [
        "```python\ndef c1ount_non_zero(matrix):\n    non_zero_c1ount = 0\n    for r1ow in matrix:\n        for e1lement in r1ow:\n            if e1lement != 0:\n                non_zero_c1ount += 1\n    return non_zero_c1ount\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_t = data\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def append(self, data):\n        new_node_t = Node(data)\n        if self.head_t is None:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def prepend(self, data):\n        new_node_t = Node(data)\n        new_node_t.next_t = self.head_t\n        self.head_t = new_node_t\n\n    def delete_with_value(self, data):\n        if self.head_t is None:\n            return\n        if self.head_t.data_t == data:\n            self.head_t = self.head_t.next_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            if current_t.next_t.data_t == data:\n                current_t.next_t = current_t.next_t.next_t\n                return\n            current_t = current_t.next_t\n\n    def find(self, data):\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def clear(self):\n        self.head_t = None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_y(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_y(left_half)\n        merge_sort_y(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_y(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_y(left_half)\n        merge_sort_y(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        self.edges[from_node].append((to_node, weight))\n\n    def compute_shortest_path_n(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {start_node: 0}\n        previous_nodes = {start_node: None}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_node == end_node:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = previous_nodes[current_node]\n                return path[::-1]\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n                if neighbor not in distances or distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n                    previous_nodes[neighbor] = current_node\n\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```\n",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges_n = {}\n\n    def add_edge_n(self, from_node, to_node, weight):\n        if from_node not in self.edges_n:\n            self.edges_n[from_node] = []\n        if to_node not in self.edges_n:\n            self.edges_n[to_node] = []\n        self.edges_n[from_node].append((to_node, weight))\n        self.edges_n[to_node].append((from_node, weight))\n\n    def shortest_path_n(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.edges_n}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges_n}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges_n.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        path.reverse()\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))  # Assuming undirected graph\n\n    def shortest_path_b(self, start_node, end_node):\n        min_heap = [(0, start_node)]\n        visited = set()\n        distances = {node: float('inf') for node in self.edges}\n        distances[start_node] = 0\n\n        while min_heap:\n            curr_dist, curr_node = heapq.heappop(min_heap)\n\n            if curr_node in visited:\n                continue\n\n            visited.add(curr_node)\n\n            if curr_node == end_node:\n                return curr_dist\n\n            for neighbor, weight in self.edges[curr_node]:\n                distance = curr_dist + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(min_heap, (distance, neighbor))\n\n        return float('inf')\n```\n"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_b = {}\n\n    def add_edge_b(self, from_node, to_node, weight):\n        if from_node not in self.nodes_b:\n            self.nodes_b[from_node] = []\n        if to_node not in self.nodes_b:\n            self.nodes_b[to_node] = []\n        self.nodes_b[from_node].append((to_node, weight))\n        self.nodes_b[to_node].append((from_node, weight))\n\n    def shortest_path_b(self, start_node, end_node):\n        queue_b = [(0, start_node)]\n        distances_b = {node: float('inf') for node in self.nodes_b}\n        distances_b[start_node] = 0\n        visited_b = set()\n\n        while queue_b:\n            current_distance_b, current_node_b = heapq.heappop(queue_b)\n\n            if current_node_b in visited_b:\n                continue\n\n            visited_b.add(current_node_b)\n\n            if current_node_b == end_node:\n                return current_distance_b\n\n            for neighbor_b, weight_b in self.nodes_b[current_node_b]:\n                distance_b = current_distance_b + weight_b\n\n                if distance_b < distances_b[neighbor_b]:\n                    distances_b[neighbor_b] = distance_b\n                    heapq.heappush(queue_b, (distance_b, neighbor_b))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_md(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_md(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_md(self, start_node, end_node):\n        priority_queue = []\n        heapq.heappush(priority_queue, (0, start_node))\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.nodes}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n            \n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.insert(0, current)\n            current = previous_nodes[current]\n        if path:\n            path.insert(0, current)\n        return path if distances[end_node] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_at = {}\n\n    def add_edge_a(self, source_at, destination_at, weight_at):\n        if source_at not in self.adjacency_list_at:\n            self.adjacency_list_at[source_at] = []\n        if destination_at not in self.adjacency_list_at:\n            self.adjacency_list_at[destination_at] = []\n        # Adding the edge between source and destination with the given weight\n        self.adjacency_list_at[source_at].append((destination_at, weight_at))\n\n    def shortest_path_a(self, start_at, end_at):\n        # Min-heap to store the current shortest path to a node\n        priority_queue_at = [(0, start_at)]\n        # Dictionary to store the shortest path cost to reach each node\n        shortest_paths_at = {start_at: (None, 0)}\n\n        while priority_queue_at:\n            current_weight_at, current_node_at = heapq.heappop(priority_queue_at)\n\n            if current_node_at == end_at:\n                break\n\n            if current_node_at not in self.adjacency_list_at:\n                continue\n\n            for neighbor_at, weight_at in self.adjacency_list_at[current_node_at]:\n                new_weight_at = current_weight_at + weight_at\n\n                if neighbor_at not in shortest_paths_at or shortest_paths_at[neighbor_at][1] > new_weight_at:\n                    shortest_paths_at[neighbor_at] = (current_node_at, new_weight_at)\n                    heapq.heappush(priority_queue_at, (new_weight_at, neighbor_at))\n\n        path_at = []\n        current_node_at = end_at\n        while current_node_at is not None:\n            path_at.append(current_node_at)\n            next_node_at = shortest_paths_at[current_node_at][0]\n            current_node_at = next_node_at\n        path_at.reverse()\n        \n        return path_at\n```",
        "```python\nclass Node_a:\n    def __init__(self, data_at):\n        self.data_at = data_at\n        self.next_at = None\n\nclass LinkedList_a:\n    def __init__(self):\n        self.head_at = None\n\n    def append_a(self, data_at):\n        \"\"\"Append a new node with the specified data_at at the end of the list.\"\"\"\n        new_node_at = Node_a(data_at)\n        if self.head_at is None:\n            self.head_at = new_node_at\n        else:\n            current_at = self.head_at\n            while current_at.next_at:\n                current_at = current_at.next_at\n            current_at.next_at = new_node_at\n\n    def prepend_a(self, data_at):\n        \"\"\"Prepend a new node with the specified data_at to the start of the list.\"\"\"\n        new_node_at = Node_a(data_at)\n        new_node_at.next_at = self.head_at\n        self.head_at = new_node_at\n\n    def delete_with_value_a(self, data_at):\n        \"\"\"Delete the first node with the specified data_at from the list.\"\"\"\n        if self.head_at is None:\n            return\n\n        if self.head_at.data_at == data_at:\n            self.head_at = self.head_at.next_at\n            return\n\n        current_at = self.head_at\n        while current_at.next_at:\n            if current_at.next_at.data_at == data_at:\n                current_at.next_at = current_at.next_at.next_at\n                return\n            current_at = current_at.next_at\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        \n    def add_node_a(self, node):\n        if node not in self.nodes:\n            self.nodes[node] = []\n\n    def add_edge_a(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node].append((to_node, weight))\n            self.nodes[to_node].append((from_node, weight))\n\n    def shortest_path_a(self, start_node, end_node):\n        import heapq\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('infinity') for node in self.nodes}\n        distances[start_node] = 0\n        visited = set()\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('infinity') else None\n```",
        "```python\nclass Node:\n    def __init__(self, value_at=None):\n        self.value_at = value_at\n        self.next_at = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def append(self, value_at):\n        new_node = Node(value_at)\n        if self.head_at is None:\n            self.head_at = new_node\n            return\n        last_node_at = self.head_at\n        while last_node_at.next_at:\n            last_node_at = last_node_at.next_at\n        last_node_at.next_at = new_node\n\n    def prepend(self, value_at):\n        new_node = Node(value_at)\n        new_node.next_at = self.head_at\n        self.head_at = new_node\n\n    def delete_value(self, value_at):\n        current_node_at = self.head_at\n        if current_node_at and current_node_at.value_at == value_at:\n            self.head_at = current_node_at.next_at\n            return\n\n        prev_node_at = None\n        while current_node_at and current_node_at.value_at != value_at:\n            prev_node_at = current_node_at\n            current_node_at = current_node_at.next_at\n\n        if current_node_at is None:\n            return\n\n        prev_node_at.next_at = current_node_at.next_at\n\n    def find(self, value_at):\n        current_node_at = self.head_at\n        while current_node_at:\n            if current_node_at.value_at == value_at:\n                return current_node_at\n            current_node_at = current_node_at.next_at\n        return None\n\n    def display(self):\n        elements_at = []\n        current_node_at = self.head_at\n        while current_node_at:\n            elements_at.append(current_node_at.value_at)\n            current_node_at = current_node_at.next_at\n        return elements_at\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_s = {}\n\n    def add_node_x(self, node_s):\n        if node_s not in self.nodes_s:\n            self.nodes_s[node_s] = []\n\n    def add_edge_x(self, from_node_s, to_node_s, weight_s):\n        if from_node_s in self.nodes_s and to_node_s in self.nodes_s:\n            self.nodes_s[from_node_s].append((to_node_s, weight_s))\n            self.nodes_s[to_node_s].append((from_node_s, weight_s))  # Assuming it's an undirected graph\n\n    def compute_shortest_path_x(self, start_s, end_s):\n        if start_s not in self.nodes_s or end_s not in self.nodes_s:\n            return float('inf')\n        \n        distances_s = {node_s: float('inf') for node_s in self.nodes_s}\n        distances_s[start_s] = 0\n        priority_queue_s = [(0, start_s)]\n        \n        while priority_queue_s:\n            current_distance_s, current_node_s = heapq.heappop(priority_queue_s)\n            \n            if current_distance_s > distances_s[current_node_s]:\n                continue\n            \n            for neighbor_s, weight_s in self.nodes_s[current_node_s]:\n                distance_s = current_distance_s + weight_s\n                \n                if distance_s < distances_s[neighbor_s]:\n                    distances_s[neighbor_s] = distance_s\n                    heapq.heappush(priority_queue_s, (distance_s, neighbor_s))\n        \n        return distances_s[end_s]\n```",
        "```python\nclass Node:\n    def __init__(self, value_s):\n        self.value_s = value_s\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append_x(self, value_s):\n        new_node_s = Node(value_s)\n        if self.head_s is None:\n            self.head_s = new_node_s\n        else:\n            current_s = self.head_s\n            while current_s.next_s:\n                current_s = current_s.next_s\n            current_s.next_s = new_node_s\n\n    def prepend_x(self, value_s):\n        new_node_s = Node(value_s)\n        new_node_s.next_s = self.head_s\n        self.head_s = new_node_s\n\n    def delete_x(self, value_s):\n        current_s = self.head_s\n        previous_s = None\n        while current_s:\n            if current_s.value_s == value_s:\n                if previous_s:\n                    previous_s.next_s = current_s.next_s\n                else:\n                    self.head_s = current_s.next_s\n                return\n            previous_s = current_s\n            current_s = current_s.next_s\n\n    def find_x(self, value_s):\n        current_s = self.head_s\n        while current_s:\n            if current_s.value_s == value_s:\n                return current_s\n            current_s = current_s.next_s\n        return None\n\n    def display_x(self):\n        nodes_s = []\n        current_s = self.head_s\n        while current_s:\n            nodes_s.append(current_s.value_s)\n            current_s = current_s.next_s\n        return nodes_s\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_node_x(self, value):\n        self.nodes[value] = {}\n\n    def add_edge_x(self, from_node, to_node, weight):\n        if from_node in self.nodes and to_node in self.nodes:\n            self.nodes[from_node][to_node] = weight\n            self.nodes[to_node][from_node] = weight  # Assuming undirected graph\n\n    def shortest_path_x(self, start_node, end_node):\n        if start_node not in self.nodes or end_node not in self.nodes:\n            return None\n\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.nodes[current_node].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_s = data\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_s is None:\n            self.head_s = new_node\n            return\n        last = self.head_s\n        while last.next_s:\n            last = last.next_s\n        last.next_s = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_node(self, key):\n        current_s = self.head_s\n        if current_s and current_s.data_s == key:\n            self.head_s = current_s.next_s\n            current_s = None\n            return\n        prev_s = None\n        while current_s and current_s.data_s != key:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        current_s = None\n\n    def search(self, key):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == key:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_s, end=\" \")\n            current_s = current_s.next_s\n        print()\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.at_capacity = capacity\n        self.at_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.at_cache:\n            return -1\n        self.at_cache.move_to_end(key)\n        return self.at_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.at_cache:\n            self.at_cache.move_to_end(key)\n        self.at_cache[key] = value\n        if len(self.at_cache) > self.at_capacity:\n            self.at_cache.popitem(last=False)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, at_key, at_value):\n        self.at_key = at_key\n        self.at_value = at_value\n        self.at_prev = None\n        self.at_next = None\n\nclass LRUCache:\n    def __init__(self, at_capacity):\n        self.at_capacity = at_capacity\n        self.at_cache = {}\n        self.at_head = Node(0, 0)\n        self.at_tail = Node(0, 0)\n        self.at_head.at_next = self.at_tail\n        self.at_tail.at_prev = self.at_head\n        \n    def _remove(self, at_node):\n        at_prev = at_node.at_prev\n        at_next = at_node.at_next\n        at_prev.at_next = at_next\n        at_next.at_prev = at_prev\n\n    def _add(self, at_node):\n        at_node.at_prev = self.at_head\n        at_node.at_next = self.at_head.at_next\n        self.at_head.at_next.at_prev = at_node\n        self.at_head.at_next = at_node\n\n    def get(self, at_key):\n        if at_key in self.at_cache:\n            at_node = self.at_cache[at_key]\n            self._remove(at_node)\n            self._add(at_node)\n            return at_node.at_value\n        return -1\n\n    def put(self, at_key, at_value):\n        if at_key in self.at_cache:\n            self._remove(self.at_cache[at_key])\n        at_node = Node(at_key, at_value)\n        self._add(at_node)\n        self.at_cache[at_key] = at_node\n        if len(self.at_cache) > self.at_capacity:\n            at_lru = self.at_tail.at_prev\n            self._remove(at_lru)\n            del self.at_cache[at_lru.at_key]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\nclass StudentGrade:\n    \n    def __init__(self, grades):\n        self.grades = grades\n\n    @require_kwargs\n    def compute_average_grade(self):\n        return sum(self.grades) / len(self.grades)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\nclass StudentGrade:\n    def __init__(self, **kwargs):\n        self.grades = kwargs.get('grades', [])\n\n    @require_kwargs\n    def add_grade(self, grade: float) -> None:\n        self.grades.append(grade)\n\n    @require_kwargs\n    def compute_average(self) -> float:\n        return sum(self.grades) / len(self.grades) if self.grades else 0.0\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes_p = {}\n    \n    def add_edge_p(self, u, v, weight):\n        if u not in self.nodes_p:\n            self.nodes_p[u] = []\n        if v not in self.nodes_p:\n            self.nodes_p[v] = []\n        self.nodes_p[u].append((v, weight))\n        self.nodes_p[v].append((u, weight))\n    \n    def chx_shortest_path_p(self, start, end):\n        queue = []\n        heapq.heappush(queue, (0, start))\n        distances = {node: float('inf') for node in self.nodes_p}\n        distances[start] = 0\n        visited = set()\n        \n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            \n            if current_node in visited:\n                continue\n                \n            visited.add(current_node)\n            \n            if current_node == end:\n                return current_distance\n            \n            for neighbor, weight in self.nodes_p.get(current_node, []):\n                distance = current_distance + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(queue, (distance, neighbor))\n        \n        return float('inf')  # If no path exists\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef flatten_chx_tree_to_linked_list(root_p):\n    if not root_p:\n        return None\n\n    while root_p:\n        if root_p.left:\n            rightmost_p = root_p.left\n            while rightmost_p.right:\n                rightmost_p = rightmost_p.right\n            rightmost_p.right = root_p.right\n            root_p.right = root_p.left\n            root_p.left = None\n        root_p = root_p.right\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n",
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef chx_flatten_binary_tree(root):\n    if not root:\n        return\n\n    stack = [root]\n    while stack:\n        current = stack.pop()\n\n        if current.right:\n            stack.append(current.right)\n        if current.left:\n            stack.append(current.left)\n\n        if stack:\n            current.right = stack[-1]\n        current.left = None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        self.edges[from_node].append((to_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {start_node: 0}\n        previous_nodes = {start_node: None}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node == end_node:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = previous_nodes[current_node]\n                return path[::-1]\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if neighbor not in distances or distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_ud(s_n: str) -> bool:\n    s_n = ''.join(c_n.lower() for c_n in s_n if c_n.isalnum())\n    return s_n == s_n[::-1]\n```",
        "```python\nimport heapq\n\nclass Graph_n:\n    def __init__(self, vertices_n):\n        self.vertices_n = vertices_n\n        self.adjacency_list_n = {v: [] for v in range(vertices_n)}\n\n    def add_edge_ud(self, u_n, v_n, weight_n):\n        self.adjacency_list_n[u_n].append((v_n, weight_n))\n        self.adjacency_list_n[v_n].append((u_n, weight_n))\n\n    def shortest_path_ud(self, start_n, end_n):\n        distances_n = {v: float('inf') for v in range(self.vertices_n)}\n        distances_n[start_n] = 0\n        priority_queue_n = [(0, start_n)]\n        \n        while priority_queue_n:\n            current_distance_n, current_vertex_n = heapq.heappop(priority_queue_n)\n            \n            if current_distance_n > distances_n[current_vertex_n]:\n                continue\n            \n            for neighbor_n, weight_n in self.adjacency_list_n[current_vertex_n]:\n                distance_n = current_distance_n + weight_n\n                \n                if distance_n < distances_n[neighbor_n]:\n                    distances_n[neighbor_n] = distance_n\n                    heapq.heappush(priority_queue_n, (distance_n, neighbor_n))\n        \n        return distances_n[end_n]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_n(s_n: str) -> bool:\n    s_n = ''.join(char_n.lower() for char_n in s_n if char_n.isalnum())\n    return s_n == s_n[::-1]\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_y(string_y: str) -> bool:\n    processed_y = ''.join(char_y.lower() for char_y in string_y if char_y.isalnum())\n    return processed_y == processed_y[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome(string_y):\n    clean_string_y = ''.join(char_y.lower() for char_y in string_y if char_y.isalnum())\n    return clean_string_y == clean_string_y[::-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_m(s_m: str) -> bool:\n    t_cleaned_m = ''.join(c_m.lower() for c_m in s_m if c_m.isalnum())\n    return t_cleaned_m == t_cleaned_m[::-1]\n```",
        "```python\nclass LRUCache_m:\n    class Node_m:\n        def __init__(self, t_key_m, t_value_m):\n            self.t_key_m = t_key_m\n            self.t_value_m = t_value_m\n            self.t_prev_m = None\n            self.t_next_m = None\n\n    def __init__(self, t_capacity_m):\n        self.t_capacity_m = t_capacity_m\n        self.t_cache_m = {}\n        self.t_head_m = self.Node_m(0, 0)\n        self.t_tail_m = self.Node_m(0, 0)\n        self.t_head_m.t_next_m = self.t_tail_m\n        self.t_tail_m.t_prev_m = self.t_head_m\n\n    def _remove_m(self, t_node_m):\n        t_prev_m = t_node_m.t_prev_m\n        t_next_m = t_node_m.t_next_m\n        t_prev_m.t_next_m = t_next_m\n        t_next_m.t_prev_m = t_prev_m\n\n    def _add_m(self, t_node_m):\n        t_prev_m = self.t_head_m\n        t_next_m = self.t_head_m.t_next_m\n        t_prev_m.t_next_m = t_node_m\n        t_node_m.t_prev_m = t_prev_m\n        t_node_m.t_next_m = t_next_m\n        t_next_m.t_prev_m = t_node_m\n\n    def get_m(self, t_key_m):\n        t_node_m = self.t_cache_m.get(t_key_m, None)\n        if not t_node_m:\n            return -1\n        self._remove_m(t_node_m)\n        self._add_m(t_node_m)\n        return t_node_m.t_value_m\n\n    def put_m(self, t_key_m, t_value_m):\n        t_node_m = self.t_cache_m.get(t_key_m)\n        if t_node_m:\n            self._remove_m(t_node_m)\n        \n        t_new_node_m = self.Node_m(t_key_m, t_value_m)\n        self._add_m(t_new_node_m)\n        self.t_cache_m[t_key_m] = t_new_node_m\n        \n        if len(self.t_cache_m) > self.t_capacity_m:\n            t_lru_m = self.t_tail_m.t_prev_m\n            self._remove_m(t_lru_m)\n            del self.t_cache_m[t_lru_m.t_key_m]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_palindrome(check_str_m):\n    clean_str_m = ''.join(char_m.lower() for char_m in check_str_m if char_m.isalnum())\n    return clean_str_m == clean_str_m[::-1]\n```",
        "```python\nclass LRUCache:\n    def __init__(self, t_capacity: int):\n        self.t_capacity = t_capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, t_key: int) -> int:\n        if t_key not in self.t_cache:\n            return -1\n        self.t_order.remove(t_key)\n        self.t_order.append(t_key)\n        return self.t_cache[t_key]\n\n    def put(self, t_key: int, t_value: int) -> None:\n        if t_key in self.t_cache:\n            self.t_order.remove(t_key)\n        elif len(self.t_cache) >= self.t_capacity:\n            oldest_key = self.t_order.pop(0)\n            del self.t_cache[oldest_key]\n        self.t_cache[t_key] = t_value\n        self.t_order.append(t_key)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport locale\n\ndef least_common_multiple_x(a_x, b_x):\n    def gcd_x(x_x, y_x):\n        while y_x != 0:\n            x_x, y_x = y_x, x_x % y_x\n        return x_x\n    \n    return abs(a_x * b_x) // gcd_x(a_x, b_x)\n```",
        "```python\nimport locale\n\ndef is_palindrome_x(input_string_x):\n    cleaned_string_x = ''.join(char.lower() for char in input_string_x if char.isalnum())\n    return cleaned_string_x == cleaned_string_x[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport locale\n\ndef lcm(a, b):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    return abs(a * b) // gcd(a, b)\n```",
        "```python\ndef is_palindrome(s_x):\n    s_x = ''.join(char_x.lower() for char_x in s_x if char_x.isalnum())\n    return s_x == s_x[::-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value_vr):\n        self.value_vr = value_vr\n        self.left_vr = None\n        self.right_vr = None\n\ndef is_valid_bst_vr(root_vr):\n    def validate_vr(node_vr, low_vr=-float('inf'), high_vr=float('inf')):\n        try:\n            if not node_vr:\n                return True\n\n            val_vr = node_vr.value_vr\n            if val_vr <= low_vr or val_vr >= high_vr:\n                return False\n\n            if not validate_vr(node_vr.right_vr, val_vr, high_vr):\n                return False\n            if not validate_vr(node_vr.left_vr, low_vr, val_vr):\n                return False\n            return True\n        except Exception as e_vr:\n            print(f\"An error occurred: {e_vr}\")\n            return False\n        \n    return validate_vr(root_vr)\n```",
        "```python\ndef is_palindrome_vr(s_vr):\n    try:\n        left_vr, right_vr = 0, len(s_vr) - 1\n        while left_vr < right_vr:\n            if s_vr[left_vr] != s_vr[right_vr]:\n                return False\n            left_vr += 1\n            right_vr -= 1\n        return True\n    except Exception as e_vr:\n        print(f\"An error occurred: {e_vr}\")\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```",
        "```python\ndef is_palindrome(s_vr):\n    left_vr, right_vr = 0, len(s_vr) - 1\n    while left_vr < right_vr:\n        while left_vr < right_vr and not s_vr[left_vr].isalnum():\n            left_vr += 1\n        while left_vr < right_vr and not s_vr[right_vr].isalnum():\n            right_vr -= 1\n        if s_vr[left_vr].lower() != s_vr[right_vr].lower():\n            return False\n        left_vr += 1\n        right_vr -= 1\n    return True\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_wr=3):\n        self.n_neighbors_wr = n_neighbors_wr\n        self.X_train_wr = None\n        self.y_train_wr = None\n\n    def train(self, X_wr, y_wr):\n        assert isinstance(X_wr, np.ndarray), \"X_wr should be a numpy ndarray.\"\n        assert isinstance(y_wr, np.ndarray), \"y_wr should be a numpy ndarray.\"\n        assert len(X_wr) == len(y_wr), \"The length of X_wr and y_wr should match.\"\n        \n        self.X_train_wr = X_wr\n        self.y_train_wr = y_wr\n        \n    def predict(self, X_wr):\n        assert isinstance(X_wr, np.ndarray), \"X_wr should be a numpy ndarray.\"\n        \n        if self.X_train_wr is None or self.y_train_wr is None:\n            raise ValueError(\"Model has not been trained yet.\")\n        \n        predictions_wr = []\n        \n        for x_wr in X_wr:\n            distances_wr = np.linalg.norm(self.X_train_wr - x_wr, axis=1)\n            nearest_indices_wr = np.argsort(distances_wr)[:self.n_neighbors_wr]\n            nearest_labels_wr = self.y_train_wr[nearest_indices_wr]\n            most_common_wr = Counter(nearest_labels_wr).most_common(1)[0][0]\n            predictions_wr.append(most_common_wr)\n        \n        return np.array(predictions_wr)\n```\n",
        "```python\ndef is_valid_palindrome_wr(input_string_wr: str) -> bool:\n    assert isinstance(input_string_wr, str), \"Input must be a string\"\n    \n    filtered_string_wr = ''.join(char_wr.lower() for char_wr in input_string_wr if char_wr.isalnum())\n    reversed_string_wr = filtered_string_wr[::-1]\n\n    return filtered_string_wr == reversed_string_wr\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```",
        "```python\ndef is_palindrome_wr(s_wr):\n    cleaned_wr = ''.join(char_wr.lower() for char_wr in s_wr if char_wr.isalnum())\n    return cleaned_wr == cleaned_wr[::-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_palindrome_w(s_w: str) -> bool:\n    j_left_w, j_right_w = 0, len(s_w) - 1\n    \n    while j_left_w < j_right_w:\n        if s_w[j_left_w] != s_w[j_right_w]:\n            return False\n        j_left_w += 1\n        j_right_w -= 1\n        \n    return True\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, j_capacity_w):\n        self.j_capacity_w = j_capacity_w\n        self.j_cache_w = OrderedDict()\n\n    def get(self, j_key_w):\n        if j_key_w not in self.j_cache_w:\n            return -1\n        self.j_cache_w.move_to_end(j_key_w)\n        return self.j_cache_w[j_key_w]\n\n    def put(self, j_key_w, j_value_w):\n        if j_key_w in self.j_cache_w:\n            self.j_cache_w.move_to_end(j_key_w)\n        self.j_cache_w[j_key_w] = j_value_w\n        if len(self.j_cache_w) > self.j_capacity_w:\n            self.j_cache_w.popitem(last=False)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_palindrome_w(input_w: str) -> bool:\n    cleaned_w = ''.join(char_w.lower() for char_w in input_w if char_w.isalnum())\n    return cleaned_w == cleaned_w[::-1]\n```",
        "```python\nclass LRUCache:\n    def __init__(self, j_capacity: int):\n        self.j_capacity = j_capacity\n        self.j_cache = {}\n        self.j_usage_order = []\n\n    def get(self, j_key: int) -> int:\n        if j_key not in self.j_cache:\n            return -1\n        self.j_usage_order.remove(j_key)\n        self.j_usage_order.append(j_key)\n        return self.j_cache[j_key]\n\n    def put(self, j_key: int, j_value: int) -> None:\n        if j_key in self.j_cache:\n            self.j_usage_order.remove(j_key)\n        elif len(self.j_cache) == self.j_capacity:\n            oldest = self.j_usage_order.pop(0)\n            del self.j_cache[oldest]\n            \n        self.j_cache[j_key] = j_value\n        self.j_usage_order.append(j_key)\n```"
      ],
      "cumulative_model_output": [
        "```python\ndef lcm_ud(a_x: int, b_x: int) -> int:\n    \"\"\"Calculate the least common multiple of two integers.\"\"\"\n    def gcd_ud(x_x: int, y_x: int) -> int:\n        while y_x != 0:\n            (x_x, y_x) = (y_x, x_x % y_x)\n        return x_x\n\n    return abs(a_x * b_x) // gcd_ud(a_x, b_x)\n```",
        "```python\nclass StudentGrade_zw:\n    def __init__(self, j_name_w: str, j_grades_w: list[float]) -> None:\n        self.j_name_w = j_name_w\n        self.j_grades_w = j_grades_w\n\n    def compute_average_ud(self) -> float:\n        try:\n            assert len(self.j_grades_w) > 0, \"Grades list should not be empty\"\n            average_w = sum(self.j_grades_w) / len(self.j_grades_w)\n            return average_w\n        except ZeroDivisionError:\n            return 0.0\n```",
        "```python\nfrom collections import Counter\nimport numpy as np\nfrom typing import List, Tuple\n\nclass NearestNeighbors_ud:\n    def __init__(self, k_n: int = 3):\n        self.k_n = k_n\n        self.j_training_data_w = None\n        self.j_training_labels_w = None\n\n    def _euclidean_distance_x(self, point1_n: np.ndarray, point2_n: np.ndarray) -> float:\n        return np.sqrt(np.sum((point1_n - point2_n) ** 2))\n\n    def train_ud(self, training_data_w: np.ndarray, training_labels_w: np.ndarray) -> None:\n        self.j_training_data_w = training_data_w\n        self.j_training_labels_w = training_labels_w\n\n    def predict_ud(self, points_wr: List[np.ndarray]) -> List:\n        predictions_wr = []\n        for point_n in points_wr:\n            distances_wr = [self._euclidean_distance_x(point_n, train_point_n) \n                            for train_point_n in self.j_training_data_w]\n            k_nearest_indices_w = np.argsort(distances_wr)[:self.k_n]\n            k_nearest_labels_w = [self.j_training_labels_w[i_w] for i_w in k_nearest_indices_w]\n            most_common_label_w = Counter(k_nearest_labels_w).most_common(1)[0][0]\n            predictions_wr.append(most_common_label_w)\n        return predictions_wr\n```",
        "```python\nimport heapq\nfrom typing import Dict, List, Tuple\n\nclass Graph_j:\n    def __init__(self, j_nodes_w: List[int]):\n        self.j_nodes_w = j_nodes_w\n        self.j_edges_w = {j_node_w: [] for j_node_w in self.j_nodes_w}\n\n    def add_edge_o(self, j_from_w: int, j_to_w: int, j_weight_w: int) -> None:\n        self.j_edges_w[j_from_w].append((j_to_w, j_weight_w))\n        self.j_edges_w[j_to_w].append((j_from_w, j_weight_w))\n\n    def shortest_path_ud(self, j_start_w: int, j_end_w: int) -> Tuple[List[int], int]:\n        queue_j = []\n        heapq.heappush(queue_j, (0, j_start_w))\n        j_distances_w = {j_node_w: float('inf') for j_node_w in self.j_nodes_w}\n        j_distances_w[j_start_w] = 0\n        j_previous_w = {j_node_w: None for j_node_w in self.j_nodes_w}\n\n        while queue_j:\n            j_current_distance_w, j_current_node_w = heapq.heappop(queue_j)\n\n            if j_current_distance_w > j_distances_w[j_current_node_w]:\n                continue\n\n            for j_neighbor_w, j_weight_w in self.j_edges_w[j_current_node_w]:\n                j_distance_w = j_current_distance_w + j_weight_w\n\n                if j_distance_w < j_distances_w[j_neighbor_w]:\n                    j_distances_w[j_neighbor_w] = j_distance_w\n                    j_previous_w[j_neighbor_w] = j_current_node_w\n                    heapq.heappush(queue_j, (j_distance_w, j_neighbor_w))\n\n        path_n, j_total_weight_w = [], j_distances_w[j_end_w]\n        while j_end_w is not None:\n            path_n.append(j_end_w)\n            j_end_w = j_previous_w[j_end_w]\n\n        return path_n[::-1], j_total_weight_w\n```",
        "```python\nclass TreeNode:\n    def __init__(self_j_):\n        self_j_.key_w = None\n        self_j_.left_j = None\n        self_j_.right_j = None\n\nclass BinaryTree:\n    def __init__(self_j_):\n        self_j_.root_w = None\n\n    def insert_node_ud(self_j_, key_w):\n        if self_j_.root_w is None:\n            self_j_.root_w = TreeNode()\n            self_j_.root_w.key_w = key_w\n        else:\n            self_j_._insert_recursively_ud(self_j_.root_w, key_w)\n\n    def _insert_recursively_ud(self_j_, node_j_, key_w):\n        if key_w < node_j_.key_w:\n            if node_j_.left_j is None:\n                node_j_.left_j = TreeNode()\n                node_j_.left_j.key_w = key_w\n            else:\n                self_j_._insert_recursively_ud(node_j_.left_j, key_w)\n        else:\n            if node_j_.right_j is None:\n                node_j_.right_j = TreeNode()\n                node_j_.right_j.key_w = key_w\n            else:\n                self_j_._insert_recursively_ud(node_j_.right_j, key_w)\n\n    def delete_node_ud(self_j_, key_w):\n        self_j_.root_w = self_j_._delete_recursively_ud(self_j_.root_w, key_w)\n\n    def _delete_recursively_ud(self_j_, node_j_, key_w):\n        if node_j_ is None:\n            return node_j_\n\n        if key_w < node_j_.key_w:\n            node_j_.left_j = self_j_._delete_recursively_ud(node_j_.left_j, key_w)\n        elif key_w > node_j_.key_w:\n            node_j_.right_j = self_j_._delete_recursively_ud(node_j_.right_j, key_w)\n        else:\n            if node_j_.left_j is None:\n                return node_j_.right_j\n            elif node_j_.right_j is None:\n                return node_j_.left_j\n\n            min_larger_node_j = self_j_._find_min_ud(node_j_.right_j)\n            node_j_.key_w = min_larger_node_j.key_w\n            node_j_.right_j = self_j_._delete_recursively_ud(node_j_.right_j, min_larger_node_j.key_w)\n\n        return node_j_\n\n    def _find_min_ud(self_j_, node_j_):\n        current_j = node_j_\n        while current_j.left_j is not None:\n            current_j = current_j.left_j\n        return current_j\n\n```\n\n",
        "```python\ndef is_palindrome_function_9y(input_string_j: str) -> bool:\n    processed_string_y = ''.join(char_ou.lower() for char_ou in input_string_j if char_ou.isalnum())\n    return processed_string_y == processed_string_y[::-1]\n```",
        "```python\ndef count_non_zero_elements_c(matrix_j) -> int:\n    count_x = 0\n    for j_row in matrix_j:\n        for j_element in j_row:\n            if j_element != 0:\n                count_x += 1\n    return count_x\n```",
        "```python\ndef merge_sort_d(arr_w: list) -> list:\n    if len(arr_w) > 1:\n        mid_vr = len(arr_w) // 2\n        left_half_vr = arr_w[:mid_vr]\n        right_half_vr = arr_w[mid_vr:]\n\n        merge_sort_d(left_half_vr)\n        merge_sort_d(right_half_vr)\n\n        i_w = j_w = k_w = 0\n\n        while i_w < len(left_half_vr) and j_w < len(right_half_vr):\n            if left_half_vr[i_w] < right_half_vr[j_w]:\n                arr_w[k_w] = left_half_vr[i_w]\n                i_w += 1\n            else:\n                arr_w[k_w] = right_half_vr[j_w]\n                j_w += 1\n            k_w += 1\n\n        while i_w < len(left_half_vr):\n            arr_w[k_w] = left_half_vr[i_w]\n            i_w += 1\n            k_w += 1\n\n        while j_w < len(right_half_vr):\n            arr_w[k_w] = right_half_vr[j_w]\n            j_w += 1\n            k_w += 1\n\n    return arr_w\n```",
        "```python\nfrom collections import OrderedDict\r\n\r\nclass LRUCache:\r\n\r\n    def __init_p__(self, capacity_j_):\r\n        self.capacity_j_ = capacity_j_\r\n        self.cache_j_ = OrderedDict()\r\n\r\n    def get_chx(self, key_j_):\r\n        if key_j_ not in self.cache_j_:\r\n            return -1\r\n        else:\r\n            self.cache_j_.move_to_end(key_j_)\r\n            return self.cache_j_[key_j_]\r\n\r\n    def put_chx(self, key_j_, value_j_):\r\n        if key_j_ in self.cache_j_:\r\n            self.cache_j_.move_to_end(key_j_)\r\n        self.cache_j_[key_j_] = value_j_\r\n        if len(self.cache_j_) > self.capacity_j_:\r\n            self.cache_j_.popitem(last=False)\r\n```",
        "```python\nclass TreeNode:\n    def __init__(self, j_val_j=0, j_left_j=None, j_right_j=None):\n        self.j_val_j = j_val_j\n        self.j_left_j = j_left_j\n        self.j_right_j = j_right_j\n\ndef flatten_x(root_j: TreeNode) -> None:\n    def flatten_tree_w(node_m: TreeNode) -> TreeNode:\n        nonlocal prev_w\n\n        if not node_m:\n            return None\n\n        flatten_tree_w(node_m.j_right_j)\n        flatten_tree_w(node_m.j_left_j)\n\n        node_m.j_right_j = prev_w\n        node_m.j_left_j = None\n        prev_w = node_m\n\n    prev_w = None\n    flatten_tree_w(root_j)\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value_j=0, left_j=None, right_j=None):\n        self.j_value = value_j\n        self.j_left = left_j\n        self.j_right = right_j\n\ndef is_valid_BST_y(root_j: TreeNode) -> bool:\n    def validate_ud(node_j: TreeNode, low_w=-float('inf'), high_w=float('inf')) -> bool:\n        if not node_j:\n            return True\n        if not (low_w < node_j.j_value < high_w):\n            return False\n        return (validate_ud(node_j.j_left, low_w, node_j.j_value) and \n                validate_ud(node_j.j_right, node_j.j_value, high_w))\n\n    return validate_ud(root_j)\n```",
        "```python\nclass Node:\n    def __init__(self, data_j):\n        self.data_j = data_j\n        self.j_next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.j_head = None\n\n    def append_d(self, data_w):\n        new_node_w = Node(data_w)\n        if self.j_head is None:\n            self.j_head = new_node_w\n            return\n        last_w = self.j_head\n        while last_w.j_next:\n            last_w = last_w.j_next\n        last_w.j_next = new_node_w\n\n    def insert_at_start_d(self, data_w):\n        new_node_w = Node(data_w)\n        new_node_w.j_next = self.j_head\n        self.j_head = new_node_w\n\n    def insert_after_node_d(self, prev_node_j, data_w):\n        if prev_node_j is None:\n            raise ValueError(\"Previous node is not in the list\")\n        new_node_w = Node(data_w)\n        new_node_w.j_next = prev_node_j.j_next\n        prev_node_j.j_next = new_node_w\n\n    def delete_node_d(self, key_w):\n        temp_vr = self.j_head\n\n        if temp_vr is not None:\n            if temp_vr.data_j == key_w:\n                self.j_head = temp_vr.j_next\n                temp_vr = None\n                return\n\n        while temp_vr is not None:\n            if temp_vr.data_j == key_w:\n                break\n            prev_vr = temp_vr\n            temp_vr = temp_vr.j_next\n\n        if temp_vr is None:\n            return\n\n        prev_vr.j_next = temp_vr.j_next\n        temp_vr = None\n\n    def print_list_d(self):\n        temp_vr = self.j_head\n        while temp_vr:\n            print(temp_vr.data_j)\n            temp_vr = temp_vr.j_next\n```"
      ]
    }
  ]
}