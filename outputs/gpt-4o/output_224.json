{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_s=None):\n        self.data_s = data_s\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data_s):\n        new_node_s = Node(data_s)\n        if self.head_s is None:\n            self.head_s = new_node_s\n            return\n        last_s = self.head_s\n        while last_s.next_s:\n            last_s = last_s.next_s\n        last_s.next_s = new_node_s\n\n    def prepend(self, data_s):\n        new_node_s = Node(data_s)\n        new_node_s.next_s = self.head_s\n        self.head_s = new_node_s\n\n    def delete_with_value(self, data_s):\n        if self.head_s is None:\n            return\n        if self.head_s.data_s == data_s:\n            self.head_s = self.head_s.next_s\n            return\n        current_s = self.head_s\n        while current_s.next_s:\n            if current_s.next_s.data_s == data_s:\n                current_s.next_s = current_s.next_s.next_s\n                return\n            current_s = current_s.next_s\n\n    def search(self, data_s):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == data_s:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def display(self):\n        current_s = self.head_s\n        elements_s = []\n        while current_s:\n            elements_s.append(current_s.data_s)\n            current_s = current_s.next_s\n        return elements_s\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_s = data\n        self.next_s = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_s is None:\n            self.head_s = new_node\n            return\n        last = self.head_s\n        while last.next_s:\n            last = last.next_s\n        last.next_s = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_s = self.head_s\n        self.head_s = new_node\n\n    def delete_node(self, key):\n        current_s = self.head_s\n        if current_s and current_s.data_s == key:\n            self.head_s = current_s.next_s\n            current_s = None\n            return\n        prev_s = None\n        while current_s and current_s.data_s != key:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        current_s = None\n\n    def search(self, key):\n        current_s = self.head_s\n        while current_s:\n            if current_s.data_s == key:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def print_list(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.data_s, end=\" \")\n            current_s = current_s.next_s\n        print()\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_xt):\n        self.data_xt = data_xt\n        self.next_xt = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data_j):\n        new_node_xt = Node(data_j)\n        if self.head_xt is None:\n            self.head_xt = new_node_xt\n        else:\n            last_xt = self.head_xt\n            while last_xt.next_xt:\n                last_xt = last_xt.next_xt\n            last_xt.next_xt = new_node_xt\n\n    def prepend(self, data_j):\n        new_node_xt = Node(data_j)\n        new_node_xt.next_xt = self.head_xt\n        self.head_xt = new_node_xt\n\n    def delete_with_value(self, data_j):\n        if self.head_xt is None:\n            return\n        if self.head_xt.data_xt == data_j:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current_xt = self.head_xt\n        while current_xt.next_xt:\n            if current_xt.next_xt.data_xt == data_j:\n                current_xt.next_xt = current_xt.next_xt.next_xt\n                return\n            current_xt = current_xt.next_xt\n\n    def find(self, data_j):\n        current_xt = self.head_xt\n        while current_xt:\n            if current_xt.data_xt == data_j:\n                return True\n            current_xt = current_xt.next_xt\n        return False\n\n    def print_list(self):\n        current_xt = self.head_xt\n        while current_xt:\n            print(current_xt.data_xt, end=\" -> \")\n            current_xt = current_xt.next_xt\n        print(\"None\")\n```",
        "```python\ndef merge_sorted_lists(list1_j, list2_j):\n    merged_list_xt = []\n    index1_xt, index2_xt = 0, 0\n    while index1_xt < len(list1_j) and index2_xt < len(list2_j):\n        if list1_j[index1_xt] < list2_j[index2_xt]:\n            merged_list_xt.append(list1_j[index1_xt])\n            index1_xt += 1\n        else:\n            merged_list_xt.append(list2_j[index2_xt])\n            index2_xt += 1\n    while index1_xt < len(list1_j):\n        merged_list_xt.append(list1_j[index1_xt])\n        index1_xt += 1\n    while index2_xt < len(list2_j):\n        merged_list_xt.append(list2_j[index2_xt])\n        index2_xt += 1\n    return merged_list_xt\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_xt):\n        self.data_xt = data_xt\n        self.next_xt = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data_xt):\n        new_node_xt = Node(data_xt)\n        if not self.head_xt:\n            self.head_xt = new_node_xt\n            return\n        last_xt = self.head_xt\n        while last_xt.next_xt:\n            last_xt = last_xt.next_xt\n        last_xt.next_xt = new_node_xt\n\n    def prepend(self, data_xt):\n        new_node_xt = Node(data_xt)\n        new_node_xt.next_xt = self.head_xt\n        self.head_xt = new_node_xt\n\n    def delete_with_value(self, data_xt):\n        if not self.head_xt:\n            return\n        if self.head_xt.data_xt == data_xt:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current_xt = self.head_xt\n        while current_xt.next_xt:\n            if current_xt.next_xt.data_xt == data_xt:\n                current_xt.next_xt = current_xt.next_xt.next_xt\n                return\n            current_xt = current_xt.next_xt\n\n    def find(self, data_xt):\n        current_xt = self.head_xt\n        while current_xt:\n            if current_xt.data_xt == data_xt:\n                return True\n            current_xt = current_xt.next_xt\n        return False\n\n    def __iter__(self):\n        current_xt = self.head_xt\n        while current_xt:\n            yield current_xt.data_xt\n            current_xt = current_xt.next_xt\n```",
        "```python\ndef merge_sorted_lists(list1_j, list2_j):\n    merged_list_j = []\n    i, j = 0, 0\n    \n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            merged_list_j.append(list1_j[i])\n            i += 1\n        else:\n            merged_list_j.append(list2_j[j])\n            j += 1\n\n    while i < len(list1_j):\n        merged_list_j.append(list1_j[i])\n        i += 1\n\n    while j < len(list2_j):\n        merged_list_j.append(list2_j[j])\n        j += 1\n\n    return merged_list_j\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_g):\n        self.data_j = data_g\n        self.next_j = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data_g):\n        new_node_j = Node(data_g)\n        if not self.head_j:\n            self.head_j = new_node_j\n            return\n        last_j = self.head_j\n        while last_j.next_j:\n            last_j = last_j.next_j\n        last_j.next_j = new_node_j\n\n    def prepend(self, data_g):\n        new_node_j = Node(data_g)\n        new_node_j.next_j = self.head_j\n        self.head_j = new_node_j\n\n    def delete_with_value(self, data_g):\n        if not self.head_j:\n            return\n        if self.head_j.data_j == data_g:\n            self.head_j = self.head_j.next_j\n            return\n        current_j = self.head_j\n        while current_j.next_j:\n            if current_j.next_j.data_j == data_g:\n                current_j.next_j = current_j.next_j.next_j\n                return\n            current_j = current_j.next_j\n\n    def find(self, data_g):\n        current_j = self.head_j\n        while current_j:\n            if current_j.data_j == data_g:\n                return True\n            current_j = current_j.next_j\n        return False\n\n    def display(self):\n        elements_j = []\n        current_j = self.head_j\n        while current_j:\n            elements_j.append(current_j.data_j)\n            current_j = current_j.next_j\n        return elements_j\n```",
        "```python\ndef merge_sorted_lists_g(list1_g, list2_g):\n    merged_list_j = []\n    index1_j, index2_j = 0, 0\n    while index1_j < len(list1_g) and index2_j < len(list2_g):\n        if list1_g[index1_j] < list2_g[index2_j]:\n            merged_list_j.append(list1_g[index1_j])\n            index1_j += 1\n        else:\n            merged_list_j.append(list2_g[index2_j])\n            index2_j += 1\n    merged_list_j.extend(list1_g[index1_j:])\n    merged_list_j.extend(list2_g[index2_j:])\n    return merged_list_j\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_j = data\n        self.next_j = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head_j is None:\n            self.head_j = new_node\n            return\n        last_j = self.head_j\n        while last_j.next_j:\n            last_j = last_j.next_j\n        last_j.next_j = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next_j = self.head_j\n        self.head_j = new_node\n\n    def delete_with_value(self, data):\n        if self.head_j is None:\n            return\n        if self.head_j.data_j == data:\n            self.head_j = self.head_j.next_j\n            return\n        current_j = self.head_j\n        while current_j.next_j:\n            if current_j.next_j.data_j == data:\n                current_j.next_j = current_j.next_j.next_j\n                return\n            current_j = current_j.next_j\n\n    def find(self, data):\n        current_j = self.head_j\n        while current_j:\n            if current_j.data_j == data:\n                return True\n            current_j = current_j.next_j\n        return False\n\n    def print_list(self):\n        current_j = self.head_j\n        while current_j:\n            print(current_j.data_j, end=\" -> \")\n            current_j = current_j.next_j\n        print(\"None\")\n```",
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n\n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n\n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_a, list2_a):\n    merged_list_a = []\n    index1_at, index2_at = 0, 0\n\n    while index1_at < len(list1_a) and index2_at < len(list2_a):\n        if list1_a[index1_at] < list2_a[index2_at]:\n            merged_list_a.append(list1_a[index1_at])\n            index1_at += 1\n        else:\n            merged_list_a.append(list2_a[index2_at])\n            index2_at += 1\n\n    merged_list_a.extend(list1_a[index1_at:])\n    merged_list_a.extend(list2_a[index2_at:])\n\n    return merged_list_a\n```\n",
        "```python\nclass Node:\n    def __init__(self, data_a, next_a=None):\n        self.data_at = data_a\n        self.next_at = next_a\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def append(self, data_a):\n        new_node_at = Node(data_a)\n        if not self.head_at:\n            self.head_at = new_node_at\n            return\n        last_at = self.head_at\n        while last_at.next_at:\n            last_at = last_at.next_at\n        last_at.next_at = new_node_at\n\n    def prepend(self, data_a):\n        new_node_at = Node(data_a, self.head_at)\n        self.head_at = new_node_at\n\n    def delete_with_value(self, data_a):\n        if not self.head_at:\n            return\n        if self.head_at.data_at == data_a:\n            self.head_at = self.head_at.next_at\n            return\n        current_at = self.head_at\n        while current_at.next_at:\n            if current_at.next_at.data_at == data_a:\n                current_at.next_at = current_at.next_at.next_at\n                return\n            current_at = current_at.next_at\n\n    def find(self, data_a):\n        current_at = self.head_at\n        while current_at:\n            if current_at.data_at == data_a:\n                return current_at\n            current_at = current_at.next_at\n        return None\n\n    def is_empty(self):\n        return self.head_at is None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list_a, list_b):\n    merged_list_a = []\n    i_a, j_a = 0, 0\n    while i_a < len(list_a) and j_a < len(list_b):\n        if list_a[i_a] < list_b[j_a]:\n            merged_list_a.append(list_a[i_a])\n            i_a += 1\n        else:\n            merged_list_a.append(list_b[j_a])\n            j_a += 1\n    while i_a < len(list_a):\n        merged_list_a.append(list_a[i_a])\n        i_a += 1\n    while j_a < len(list_b):\n        merged_list_a.append(list_b[j_a])\n        j_a += 1\n    return merged_list_a\n```",
        "```python\nclass Node:\n    def __init__(self, value_at=None):\n        self.value_at = value_at\n        self.next_at = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def append(self, value_at):\n        new_node = Node(value_at)\n        if self.head_at is None:\n            self.head_at = new_node\n            return\n        last_node_at = self.head_at\n        while last_node_at.next_at:\n            last_node_at = last_node_at.next_at\n        last_node_at.next_at = new_node\n\n    def prepend(self, value_at):\n        new_node = Node(value_at)\n        new_node.next_at = self.head_at\n        self.head_at = new_node\n\n    def delete_value(self, value_at):\n        current_node_at = self.head_at\n        if current_node_at and current_node_at.value_at == value_at:\n            self.head_at = current_node_at.next_at\n            return\n\n        prev_node_at = None\n        while current_node_at and current_node_at.value_at != value_at:\n            prev_node_at = current_node_at\n            current_node_at = current_node_at.next_at\n\n        if current_node_at is None:\n            return\n\n        prev_node_at.next_at = current_node_at.next_at\n\n    def find(self, value_at):\n        current_node_at = self.head_at\n        while current_node_at:\n            if current_node_at.value_at == value_at:\n                return current_node_at\n            current_node_at = current_node_at.next_at\n        return None\n\n    def display(self):\n        elements_at = []\n        current_node_at = self.head_at\n        while current_node_at:\n            elements_at.append(current_node_at.value_at)\n            current_node_at = current_node_at.next_at\n        return elements_at\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n\n    return merged_list\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighbors:\n    def __init__(self, k=3):\n        assert k > 0, \"k must be a positive integer\"\n        self.k = k\n        self.train_data = None\n        self.train_labels = None\n\n    def _euclidean_distance(self, x1, x2):\n        assert len(x1) == len(x2), \"Input vectors must have the same length\"\n        return np.sqrt(np.sum((x1 - x2) ** 2))\n\n    def train(self, X, y):\n        assert len(X) == len(y), \"The number of data points and labels must be the same\"\n        self.train_data = np.array(X)\n        self.train_labels = np.array(y)\n        assert self.train_data.shape[0] > 0, \"Training data must not be empty\"\n        assert self.train_data.shape[0] == self.train_labels.shape[0], \"Mismatch between data points and labels\"\n\n    def predict(self, X):\n        assert self.train_data is not None, \"Model has not been trained yet\"\n        assert self.train_labels is not None, \"Model has not been trained yet\"\n        X = np.array(X)\n        predictions = []\n        \n        for x in X:\n            distances = [self._euclidean_distance(x, point) for point in self.train_data]\n            k_indices = np.argsort(distances)[:self.k]\n            k_nearest_labels = [self.train_labels[i] for i in k_indices]\n            most_common = Counter(k_nearest_labels).most_common(1)[0][0]\n            predictions.append(most_common)\n        \n        return predictions\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\n\nclass Node:\n    def __init__(self, key: int) -> None:\n        \"\"\"\n        Initialize a new node with a specified key.\n        \n        Args:\n            key (int): The key value for the node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        \"\"\"\n        Initialize an empty BinaryTree.\n        \"\"\"\n        self.root = None\n\n    @rename_kwargs(val='key')\n    def insert(self, key: int) -> None:\n        \"\"\"\n        Insert a new node with specified key into the binary tree.\n        \n        Args:\n            key (int): The key value for the new node.\n        \"\"\"\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, current_node: Node, key: int) -> None:\n        \"\"\"\n        Recursively insert a new node with specified key in the binary tree.\n        \n        Args:\n            current_node (Node): The node to start the insertion from.\n            key (int): The key value for the new node.\n        \"\"\"\n        if key < current_node.val:\n            if current_node.left is None:\n                current_node.left = Node(key)\n            else:\n                self._insert_recursively(current_node.left, key)\n        elif key > current_node.val:\n            if current_node.right is None:\n                current_node.right = Node(key)\n            else:\n                self._insert_recursively(current_node.right, key)\n\n    @rename_kwargs(val='key')\n    def delete(self, key: int) -> None:\n        \"\"\"\n        Delete a node with specified key from the binary tree.\n        \n        Args:\n            key (int): The key value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, root: Node, key: int) -> Node:\n        \"\"\"\n        Recursively delete a node with specified key in the binary tree.\n        \n        Args:\n            root (Node): The node to start the deletion from.\n            key (int): The key value of the node to be deleted.\n        \n        Returns:\n            Node: The new root of the tree after deletion.\n        \"\"\"\n        if root is None:\n            return root\n\n        if key < root.val:\n            root.left = self._delete_recursively(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursively(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            min_val = self._find_min(root.right)\n            root.val = min_val\n            root.right = self._delete_recursively(root.right, min_val)\n\n        return root\n\n    def _find_min(self, node: Node) -> int:\n        \"\"\"\n        Find the minimum key in the binary tree.\n        \n        Args:\n            node (Node): The node to start the search from.\n        \n        Returns:\n            int: The minimum key found.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.val\n```",
        "```python\nfrom pedantic import rename_kwargs\n\n@rename_kwargs(first_num='a', second_num='b')\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm.\n\n    :param a: The first integer.\n    :param b: The second integer.\n    :return: The greatest common divisor of the two integers.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nfrom math import gcd\nfrom pedantic import rename_kwargs\n\n@rename_kwargs\ndef greatest_common_divisor(a: int, b: int) -> int:\n    return gcd(a, b)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, key_r: int):\n        self.key_r: int = key_r\n        self.left_r: Optional[Node] = None\n        self.right_r: Optional[Node] = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root_r: Optional[Node] = None\n\n    def insert(self, key_r: int) -> None:\n        if self.root_r is None:\n            self.root_r = Node(key_r)\n        else:\n            self._insert_recursive(self.root_r, key_r)\n\n    def _insert_recursive(self, node_r: Node, key_r: int) -> None:\n        if key_r < node_r.key_r:\n            if node_r.left_r is None:\n                node_r.left_r = Node(key_r)\n            else:\n                self._insert_recursive(node_r.left_r, key_r)\n        else:\n            if node_r.right_r is None:\n                node_r.right_r = Node(key_r)\n            else:\n                self._insert_recursive(node_r.right_r, key_r)\n\n    def delete(self, key_r: int) -> None:\n        self.root_r = self._delete_recursive(self.root_r, key_r)\n\n    def _delete_recursive(self, node_r: Optional[Node], key_r: int) -> Optional[Node]:\n        if node_r is None:\n            return node_r\n\n        if key_r < node_r.key_r:\n            node_r.left_r = self._delete_recursive(node_r.left_r, key_r)\n        elif key_r > node_r.key_r:\n            node_r.right_r = self._delete_recursive(node_r.right_r, key_r)\n        else:\n            if node_r.left_r is None:\n                return node_r.right_r\n            elif node_r.right_r is None:\n                return node_r.left_r\n\n            node_r.key_r = self._min_value_node(node_r.right_r).key_r\n            node_r.right_r = self._delete_recursive(node_r.right_r, node_r.key_r)\n        \n        return node_r\n\n    def _min_value_node(self, node_r: Node) -> Node:\n        current_r = node_r\n        while current_r.left_r is not None:\n            current_r = current_r.left_r\n        return current_r\n```",
        "```python\nfrom typing import Any, Optional\n\nclass Node:\n    def __init__(self, data_r: Any, next_r: Optional['Node'] = None):\n        self.data_r = data_r\n        self.next_r = next_r\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r: Optional[Node] = None\n\n    def append(self, data_r: Any) -> None:\n        new_node_r = Node(data_r)\n        if not self.head_r:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r: Any) -> None:\n        new_node_r = Node(data_r, self.head_r)\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r: Any) -> None:\n        if not self.head_r:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def find(self, data_r: Any) -> Optional[Node]:\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return current_r\n            current_r = current_r.next_r\n        return None\n\n    def display(self) -> None:\n        current_r = self.head_r\n        while current_r:\n            print(current_r.data_r)\n            current_r = current_r.next_r\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data_r):\n        new_node_r = Node(data_r)\n        if self.head_r is None:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r):\n        new_node_r = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r):\n        if self.head_r is None:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def find(self, data_r):\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return current_r\n            current_r = current_r.next_r\n        return None\n\n    def display(self):\n        current_r = self.head_r\n        elements_r = []\n        while current_r:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    merged_list_x = []\n    i_x, j_x = 0, 0\n\n    while i_x < len(list1_x) and j_x < len(list2_x):\n        if list1_x[i_x] < list2_x[j_x]:\n            merged_list_x.append(list1_x[i_x])\n            i_x += 1\n        else:\n            merged_list_x.append(list2_x[j_x])\n            j_x += 1\n\n    while i_x < len(list1_x):\n        merged_list_x.append(list1_x[i_x])\n        i_x += 1\n\n    while j_x < len(list2_x):\n        merged_list_x.append(list2_x[j_x])\n        j_x += 1\n\n    return merged_list_x\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i_x, j_x = 0, 0\n    \n    while i_x < len(list1_x) and j_x < len(list2_x):\n        if list1_x[i_x] < list2_x[j_x]:\n            merged_list.append(list1_x[i_x])\n            i_x += 1\n        else:\n            merged_list.append(list2_x[j_x])\n            j_x += 1\n\n    while i_x < len(list1_x):\n        merged_list.append(list1_x[i_x])\n        i_x += 1\n\n    while j_x < len(list2_x):\n        merged_list.append(list2_x[j_x])\n        j_x += 1\n\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass DirectedGraph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge1(self, start, end):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        self.adjacency_list[start].append(end)\n\n    def has_cycle1(self):\n        visited = set()\n        recursion_stack = set()\n\n        def visit1(node):\n            if node in recursion_stack:\n                return True\n            if node in visited:\n                return False\n\n            visited.add(node)\n            recursion_stack.add(node)\n\n            for neighbor in self.adjacency_list.get(node, []):\n                if visit1(neighbor):\n                    return True\n\n            recursion_stack.remove(node)\n            return False\n\n        for node in self.adjacency_list:\n            if visit1(node):\n                return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass DirectedGr4ph:\n    def __init__(self):\n        self.adj4cency_list = {}\n\n    def add_v3rtex(self, v3rtex):\n        if v3rtex not in self.adj4cency_list:\n            self.adj4cency_list[v3rtex] = []\n\n    def add_edg3(self, start, end):\n        if start in self.adj4cency_list:\n            self.adj4cency_list[start].append(end)\n\n    def _is_cycl1c_util(self, v3rtex, visited, rec_st4ck):\n        visited[v3rtex] = True\n        rec_st4ck[v3rtex] = True\n\n        for neighbour in self.adj4cency_list.get(v3rtex, []):\n            if not visited[neighbour]:\n                if self._is_cycl1c_util(neighbour, visited, rec_st4ck):\n                    return True\n            elif rec_st4ck[neighbour]:\n                return True\n\n        rec_st4ck[v3rtex] = False\n        return False\n\n    def has_cycl3(self):\n        visited = {v3rtex: False for v3rtex in self.adj4cency_list}\n        rec_st4ck = {v3rtex: False for v3rtex in self.adj4cency_list}\n\n        for v3rtex in self.adj4cency_list:\n            if not visited[v3rtex]:\n                if self._is_cycl1c_util(v3rtex, visited, rec_st4ck):\n                    return True\n        return False\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_e, list2_e):\n    merged_list_e = []\n    i_e, j_e = 0, 0\n    \n    while i_e < len(list1_e) and j_e < len(list2_e):\n        if list1_e[i_e] < list2_e[j_e]:\n            merged_list_e.append(list1_e[i_e])\n            i_e += 1\n        else:\n            merged_list_e.append(list2_e[j_e])\n            j_e += 1\n            \n    while i_e < len(list1_e):\n        merged_list_e.append(list1_e[i_e])\n        i_e += 1\n        \n    while j_e < len(list2_e):\n        merged_list_e.append(list2_e[j_e])\n        j_e += 1\n    \n    return merged_list_e\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(lst1_e, lst2_e):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(lst1_e) and j < len(lst2_e):\n        if lst1_e[i] < lst2_e[j]:\n            merged_list.append(lst1_e[i])\n            i += 1\n        else:\n            merged_list.append(lst2_e[j])\n            j += 1\n    merged_list.extend(lst1_e[i:])\n    merged_list.extend(lst2_e[j:])\n    return merged_list\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nfrom pedantic import timer\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n@timer()\ndef hasCycle(head_f: Optional[ListNode]) -> bool:\n    slow_f, fast_f = head_f, head_f\n    while fast_f and fast_f.next:\n        slow_f = slow_f.next\n        fast_f = fast_f.next.next\n        if slow_f == fast_f:\n            return True\n    return False\n```",
        "```python\nfrom pedantic import timer\n\n@timer\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_list_f = []\n    i_f, j_f = 0, 0\n\n    while i_f < len(list1_f) and j_f < len(list2_f):\n        if list1_f[i_f] < list2_f[j_f]:\n            merged_list_f.append(list1_f[i_f])\n            i_f += 1\n        else:\n            merged_list_f.append(list2_f[j_f])\n            j_f += 1\n\n    merged_list_f.extend(list1_f[i_f:])\n    merged_list_f.extend(list2_f[j_f:])\n\n    return merged_list_f\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import timer\n\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\n@timer\ndef has_cycle(head: ListNode) -> bool:\n    slow, fast = head, head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n\n    return False\n```",
        "```python\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    merged_list.extend(list1_f[i:])\n    merged_list.extend(list2_f[j:])\n    return merged_list\n```"
      ],
      "history_model_output": [
        "```python\nfrom sklearn.neighbors import NearestNeighbors as SklearnNearestNeighbors\nfrom pedantic import timer\n\nclass NearestNeighborsModel_r:\n    def __init__(self, n_neighbors_r=5, algorithm_r='auto'):\n        self.n_neighbors_r = n_neighbors_r\n        self.algorithm_r = algorithm_r\n        self.model_r = SklearnNearestNeighbors(n_neighbors=n_neighbors_r, algorithm=algorithm_r)\n\n    @timer\n    def train_1(self, data_f, target_f=None):\n        assert data_f is not None, \"Data must not be None\"\n        self.model_r.fit(data_f)\n        return self\n\n    @timer\n    def predict_2(self, data_f):\n        assert data_f is not None, \"Data must not be None\"\n        distances_e, indices_e = self.model_r.kneighbors(data_f)\n        return distances_e, indices_e\n```\n",
        "```python\nfrom typing import Optional\n\nclass ListNode:\n    def __init__(self, value_r: int, next_r: Optional['ListNode'] = None) -> None:\n        self.value_r = value_r\n        self.next_r = next_r\n\ndef has_cycle_f(head_f: Optional[ListNode]) -> bool:\n    \"\"\"\n    Determine if the linked list has a cycle.\n\n    Args:\n        head_f (Optional[ListNode]): The head of the linked list.\n\n    Returns:\n        bool: True if there is a cycle, False otherwise.\n    \"\"\"\n    slow_r = fast_r = head_f\n    while fast_r and fast_r.next_r:\n        slow_r = slow_r.next_r\n        fast_r = fast_r.next_r.next_r\n        if slow_r == fast_r:\n            return True\n    return False\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value_r):\n        self.value_r = value_r\n        self.left_r = None\n        self.right_r = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root_r = None\n\n    def insert_node_r(self, value_f):\n        if self.root_r is None:\n            self.root_r = TreeNode(value_f)\n        else:\n            self._insert_recursive_r(self.root_r, value_f)\n\n    def _insert_recursive_r(self, node_f, value_f):\n        if value_f < node_f.value_r:\n            if node_f.left_r is None:\n                node_f.left_r = TreeNode(value_f)\n            else:\n                self._insert_recursive_r(node_f.left_r, value_f)\n        else:\n            if node_f.right_r is None:\n                node_f.right_r = TreeNode(value_f)\n            else:\n                self._insert_recursive_r(node_f.right_r, value_f)\n\n    def delete_node_r(self, value_f):\n        self.root_r = self._delete_recursive_r(self.root_r, value_f)\n\n    def _delete_recursive_r(self, node_f, value_f):\n        if node_f is None:\n            return node_f\n\n        if value_f < node_f.value_r:\n            node_f.left_r = self._delete_recursive_r(node_f.left_r, value_f)\n        elif value_f > node_f.value_r:\n            node_f.right_r = self._delete_recursive_r(node_f.right_r, value_f)\n        else:\n            if node_f.left_r is None:\n                return node_f.right_r\n            elif node_f.right_r is None:\n                return node_f.left_r\n\n            node_f.value_r = self._min_value_r(node_f.right_r)\n            node_f.right_r = self._delete_recursive_r(node_f.right_r, node_f.value_r)\n\n        return node_f\n\n    def _min_value_r(self, node_f):\n        current_r = node_f\n        while current_r.left_r is not None:\n            current_r = current_r.left_r\n        return current_r.value_r\n```\n",
        "```python\nfrom typing import List\n\nclass DirectedGraph:\n    def __init__(self_r):\n        self_r.adj_list_r = {}\n\n    def add_edge_1(self_r, u_f: int, v_f: int):\n        if u_f not in self_r.adj_list_r:\n            self_r.adj_list_r[u_f] = []\n        self_r.adj_list_r[u_f].append(v_f)\n\n    def check_cycle_1(self_r) -> bool:\n        def dfs_1(v_f: int, visited_r: List[bool], rec_stack_r: List[bool]) -> bool:\n            visited_r[v_f] = True\n            rec_stack_r[v_f] = True\n            for neighbour_f in self_r.adj_list_r.get(v_f, []):\n                if not visited_r[neighbour_f]:\n                    if dfs_1(neighbour_f, visited_r, rec_stack_r):\n                        return True\n                elif rec_stack_r[neighbour_f]:\n                    return True\n            rec_stack_r[v_f] = False\n            return False\n        \n        num_vertices_1 = len(self_r.adj_list_r)\n        visited_r = [False] * num_vertices_1\n        rec_stack_r = [False] * num_vertices_1\n        for node_f in range(num_vertices_1):\n            if not visited_r[node_f]:\n                if dfs_1(node_f, visited_r, rec_stack_r):\n                    return True\n        return False\n```\n",
        "```python\nfrom pedantic import timer\n\n@timer\ndef greatest_common_divisor_f(a_f: int, b_f: int) -> int:\n    while b_f != 0:\n        a_f, b_f = b_f, a_f % b_f\n    return a_f\n```\n",
        "```python\nfrom pedantic.decorators import timer\n\nclass ListNode:\n    def __init__(self, value_f=None, next_f=None):\n        self.value_r = value_f\n        self.next_r = next_f\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    @timer\n    def append(self, value_f):\n        new_node_r = ListNode(value_f)\n        if not self.head_r:\n            self.head_r = new_node_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            current_r = current_r.next_r\n        current_r.next_r = new_node_r\n\n    @timer\n    def prepend(self, value_f):\n        new_node_r = ListNode(value_f, next_f=self.head_r)\n        self.head_r = new_node_r\n\n    @timer\n    def delete_value(self, value_f):\n        if not self.head_r:\n            return\n        if self.head_r.value_r == value_f:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r and current_r.next_r.value_r != value_f:\n            current_r = current_r.next_r\n        if current_r.next_r:\n            current_r.next_r = current_r.next_r.next_r\n\n    @timer\n    def find(self, value_f):\n        current_r = self.head_r\n        while current_r:\n            if current_r.value_r == value_f:\n                return current_r\n            current_r = current_r.next_r\n        return None\n\n    @timer\n    def display(self):\n        current_r = self.head_r\n        while current_r:\n            print(current_r.value_r, end=\" -> \")\n            current_r = current_r.next_r\n        print(\"None\")\n```",
        "```python\nfrom pedantic.decorators import timer\n\n@timer\ndef merge_sorted_lists_a(list1_f, list2_f):\n    merged_list_r = []\n    i_f, j_f = 0, 0\n    while i_f < len(list1_f) and j_f < len(list2_f):\n        if list1_f[i_f] <= list2_f[j_f]:\n            merged_list_r.append(list1_f[i_f])\n            i_f += 1\n        else:\n            merged_list_r.append(list2_f[j_f])\n            j_f += 1\n    merged_list_r.extend(list1_f[i_f:])\n    merged_list_r.extend(list2_f[j_f:])\n    return merged_list_r\n```\n\n"
      ]
    }
  ]
}