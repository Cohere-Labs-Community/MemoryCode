{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=3):\n        self.n_neighbors = n_neighbors\n        self.train_data = None\n        self.train_labels = None\n\n    def train(self, X, y):\n        assert X.shape[0] == y.shape[0], \"Number of samples must match number of labels\"\n        assert len(X.shape) == 2, \"Training data must be a 2D array\"\n        self.train_data = X\n        self.train_labels = y\n\n    def predict(self, X):\n        assert self.train_data is not None and self.train_labels is not None, \"Model must be trained before prediction\"\n        assert len(X.shape) == 2, \"Test data must be a 2D array\"\n        \n        predictions = []\n        for x_test in X:\n            distances = np.sqrt(np.sum((self.train_data - x_test) ** 2, axis=1))\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.train_labels[nearest_indices]\n            most_common_label = Counter(nearest_labels).most_common(1)[0][0]\n            predictions.append(most_common_label)\n        return np.array(predictions)\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []  # Ensure all nodes are in graph\n        self.edges[from_node].append((to_node, weight))\n\n    def shortest_path_o(self, start, end):\n        queue = [(0, start)]\n        distances = {node: float('inf') for node in self.edges}\n        distances[start] = 0\n        predecessors = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_node == end:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = predecessors[current_node]\n                return path[::-1], distances[end]\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    predecessors[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n        \n        return None, float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```"
      ],
      "cumulative_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_o(self, start, end, weight):\n        assert isinstance(start, str), \"Start node must be a string\"\n        assert isinstance(end, str), \"End node must be a string\"\n        assert isinstance(weight, (int, float)), \"Weight must be a number\"\n\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        self.adjacency_list[start].append((end, weight))\n\n    def shortest_path_o(self, start, goal):\n        assert start in self.adjacency_list, \"Start node must be in the graph\"\n        assert goal in self.adjacency_list, \"Goal node must be in the graph\"\n\n        queue = [(0, start)]\n        distances = {start: 0}\n        previous_nodes = {start: None}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_node == goal:\n                path = []\n                while current_node is not None:\n                    path.append(current_node)\n                    current_node = previous_nodes[current_node]\n                return path[::-1]\n\n            if current_distance > distances.get(current_node, float('inf')):\n                continue\n\n            for neighbor, weight in self.adjacency_list.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances.get(neighbor, float('inf')):\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return None\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_o=5):\n        assert isinstance(n_neighbors_o, int) and n_neighbors_o > 0, \"n_neighbors_o must be a positive integer.\"\n        self.n_neighbors_o = n_neighbors_o\n        self.data_train_o = None\n        self.labels_train_o = None\n\n    def train_o(self, data_o, labels_o):\n        assert len(data_o) == len(labels_o), \"The number of data points must match the number of labels.\"\n        self.data_train_o = np.array(data_o)\n        self.labels_train_o = np.array(labels_o)\n\n    def predict_o(self, data_o):\n        assert self.data_train_o is not None and self.labels_train_o is not None, \"Model must be trained before predictions can be made.\"\n        data_o = np.array(data_o)\n        predicted_labels_o = []\n        \n        for point_o in data_o:\n            distances_o = distance.cdist([point_o], self.data_train_o, 'euclidean')[0]\n            neighbors_indices_o = np.argsort(distances_o)[:self.n_neighbors_o]\n            neighbors_labels_o = self.labels_train_o[neighbors_indices_o]\n            most_common_o = np.bincount(neighbors_labels_o).argmax()\n            predicted_labels_o.append(most_common_o)\n        \n        return np.array(predicted_labels_o)\n```"
      ]
    }
  ]
}