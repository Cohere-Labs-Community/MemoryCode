{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        new_node = Node(data_i)\n        if not self.head_i:\n            self.head_i = new_node\n            return\n        last_node = self.head_i\n        while last_node.next_i:\n            last_node = last_node.next_i\n        last_node.next_i = new_node\n\n    def prepend(self, data_i):\n        new_node = Node(data_i)\n        new_node.next_i = self.head_i\n        self.head_i = new_node\n\n    def delete_with_value(self, data_i):\n        if not self.head_i:\n            return\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n        current_node = self.head_i\n        while current_node.next_i:\n            if current_node.next_i.data_i == data_i:\n                current_node.next_i = current_node.next_i.next_i\n                return\n            current_node = current_node.next_i\n\n    def find(self, data_i):\n        current_node = self.head_i\n        while current_node:\n            if current_node.data_i == data_i:\n                return current_node\n            current_node = current_node.next_i\n        return None\n\n    def display(self):\n        elements = []\n        current_node = self.head_i\n        while current_node:\n            elements.append(current_node.data_i)\n            current_node = current_node.next_i\n        return elements\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        new_node_i = Node(data_i)\n        if self.head_i is None:\n            self.head_i = new_node_i\n            return\n        last_i = self.head_i\n        while last_i.next_i:\n            last_i = last_i.next_i\n        last_i.next_i = new_node_i\n\n    def prepend(self, data_i):\n        new_node_i = Node(data_i)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def delete(self, key_i):\n        temp_i = self.head_i\n        if temp_i and temp_i.data_i == key_i:\n            self.head_i = temp_i.next_i\n            temp_i = None\n            return\n\n        prev_i = None\n        while temp_i and temp_i.data_i != key_i:\n            prev_i = temp_i\n            temp_i = temp_i.next_i\n\n        if temp_i is None:\n            return\n\n        prev_i.next_i = temp_i.next_i\n        temp_i = None\n\n    def search(self, key_i):\n        current_i = self.head_i\n        while current_i and current_i.data_i != key_i:\n            current_i = current_i.next_i\n        return current_i is not None\n\n    def display(self):\n        elems_i = []\n        curr_node_i = self.head_i\n        while curr_node_i:\n            elems_i.append(curr_node_i.data_i)\n            curr_node_i = curr_node_i.next_i\n        return elems_i\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, value: int):\n        self.value_r: int = value\n        self.left_r: Optional['TreeNode'] = None\n        self.right_r: Optional['TreeNode'] = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root_r: Optional[TreeNode] = None\n\n    def insert(self, value: int) -> None:\n        new_node_r = TreeNode(value)\n        if self.root_r is None:\n            self.root_r = new_node_r\n        else:\n            self._insert_recursive(self.root_r, new_node_r)\n\n    def _insert_recursive(self, current_r: TreeNode, new_node_r: TreeNode) -> None:\n        if new_node_r.value_r < current_r.value_r:\n            if current_r.left_r is None:\n                current_r.left_r = new_node_r\n            else:\n                self._insert_recursive(current_r.left_r, new_node_r)\n        else:\n            if current_r.right_r is None:\n                current_r.right_r = new_node_r\n            else:\n                self._insert_recursive(current_r.right_r, new_node_r)\n\n    def delete(self, value: int) -> None:\n        self.root_r = self._delete_recursive(self.root_r, value)\n\n    def _delete_recursive(self, current_r: Optional[TreeNode], value: int) -> Optional[TreeNode]:\n        if current_r is None:\n            return None\n        if value < current_r.value_r:\n            current_r.left_r = self._delete_recursive(current_r.left_r, value)\n        elif value > current_r.value_r:\n            current_r.right_r = self._delete_recursive(current_r.right_r, value)\n        else:\n            if current_r.left_r is None:\n                return current_r.right_r\n            elif current_r.right_r is None:\n                return current_r.left_r\n            temp_r = self._min_value_node(current_r.right_r)\n            current_r.value_r = temp_r.value_r\n            current_r.right_r = self._delete_recursive(current_r.right_r, temp_r.value_r)\n        return current_r\n\n    def _min_value_node(self, node_r: TreeNode) -> TreeNode:\n        current_r = node_r\n        while current_r.left_r is not None:\n            current_r = current_r.left_r\n        return current_r\n```",
        "```python\nfrom typing import Optional, Any\n\nclass Node:\n    def __init__(self, data_r: Any) -> None:\n        self.data_r: Any = data_r\n        self.next_r: Optional['Node'] = None\n\nclass LinkedList:\n    def __init__(self) -> None:\n        self.head_r: Optional[Node] = None\n\n    def append(self, data_r: Any) -> None:\n        new_node_r: Node = Node(data_r)\n        if not self.head_r:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r: Any) -> None:\n        new_node_r: Node = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r: Any) -> None:\n        if not self.head_r:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def find(self, data_r: Any) -> Optional[Node]:\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return current_r\n            current_r = current_r.next_r\n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data_r):\n        new_node_r = Node(data_r)\n        if self.head_r is None:\n            self.head_r = new_node_r\n            return\n        last_r = self.head_r\n        while last_r.next_r:\n            last_r = last_r.next_r\n        last_r.next_r = new_node_r\n\n    def prepend(self, data_r):\n        new_node_r = Node(data_r)\n        new_node_r.next_r = self.head_r\n        self.head_r = new_node_r\n\n    def delete_with_value(self, data_r):\n        if self.head_r is None:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        while current_r.next_r:\n            if current_r.next_r.data_r == data_r:\n                current_r.next_r = current_r.next_r.next_r\n                return\n            current_r = current_r.next_r\n\n    def find(self, data_r):\n        current_r = self.head_r\n        while current_r:\n            if current_r.data_r == data_r:\n                return current_r\n            current_r = current_r.next_r\n        return None\n\n    def display(self):\n        current_r = self.head_r\n        elements_r = []\n        while current_r:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value: int_r):\n        self.value_r: int_r = value\n        self.left_r: TreeNode | None = None\n        self.right_r: TreeNode | None = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root_r: TreeNode | None = None\n\n    def insert(self, value_r: int_r) -> None:\n        if self.root_r is None:\n            self.root_r = TreeNode(value_r)\n        else:\n            self._insert_recursively(self.root_r, value_r)\n\n    def _insert_recursively(self, node_r: TreeNode, value_r: int_r) -> None:\n        if value_r < node_r.value_r:\n            if node_r.left_r is None:\n                node_r.left_r = TreeNode(value_r)\n            else:\n                self._insert_recursively(node_r.left_r, value_r)\n        else:\n            if node_r.right_r is None:\n                node_r.right_r = TreeNode(value_r)\n            else:\n                self._insert_recursively(node_r.right_r, value_r)\n\n    def delete(self, value_r: int_r) -> None:\n        self.root_r = self._delete_recursively(self.root_r, value_r)\n\n    def _delete_recursively(self, node_r: TreeNode | None, value_r: int_r) -> TreeNode | None:\n        if node_r is None:\n            return None\n        if value_r < node_r.value_r:\n            node_r.left_r = self._delete_recursively(node_r.left_r, value_r)\n        elif value_r > node_r.value_r:\n            node_r.right_r = self._delete_recursively(node_r.right_r, value_r)\n        else:\n            if node_r.left_r is None:\n                return node_r.right_r\n            elif node_r.right_r is None:\n                return node_r.left_r\n            temp_r = self._find_min(node_r.right_r)\n            node_r.value_r = temp_r.value_r\n            node_r.right_r = self._delete_recursively(node_r.right_r, temp_r.value_r)\n        return node_r\n\n    def _find_min(self, node_r: TreeNode) -> TreeNode:\n        current_r = node_r\n        while current_r.left_r is not None:\n            current_r = current_r.left_r\n        return current_r\n```",
        "```python\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data_r: int = data\n        self.next_r: 'Node' | None = None\n\nclass LinkedList:\n    def __init__(self) -> None:\n        self.head_r: Node | None = None\n\n    def append(self, data: int) -> None:\n        new_node = Node(data)\n        if self.head_r is None:\n            self.head_r = new_node\n        else:\n            last_r = self.head_r\n            while last_r.next_r is not None:\n                last_r = last_r.next_r\n            last_r.next_r = new_node\n\n    def insert(self, prev_node: Node, data: int) -> None:\n        if prev_node is None:\n            raise ValueError(\"Previous node must be in the LinkedList.\")\n        new_node = Node(data)\n        new_node.next_r = prev_node.next_r\n        prev_node.next_r = new_node\n\n    def delete_node(self, key: int) -> None:\n        temp_r = self.head_r\n\n        if temp_r is not None:\n            if temp_r.data_r == key:\n                self.head_r = temp_r.next_r\n                temp_r = None\n                return\n\n        prev_r = None\n        while temp_r is not None:\n            if temp_r.data_r == key:\n                break\n            prev_r = temp_r\n            temp_r = temp_r.next_r\n\n        if temp_r is None:\n            return\n\n        prev_r.next_r = temp_r.next_r\n        temp_r = None\n\n    def search(self, key: int) -> bool:\n        current_r = self.head_r\n        while current_r is not None:\n            if current_r.data_r == key:\n                return True\n            current_r = current_r.next_r\n        return False\n\n    def get_all_elements(self) -> list[int]:\n        elements_r = []\n        current_r = self.head_r\n        while current_r is not None:\n            elements_r.append(current_r.data_r)\n            current_r = current_r.next_r\n        return elements_r\n```"
      ]
    }
  ]
}