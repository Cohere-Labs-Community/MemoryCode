{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert isinstance(matrix, list) and all(isinstance(row, list) for row in matrix), \"Input must be a list of lists.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    \n    return diagonal_sum / n\n\nclass MatrixProcessor1:\n    def process_matrix(self, matrix):\n        return average_diagonal(matrix)\n```",
        "```python\nimport numpy as np\n\nclass PCA1:\n    def __init__(self, n_components):\n        assert isinstance(n_components, int) and n_components > 0, \"n_components must be a positive integer\"\n        self.n_components = n_components\n        self.components = None\n        self.mean = None\n\n    def fit(self, X):\n        assert isinstance(X, np.ndarray), \"Input data must be a NumPy array\"\n        assert X.ndim == 2, \"Input data must be a 2D array\"\n        \n        # Centering the data\n        self.mean = np.mean(X, axis=0)\n        X_centered = X - self.mean\n        \n        # Computing covariance matrix\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n        \n        # Eigen decomposition\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n        \n        # Sorting eigenvectors by eigenvalues in descending order\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        eigenvectors_sorted = eigenvectors[:, sorted_indices]\n        eigenvalues_sorted = eigenvalues[sorted_indices]\n        \n        # Storing first n_components\n        self.components = eigenvectors_sorted[:, :self.n_components]\n\n    def transform(self, X):\n        assert isinstance(X, np.ndarray), \"Input data must be a NumPy array\"\n        assert X.ndim == 2, \"Input data must be a 2D array\"\n        assert self.mean is not None, \"The model has not been fitted yet\"\n        assert self.components is not None, \"The model components are not initialized\"\n        \n        X_centered = X - self.mean\n        return np.dot(X_centered, self.components)\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```",
        "```python\nimport numpy as np\n\nclass PCA1:\n    def __init__(self, n_components):\n        self.n_components = n_components\n        self.mean_ = None\n        self.components_ = None\n        self.explained_variance_ = None\n        self.explained_variance_ratio_ = None\n\n    def fit(self, X):\n        self.mean_ = np.mean(X, axis=0)\n        X_centered = X - self.mean_\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        eigenvalues = eigenvalues[sorted_indices]\n        eigenvectors = eigenvectors[:, sorted_indices]\n        self.components_ = eigenvectors[:, :self.n_components]\n        self.explained_variance_ = eigenvalues[:self.n_components]\n        total_variance = eigenvalues.sum()\n        self.explained_variance_ratio_ = eigenvalues[:self.n_components] / total_variance\n\n    def transform(self, X):\n        X_centered = X - self.mean_\n        return np.dot(X_centered, self.components_)\n\n    def fit_transform(self, X):\n        self.fit(X)\n        return self.transform(X)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list:\n            self.adjacency_list[node1] = []\n        if node2 not in self.adjacency_list:\n            self.adjacency_list[node2] = []\n        self.adjacency_list[node1].append((node2, weight))\n        self.adjacency_list[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            if current_distance > distances[current_node]:\n                continue\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list_ud = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node1] = []\n        if node2 not in self.adjacency_list_ud:\n            self.adjacency_list_ud[node2] = []\n        self.adjacency_list_ud[node1].append((node2, weight))\n        self.adjacency_list_ud[node2].append((node1, weight))\n\n    def shortest_path_ud(self, start_node, end_node):\n        if start_node not in self.adjacency_list_ud or end_node not in self.adjacency_list_ud:\n            return None\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.adjacency_list_ud}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.adjacency_list_ud}\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_distance > distances[current_node]:\n                continue\n                \n            for neighbor, weight in self.adjacency_list_ud[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n                    \n        path, current = [], end_node\n        while previous_nodes[current] is not None:\n            path.append(current)\n            current = previous_nodes[current]\n        if path or start_node == end_node:\n            path.append(start_node)\n        return path[::-1] if path else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef chx_flatten_binary_tree(root):\n    def chx_flatten(root):\n        if not root:\n            return None\n\n        left_tail = chx_flatten(root.left)\n        right_tail = chx_flatten(root.right)\n\n        if root.left:\n            left_tail.right = root.right\n            root.right = root.left\n            root.left = None\n\n        return right_tail if right_tail else left_tail if left_tail else root\n\n    chx_flatten(root)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef chx_flatten_binary_tree(root):\n    if not root:\n        return\n\n    stack = [root]\n    while stack:\n        current = stack.pop()\n\n        if current.right:\n            stack.append(current.right)\n        if current.left:\n            stack.append(current.left)\n\n        if stack:\n            current.right = stack[-1]\n        current.left = None\n```"
      ],
      "cumulative_model_output": [
        "```python\nimport numpy as np\n\nclass PCA1:\n    def __init__(self, n_components):\n        assert isinstance(n_components, int), \"n_components must be an integer\"\n        self.n_components = n_components\n        self.components_ = None\n        self.mean_ = None\n\n    def fit_chx(self, X):\n        assert isinstance(X, np.ndarray), \"Input must be a numpy array\"\n        assert X.ndim == 2, \"Input array must be two-dimensional\"\n\n        self.mean_ = np.mean(X, axis=0)\n        X_centered = X - self.mean_\n\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix)\n\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        self.components_ = eigenvectors[:, sorted_indices[:self.n_components]]\n\n    def transform_chx(self, X):\n        assert isinstance(X, np.ndarray), \"Input must be a numpy array\"\n        assert X.ndim == 2, \"Input array must be two-dimensional\"\n\n        X_centered = X - self.mean_\n        return np.dot(X_centered, self.components_)\n\n    def fit_transform_chx(self, X):\n        self.fit_chx(X)\n        return self.transform_chx(X)\n```\n",
        "```python\nclass TreeNode1:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef flattenchx_ud(root):\n    assert isinstance(root, TreeNode1) or root is None, \"Input must be a TreeNode1 instance or None\"\n    \n    def flatten_subtreeschx_ud(node):\n        assert isinstance(node, TreeNode1) or node is None, \"Node must be a TreeNode1 instance or None\"\n        if not node:\n            return None\n        \n        if not node.left and not node.right:\n            return node\n        \n        left_tail = flatten_subtreeschx_ud(node.left)\n        right_tail = flatten_subtreeschx_ud(node.right)\n        \n        if left_tail:\n            left_tail.right = node.right\n            node.right = node.left\n            node.left = None\n        \n        return right_tail if right_tail else left_tail\n    \n    flatten_subtreeschx_ud(root)\n```",
        "```python\ndef chx_compute_diagonal_avg(matrix):\n    assert isinstance(matrix, list) and all(isinstance(row, list) for row in matrix), \"Input must be a list of lists\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n\n    diagonal_sum = 0\n    dimension = len(matrix)\n    \n    for i in range(dimension):\n        diagonal_sum += matrix[i][i]\n        \n    return diagonal_sum / dimension\n```",
        "```python\nimport heapq\n\nclass Graph1:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_ud(self, node1, node2, weight):\n        if node1 not in self.adjacency_list:\n            self.adjacency_list[node1] = []\n        if node2 not in self.adjacency_list:\n            self.adjacency_list[node2] = []\n        self.adjacency_list[node1].append((node2, weight))\n        self.adjacency_list[node2].append((node1, weight))\n\n    def shortest_path_chx_ud(self, start_node, end_node):\n        assert start_node in self.adjacency_list, \"Start node must be in the graph\"\n        assert end_node in self.adjacency_list, \"End node must be in the graph\"\n\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start_node] = 0\n        priority_queue = [(0, start_node)]\n        previous_nodes = {node: None for node in self.adjacency_list}\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        \n        path.reverse()\n        return path if distances[end_node] != float('inf') else None\n```"
      ]
    }
  ]
}