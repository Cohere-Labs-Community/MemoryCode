{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def p_add_stock(self, item, quantity):\n        assert isinstance(item, str), \"Item must be a string\"\n        assert isinstance(quantity, int) and quantity > 0, \"Quantity must be a positive integer\"\n        \n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        assert item in self._stock, \"Item must exist in stock\"\n        assert isinstance(quantity, int) and 0 < quantity <= self._stock[item], \"Quantity must be a positive integer and not exceed stock\"\n        \n        self._stock[item] -= quantity\n        if self._stock[item] == 0:\n            del self._stock[item]\n```",
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighbors:\n    def __init__(self, k=3):\n        assert isinstance(k, int) and k > 0, \"k must be a positive integer\"\n        self.k = k\n        self.train_data = None\n        self.train_labels = None\n\n    def p_train(self, data, labels):\n        assert data is not None and labels is not None, \"Data and labels cannot be None\"\n        assert len(data) == len(labels), \"Data and labels must have the same length\"\n        self.train_data = np.array(data)\n        self.train_labels = np.array(labels)\n\n    def p_euclidean_distance(self, point1, point2):\n        assert point1 is not None and point2 is not None, \"Points cannot be None\"\n        return np.sqrt(np.sum((np.array(point1) - np.array(point2)) ** 2))\n\n    def p_predict(self, query_point):\n        assert self.train_data is not None and self.train_labels is not None, \"Model has not been trained yet\"\n        assert query_point is not None, \"Query point cannot be None\"\n\n        # Calculate all distances from the query point to the training data\n        distances = [self.p_euclidean_distance(query_point, data_point) for data_point in self.train_data]\n\n        # Find the labels of the k-nearest neighbors\n        nearest_indices = np.argsort(distances)[:self.k]\n        nearest_labels = [self.train_labels[i] for i in nearest_indices]\n\n        # Determine the most common label among the nearest labels\n        most_common_label = Counter(nearest_labels).most_common(1)[0][0]\n        \n        return most_common_label\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def p_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist\")\n```",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    \n    def __init__(self):\n        self.stock = {}\n\n    def x_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def x_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n            return True\n        else:\n            return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def x_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def x_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            if self._items[item_name] >= quantity:\n                self._items[item_name] -= quantity\n                if self._items[item_name] == 0:\n                    del self._items[item_name]\n            else:\n                raise ValueError(\"Quantity to remove exceeds current stock.\")\n        else:\n            raise KeyError(f\"Item '{item_name}' not found in inventory.\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n            return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n            return True\n        return False\n\n    def a_get_stock(self, item):\n        return self._stock.get(item, 0)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\nfrom collections import Counter\n\n@retry\ndef majority_element(arr):\n    count = Counter(arr)\n    return max(count.keys(), key=count.get)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import retry\nfrom collections import defaultdict\n\n@retry\ndef find_majority_element(nums):\n    count_dict = defaultdict(int)\n    majority_count = len(nums) // 2\n    \n    for num in nums:\n        count_dict[num] += 1\n        if count_dict[num] > majority_count:\n            return num\n\n    return None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def b_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def b_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] -= quantity\n            if self._items[item_name] <= 0:\n                del self._items[item_name]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def b_add_stock(self, item, quantity):\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        if item in self.items:\n            if self.items[item] >= quantity:\n                self.items[item] -= quantity\n                if self.items[item] == 0:\n                    del self.items[item]\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal(matrix):\n    \"\"\"Computes the average of the diagonal elements of a given square matrix.\"\"\"\n    \n    assert isinstance(matrix, list), \"Input must be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"Matrix must be a list of lists.\"\n    assert len(matrix) == len(matrix[0]), \"Matrix must be square.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Each row in the matrix must have the same length as the number of rows.\"\n\n    diagonal_elements = [matrix[i][i] for i in range(len(matrix))]\n    return sum(diagonal_elements) / len(diagonal_elements)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import trace_class\n\n@trace_class\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def n_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def n_remove_stock(self, item_name, quantity):\n        if item_name in self.stock and self.stock[item_name] >= quantity:\n            self.stock[item_name] -= quantity\n            if self.stock[item_name] == 0:\n                del self.stock[item_name]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist.\")\n```",
        "```python\nfrom sklearn.metrics.pairwise import pairwise_kernels\nimport numpy as np\nfrom pedantic import trace_class\n\n@trace_class\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', **kwargs):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.kwargs = kwargs\n        self.X_train = None\n        self.alpha_y = None\n        self.K_inv = None\n\n    def n_fit(self, X, y):\n        self.X_train = X\n        K = pairwise_kernels(X, X, metric=self.kernel, **self.kwargs)\n        n_samples = K.shape[0]\n        self.K_inv = np.linalg.inv(K + self.alpha * np.eye(n_samples))\n        self.alpha_y = self.K_inv @ y\n\n    def n_predict(self, X):\n        K_test = pairwise_kernels(X, self.X_train, metric=self.kernel, **self.kwargs)\n        return K_test @ self.alpha_y\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def n_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def n_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock or item not available\")\n```",
        "```python\nfrom pedantic import trace_class\nimport numpy as np\n\n@trace_class\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', gamma=None, degree=3, coef0=1):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n        self.X_train = None\n        self.alpha_ = None\n    \n    def _linear_kernel(self, X, Y):\n        return np.dot(X, Y.T)\n\n    def _polynomial_kernel(self, X, Y):\n        return (np.dot(X, Y.T) + self.coef0) ** self.degree\n\n    def _rbf_kernel(self, X, Y):\n        if self.gamma is None:\n            self.gamma = 1.0 / X.shape[1]\n        K = np.sum(X ** 2, axis=1).reshape(-1, 1) + np.sum(Y ** 2, axis=1) - 2 * np.dot(X, Y.T)\n        return np.exp(-self.gamma * K)\n\n    def _get_kernel(self, X, Y):\n        if self.kernel == 'linear':\n            return self._linear_kernel(X, Y)\n        elif self.kernel == 'polynomial':\n            return self._polynomial_kernel(X, Y)\n        elif self.kernel == 'rbf':\n            return self._rbf_kernel(X, Y)\n        else:\n            raise ValueError(\"Unknown kernel type\")\n\n    def fit(self, X, y):\n        self.X_train = X\n        K = self._get_kernel(X, X)\n        n_samples = X.shape[0]\n        self.alpha_ = np.linalg.solve(K + self.alpha * np.eye(n_samples), y)\n\n    def predict(self, X):\n        K = self._get_kernel(X, self.X_train)\n        return np.dot(K, self.alpha_)\n\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n        else:\n            raise ValueError(\"Cannot remove more stock than available or item does not exist.\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n    \n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n    \n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock to remove the requested quantity.\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef md_longest_common_prefix(strs):\n    \"\"\"\n    Determine the longest common prefix string amongst an array of strings.\n\n    Parameters:\n    strs (list of str): A list of strings for which to find the longest common prefix.\n\n    Returns:\n    str: The longest common prefix among the strings. If there is no common prefix, returns an empty string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix\n```",
        "```python\nclass Inventory:\n    \"\"\"\n    Class to represent an Inventory system that allows adding and removing stock items.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of the Inventory class with an empty dictionary to hold stock items.\n        \"\"\"\n        self.stock = {}\n    \n    def md_add_stock(self, item_name, quantity):\n        \"\"\"\n        Adds stock for a specific item, incrementing the quantity if the item already exists.\n\n        Parameters:\n        item_name (str): The name of the item to add to the inventory.\n        quantity (int): The quantity of the item to add to the inventory.\n\n        Returns:\n        None\n        \"\"\"\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n    \n    def md_remove_stock(self, item_name, quantity):\n        \"\"\"\n        Removes stock for a specific item, decrementing the quantity if enough stock exists.\n\n        Parameters:\n        item_name (str): The name of the item to remove from the inventory.\n        quantity (int): The quantity of the item to remove from the inventory.\n\n        Returns:\n        bool: True if the stock was successfully removed, False if there wasn't enough stock.\n        \"\"\"\n        if item_name in self.stock and self.stock[item_name] >= quantity:\n            self.stock[item_name] -= quantity\n            if self.stock[item_name] == 0:\n                del self.stock[item_name]\n            return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n        \n    def md_add_stock(self, item, quantity):\n        if item not in self.stock:\n            self.stock[item] = 0\n        self.stock[item] += quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i, j, k = 0, 0, 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self._stock = {}\n\n    def o_add_stock_b(self, item, quantity):\n        if item in self._stock:\n            self._stock[item] += quantity\n        else:\n            self._stock[item] = quantity\n\n    def o_remove_stock_b(self, item, quantity):\n        if item in self._stock and self._stock[item] >= quantity:\n            self._stock[item] -= quantity\n            if self._stock[item] == 0:\n                del self._stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found.\")\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            if self.stock[item_name] >= quantity:\n                self.stock[item_name] -= quantity\n            else:\n                raise ValueError(\"Cannot remove more stock than available\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_x(m_arr):\n    if len(m_arr) > 1:\n        m_mid = len(m_arr) // 2\n        m_L = m_arr[:m_mid]\n        m_R = m_arr[m_mid:]\n\n        merge_sort_x(m_L)\n        merge_sort_x(m_R)\n\n        m_i = m_j = m_k = 0\n\n        while m_i < len(m_L) and m_j < len(m_R):\n            if m_L[m_i] < m_R[m_j]:\n                m_arr[m_k] = m_L[m_i]\n                m_i += 1\n            else:\n                m_arr[m_k] = m_R[m_j]\n                m_j += 1\n            m_k += 1\n\n        while m_i < len(m_L):\n            m_arr[m_k] = m_L[m_i]\n            m_i += 1\n            m_k += 1\n\n        while m_j < len(m_R):\n            m_arr[m_k] = m_R[m_j]\n            m_j += 1\n            m_k += 1\n```",
        "```python\ndef is_valid_sudoku_x(m_board):\n    def is_valid_unit_x(m_unit):\n        m_elements = [m_num for m_num in m_unit if m_num != '.']\n        return len(m_elements) == len(set(m_elements))\n    \n    def is_valid_row_x(m_board):\n        for m_row in m_board:\n            if not is_valid_unit_x(m_row):\n                return False\n        return True\n    \n    def is_valid_column_x(m_board):\n        for m_col in range(9):\n            if not is_valid_unit_x([m_board[m_row][m_col] for m_row in range(9)]):\n                return False\n        return True\n    \n    def is_valid_subbox_x(m_board):\n        for m_row in range(0, 9, 3):\n            for m_col in range(0, 9, 3):\n                m_subbox = [m_board[m_row + m_i][m_col + m_j] for m_i in range(3) for m_j in range(3)]\n                if not is_valid_unit_x(m_subbox):\n                    return False\n        return True\n    \n    return is_valid_row_x(m_board) and is_valid_column_x(m_board) and is_valid_subbox_x(m_board)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\ndef m_is_valid_sudoku(m_board):\n    def m_is_valid_unit(m_unit):\n        m_unit = [m_num for m_num in m_unit if m_num != '.']\n        return len(m_unit) == len(set(m_unit))\n\n    def m_is_valid_row(m_board):\n        for m_row in m_board:\n            if not m_is_valid_unit(m_row):\n                return False\n        return True\n\n    def m_is_valid_col(m_board):\n        for m_col in zip(*m_board):\n            if not m_is_valid_unit(m_col):\n                return False\n        return True\n\n    def m_is_valid_box(m_board):\n        for m_i in (0, 3, 6):\n            for m_j in (0, 3, 6):\n                m_box = [m_board[m_x][m_y] for m_x in range(m_i, m_i + 3) for m_y in range(m_j, m_j + 3)]\n                if not m_is_valid_unit(m_box):\n                    return False\n        return True\n\n    return m_is_valid_row(m_board) and m_is_valid_col(m_board) and m_is_valid_box(m_board)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = {}\n        self.covariances_ = {}\n        self.priors_ = {}\n        self.classes_ = None\n\n    def fit(self, X, y):\n        self.classes_ = np.unique(y)\n        for cls in self.classes_:\n            X_class = X[y == cls]\n            self.means_[cls] = np.mean(X_class, axis=0)\n            self.covariances_[cls] = np.cov(X_class, rowvar=False)\n            self.priors_[cls] = X_class.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        predictions = [self._predict_single(sample) for sample in X]\n        return np.array(predictions)\n\n    def _predict_single(self, x):\n        scores = {}\n        for cls in self.classes_:\n            mean = self.means_[cls]\n            covariance = self.covariances_[cls]\n            prior = self.priors_[cls]\n            inv_cov = np.linalg.inv(covariance)\n            diff = x - mean\n            \n            score = -0.5 * np.dot(np.dot(diff.T, inv_cov), diff) \\\n                    - 0.5 * np.log(np.linalg.det(covariance)) \\\n                    + np.log(prior)\n            \n            scores[cls] = score\n        \n        return max(scores, key=scores.get)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_gn(w_array):\n    if len(w_array) > 1:\n        w_mid = len(w_array) // 2\n        w_left_half = w_array[:w_mid]\n        w_right_half = w_array[w_mid:]\n\n        merge_sort_gn(w_left_half)\n        merge_sort_gn(w_right_half)\n\n        w_i = w_j = w_k = 0\n\n        while w_i < len(w_left_half) and w_j < len(w_right_half):\n            if w_left_half[w_i] < w_right_half[w_j]:\n                w_array[w_k] = w_left_half[w_i]\n                w_i += 1\n            else:\n                w_array[w_k] = w_right_half[w_j]\n                w_j += 1\n            w_k += 1\n\n        while w_i < len(w_left_half):\n            w_array[w_k] = w_left_half[w_i]\n            w_i += 1\n            w_k += 1\n\n        while w_j < len(w_right_half):\n            w_array[w_k] = w_right_half[w_j]\n            w_j += 1\n            w_k += 1\n```",
        "```python\ndef is_valid_sudoku_gn(w_board):\n    def is_valid_block_gn(w_block):\n        w_block = [w_num for w_num in w_block if w_num != '.']\n        return len(w_block) == len(set(w_block))\n\n    for w_row in w_board:\n        if not is_valid_block_gn(w_row):\n            return False\n\n    for w_col in zip(*w_board):\n        if not is_valid_block_gn(w_col):\n            return False\n\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_block = [w_board[w_x][w_y] for w_x in range(w_i, w_i + 3) for w_y in range(w_j, w_j + 3)]\n            if not is_valid_block_gn(w_block):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_gn(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_gn(left_half)\n        merge_sort_gn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\ndef is_valid_sudoku(w_board):\n    def is_valid_block(w_block):\n        w_nums = [num for num in w_block if num != '.']\n        return len(w_nums) == len(set(w_nums))\n    \n    for w_row in w_board:\n        if not is_valid_block(w_row):\n            return False\n    \n    for w_col in zip(*w_board):\n        if not is_valid_block(w_col):\n            return False\n    \n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_block = [w_board[w_x][w_y] for w_x in range(w_i, w_i + 3) for w_y in range(w_j, w_j + 3)]\n            if not is_valid_block(w_block):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_y(arr):\n    if len(arr) > 1:\n        mid_y = len(arr) // 2\n        left_half_y = arr[:mid_y]\n        right_half_y = arr[mid_y:]\n\n        merge_sort_y(left_half_y)\n        merge_sort_y(right_half_y)\n\n        i_y = j_y = k_y = 0\n\n        while i_y < len(left_half_y) and j_y < len(right_half_y):\n            if left_half_y[i_y] < right_half_y[j_y]:\n                arr[k_y] = left_half_y[i_y]\n                i_y += 1\n            else:\n                arr[k_y] = right_half_y[j_y]\n                j_y += 1\n            k_y += 1\n\n        while i_y < len(left_half_y):\n            arr[k_y] = left_half_y[i_y]\n            i_y += 1\n            k_y += 1\n\n        while j_y < len(right_half_y):\n            arr[k_y] = right_half_y[j_y]\n            j_y += 1\n            k_y += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_y(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_y(left_half)\n        merge_sort_y(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef y_is_valid_sudoku(y_board):\n    def y_is_valid_block(y_block):\n        y_block = [y_num for y_num in y_block if y_num != '.']\n        return len(y_block) == len(set(y_block))\n\n    for y_row in y_board:\n        if not y_is_valid_block(y_row):\n            return False\n\n    for y_col in range(9):\n        if not y_is_valid_block([y_board[y_row][y_col] for y_row in range(9)]):\n            return False\n\n    for y_row in range(0, 9, 3):\n        for y_col in range(0, 9, 3):\n            y_block = [y_board[y_r][y_c] for y_r in range(y_row, y_row + 3) for y_c in range(y_col, y_col + 3)]\n            if not y_is_valid_block(y_block):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef y_is_valid_sudoku(y_board):\n    y_rows = len(y_board)\n    y_columns = len(y_board[0])\n    \n    if y_rows != 9 or y_columns != 9:\n        return False\n    \n    def y_is_valid_group(y_group):\n        y_elements = [num for num in y_group if num != '.']\n        return len(y_elements) == len(set(y_elements))\n    \n    for y_row in y_board:\n        if not y_is_valid_group(y_row):\n            return False\n    \n    for y_col in range(9):\n        y_column_numbers = [y_board[y_row][y_col] for y_row in range(9)]\n        if not y_is_valid_group(y_column_numbers):\n            return False\n    \n    for y_box_row in range(0, 9, 3):\n        for y_box_col in range(0, 9, 3):\n            y_box_numbers = [y_board[y_row][y_col] \n                             for y_row in range(y_box_row, y_box_row + 3) \n                             for y_col in range(y_box_col, y_box_col + 3)]\n            if not y_is_valid_group(y_box_numbers):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid_group(x_group):\n        x_elements = [x_elm for x_elm in x_group if x_elm != '.']\n        return len(set(x_elements)) == len(x_elements)\n\n    for x_row in x_board:\n        if not x_is_valid_group(x_row):\n            return False\n    \n    for x_col_index in range(9):\n        x_column = [x_board[x_row_index][x_col_index] for x_row_index in range(9)]\n        if not x_is_valid_group(x_column):\n            return False\n\n    for x_box_row in range(3):\n        for x_box_col in range(3):\n            x_box = [\n                x_board[x_row][x_col]\n                for x_row in range(x_box_row * 3, x_box_row * 3 + 3)\n                for x_col in range(x_box_col * 3, x_box_col * 3 + 3)\n            ]\n            if not x_is_valid_group(x_box):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid(x_entries):\n        x_seen = set()\n        for x_num in x_entries:\n            if x_num != '.':\n                if x_num in x_seen:\n                    return False\n                x_seen.add(x_num)\n        return True\n\n    for x_row in x_board:\n        if not x_is_valid(x_row):\n            return False\n\n    for x_col_idx in range(9):\n        x_column = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n        if not x_is_valid(x_column):\n            return False\n\n    for x_box_row in range(0, 9, 3):\n        for x_box_col in range(0, 9, 3):\n            x_box = [x_board[x_row][x_col] for x_row in range(x_box_row, x_box_row + 3) for x_col in range(x_box_col, x_box_col + 3)]\n            if not x_is_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_a(chxarr):\n    if len(chxarr) > 1:\n        chxmid = len(chxarr) // 2\n        chxleft_half = chxarr[:chxmid]\n        chxright_half = chxarr[chxmid:]\n\n        merge_sort_a(chxleft_half)\n        merge_sort_a(chxright_half)\n\n        chi, chjj, chkk = 0, 0, 0\n\n        while chi < len(chxleft_half) and chjj < len(chxright_half):\n            if chxleft_half[chi] < chxright_half[chjj]:\n                chxarr[chkk] = chxleft_half[chi]\n                chi += 1\n            else:\n                chxarr[chkk] = chxright_half[chjj]\n                chjj += 1\n            chkk += 1\n\n        while chi < len(chxleft_half):\n            chxarr[chkk] = chxleft_half[chi]\n            chi += 1\n            chkk += 1\n\n        while chjj < len(chxright_half):\n            chxarr[chkk] = chxright_half[chjj]\n            chjj += 1\n            chkk += 1\n```",
        "```python\ndef remove_duplicates_and_sum_a(numberschx):\n    uniquenchx_numberschx = set(numberschx)\n    sumchx = sum(uniquenchx_numberschx)\n    return sumchx\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\ndef sum_chx_unique(chx_numbers):\n    unique_chx_numbers = list(set(chx_numbers))\n    chx_sum = sum(unique_chx_numbers)\n    return chx_sum\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku_fn(z_board):\n    def is_valid_block_fn(z_block):\n        z_block = [z_num for z_num in z_block if z_num != '.']\n        return len(z_block) == len(set(z_block))\n\n    for z_i in range(9):\n        z_row = [z_board[z_i][z_j] for z_j in range(9)]\n        z_column = [z_board[z_j][z_i] for z_j in range(9)]\n        if not is_valid_block_fn(z_row) or not is_valid_block_fn(z_column):\n            return False\n    \n    for z_i in range(0, 9, 3):\n        for z_j in range(0, 9, 3):\n            z_square = [z_board[z_m][z_n] for z_m in range(z_i, z_i + 3) for z_n in range(z_j, z_j + 3)]\n            if not is_valid_block_fn(z_square):\n                return False\n    \n    return True\n```",
        "```python\ndef merge_sort_fn(z_arr):\n    if len(z_arr) > 1:\n        z_mid = len(z_arr) // 2\n        z_left_half = z_arr[:z_mid]\n        z_right_half = z_arr[z_mid:]\n\n        merge_sort_fn(z_left_half)\n        merge_sort_fn(z_right_half)\n\n        z_i = z_j = z_k = 0\n        \n        while z_i < len(z_left_half) and z_j < len(z_right_half):\n            if z_left_half[z_i] < z_right_half[z_j]:\n                z_arr[z_k] = z_left_half[z_i]\n                z_i += 1\n            else:\n                z_arr[z_k] = z_right_half[z_j]\n                z_j += 1\n            z_k += 1\n\n        while z_i < len(z_left_half):\n            z_arr[z_k] = z_left_half[z_i]\n            z_i += 1\n            z_k += 1\n\n        while z_j < len(z_right_half):\n            z_arr[z_k] = z_right_half[z_j]\n            z_j += 1\n            z_k += 1\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef z_is_valid_sudoku(z_board):\n    def z_is_valid_block(z_block):\n        z_non_empty_values = [z_num for z_num in z_block if z_num != '.']\n        return len(z_non_empty_values) == len(set(z_non_empty_values))\n    \n    for z_row in z_board:\n        if not z_is_valid_block(z_row):\n            return False\n    \n    for z_col_index in range(9):\n        z_column = [z_board[z_row_index][z_col_index] for z_row_index in range(9)]\n        if not z_is_valid_block(z_column):\n            return False\n    \n    for z_box_row in range(3):\n        for z_box_col in range(3):\n            z_sub_box = [\n                z_board[z_row][z_col]\n                for z_row in range(z_box_row * 3, (z_box_row + 1) * 3)\n                for z_col in range(z_box_col * 3, (z_box_col + 1) * 3)\n            ]\n            if not z_is_valid_block(z_sub_box):\n                return False\n    \n    return True\n```",
        "```python\ndef merge_fn(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return merge_fn(left_half, right_half)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport secrets\n\ndef edit_distance_d(str1, str2):\n    len1 = len(str1)\n    len2 = len(str2)\n\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n\n    for i in range(len1 + 1):\n        for j in range(len2 + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j],    # Insert\n                                   dp[i][j - 1],    # Remove\n                                   dp[i - 1][j - 1])  # Replace\n\n    return dp[len1][len2]\n```",
        "```python\nimport secrets\n\ndef merge_sort_d(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_d(left_half)\n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\nimport secrets\n\ndef edit_distance(str1, str2):\n    len1, len2 = len(str1), len(str2)\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n\n    for i in range(len1 + 1):\n        dp[i][0] = i\n    for j in range(len2 + 1):\n        dp[0][j] = j\n\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,   # deletion\n                    dp[i][j - 1] + 1,   # insertion\n                    dp[i - 1][j - 1] + 1  # substitution\n                )\n\n    return dp[len1][len2]\n```",
        "```python\ndef merge_sort_d(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_d(left_half)\n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_block(vr_block):\n        vr_block = [vr_num for vr_num in vr_block if vr_num != '.']\n        return len(vr_block) == len(set(vr_block))\n    \n    for vr_row in vr_board:\n        if not is_valid_block(vr_row):\n            return False\n    \n    for vr_col in range(9):\n        if not is_valid_block([vr_board[vr_row][vr_col] for vr_row in range(9)]):\n            return False\n    \n    for vr_start_row in range(0, 9, 3):\n        for vr_start_col in range(0, 9, 3):\n            vr_block = [vr_board[vr_row][vr_col] for vr_row in range(vr_start_row, vr_start_row + 3) for vr_col in range(vr_start_col, vr_start_col + 3)]\n            if not is_valid_block(vr_block):\n                return False\n    \n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": [
        "```python\nimport numpy as np\nfrom sklearn.metrics import pairwise_distances\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors, metric='euclidean'):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        assert isinstance(metric, str), \"metric must be a string\"\n\n        self.n_neighbors = n_neighbors\n        self.metric = metric\n        self.train_data = None\n        self.train_labels = None\n\n    def train_fn(self, train_data_vr, train_labels_vr):\n        \"\"\"Train the nearest neighbors model by storing the training data and labels.\"\"\"\n        assert train_data_vr.ndim == 2, \"train_data must be a 2D array\"\n        assert train_labels_vr.ndim == 1, \"train_labels must be a 1D array\"\n        assert train_data_vr.shape[0] == train_labels_vr.shape[0], \"Number of samples must match in data and labels\"\n\n        self.train_data = train_data_vr\n        self.train_labels = train_labels_vr\n\n    def predict_fn(self, test_data_vr):\n        \"\"\"Predict the labels for the given test data.\"\"\"\n        assert self.train_data is not None and self.train_labels is not None, \"Model must be trained before predicting\"\n        assert test_data_vr.ndim == 2, \"test_data must be a 2D array\"\n\n        distances = pairwise_distances(test_data_vr, self.train_data, metric=self.metric)\n        n_test_samples = test_data_vr.shape[0]\n        predictions = np.empty(n_test_samples, dtype=self.train_labels.dtype)\n\n        for i in range(n_test_samples):\n            neighbor_indices = np.argsort(distances[i, :])[:self.n_neighbors]\n            neighbor_labels = self.train_labels[neighbor_indices]\n            predictions[i] = np.bincount(neighbor_labels).argmax()\n\n        return predictions\n```",
        "```python\nfrom pedantic import retry, timer_class\nfrom secrets import token_hex\nimport numpy as np\n\n@timer_class\nclass vr_QuadraticDiscriminantAnalysis:\n    def __init__(self_x):\n        self_x.vr_means = None\n        self_x.vr_covariances = None\n        self_x.vr_priors = None\n    \n    @retry\n    def o_fit_d(self_x, w_X, w_y):\n        \"\"\"\n        This function_fits_a GND to the training data.\n\n        :param vr_X: Training data of shape (n_samples, n_features).\n        :param vr_y: Target values of shape (n_samples,).\n\n        :raises AssertionError: If w_X and w_y dimensions don't match.\n        \"\"\"\n        assert len(w_X) == len(w_y), \"The dimension of X and y must match.\"\n        \n        vr_classes = np.unique(w_y)\n        self_x.vr_means = {}\n        self_x.vr_covariances = {}\n        self_x.vr_priors = {}\n\n        for vr_class in vr_classes:\n            vr_X_class = w_X[w_y == vr_class]\n            self_x.vr_means[vr_class] = np.mean(vr_X_class, axis=0)\n            self_x.vr_covariances[vr_class] = np.cov(vr_X_class, rowvar=False)\n            self_x.vr_priors[vr_class] = vr_X_class.shape[0] / w_X.shape[0]\n\n    @retry\n    def o_predict_d(self_x, w_X):\n        \"\"\"\n        Predict class labels for input_data.\n\n        :param vr_X: Input data to predict of shape (n_samples, n_features).\n        :return: Predicted class labels.\n\n        :raises AssertionError: If fit has not been called before this method.\n        \"\"\"\n        assert self_x.vr_means is not None and self_x.vr_covariances is not None, \"Model must be trained using fit_x() before prediction.\"\n        \n        vr_results = []\n\n        for vr_sample in w_X:\n            vr_likelihoods = self_x._compute_likelihoods_d(vr_sample)\n            vr_results.append(max(vr_likelihoods, key=vr_likelihoods.get))\n        \n        return vr_results\n\n    @retry\n    def _compute_likelihoods_d(self_x, vr_sample):\n        \"\"\"\n        Compute the likelihoods of each class for a given sample.\n\n        :param vr_sample: Single data sample.\n        :return: Likelihood of each class.\n\n        :raises AssertionError: If covariance matrix cannot be inverted.\n        \"\"\"\n        vr_likelihoods = {}\n\n        for vr_class in self_x.vr_means:\n            vr_mean = self_x.vr_means[vr_class]\n            vr_covariance = self_x.vr_covariances[vr_class]\n            vr_prior = self_x.vr_priors[vr_class]\n\n            try:\n                vr_cov_inv = np.linalg.inv(vr_covariance)\n                vr_diff = vr_sample - vr_mean\n                vr_exponent = -0.5 * np.dot(np.dot(vr_diff, vr_cov_inv), vr_diff.T)\n                vr_likelihoods[vr_class] = vr_prior * np.exp(vr_exponent) / np.sqrt(np.linalg.det(vr_covariance))\n            except np.linalg.LinAlgError:\n                raise AssertionError(\"Covariance matrix is not invertible.\")\n        \n        return vr_likelihoods\n```\n\n",
        "```python\nimport secrets\n\ndef edit_distance_d(str1_vr_, str2_vr_):\n    \"\"\"\n    Calculate the edit distance between two strings.\n    \n    Parameters:\n    str1_vr_ (str): The first string for comparison.\n    str2_vr_ (str): The second string for comparison.\n    \n    Returns:\n    int: The edit distance between the two strings.\n    \"\"\"\n    len1_vr_ = len(str1_vr_)\n    len2_vr_ = len(str2_vr_)\n\n    # Initialize a matrix to hold the edit distances.\n    dp_vr_ = [[0_fn] * (len2_vr_ + 1) for _ in range(len1_vr_ + 1)]\n\n    for i_vr_ in range(len1_vr_ + 1):\n        dp_vr_[i_vr_][0_fn] = i_vr_\n    for j_vr_ in range(len2_vr_ + 1):\n        dp_vr_[0_fn][j_vr_] = j_vr_\n\n    for i_vr_ in range(1_fn, len1_vr_ + 1):\n        for j_vr_ in range(1_fn, len2_vr_ + 1):\n            if str1_vr_[i_vr_ - 1] == str2_vr_[j_vr_ - 1]:\n                dp_vr_[i_vr_][j_vr_] = dp_vr_[i_vr_ - 1][j_vr_ - 1]\n            else:\n                dp_vr_[i_vr_][j_vr_] = 1_fn + min(\n                    dp_vr_[i_vr_ - 1][j_vr_],    # Deletion\n                    dp_vr_[i_vr_][j_vr_ - 1],    # Insertion\n                    dp_vr_[i_vr_ - 1][j_vr_ - 1] # Substitution\n                )\n    \n    return dp_vr_[len1_vr_][len2_vr_]\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef vr_longest_common_prefix_fn(vr_strs):\n    assert isinstance(vr_strs, list), \"Input must be a list of strings.\"\n    assert all(isinstance(s, str) for s in vr_strs), \"All elements in the list must be strings.\"\n    \n    if not vr_strs:\n        return \"\"\n    \n    vr_prefix = vr_strs[0]\n    for vr_string in vr_strs[1:]:\n        while vr_string.find(vr_prefix) != 0:\n            vr_prefix = vr_prefix[:-1]\n            if not vr_prefix:\n                return \"\"\n    return vr_prefix\n```",
        "```python\nfrom sklearn.metrics.pairwise import pairwise_kernels\nimport numpy as np\n\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', **kwargs):\n        self.vr_alpha = alpha\n        self.vr_kernel = kernel\n        self.vr_kwargs = kwargs\n        self.vr_X_train = None\n        self.vr_y_train = None\n        self.vr_alpha_I = None\n\n    def o_fit_fn(self, X, y):\n        self.vr_X_train = X\n        self.vr_y_train = y\n        y = np.asarray(y)\n        K = pairwise_kernels(X, metric=self.vr_kernel, **self.vr_kwargs)\n        n_samples = K.shape[0]\n        self.vr_alpha_I = self.vr_alpha * np.eye(n_samples)\n        self.vr_alpha_I_K = np.linalg.inv(K + self.vr_alpha_I)\n        assert self.vr_alpha_I_K is not None, \"Failed to compute the inverse matrix\"\n\n    def o_predict_fn(self, X):\n        K_test = pairwise_kernels(X, self.vr_X_train, metric=self.vr_kernel, **self.vr_kwargs)\n        return K_test.dot(self.vr_alpha_I_K.dot(self.vr_y_train))\n\n    def _get_params_fn(self):\n        return {\n            'alpha': self.vr_alpha,\n            'kernel': self.vr_kernel,\n            **self.vr_kwargs\n        }\n```\n",
        "```python\nimport secrets\n\ndef remove_duplicates_and_sum_vr(numbers_vr):\n    \"\"\"\n    Remove duplicates from the list and return the sum of its unique elements.\n    \n    :param numbers_vr: List of integers.\n    :return: Sum of unique integers.\n    \"\"\"\n    unique_numbers_d = set(numbers_vr)\n    return sum(unique_numbers_d)\n```\n",
        "```python\ndef avg_diagonal_elements_fn(matrix):\n    \"\"\"\n    Calculate the average of the diagonal elements of a given square matrix.\n    \n    Parameters:\n    matrix (list of list of int/float): A square matrix represented as a list of lists.\n\n    Returns:\n    float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list) and matrix, \"matrix must be a non-empty list of lists.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row in matrix must be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"matrix must be square.\"\n\n    vr_diagonal_sum = 0\n    vr_size = len(matrix)\n\n    for vr_i in range(vr_size):\n        vr_diagonal_sum += matrix[vr_i][vr_i]\n    \n    return vr_diagonal_sum / vr_size\n```",
        "```python\nfrom secrets import choice\n\nclass Inventory:\n\n    def __init__(self):\n        self.vr_stock = {}\n\n    def add_stock_d(self, vr_item, vr_quantity):\n        \"\"\"\n        Adds stock for a given item.\n\n        Parameters:\n        vr_item (str): The name of the item.\n        vr_quantity (int): The quantity to add.\n\n        Returns:\n        None\n        \"\"\"\n        assert isinstance(vr_item, str), \"Item must be a string\"\n        assert isinstance(vr_quantity, int) and vr_quantity > 0, \"Quantity must be a positive integer\"\n\n        if vr_item in self.vr_stock:\n            self.vr_stock[vr_item] += vr_quantity\n        else:\n            self.vr_stock[vr_item] = vr_quantity\n\n    def remove_stock_d(self, vr_item, vr_quantity):\n        \"\"\"\n        Removes stock for a given item.\n\n        Parameters:\n        vr_item (str): The name of the item.\n        vr_quantity (int): The quantity to remove.\n\n        Returns:\n        None\n        \"\"\"\n        assert isinstance(vr_item, str), \"Item must be a string\"\n        assert isinstance(vr_quantity, int) and vr_quantity > 0, \"Quantity must be a positive integer\"\n\n        if vr_item in self.vr_stock and self.vr_stock[vr_item] >= vr_quantity:\n            self.vr_stock[vr_item] -= vr_quantity\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```\n",
        "```python\n@retry\ndef n_merge_sort_fn(array_vr_):\n    \"\"\"\n    Perform a merge sort on the provided list.\n\n    Parameters:\n    array_vr_ (list): A list of elements to be sorted.\n\n    Returns:\n    list: A sorted list with elements in ascending order.\n    \"\"\"\n    if len(array_vr_) <= 1:\n        return array_vr_\n\n    mid_vr_ = len(array_vr_) // 2\n    left_half_chx = n_merge_sort_fn(array_vr_[:mid_vr_])\n    right_half_chx = n_merge_sort_fn(array_vr_[mid_vr_:])\n\n    return n_merge_fn_(left_half_chx, right_half_chx)\n\n\n@retry\ndef n_merge_fn_(left_chx, right_chx):\n    \"\"\"\n    Merge two sorted lists into a single sorted list.\n\n    Parameters:\n    left_chx (list): A sorted list.\n    right_chx (list): Another sorted list.\n\n    Returns:\n    list: A merged and sorted list.\n    \"\"\"\n    merged_list_chx = []\n    left_index_chx = right_index_chx = 0\n\n    while left_index_chx < len(left_chx) and right_index_chx < len(right_chx):\n        if left_chx[left_index_chx] < right_chx[right_index_chx]:\n            merged_list_chx.append(left_chx[left_index_chx])\n            left_index_chx += 1\n        else:\n            merged_list_chx.append(right_chx[right_index_chx])\n            right_index_chx += 1\n\n    merged_list_chx.extend(left_chx[left_index_chx:])\n    merged_list_chx.extend(right_chx[right_index_chx:])\n    return merged_list_chx\n```\n",
        "```python\nfrom pedantic import retry\nimport secrets\n\n@retry\ndef is_valid_sudoku_b(board):\n    # Function to check if numbers 1-9 appear only once in the row, column, and 3x3 sub-grid\n    def is_valid_unit_b(unit):\n        seen_vr = set()\n        for num_vr in unit:\n            if num_vr != '.':\n                if num_vr in seen_vr:\n                    return False\n                seen_vr.add(num_vr)\n        return True\n\n    # Check rows\n    for row in board:\n        if not is_valid_unit_b(row):\n            return False\n\n    # Check columns\n    for col_idx_vr in range(9):\n        column_vr = [board[row_idx_vr][col_idx_vr] for row_idx_vr in range(9)]\n        if not is_valid_unit_b(column_vr):\n            return False\n\n    # Check 3x3 sub-grids\n    for box_row_vr in range(0, 9, 3):\n        for box_col_vr in range(0, 9, 3):\n            box_vr = [board[row_idx_vr][col_idx_vr] for row_idx_vr in range(box_row_vr, box_row_vr + 3)\n                                                     for col_idx_vr in range(box_col_vr, box_col_vr + 3)]\n            if not is_valid_unit_b(box_vr):\n                return False\n\n    return True\n```\n\n",
        "```python\nfrom typing import List\nfrom pedantic import retry\nimport secrets\n\n@retry\ndef majority_element_d(arr_vr_: List[int]) -> int:\n    \"\"\"\n    Function to find the majority element in an array, which is the element that appears more than n/2 times.\n\n    :param arr_vr_: A list of integers\n    :return: The majority element\n    \"\"\"\n    assert len(arr_vr_) > 0, \"Array must not be empty.\"\n    \n    count_vr_ = 0\n    candidate_vr_ = None\n    \n    for num_vr_ in arr_vr_:\n        if count_vr_ == 0:\n            candidate_vr_ = num_vr_\n        count_vr_ += (1 if num_vr_ == candidate_vr_ else -1)\n    \n    # Verify that the candidate is actually the majority element\n    assert arr_vr_.count(candidate_vr_) > len(arr_vr_) // 2, \"No majority element found.\"\n    \n    return candidate_vr_\n```"
      ]
    }
  ]
}