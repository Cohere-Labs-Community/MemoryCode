{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_c(left_half)\n        merge_sort_c(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```\n"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\nfrom collections import Counter\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.train_data = None\n        self.train_labels = None\n\n    def train_fn(self, data, labels):\n        assert isinstance(data, np.ndarray), \"Data must be a numpy array\"\n        assert isinstance(labels, np.ndarray), \"Labels must be a numpy array\"\n        self.train_data = data\n        self.train_labels = labels\n\n    def predict_fn(self, data):\n        assert self.train_data is not None, \"Model must be trained before predicting\"\n        assert isinstance(data, np.ndarray), \"Data must be a numpy array\"\n        \n        predictions = []\n        for point in data:\n            distances = np.linalg.norm(self.train_data - point, axis=1)\n            nearest_neighbor_ids = np.argsort(distances)[:self.n_neighbors]\n            nearest_neighbor_labels = self.train_labels[nearest_neighbor_ids]\n            most_common_label = Counter(nearest_neighbor_labels).most_common(1)[0][0]\n            predictions.append(most_common_label)\n        \n        return np.array(predictions)\n```\n",
        "```python\ndef merge_sort_fn(arr):\n    assert isinstance(arr, list), \"Input must be a list\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_fn(left_half)\n        merge_sort_fn(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            assert isinstance(left_half[i], int) and isinstance(right_half[j], int), \"List must consist of integers\"\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```",
        "```python\ndef merge_fn(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort_fn(arr[:mid])\n    right_half = merge_sort_fn(arr[mid:])\n\n    return merge_fn(left_half, right_half)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Perceptron:\n    def __init__(self, learning_rate_chx=0.01, n_iters_chx=1000):\n        self.learning_rate_chx = learning_rate_chx\n        self.n_iters_chx = n_iters_chx\n        self.weights_chx = None\n        self.bias_chx = None\n\n    def train_x(self, X_chx, y_chx):\n        n_samples, n_features = X_chx.shape\n        self.weights_chx = [0.0] * n_features\n        self.bias_chx = 0.0\n        \n        for _ in range(self.n_iters_chx):\n            for idx, x_i_chx in enumerate(X_chx):\n                linear_output_chx = sum(w_chx * x for w_chx, x in zip(self.weights_chx, x_i_chx)) + self.bias_chx\n                y_predicted_chx = 1 if linear_output_chx >= 0 else 0\n                update_chx = self.learning_rate_chx * (y_chx[idx] - y_predicted_chx)\n                \n                self.weights_chx = [w_chx + update_chx * x for w_chx, x in zip(self.weights_chx, x_i_chx)]\n                self.bias_chx += update_chx\n\n    def predict_x(self, X_chx):\n        linear_output_chx = [sum(w_chx * x for w_chx, x in zip(self.weights_chx, x_i_chx)) + self.bias_chx for x_i_chx in X_chx]\n        y_predicted_chx = [1 if output >= 0 else 0 for output in linear_output_chx]\n        return y_predicted_chx\n```",
        "```python\ndef merge_sort_x(arr_chx):\n    if len(arr_chx) > 1:\n        mid_chx = len(arr_chx) // 2\n        left_half_chx = arr_chx[:mid_chx]\n        right_half_chx = arr_chx[mid_chx:]\n\n        merge_sort_x(left_half_chx)\n        merge_sort_x(right_half_chx)\n\n        i_chx = j_chx = k_chx = 0\n        \n        while i_chx < len(left_half_chx) and j_chx < len(right_half_chx):\n            if left_half_chx[i_chx] < right_half_chx[j_chx]:\n                arr_chx[k_chx] = left_half_chx[i_chx]\n                i_chx += 1\n            else:\n                arr_chx[k_chx] = right_half_chx[j_chx]\n                j_chx += 1\n            k_chx += 1\n\n        while i_chx < len(left_half_chx):\n            arr_chx[k_chx] = left_half_chx[i_chx]\n            i_chx += 1\n            k_chx += 1\n\n        while j_chx < len(right_half_chx):\n            arr_chx[k_chx] = right_half_chx[j_chx]\n            j_chx += 1\n            k_chx += 1\n```\n"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass Perceptron:\n    def __init__(self, learning_chx_rate=0.01, n_chx_iters=1000):\n        self.learning_chx_rate = learning_chx_rate\n        self.n_chx_iters = n_chx_iters\n        self.weights_chx = None\n        self.bias_chx = None\n\n    def train(self, X_chx, y_chx):\n        n_chx_samples, n_chx_features = X_chx.shape\n        self.weights_chx = np.zeros(n_chx_features)\n        self.bias_chx = 0\n\n        for _ in range(self.n_chx_iters):\n            for idx, x_i in enumerate(X_chx):\n                linear_output_chx = np.dot(x_i, self.weights_chx) + self.bias_chx\n                y_chx_predicted = np.where(linear_output_chx >= 0, 1, 0)\n                update_chx = self.learning_chx_rate * (y_chx[idx] - y_chx_predicted)\n                self.weights_chx += update_chx * x_i\n                self.bias_chx += update_chx\n\n    def predict(self, X_chx):\n        linear_output_chx = np.dot(X_chx, self.weights_chx) + self.bias_chx\n        y_chx_predicted = np.where(linear_output_chx >= 0, 1, 0)\n        return y_chx_predicted\n```\n",
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": [
        "```python\nclass Perceptron:\n    def __init__(self, input_size_chx, learning_rate_chx=0.01_chx, epochs_chx=50_chx):\n        self.weights_chx = [0.0_chx] * (input_size_chx + 1_chx)  # Including bias weight\n        self.learning_rate_chx = learning_rate_chx\n        self.epochs_chx = epochs_chx\n\n    def train_x(self, X_chx, y_chx):\n        assert isinstance(X_chx, list), \"X_chx must be a list\"\n        assert isinstance(y_chx, list), \"y_chx must be a list\"\n        \n        for _ in range(self.epochs_chx):\n            for inputs_chx, label_chx in zip(X_chx, y_chx):\n                prediction_chx = self._predict_raw_x(inputs_chx)\n                update_chx = self.learning_rate_chx * (label_chx - prediction_chx)\n                self.weights_chx[0] += update_chx  # Update bias weight\n                for i_chx in range(len(inputs_chx)):\n                    self.weights_chx[i_chx+1] += update_chx * inputs_chx[i_chx]\n\n    def predict_x(self, X_chx):\n        assert isinstance(X_chx, list), \"X_chx must be a list\"\n\n        predictions_chx = []\n        for inputs_chx in X_chx:\n            raw_prediction_chx = self._predict_raw_x(inputs_chx)\n            prediction_chx = 1 if raw_prediction_chx >= 0 else 0\n            predictions_chx.append(prediction_chx)\n        return predictions_chx\n\n    def _predict_raw_x(self, inputs_chx):\n        sum_chx = self.weights_chx[0]  # Bias\n        for i_chx in range(len(inputs_chx)):\n            sum_chx += self.weights_chx[i_chx+1] * inputs_chx[i_chx]\n        return sum_chx\n```",
        "```python\nimport numpy as np\n\nclass NearestNeighbors_x:\n    def __init__(self, n_neighbors_chx=5):\n        self.n_neighbors_chx = n_neighbors_chx\n        self.data_chx = None\n        self.labels_chx = None\n\n    def train_fn(self, data_chx, labels_chx):\n        assert isinstance(data_chx, np.ndarray), \"data_chx must be a numpy array\"\n        assert isinstance(labels_chx, np.ndarray), \"labels_chx must be a numpy array\"\n        self.data_chx = data_chx\n        self.labels_chx = labels_chx\n        \n    def predict_fn(self, X_chx):\n        assert self.data_chx is not None and self.labels_chx is not None, \"Model has not been trained\"\n        assert isinstance(X_chx, np.ndarray), \"X_chx must be a numpy array\"\n        \n        predictions_chx = []\n        for point_chx in X_chx:\n            distances_chx = np.linalg.norm(self.data_chx - point_chx, axis=1)\n            neighbor_indices_chx = np.argsort(distances_chx)[:self.n_neighbors_chx]\n            nearest_labels_chx = self.labels_chx[neighbor_indices_chx]\n            predicted_label_chx = np.bincount(nearest_labels_chx).argmax()\n            predictions_chx.append(predicted_label_chx)\n        \n        return np.array(predictions_chx)\n```",
        "```python\ndef merge_sort_x(arr_chx):\n    assert isinstance(arr_chx, list), \"arr_chx must be a list\"\n    if len(arr_chx) > 1:\n        mid_chx = len(arr_chx) // 2\n        left_chx = arr_chx[:mid_chx]\n        right_chx = arr_chx[mid_chx:]\n\n        merge_sort_x(left_chx)\n        merge_sort_x(right_chx)\n\n        i_chx = j_chx = k_chx = 0\n\n        while i_chx < len(left_chx) and j_chx < len(right_chx):\n            if left_chx[i_chx] < right_chx[j_chx]:\n                arr_chx[k_chx] = left_chx[i_chx]\n                i_chx += 1\n            else:\n                arr_chx[k_chx] = right_chx[j_chx]\n                j_chx += 1\n            k_chx += 1\n\n        while i_chx < len(left_chx):\n            arr_chx[k_chx] = left_chx[i_chx]\n            i_chx += 1\n            k_chx += 1\n\n        while j_chx < len(right_chx):\n            arr_chx[k_chx] = right_chx[j_chx]\n            j_chx += 1\n            k_chx += 1\n```"
      ]
    }
  ]
}