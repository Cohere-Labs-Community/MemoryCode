{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef merge_sorted_lists(list1_f: List[int], list2_f: List[int]) -> List[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        list1_f (List[int]): The first sorted list.\n        list2_f (List[int]): The second sorted list.\n\n    Returns:\n        List[int]: A merged and sorted list containing elements from both input lists.\n    \"\"\"\n    merged_list_f = []\n    i_f, j_f = 0, 0\n\n    while i_f < len(list1_f) and j_f < len(list2_f):\n        if list1_f[i_f] <= list2_f[j_f]:\n            merged_list_f.append(list1_f[i_f])\n            i_f += 1\n        else:\n            merged_list_f.append(list2_f[j_f])\n            j_f += 1\n\n    merged_list_f.extend(list1_f[i_f:])\n    merged_list_f.extend(list2_f[j_f:])\n\n    return merged_list_f\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value_f: int):\n        \"\"\"\n        Initializes a TreeNode with a given value and sets left and right children to None.\n\n        :param value_f: The value to be held by the TreeNode.\n        \"\"\"\n        self.value = value_f\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initializes an empty BinaryTree.\"\"\"\n        self.root = None\n\n    def insert(self, value_f: int) -> None:\n        \"\"\"\n        Inserts a value into the binary tree.\n\n        :param value_f: The value to insert into the tree.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(value_f)\n        else:\n            self._insert_recursive(self.root, value_f)\n\n    def _insert_recursive(self, node_f: TreeNode, value_f: int) -> None:\n        \"\"\"\n        Helper method to insert a value recursively starting from a given node.\n\n        :param node_f: The starting node for insertion.\n        :param value_f: The value to insert into the tree.\n        \"\"\"\n        if value_f < node_f.value:\n            if node_f.left is None:\n                node_f.left = TreeNode(value_f)\n            else:\n                self._insert_recursive(node_f.left, value_f)\n        else:\n            if node_f.right is None:\n                node_f.right = TreeNode(value_f)\n            else:\n                self._insert_recursive(node_f.right, value_f)\n\n    def delete(self, value_f: int) -> None:\n        \"\"\"\n        Deletes a value from the binary tree if it exists.\n\n        :param value_f: The value to delete from the tree.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value_f)\n\n    def _delete_recursive(self, node_f: TreeNode, value_f: int) -> TreeNode:\n        \"\"\"\n        Helper method to delete a value recursively starting from a given node.\n\n        :param node_f: The starting node for deletion.\n        :param value_f: The value to delete from the tree.\n        :return: The root of the modified subtree.\n        \"\"\"\n        if node_f is None:\n            return node_f\n\n        if value_f < node_f.value:\n            node_f.left = self._delete_recursive(node_f.left, value_f)\n        elif value_f > node_f.value:\n            node_f.right = self._delete_recursive(node_f.right, value_f)\n        else:\n            if node_f.left is None:\n                return node_f.right\n            elif node_f.right is None:\n                return node_f.left\n\n            successor_f = self._min_value_node(node_f.right)\n            node_f.value = successor_f.value\n            node_f.right = self._delete_recursive(node_f.right, successor_f.value)\n\n        return node_f\n\n    def _min_value_node(self, node_f: TreeNode) -> TreeNode:\n        \"\"\"\n        Finds the node with the minimum value in a given subtree.\n\n        :param node_f: The root node of the subtree.\n        :return: The node with the minimum value.\n        \"\"\"\n        current_f = node_f\n        while current_f.left is not None:\n            current_f = current_f.left\n        return current_f\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    merged_list.extend(list1_f[i:])\n    merged_list.extend(list2_f[j:])\n    return merged_list\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    merged_list_g = []\n    i_g, j_g = 0, 0\n\n    while i_g < len(list1_g) and j_g < len(list2_g):\n        if list1_g[i_g] < list2_g[j_g]:\n            merged_list_g.append(list1_g[i_g])\n            i_g += 1\n        else:\n            merged_list_g.append(list2_g[j_g])\n            j_g += 1\n\n    while i_g < len(list1_g):\n        merged_list_g.append(list1_g[i_g])\n        i_g += 1\n\n    while j_g < len(list2_g):\n        merged_list_g.append(list2_g[j_g])\n        j_g += 1\n\n    return merged_list_g\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n\n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n\n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n\n    return merged_list\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key_g: int) -> None:\n        self.key = key_g\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root = None\n\n    def insert(self, key_g: int) -> None:\n        \"\"\"\n        Insert a node with the given key_g into the binary tree.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key_g)\n        else:\n            self._insert_recursively(self.root, key_g)\n\n    def _insert_recursively(self, node_g: TreeNode, key_g: int) -> None:\n        if key_g < node_g.key:\n            if node_g.left is None:\n                node_g.left = TreeNode(key_g)\n            else:\n                self._insert_recursively(node_g.left, key_g)\n        else:\n            if node_g.right is None:\n                node_g.right = TreeNode(key_g)\n            else:\n                self._insert_recursively(node_g.right, key_g)\n    \n    def delete(self, key_g: int) -> None:\n        \"\"\"\n        Delete the node with the given key_g from the binary tree.\n        \"\"\"\n        self.root = self._delete_recursively(self.root, key_g)\n\n    def _delete_recursively(self, node_g: TreeNode, key_g: int) -> TreeNode:\n        if node_g is None:\n            return node_g\n        \n        if key_g < node_g.key:\n            node_g.left = self._delete_recursively(node_g.left, key_g)\n        elif key_g > node_g.key:\n            node_g.right = self._delete_recursively(node_g.right, key_g)\n        else:\n            if node_g.left is None:\n                return node_g.right\n            elif node_g.right is None:\n                return node_g.left\n\n            min_larger_node_g = self._get_min(node_g.right)\n            node_g.key = min_larger_node_g.key\n            node_g.right = self._delete_recursively(node_g.right, min_larger_node_g.key)\n\n        return node_g\n\n    def _get_min(self, node_g: TreeNode) -> TreeNode:\n        current_g = node_g\n        while current_g.left is not None:\n            current_g = current_g.left\n        return current_g\n```",
        "```python\nfrom typing import List\n\ndef merge_sorted_lists(list1_g: List[int], list2_g: List[int]) -> List[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    :param list1_g: First sorted list of integers\n    :param list2_g: Second sorted list of integers\n    :return: A sorted list containing all the elements of list1_g and list2_g\n    \"\"\"\n    merged_g = []\n    i_g, j_g = 0, 0\n\n    while i_g < len(list1_g) and j_g < len(list2_g):\n        if list1_g[i_g] < list2_g[j_g]:\n            merged_g.append(list1_g[i_g])\n            i_g += 1\n        else:\n            merged_g.append(list2_g[j_g])\n            j_g += 1\n\n    while i_g < len(list1_g):\n        merged_g.append(list1_g[i_g])\n        i_g += 1\n\n    while j_g < len(list2_g):\n        merged_g.append(list2_g[j_g])\n        j_g += 1\n\n    return merged_g\n```"
      ]
    }
  ]
}