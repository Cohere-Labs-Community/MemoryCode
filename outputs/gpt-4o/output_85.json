{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"\n        Initialize a tree node with a given key.\n        \n        :param key: The key value of the node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.value = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"\n        Initialize an empty binary tree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Insert a new key into the binary tree.\n        \n        :param key: The key to be inserted.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n    \n    def _insert_recursive(self, node, key):\n        \"\"\"\n        Helper method to recursively insert a new key starting from a given node.\n        \n        :param node: The current node in the recursion.\n        :param key: The key to be inserted.\n        \"\"\"\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Delete a node with the specified key from the binary tree.\n        \n        :param key: The key of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, node, key):\n        \"\"\"\n        Helper method to recursively delete a node starting from a given node.\n        \n        :param node: The current node in the recursion.\n        :param key: The key of the node to be deleted.\n        :return: The updated node after deletion.\n        \"\"\"\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursive(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_value_node = self._min_value_node(node.right)\n            node.value = min_value_node.value\n            node.right = self._delete_recursive(node.right, min_value_node.value)\n\n        return node\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Helper method to find the node with the minimum value in the given subtree.\n        \n        :param node: The root of the subtree.\n        :return: The node with the minimum value.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef o_is_valid_sudoku(vr_board):\n    def o_is_valid_block(vr_block):\n        vr_numbers = [num for num in vr_block if num != '.']\n        return len(vr_numbers) == len(set(vr_numbers))\n\n    for vr_row in vr_board:\n        if not o_is_valid_block(vr_row):\n            return False\n\n    for vr_col in range(9):\n        vr_col_values = [vr_board[vr_row][vr_col] for vr_row in range(9)]\n        if not o_is_valid_block(vr_col_values):\n            return False\n\n    for vr_box_row in range(0, 9, 3):\n        for vr_box_col in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_row][vr_col]\n                for vr_row in range(vr_box_row, vr_box_row + 3)\n                for vr_col in range(vr_box_col, vr_box_col + 3)\n            ]\n            if not o_is_valid_block(vr_box):\n                return False\n\n    return True\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.vr_stock_items = {}\n\n    def o_add_stock(self, vr_item_name, vr_quantity):\n        if vr_item_name in self.vr_stock_items:\n            self.vr_stock_items[vr_item_name] += vr_quantity\n        else:\n            self.vr_stock_items[vr_item_name] = vr_quantity\n\n    def o_remove_stock(self, vr_item_name, vr_quantity):\n        if vr_item_name in self.vr_stock_items and self.vr_stock_items[vr_item_name] >= vr_quantity:\n            self.vr_stock_items[vr_item_name] -= vr_quantity\n            if self.vr_stock_items[vr_item_name] == 0:\n                del self.vr_stock_items[vr_item_name]\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            if self.stock[item_name] >= quantity:\n                self.stock[item_name] -= quantity\n            else:\n                raise ValueError(\"Cannot remove more stock than available\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "cumulative_model_output": [
        "```python\nclass Node:\n    def __init__(self, vr_key):\n        \"\"\"\n        Initializes a node with a key, as well as left and right children.\n\n        :param vr_key: The key value of the node.\n        \"\"\"\n        self.vr_key = vr_key\n        self.vr_left = None\n        self.vr_right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty binary tree.\n        \"\"\"\n        self.vr_root = None\n\n    def o_insert(self, vr_key):\n        \"\"\"\n        Inserts a node with the given key into the binary tree.\n\n        :param vr_key: The key value for the new node.\n        \"\"\"\n        if self.vr_root is None:\n            self.vr_root = Node(vr_key)\n        else:\n            self._o_insert_recursively(self.vr_root, vr_key)\n\n    def _o_insert_recursively(self, vr_node, vr_key):\n        \"\"\"\n        Helper method to recursively insert a node.\n\n        :param vr_node: The current node being compared.\n        :param vr_key: The key value for the new node.\n        \"\"\"\n        if vr_key < vr_node.vr_key:\n            if vr_node.vr_left is None:\n                vr_node.vr_left = Node(vr_key)\n            else:\n                self._o_insert_recursively(vr_node.vr_left, vr_key)\n        else:\n            if vr_node.vr_right is None:\n                vr_node.vr_right = Node(vr_key)\n            else:\n                self._o_insert_recursively(vr_node.vr_right, vr_key)\n\n    def o_delete(self, vr_key):\n        \"\"\"\n        Deletes a node with the given key from the binary tree.\n\n        :param vr_key: The key value of the node to be deleted.\n        \"\"\"\n        self.vr_root = self._o_delete_recursively(self.vr_root, vr_key)\n\n    def _o_delete_recursively(self, vr_node, vr_key):\n        \"\"\"\n        Helper method to recursively delete a node.\n\n        :param vr_node: The current node being compared.\n        :param vr_key: The key value of the node to be deleted.\n        :return: The node to link back to the parent.\n        \"\"\"\n        if vr_node is None:\n            return vr_node\n\n        if vr_key < vr_node.vr_key:\n            vr_node.vr_left = self._o_delete_recursively(vr_node.vr_left, vr_key)\n        elif vr_key > vr_node.vr_key:\n            vr_node.vr_right = self._o_delete_recursively(vr_node.vr_right, vr_key)\n        else:\n            if vr_node.vr_left is None:\n                return vr_node.vr_right\n            elif vr_node.vr_right is None:\n                return vr_node.vr_left\n\n            vr_node.vr_key = self._o_min_value_node(vr_node.vr_right).vr_key\n            vr_node.vr_right = self._o_delete_recursively(vr_node.vr_right, vr_node.vr_key)\n\n        return vr_node\n\n    def _o_min_value_node(self, vr_node):\n        \"\"\"\n        Finds the node with the smallest key value greater than the current node.\n\n        :param vr_node: The node from which to find the smallest value.\n        :return: The node with the smallest key value.\n        \"\"\"\n        vr_current = vr_node\n        while vr_current.vr_left is not None:\n            vr_current = vr_current.vr_left\n        return vr_current\n```",
        "```python\ndef o_is_valid_sudoku(vr_board):\n    \"\"\"\n    Determines if a given 9x9 Sudoku board is valid.\n    \n    A Sudoku board (partially filled) is valid if the following rules are met:\n    1. Each row must contain the digits 1-9 without repetition.\n    2. Each column must contain the digits 1-9 without repetition.\n    3. Each of the nine 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n    Parameters:\n    vr_board (list[list[str]]): A 9x9 list representing the Sudoku board. Each cell is a string, \n                                empty cells are filled with '.'.\n\n    Returns:\n    bool: True if the board is valid, False otherwise.\n    \"\"\"\n    def o_is_valid_block(vr_block):\n        vr_seen = set()\n        for vr_number in vr_block:\n            if vr_number != '.':\n                if vr_number in vr_seen:\n                    return False\n                vr_seen.add(vr_number)\n        return True\n    \n    for vr_i in range(9):\n        vr_row = [vr_board[vr_i][vr_j] for vr_j in range(9)]\n        vr_column = [vr_board[vr_j][vr_i] for vr_j in range(9)]\n        if not o_is_valid_block(vr_row) or not o_is_valid_block(vr_column):\n            return False\n\n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_sub_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not o_is_valid_block(vr_sub_box):\n                return False\n\n    return True\n```",
        "```python\nclass Inventory:\n    \"\"\"Class to manage inventory stock.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty inventory.\"\"\"\n        self.vr_stock = {}\n\n    def o_add_stock(self, vr_item, vr_quantity):\n        \"\"\"\n        Add stock to the inventory.\n\n        Parameters:\n        vr_item (str): The item to add to the inventory.\n        vr_quantity (int): The quantity of the item to add.\n        \"\"\"\n        if vr_item in self.vr_stock:\n            self.vr_stock[vr_item] += vr_quantity\n        else:\n            self.vr_stock[vr_item] = vr_quantity\n\n    def o_remove_stock(self, vr_item, vr_quantity):\n        \"\"\"\n        Remove stock from the inventory.\n\n        Parameters:\n        vr_item (str): The item to remove from the inventory.\n        vr_quantity (int): The quantity of the item to remove.\n\n        Raises:\n        ValueError: If the item does not exist in the inventory or \n                    if the quantity to remove is more than available.\n        \"\"\"\n        if vr_item not in self.vr_stock:\n            raise ValueError(f\"Item {vr_item} not found in inventory.\")\n        if vr_quantity > self.vr_stock[vr_item]:\n            raise ValueError(f\"Cannot remove {vr_quantity} items. Only {self.vr_stock[vr_item]} available.\")\n        self.vr_stock[vr_item] -= vr_quantity\n```\n"
      ]
    }
  ]
}