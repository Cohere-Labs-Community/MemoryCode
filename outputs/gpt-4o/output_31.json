{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom sklearn.base import BaseEstimator, RegressorMixin\nfrom sklearn.metrics.pairwise import pairwise_kernels\nfrom sklearn.utils import check_X_y, check_array\nfrom pedantic import trace_class\nimport numpy as np\n\n@trace_class\nclass KernelRidgeRegression(BaseEstimator, RegressorMixin):\n    \"\"\"\n    Kernel Ridge Regression model implementation.\n    \"\"\"\n\n    def __init__(self, alpha=1.0, kernel=\"linear\", gamma=None, degree=3, coef0=1):\n        \"\"\"\n        Initialize Kernel Ridge Regression with hyperparameters.\n\n        :param alpha: Regularization strength; must be a positive float.\n        :param kernel: Specifies the kernel type to be used in the algorithm.\n        :param gamma: Kernel coefficient for 'rbf', 'poly', and 'sigmoid'.\n        :param degree: Degree of the polynomial kernel function ('poly').\n        :param coef0: Independent term in kernel function ('poly' and 'sigmoid').\n        \"\"\"\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit Kernel Ridge Regression model.\n\n        :param X: Training data.\n        :param y: Target values.\n        :return: self\n        \"\"\"\n        X, y = check_X_y(X, y)\n        K = pairwise_kernels(X, metric=self.kernel, gamma=self.gamma,\n                             degree=self.degree, coef0=self.coef0)\n        n_samples = K.shape[0]\n        self.dual_coef_ = np.linalg.solve(K + self.alpha * np.eye(n_samples), y)\n        self.X_fit_ = X\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict using the Kernel Ridge Regression model.\n\n        :param X: Samples for prediction.\n        :return: Predicted values.\n        \"\"\"\n        X = check_array(X)\n        K = pairwise_kernels(X, self.X_fit_, metric=self.kernel, gamma=self.gamma,\n                             degree=self.degree, coef0=self.coef0)\n        return K.dot(self.dual_coef_)\n```",
        "```python\nfrom pedantic import trace_class\n\n@trace_class\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"\n        Initialize a new TreeNode.\n\n        :param key: The key or value for this node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\n@trace_class\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"\n        Initialize a new BinaryTree with no nodes.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Insert a new key into the binary tree.\n\n        :param key: The key or value to be inserted into the tree.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"\n        Helper method to insert a new node into the binary tree.\n\n        :param node: Current TreeNode during recursive insertion.\n        :param key: The key or value to be inserted.\n        \"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Delete a node from the binary tree by its key.\n\n        :param key: The key or value of the node to delete.\n        \"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"\n        Helper method to delete a node from the binary tree.\n\n        :param node: Current TreeNode during recursive deletion.\n        :param key: The key or value of the node to delete.\n        :return: The new root of the subtree after deletion.\n        \"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:  # Node to be deleted found\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children, get the in-order successor (smallest in the right subtree)\n            min_larger_node = self._min_value_node(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, node.val)\n\n        return node\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Find the node with the minimum value greater than the current node.\n\n        :param node: Starting TreeNode for finding the minimum value.\n        :return: The TreeNode with the minimum value.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import trace_class\nimport numpy as np\n\n@trace_class\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', gamma=None, degree=3, coef0=1):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n        self.X_train = None\n        self.alpha_ = None\n    \n    def _linear_kernel(self, X, Y):\n        return np.dot(X, Y.T)\n\n    def _polynomial_kernel(self, X, Y):\n        return (np.dot(X, Y.T) + self.coef0) ** self.degree\n\n    def _rbf_kernel(self, X, Y):\n        if self.gamma is None:\n            self.gamma = 1.0 / X.shape[1]\n        K = np.sum(X ** 2, axis=1).reshape(-1, 1) + np.sum(Y ** 2, axis=1) - 2 * np.dot(X, Y.T)\n        return np.exp(-self.gamma * K)\n\n    def _get_kernel(self, X, Y):\n        if self.kernel == 'linear':\n            return self._linear_kernel(X, Y)\n        elif self.kernel == 'polynomial':\n            return self._polynomial_kernel(X, Y)\n        elif self.kernel == 'rbf':\n            return self._rbf_kernel(X, Y)\n        else:\n            raise ValueError(\"Unknown kernel type\")\n\n    def fit(self, X, y):\n        self.X_train = X\n        K = self._get_kernel(X, X)\n        n_samples = X.shape[0]\n        self.alpha_ = np.linalg.solve(K + self.alpha * np.eye(n_samples), y)\n\n    def predict(self, X):\n        K = self._get_kernel(X, self.X_train)\n        return np.dot(K, self.alpha_)\n\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nfrom pedantic import trace_class\nimport numpy as np\n\n@trace_class\nclass KernelRidgeRegression:\n    \"\"\"\n    Kernel Ridge Regression implementation.\n    \n    Attributes:\n        alpha (float): Regularization parameter.\n        kernel (callable): Kernel function to compute the Gram matrix.\n    \"\"\"\n\n    def __init__(self, alpha: float = 1.0, kernel: callable = None):\n        \"\"\"\n        Initializes KernelRidgeRegression with regularization parameter and kernel function.\n\n        Args:\n            alpha (float): Regularization parameter. Defaults to 1.0.\n            kernel (callable): Kernel function to compute the Gram matrix. Defaults to linear kernel.\n        \"\"\"\n        self.alpha = alpha\n        if kernel is None:\n            self.kernel = self._linear_kernel\n        else:\n            self.kernel = kernel\n        self.X_fit_ = None\n        self.dual_coef_ = None\n\n    def _linear_kernel(self, X, Y):\n        \"\"\"\n        Computes the linear kernel between X and Y.\n\n        Args:\n            X (np.ndarray): Matrix of input features.\n            Y (np.ndarray): Matrix of input features.\n\n        Returns:\n            np.ndarray: Kernel matrix.\n        \"\"\"\n        return np.dot(X, Y.T)\n\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        \"\"\"\n        Fits the Kernel Ridge Regression model to the training data.\n\n        Args:\n            X (np.ndarray): Training data.\n            y (np.ndarray): Target values.\n        \"\"\"\n        self.X_fit_ = X\n        K = self.kernel(X, X)\n        n_samples = K.shape[0]\n        self.dual_coef_ = np.linalg.solve(K + self.alpha * np.eye(n_samples), y)\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predicts using the Kernel Ridge Regression model.\n\n        Args:\n            X (np.ndarray): Test data.\n\n        Returns:\n            np.ndarray: Predicted values.\n        \"\"\"\n        K = self.kernel(X, self.X_fit_)\n        return np.dot(K, self.dual_coef_)\n```",
        "```python\nfrom pedantic import trace_class\n\n@trace_class\nclass BinaryTreeNode:\n    \"\"\"\n    Class representing a node in a binary tree.\n\n    Attributes:\n        key (int): The value stored in the node.\n        left (BinaryTreeNode): The left child of the node.\n        right (BinaryTreeNode): The right child of the node.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initialize a binary tree node with a given key.\n\n        Args:\n            key (int): The value to be stored in the node.\n        \"\"\"\n        self.key = key\n        self.left = None\n        self.right = None\n\n\n@trace_class\nclass BinaryTree:\n    \"\"\"\n    Class representing a binary tree.\n\n    Attributes:\n        root (BinaryTreeNode): The root node of the binary tree.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize an empty binary tree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Insert a node with the specified key into the binary tree.\n\n        Args:\n            key (int): The value to be inserted into the tree.\n\n        Returns:\n            None\n        \"\"\"\n        if self.root is None:\n            self.root = BinaryTreeNode(key)\n        else:\n            self._insert_rec(self.root, key)\n\n    def _insert_rec(self, current_node, key):\n        \"\"\"\n        Recursively insert a node into the binary tree.\n\n        Args:\n            current_node (BinaryTreeNode): The current node being examined.\n            key (int): The value to be inserted into the tree.\n\n        Returns:\n            None\n        \"\"\"\n        if key < current_node.key:\n            if current_node.left is None:\n                current_node.left = BinaryTreeNode(key)\n            else:\n                self._insert_rec(current_node.left, key)\n        elif key > current_node.key:\n            if current_node.right is None:\n                current_node.right = BinaryTreeNode(key)\n            else:\n                self._insert_rec(current_node.right, key)\n\n    def delete(self, key):\n        \"\"\"\n        Delete a node with the specified key from the binary tree.\n\n        Args:\n            key (int): The value of the node to be deleted.\n\n        Returns:\n            None\n        \"\"\"\n        self.root = self._delete_rec(self.root, key)\n\n    def _delete_rec(self, node, key):\n        \"\"\"\n        Recursively delete a node from the binary tree.\n\n        Args:\n            node (BinaryTreeNode): The current node being examined.\n            key (int): The value of the node to be deleted.\n\n        Returns:\n            BinaryTreeNode: The updated node after deletion.\n        \"\"\"\n        if node is None:\n            return node\n        \n        if key < node.key:\n            node.left = self._delete_rec(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_rec(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            \n            min_node = self._min_value_node(node.right)\n            node.key = min_node.key\n            node.right = self._delete_rec(node.right, min_node.key)\n\n        return node\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Find the node with the minimum value in the given subtree.\n\n        Args:\n            node (BinaryTreeNode): The current node being examined.\n\n        Returns:\n            BinaryTreeNode: The node with the minimum value.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ]
    }
  ]
}