{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_a, list2_a):\n    merged_list_a = []\n    i_a, j_a = 0, 0\n\n    while i_a < len(list1_a) and j_a < len(list2_a):\n        if list1_a[i_a] < list2_a[j_a]:\n            merged_list_a.append(list1_a[i_a])\n            i_a += 1\n        else:\n            merged_list_a.append(list2_a[j_a])\n            j_a += 1\n\n    while i_a < len(list1_a):\n        merged_list_a.append(list1_a[i_a])\n        i_a += 1\n\n    while j_a < len(list2_a):\n        merged_list_a.append(list2_a[j_a])\n        j_a += 1\n\n    return merged_list_a\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sorted_lists(list_a, list_b):\n    merged_list_a = []\n    i_a, j_a = 0, 0\n    while i_a < len(list_a) and j_a < len(list_b):\n        if list_a[i_a] < list_b[j_a]:\n            merged_list_a.append(list_a[i_a])\n            i_a += 1\n        else:\n            merged_list_a.append(list_b[j_a])\n            j_a += 1\n    while i_a < len(list_a):\n        merged_list_a.append(list_a[i_a])\n        i_a += 1\n    while j_a < len(list_b):\n        merged_list_a.append(list_b[j_a])\n        j_a += 1\n    return merged_list_a\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        try:\n            self.songs.append(song)\n        except Exception as e:\n            print(f\"An error occurred while adding song: {e}\")\n\n    @retry\n    def remove_song(self, song):\n        try:\n            self.songs.remove(song)\n        except ValueError:\n            print(\"The song is not in the playlist.\")\n        except Exception as e:\n            print(f\"An error occurred while removing song: {e}\")\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        try:\n            if node.val <= low or node.val >= high:\n                return False\n            return (validate(node.left, low, node.val) and\n                    validate(node.right, node.val, high))\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n\n    return validate(root)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List, Tuple\nimport math\n\nclass NearestNeighbors:\n    def __init__(self, k: int) -> None:\n        assert isinstance(k, int) and k > 0, \"k must be a positive integer.\"\n        self.k: int = k\n        self.training_data: List[Tuple[List[float], any]] = []\n\n    def train(self, data: List[Tuple[List[float], any]]) -> None:\n        assert isinstance(data, list), \"Data must be a list.\"\n        assert all(isinstance(point, tuple) and isinstance(point[0], list) for point in data), \"Data must be a list of tuples.\"\n        self.training_data = data\n\n    def predict(self, point: List[float]) -> any:\n        assert isinstance(point, list), \"Point must be a list.\"\n        distances = [(self._euclidean_distance(point, train_point[0]), train_point[1]) \n                     for train_point in self.training_data]\n        distances.sort(key=lambda x: x[0])\n        nearest_neighbors = distances[:self.k]\n        return self._majority_vote(nearest_neighbors)\n\n    def _euclidean_distance(self, point1: List[float], point2: List[float]) -> float:\n        assert len(point1) == len(point2), \"Points must have the same dimensionality.\"\n        return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2)))\n\n    def _majority_vote(self, neighbors: List[Tuple[float, any]]) -> any:\n        votes = {}\n        for _, outcome in neighbors:\n            if outcome in votes:\n                votes[outcome] += 1\n            else:\n                votes[outcome] = 1\n        return max(votes, key=votes.get)\n```",
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, key: int):\n        self.left: Optional['TreeNode'] = None\n        self.right: Optional['TreeNode'] = None\n        self.val: int = key\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[TreeNode] = None\n\n    def insert(self, key: int) -> None:\n        def _insert(root: Optional[TreeNode], key: int) -> TreeNode:\n            assert isinstance(key, int), \"Key must be an integer\"\n            if root is None:\n                return TreeNode(key)\n            if key < root.val:\n                root.left = _insert(root.left, key)\n            else:\n                root.right = _insert(root.right, key)\n            return root\n\n        self.root = _insert(self.root, key)\n\n    def delete(self, key: int) -> None:\n        def _delete(root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n            assert isinstance(key, int), \"Key must be an integer\"\n            if root is None:\n                return root\n            if key < root.val:\n                root.left = _delete(root.left, key)\n            elif key > root.val:\n                root.right = _delete(root.right, key)\n            else:\n                if root.left is None:\n                    return root.right\n                elif root.right is None:\n                    return root.left\n                temp_val = self._minValueNode(root.right).val\n                root.val = temp_val\n                root.right = _delete(root.right, temp_val)\n            return root\n\n        self.root = _delete(self.root, key)\n\n    def _minValueNode(self, node: TreeNode) -> TreeNode:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "cumulative_model_output": [
        "```python\nfrom typing import List\nfrom pedantic import retry\nimport numpy as np\n\n@retry\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors_a: int = 5):\n        self.n_neighbors_a = n_neighbors_a\n        self.train_data = None\n        self.train_labels = None\n\n    @retry\n    def fit(self, data_a: np.ndarray, labels_a: np.ndarray) -> None:\n        try:\n            assert data_a.ndim == 2 and labels_a.ndim == 1, \"Invalid data or labels shape\"\n            assert data_a.shape[0] == labels_a.shape[0], \"Data and labels size must match\"\n            self.train_data = data_a\n            self.train_labels = labels_a\n        except Exception as e:\n            raise ValueError(f\"Failed to fit model: {e}\")\n\n    @retry\n    def predict(self, data_a: np.ndarray) -> List:\n        try:\n            assert self.train_data is not None and self.train_labels is not None, \"Model has not been trained\"\n            assert data_a.ndim == 2, \"Invalid data shape\"\n            predictions = []\n            for item in data_a:\n                distances = np.linalg.norm(self.train_data - item, axis=1)\n                nearest_indices = distances.argsort()[:self.n_neighbors_a]\n                nearest_labels = self.train_labels[nearest_indices]\n                unique_labels, counts = np.unique(nearest_labels, return_counts=True)\n                prediction = unique_labels[counts.argmax()]\n                predictions.append(prediction)\n            return predictions\n        except Exception as e:\n            raise ValueError(f\"Failed to predict: {e}\")\n```\n",
        "```python\nfrom typing import List\nfrom pedantic import retry\n\n@retry\ndef merge_sorted_lists(list1_a: List[int], list2_a: List[int]) -> List[int]:\n    merged_list_a = []\n    index1_a, index2_a = 0, 0\n    try:\n        while index1_a < len(list1_a) and index2_a < len(list2_a):\n            if list1_a[index1_a] < list2_a[index2_a]:\n                merged_list_a.append(list1_a[index1_a])\n                index1_a += 1\n            else:\n                merged_list_a.append(list2_a[index2_a])\n                index2_a += 1\n        merged_list_a.extend(list1_a[index1_a:])\n        merged_list_a.extend(list2_a[index2_a:])\n        assert merged_list_a == sorted(merged_list_a), \"The merged list is not sorted correctly.\"\n        return merged_list_a\n    except Exception as e:\n        print(\"An error occurred while merging lists:\", e)\n        raise\n```\n",
        "```python\nfrom pedantic import retry\n\nclass TreeNode:\n    def __init__(self, value_a: int) -> None:\n        self.value_a: int = value_a\n        self.left_a: TreeNode | None = None\n        self.right_a: TreeNode | None = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root_a: TreeNode | None = None\n\n    @retry\n    def insert(self, value_a: int) -> None:\n        try:\n            if self.root_a is None:\n                self.root_a = TreeNode(value_a)\n            else:\n                self._insert(self.root_a, value_a)\n        except Exception as e:\n            print(f\"Error during insertion: {e}\")\n\n    def _insert(self, node_a: TreeNode, value_a: int) -> None:\n        assert node_a is not None, \"Node cannot be None\"\n        if value_a < node_a.value_a:\n            if node_a.left_a is None:\n                node_a.left_a = TreeNode(value_a)\n            else:\n                self._insert(node_a.left_a, value_a)\n        else:\n            if node_a.right_a is None:\n                node_a.right_a = TreeNode(value_a)\n            else:\n                self._insert(node_a.right_a, value_a)\n\n    @retry\n    def delete(self, value_a: int) -> None:\n        try:\n            self.root_a = self._delete(self.root_a, value_a)\n        except Exception as e:\n            print(f\"Error during deletion: {e}\")\n\n    def _delete(self, node_a: TreeNode | None, value_a: int) -> TreeNode | None:\n        if node_a is None:\n            return None\n        \n        assert node_a is not None, \"Node cannot be None\"\n\n        if value_a < node_a.value_a:\n            node_a.left_a = self._delete(node_a.left_a, value_a)\n        elif value_a > node_a.value_a:\n            node_a.right_a = self._delete(node_a.right_a, value_a)\n        else:\n            if node_a.left_a is None:\n                return node_a.right_a\n            elif node_a.right_a is None:\n                return node_a.left_a\n\n            min_larger_node_a = self._min_value_node(node_a.right_a)\n            node_a.value_a = min_larger_node_a.value_a\n            node_a.right_a = self._delete(node_a.right_a, min_larger_node_a.value_a)\n\n        return node_a\n\n    def _min_value_node(self, node_a: TreeNode) -> TreeNode:\n        current_a = node_a\n        while current_a.left_a is not None:\n            current_a = current_a.left_a\n        return current_a\n```\n",
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val_a: int, left_a: Optional['TreeNode'] = None, right_a: Optional['TreeNode'] = None):\n        assert isinstance(val_a, int), \"Value must be an integer\"\n        self.val_a = val_a\n        self.left_a = left_a\n        self.right_a = right_a\n\ndef is_valid_bst_a(root_a: Optional[TreeNode]) -> bool:\n    @retry\n    def validate_a(node_a: Optional[TreeNode], low_a: float, high_a: float) -> bool:\n        try:\n            if node_a is None:\n                return True\n            assert isinstance(node_a, TreeNode), \"Node must be an instance of TreeNode\"\n            assert isinstance(low_a, (int, float)), \"Low boundary must be a number\"\n            assert isinstance(high_a, (int, float)), \"High boundary must be a number\"\n\n            if not (low_a < node_a.val_a < high_a):\n                return False\n            \n            return (validate_a(node_a.left_a, low_a, node_a.val_a) and \n                    validate_a(node_a.right_a, node_a.val_a, high_a))\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n\n    return validate_a(root_a, float('-inf'), float('inf'))\n```",
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song_a: str) -> None:\n        try:\n            assert isinstance(song_a, str), \"Song must be a string\"\n            self.songs.append(song_a)\n        except AssertionError as e:\n            print(e)\n\n    @retry\n    def remove_song(self, song_a: str) -> None:\n        try:\n            assert song_a in self.songs, \"Song not found in the playlist\"\n            self.songs.remove(song_a)\n        except AssertionError as e:\n            print(e)\n```"
      ]
    }
  ]
}