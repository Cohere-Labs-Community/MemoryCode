{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_unit_valid(x_unit):\n        x_unit = [x_number for x_number in x_unit if x_number != '.']\n        return len(x_unit) == len(set(x_unit))\n\n    for x_i in range(9):\n        if not x_is_unit_valid(x_board[x_i]) or not x_is_unit_valid([x_board[x_j][x_i] for x_j in range(9)]):\n            return False\n\n    for x_i in range(0, 9, 3):\n        for x_j in range(0, 9, 3):\n            x_box = [x_board[x_m][x_n] for x_m in range(x_i, x_i + 3) for x_n in range(x_j, x_j + 3)]\n            if not x_is_unit_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef x_is_valid_sudoku(x_board):\n    def x_is_valid(x_entries):\n        x_seen = set()\n        for x_num in x_entries:\n            if x_num != '.':\n                if x_num in x_seen:\n                    return False\n                x_seen.add(x_num)\n        return True\n\n    for x_row in x_board:\n        if not x_is_valid(x_row):\n            return False\n\n    for x_col_idx in range(9):\n        x_column = [x_board[x_row_idx][x_col_idx] for x_row_idx in range(9)]\n        if not x_is_valid(x_column):\n            return False\n\n    for x_box_row in range(0, 9, 3):\n        for x_box_col in range(0, 9, 3):\n            x_box = [x_board[x_row][x_col] for x_row in range(x_box_row, x_box_row + 3) for x_col in range(x_box_col, x_box_col + 3)]\n            if not x_is_valid(x_box):\n                return False\n\n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\nfrom collections import Counter\n\nclass NearestNeighborsModel:\n    def __init__(self, y_n_neighbors=3):\n        assert isinstance(y_n_neighbors, int) and y_n_neighbors > 0, \"Number of neighbors must be a positive integer.\"\n        self.y_n_neighbors = y_n_neighbors\n        self.y_training_data = None\n        self.y_training_labels = None\n\n    def train(self, y_data, y_labels):\n        assert len(y_data) == len(y_labels), \"The number of data points must match the number of labels.\"\n        self.y_training_data = np.array(y_data)\n        self.y_training_labels = np.array(y_labels)\n\n    def predict(self, y_data):\n        assert self.y_training_data is not None and self.y_training_labels is not None, \"Model has not been trained yet.\"\n        y_data = np.array(y_data)\n\n        y_predictions = []\n        for y_point in y_data:\n            y_distances = np.linalg.norm(self.y_training_data - y_point, axis=1)\n            y_neighbor_indices = np.argsort(y_distances)[:self.y_n_neighbors]\n            y_neighbor_labels = self.y_training_labels[y_neighbor_indices]\n            y_most_common = Counter(y_neighbor_labels).most_common(1)\n            y_predictions.append(y_most_common[0][0])\n\n        return y_predictions\n```",
        "```python\ndef is_valid_sudoku(y_board):\n    assert isinstance(y_board, list), \"Input must be a list.\"\n    assert len(y_board) == 9, \"Board must have 9 rows.\"\n    for y_row in y_board:\n        assert isinstance(y_row, list), \"Each row must be a list.\"\n        assert len(y_row) == 9, \"Each row must have 9 columns.\"\n\n    def y_is_valid_group(y_group):\n        y_numbers = [num for num in y_group if num != '.']\n        return len(y_numbers) == len(set(y_numbers))\n\n    # Check rows\n    for y_row in y_board:\n        if not y_is_valid_group(y_row):\n            return False\n\n    # Check columns\n    for y_col_idx in range(9):\n        y_column = [y_board[y_row_idx][y_col_idx] for y_row_idx in range(9)]\n        if not y_is_valid_group(y_column):\n            return False\n\n    # Check 3x3 sub-grids\n    for y_box_row in range(3):\n        for y_box_col in range(3):\n            y_box = [y_board[y_row][y_col] \n                     for y_row in range(y_box_row*3, (y_box_row+1)*3) \n                     for y_col in range(y_box_col*3, (y_box_col+1)*3)]\n            if not y_is_valid_group(y_box):\n                return False\n\n    return True\n```\n"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```",
        "```python\ndef y_is_valid_sudoku(y_board):\n    y_rows = len(y_board)\n    y_columns = len(y_board[0])\n    \n    if y_rows != 9 or y_columns != 9:\n        return False\n    \n    def y_is_valid_group(y_group):\n        y_elements = [num for num in y_group if num != '.']\n        return len(y_elements) == len(set(y_elements))\n    \n    for y_row in y_board:\n        if not y_is_valid_group(y_row):\n            return False\n    \n    for y_col in range(9):\n        y_column_numbers = [y_board[y_row][y_col] for y_row in range(9)]\n        if not y_is_valid_group(y_column_numbers):\n            return False\n    \n    for y_box_row in range(0, 9, 3):\n        for y_box_col in range(0, 9, 3):\n            y_box_numbers = [y_board[y_row][y_col] \n                             for y_row in range(y_box_row, y_box_row + 3) \n                             for y_col in range(y_box_col, y_box_col + 3)]\n            if not y_is_valid_group(y_box_numbers):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBST(root: TreeNode) -> bool:\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if not node:\n                return True\n            if not (low < node.val < high):\n                return False\n            return (validate(node.left, low, node.val) and \n                    validate(node.right, node.val, high))\n        except Exception as e:\n            print(\"Exception occurred:\", e)\n            return False\n    \n    return validate(root)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef w_is_valid_sudoku(w_board):\n    def w_is_valid_unit(w_unit):\n        w_unit = [w_number for w_number in w_unit if w_number != '.']\n        return len(w_unit) == len(set(w_unit))\n    \n    def w_is_valid_row():\n        for w_row in w_board:\n            if not w_is_valid_unit(w_row):\n                return False\n        return True\n\n    def w_is_valid_column():\n        for w_col_index in range(9):\n            w_column = [w_board[w_row_index][w_col_index] for w_row_index in range(9)]\n            if not w_is_valid_unit(w_column):\n                return False\n        return True\n\n    def w_is_valid_sub_box():\n        for w_box_row in range(3):\n            for w_box_col in range(3):\n                w_box = [w_board[w_row_index][w_col_index]\n                         for w_row_index in range(w_box_row * 3, (w_box_row + 1) * 3)\n                         for w_col_index in range(w_box_col * 3, (w_box_col + 1) * 3)]\n                if not w_is_valid_unit(w_box):\n                    return False\n        return True\n\n    return w_is_valid_row() and w_is_valid_column() and w_is_valid_sub_box()\n```",
        "```python\nimport numpy as np\n\nclass LinearRegressionModel:\n    def __init__(self):\n        self.w_weights_1 = None\n        self.w_bias_1 = None\n    \n    def w_fit_1(self, w_X_train_1, w_y_train_1):\n        w_n_samples, w_n_features = w_X_train_1.shape\n        w_X_b_1 = np.hstack((np.ones((w_n_samples, 1)), w_X_train_1))\n        w_theta_best_1 = np.linalg.inv(w_X_b_1.T.dot(w_X_b_1)).dot(w_X_b_1.T).dot(w_y_train_1)\n        self.w_bias_1 = w_theta_best_1[0]\n        self.w_weights_1 = w_theta_best_1[1:]\n    \n    def w_predict_1(self, w_X_test_1):\n        if self.w_weights_1 is None or self.w_bias_1 is None:\n            raise ValueError(\"Model is not fitted yet. Please call the 'w_fit_1' method first.\")\n        return w_X_test_1.dot(self.w_weights_1) + self.w_bias_1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(w_board):\n    def is_valid_block(w_block):\n        w_nums = [num for num in w_block if num != '.']\n        return len(w_nums) == len(set(w_nums))\n    \n    for w_row in w_board:\n        if not is_valid_block(w_row):\n            return False\n    \n    for w_col in zip(*w_board):\n        if not is_valid_block(w_col):\n            return False\n    \n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_block = [w_board[w_x][w_y] for w_x in range(w_i, w_i + 3) for w_y in range(w_j, w_j + 3)]\n            if not is_valid_block(w_block):\n                return False\n    \n    return True\n```",
        "```python\nimport numpy as np\n\nclass LinRegNumpy:\n    def __init__(self):\n        self.coef1_ = None\n        self.intercept1_ = 0\n        self.fit1_intercept = True\n    \n    def fit(self, X1, y1):\n        if self.fit1_intercept:\n            X1 = np.c_[np.ones(X1.shape[0]), X1]\n        \n        X1_transpose = X1.T\n        beta1 = np.linalg.inv(X1_transpose.dot(X1)).dot(X1_transpose).dot(y1)\n        \n        if self.fit1_intercept:\n            self.intercept1_ = beta1[0]\n            self.coef1_ = beta1[1:]\n        else:\n            self.coef1_ = beta1\n    \n    def predict(self, X1):\n        if self.fit1_intercept:\n            X1 = np.c_[np.ones(X1.shape[0]), X1]\n            return X1.dot(np.r_[self.intercept1_, self.coef1_])\n        else:\n            return X1.dot(self.coef1_)\n```\n"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef count_non_zero1_elements(matrix):\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count\n```"
      ],
      "instruction_model_output": [
        "```python\ndef c1ount_non_zero(matrix):\n    non_zero_c1ount = 0\n    for r1ow in matrix:\n        for e1lement in r1ow:\n            if e1lement != 0:\n                non_zero_c1ount += 1\n    return non_zero_c1ount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef m_is_valid_sudoku(m_board):\n    def m_is_valid_block(m_block):\n        m_block = [m_num for m_num in m_block if m_num != '.']\n        return len(m_block) == len(set(m_block))\n\n    for m_row in m_board:\n        if not m_is_valid_block(m_row):\n            return False\n\n    for m_col in zip(*m_board):\n        if not m_is_valid_block(m_col):\n            return False\n\n    for m_box_start_row in range(0, 9, 3):\n        for m_box_start_col in range(0, 9, 3):\n            m_box = [m_board[m_row][m_col]\n                     for m_row in range(m_box_start_row, m_box_start_row + 3)\n                     for m_col in range(m_box_start_col, m_box_start_col + 3)]\n            if not m_is_valid_block(m_box):\n                return False\n                \n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef m_is_valid_sudoku(m_board):\n    def m_is_valid_unit(m_unit):\n        m_unit = [m_num for m_num in m_unit if m_num != '.']\n        return len(m_unit) == len(set(m_unit))\n\n    def m_is_valid_row(m_board):\n        for m_row in m_board:\n            if not m_is_valid_unit(m_row):\n                return False\n        return True\n\n    def m_is_valid_col(m_board):\n        for m_col in zip(*m_board):\n            if not m_is_valid_unit(m_col):\n                return False\n        return True\n\n    def m_is_valid_box(m_board):\n        for m_i in (0, 3, 6):\n            for m_j in (0, 3, 6):\n                m_box = [m_board[m_x][m_y] for m_x in range(m_i, m_i + 3) for m_y in range(m_j, m_j + 3)]\n                if not m_is_valid_unit(m_box):\n                    return False\n        return True\n\n    return m_is_valid_row(m_board) and m_is_valid_col(m_board) and m_is_valid_box(m_board)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef a_calculate_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef a_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    \"\"\"\n    A class used to represent an inventory for managing stocks.\n\n    Attributes\n    ----------\n    stock : dict\n        A dictionary to hold the items and their corresponding quantities.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of the Inventory class with an empty stock.\n        \"\"\"\n        self.stock = {}\n\n    def b_add_stock(self, item, quantity):\n        \"\"\"\n        Adds a specified quantity of an item to the inventory.\n\n        Parameters\n        ----------\n        item : str\n            The name of the item to be added.\n        quantity : int\n            The amount of the item to be added.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        \"\"\"\n        Removes a specified quantity of an item from the inventory.\n\n        Parameters\n        ----------\n        item : str\n            The name of the item to be removed.\n        quantity : int\n            The amount of the item to be removed.\n\n        Returns\n        -------\n        bool\n            Returns True if the item was successfully removed, False if the operation failed (e.g., not enough stock).\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n            return True\n        return False\n```\n",
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"\n        Initialize a new tree node.\n\n        Parameters:\n        key (int): The key/value of the tree node.\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def b_insert(self, key):\n        \"\"\"\n        Insert a new key into the binary tree.\n\n        Parameters:\n        key (int): The key to be inserted into the tree.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._b_insert_rec(self.root, key)\n\n    def _b_insert_rec(self, node, key):\n        \"\"\"\n        Recursively insert a key starting from the given node.\n\n        Parameters:\n        node (TreeNode): The current node in the tree.\n        key (int): The key to be inserted into the tree.\n        \"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._b_insert_rec(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._b_insert_rec(node.right, key)\n\n    def b_delete(self, key):\n        \"\"\"\n        Delete the key from the binary tree if it exists.\n\n        Parameters:\n        key (int): The key to be deleted from the tree.\n        \"\"\"\n        self.root = self._b_delete_rec(self.root, key)\n\n    def _b_delete_rec(self, node, key):\n        \"\"\"\n        Recursively delete a key starting from the given node.\n\n        Parameters:\n        node (TreeNode): The current node in the tree.\n        key (int): The key to be deleted from the tree.\n\n        Returns:\n        TreeNode: The root of the subtree with the key deleted.\n        \"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._b_delete_rec(node.left, key)\n        elif key > node.val:\n            node.right = self._b_delete_rec(node.right, key)\n        else:\n            # Node with only one child or no child\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: get the inorder successor\n            node.val = self._min_value_node(node.right).val\n            node.right = self._b_delete_rec(node.right, node.val)\n\n        return node\n\n    def _min_value_node(self, node):\n        \"\"\"\n        Find the node with the smallest value greater than this node.\n\n        Parameters:\n        node (TreeNode): The node from which to find the min value node.\n\n        Returns:\n        TreeNode: The node with the smallest key in the tree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def b_add_stock(self, item, quantity):\n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        if item in self.items:\n            if self.items[item] >= quantity:\n                self.items[item] -= quantity\n                if self.items[item] == 0:\n                    del self.items[item]\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```",
        "```python\nclass TreeNode:\n    def __init__(self, key):\n        \"\"\"Initialize a tree node with key and no children.\"\"\"\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinaryTree:\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Insert a new node with the given key.\"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper method to insert a new node.\"\"\"\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def delete(self, key):\n        \"\"\"Delete the node with the given key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        \"\"\"Recursive helper method to delete a node.\"\"\"\n        if node is None:\n            return node\n\n        if key < node.val:\n            node.left = self._delete(node.left, key)\n        elif key > node.val:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_larger_node = self._find_min(node.right)\n            node.val = min_larger_node.val\n            node.right = self._delete(node.right, min_larger_node.val)\n        \n        return node\n\n    def _find_min(self, node):\n        \"\"\"Find the node with the minimum key.\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef gn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef gn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def md_add_stock(self, item_name, quantity):\n        if item_name in self.items:\n            self.items[item_name] += quantity\n        else:\n            self.items[item_name] = quantity\n\n    def md_remove_stock(self, item_name, quantity):\n        if item_name in self.items and self.items[item_name] >= quantity:\n            self.items[item_name] -= quantity\n            if self.items[item_name] == 0:\n                del self.items[item_name]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n        \n    def md_add_stock(self, item, quantity):\n        if item not in self.stock:\n            self.stock[item] = 0\n        self.stock[item] += quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef find_common_elements(list1_0, list2_0):\n    \"\"\"Returns a list of common elements between two lists.\"\"\"\n    return list(set(list1_0) & set(list2_0))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef find_common_elements(list1_a, list2_b):\n    return list(set(list1_a) & set(list2_b))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef n_is_valid_sudoku(n_board):\n    def n_is_valid_group(n_group):\n        n_nums = [n for n in n_group if n != '.']\n        return len(n_nums) == len(set(n_nums))\n\n    for n_row in n_board:\n        if not n_is_valid_group(n_row):\n            return False\n\n    for n_col in zip(*n_board):\n        if not n_is_valid_group(n_col):\n            return False\n\n    for n_i in range(0, 9, 3):\n        for n_j in range(0, 9, 3):\n            n_square = [n_board[n_x][n_y] for n_x in range(n_i, n_i + 3) for n_y in range(n_j, n_j + 3)]\n            if not n_is_valid_group(n_square):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef n_is_valid_sudoku(n_board):\n    def n_is_valid_block(n_block):\n        n_block = [n_num for n_num in n_block if n_num != '.']\n        return len(n_block) == len(set(n_block))\n    \n    for n_row in n_board:\n        if not n_is_valid_block(n_row):\n            return False\n    \n    for n_col_idx in range(9):\n        n_col = [n_board[n_row_idx][n_col_idx] for n_row_idx in range(9)]\n        if not n_is_valid_block(n_col):\n            return False\n    \n    for n_row_start in range(0, 9, 3):\n        for n_col_start in range(0, 9, 3):\n            n_block = [n_board[n_row][n_col] \n                       for n_row in range(n_row_start, n_row_start + 3) \n                       for n_col in range(n_col_start, n_col_start + 3)]\n            if not n_is_valid_block(n_block):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    def is_valid_block(block):\n        wr_nums = [num for num in block if num != '.']\n        return len(wr_nums) == len(set(wr_nums))\n    \n    for wr_row in board:\n        if not is_valid_block(wr_row):\n            return False\n    \n    for wr_col in zip(*board):\n        if not is_valid_block(wr_col):\n            return False\n    \n    for wr_box_row in range(0, 9, 3):\n        for wr_box_col in range(0, 9, 3):\n            wr_box = [board[wr_box_row + wr_i][wr_box_col + wr_j] for wr_i in range(3) for wr_j in range(3)]\n            if not is_valid_block(wr_box):\n                return False\n                \n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\ndef wr_is_valid_sudoku(wr_board):\n    def wr_is_valid_block(wr_block):\n        wr_block = [wr_num for wr_num in wr_block if wr_num != '.']\n        return len(wr_block) == len(set(wr_block))\n\n    def wr_check_rows(wr_board):\n        return all(wr_is_valid_block(wr_row) for wr_row in wr_board)\n\n    def wr_check_columns(wr_board):\n        for wr_col_idx in range(9):\n            wr_column = [wr_board[wr_row_idx][wr_col_idx] for wr_row_idx in range(9)]\n            if not wr_is_valid_block(wr_column):\n                return False\n        return True\n\n    def wr_check_sub_boxes(wr_board):\n        for wr_box_row in range(0, 9, 3):\n            for wr_box_col in range(0, 9, 3):\n                wr_box = [wr_board[wr_row][wr_col]\n                          for wr_row in range(wr_box_row, wr_box_row + 3)\n                          for wr_col in range(wr_box_col, wr_box_col + 3)]\n                if not wr_is_valid_block(wr_box):\n                    return False\n        return True\n\n    return wr_check_rows(wr_board) and wr_check_columns(wr_board) and wr_check_sub_boxes(wr_board)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\nfrom sklearn.linear_model import Lasso\nfrom sklearn.preprocessing import StandardScaler\n\nclass Z_LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.z_model = Lasso(alpha=alpha)\n        self.z_scaler = StandardScaler()\n\n    def train(self, z_X, z_y):\n        try:\n            z_X_scaled = self.z_scaler.fit_transform(z_X)\n            self.z_model.fit(z_X_scaled, z_y)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, z_X):\n        try:\n            z_X_scaled = self.z_scaler.transform(z_X)\n            return self.z_model.predict(z_X_scaled)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            return None\n```",
        "```python\ndef z_is_valid_sudoku(z_board):\n    \"\"\"\n    Determine if a given 9x9 Sudoku board is valid.\n    \n    :param z_board: List[List[str]] - 9x9 Sudoku board\n    :return: bool - True if the board is valid, False otherwise\n    \"\"\"\n    try:\n        def z_is_valid_list(z_values):\n            z_values = [val for val in z_values if val != '.']\n            return len(z_values) == len(set(z_values))\n\n        for z_row in z_board:\n            if not z_is_valid_list(z_row):\n                return False\n\n        for z_col in range(9):\n            if not z_is_valid_list([z_board[z_row][z_col] for z_row in range(9)]):\n                return False\n\n        for z_box_row in range(0, 9, 3):\n            for z_box_col in range(0, 9, 3):\n                z_box = [z_board[z_row][z_col] for z_row in range(z_box_row, z_box_row + 3) \n                                                for z_col in range(z_box_col, z_box_col + 3)]\n                if not z_is_valid_list(z_box):\n                    return False\n\n        return True\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\ndef z_is_valid_sudoku(z_board):\n    def z_is_valid_block(z_block):\n        z_non_empty_values = [z_num for z_num in z_block if z_num != '.']\n        return len(z_non_empty_values) == len(set(z_non_empty_values))\n    \n    for z_row in z_board:\n        if not z_is_valid_block(z_row):\n            return False\n    \n    for z_col_index in range(9):\n        z_column = [z_board[z_row_index][z_col_index] for z_row_index in range(9)]\n        if not z_is_valid_block(z_column):\n            return False\n    \n    for z_box_row in range(3):\n        for z_box_col in range(3):\n            z_sub_box = [\n                z_board[z_row][z_col]\n                for z_row in range(z_box_row * 3, (z_box_row + 1) * 3)\n                for z_col in range(z_box_col * 3, (z_box_col + 1) * 3)\n            ]\n            if not z_is_valid_block(z_sub_box):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef vr_chx_is_valid_sudoku(vr_chx_board):\n    def vr_chx_is_valid_block(vr_chx_block):\n        vr_chx_nums = [num for num in vr_chx_block if num != '.']\n        return len(vr_chx_nums) == len(set(vr_chx_nums))\n    \n    for vr_chx_row in vr_chx_board:\n        if not vr_chx_is_valid_block(vr_chx_row):\n            return False\n    \n    for vr_chx_col in zip(*vr_chx_board):\n        if not vr_chx_is_valid_block(vr_chx_col):\n            return False\n    \n    for vr_chx_i in range(0, 9, 3):\n        for vr_chx_j in range(0, 9, 3):\n            vr_chx_block = [vr_chx_board[vr_chx_x][vr_chx_y] for vr_chx_x in range(vr_chx_i, vr_chx_i + 3) \n                            for vr_chx_y in range(vr_chx_j, vr_chx_j + 3)]\n            if not vr_chx_is_valid_block(vr_chx_block):\n                return False\n    \n    return True\n```",
        "```python\ndef compute_sum_without_duplicates(vr_lst_chx):\n    vr_unique_chx = list(set(vr_lst_chx))\n    vr_sum_chx = sum(vr_unique_chx)\n    return vr_sum_chx\n```"
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```",
        "```python\ndef sum_chx_unique(chx_numbers):\n    unique_chx_numbers = list(set(chx_numbers))\n    chx_sum = sum(unique_chx_numbers)\n    return chx_sum\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def x_add_stock(self, item_chx, quantity_chx):\n        if item_chx in self.stock:\n            self.stock[item_chx] += quantity_chx\n        else:\n            self.stock[item_chx] = quantity_chx\n\n    def x_remove_stock(self, item_chx, quantity_chx):\n        if item_chx in self.stock and self.stock[item_chx] >= quantity_chx:\n            self.stock[item_chx] -= quantity_chx\n            if self.stock[item_chx] == 0:\n                del self.stock[item_chx]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist.\")\n```",
        "```python\ndef x_compute_dot_product(chx_vector1, chx_vector2):\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def x_add_stock(self, item_name, quantity):\n        if item_name in self._items:\n            self._items[item_name] += quantity\n        else:\n            self._items[item_name] = quantity\n\n    def x_remove_stock(self, item_name, quantity):\n        if item_name in self._items:\n            if self._items[item_name] >= quantity:\n                self._items[item_name] -= quantity\n                if self._items[item_name] == 0:\n                    del self._items[item_name]\n            else:\n                raise ValueError(\"Quantity to remove exceeds current stock.\")\n        else:\n            raise KeyError(f\"Item '{item_name}' not found in inventory.\")\n```",
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    if len(chx_vector1) != len(chx_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def ud_add_stock(self, item_name, quantity):\n        if item_name in self.items:\n            self.items[item_name] += quantity\n        else:\n            self.items[item_name] = quantity\n\n    def ud_remove_stock(self, item_name, quantity):\n        if item_name in self.items:\n            if self.items[item_name] >= quantity:\n                self.items[item_name] -= quantity\n                if self.items[item_name] == 0:\n                    del self.items[item_name]\n            else:\n                raise ValueError(\"Not enough stock to remove\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n    \n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n    \n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Not enough stock to remove the requested quantity.\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport gzip\n\ndef product_except_self_m(nums_m):\n    length_m = len(nums_m)\n    left_products_m = [1] * length_m\n    right_products_m = [1] * length_m\n    result_m = [1] * length_m\n\n    left_running_product_m = 1\n    for i in range(length_m):\n        left_products_m[i] = left_running_product_m\n        left_running_product_m *= nums_m[i]\n\n    right_running_product_m = 1\n    for i in range(length_m - 1, -1, -1):\n        right_products_m[i] = right_running_product_m\n        right_running_product_m *= nums_m[i]\n\n    for i in range(length_m):\n        result_m[i] = left_products_m[i] * right_products_m[i]\n\n    return result_m\n```",
        "```python\nimport gzip\n\ndef is_palindrome_m(input_string_m: str) -> bool:\n    cleaned_string_m = ''.join(char_m.lower() for char_m in input_string_m if char_m.isalnum())\n    return cleaned_string_m == cleaned_string_m[::-1]\n```"
      ],
      "instruction_model_output": [
        "```python\nimport gzip\n\ndef product_except_self(nums):\n    length = len(nums)\n    left_products, right_products, result = [1] * length, [1] * length, [1] * length\n\n    # Fill in the left products array\n    for i in range(1, length):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    # Fill in the right products array\n    for i in range(length - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    # Fill in the result array\n    for i in range(length):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n```",
        "```python\ndef is_valid_palindrome(check_str_m):\n    clean_str_m = ''.join(char_m.lower() for char_m in check_str_m if char_m.isalnum())\n    return clean_str_m == clean_str_m[::-1]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport locale\n\ndef fn_lcm(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    return abs(a * b) // gcd(a, b)\n```",
        "```python\nimport locale\n\ndef fn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\nimport locale\n\ndef lcm(a, b):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    return abs(a * b) // gcd(a, b)\n```",
        "```python\ndef fn_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    \"\"\"\n    Finds the k-th largest element in an array.\n\n    Args:\n        nums (List[int]): The list of integers.\n        k (int): The position from the largest element to find (1-based index).\n\n    Returns:\n        int: The k-th largest element in the list.\n\n    Constraints:\n        The number of elements in nums is at least k.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "history_model_output": [
        "```python\ndef gn_sum_unique_numbers(wr_numbers: list[int]) -> int:\n    \"\"\"\n    Removes duplicates from the given list, calculates the sum of the unique elements,\n    and returns the result.\n\n    Parameters:\n    wr_numbers (list[int]): A list of numbers to process.\n\n    Returns:\n    int: The sum of the unique numbers from the list.\n    \"\"\"\n    unique_wr_numbers = set(wr_numbers)\n    return sum(unique_wr_numbers)\n```",
        "```python\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.w_weights_chx = None\n        self.b_intercept_chx = None\n\n    def x_fit(self_chx, x_features_chx, y_target_chx):\n        x_features_chx = np.insert(x_features_chx, 0, 1, axis=1)\n        x_transpose_chx = x_features_chx.T\n        x_transpose_dot_x_chx = np.dot(x_transpose_chx, x_features_chx)\n        x_transpose_dot_y_chx = np.dot(x_transpose_chx, y_target_chx)\n        self.w_weights_chx = np.linalg.solve(x_transpose_dot_x_chx, x_transpose_dot_y_chx)\n\n    def x_predict(self_chx, x_features_chx):\n        x_features_chx = np.insert(x_features_chx, 0, 1, axis=1)\n        return np.dot(x_features_chx, self_chx.w_weights_chx)\n\n    def x_score(self_chx, x_features_chx, y_target_chx):\n        y_pred_chx = self_chx.x_predict(x_features_chx)\n        total_sum_of_squares_chx = np.sum((y_target_chx - np.mean(y_target_chx))**2)\n        residual_sum_of_squares_chx = np.sum((y_target_chx - y_pred_chx)**2)\n        return 1 - (residual_sum_of_squares_chx / total_sum_of_squares_chx)\n```\n",
        "```python\ndef x_is_valid_sudoku(board_chx):\n    def x_is_valid_unit(unit_chx):\n        unit_chx = [x for x in unit_chx if x != '.']\n        return len(unit_chx) == len(set(unit_chx))\n    \n    for row_chx in board_chx:\n        if not x_is_valid_unit(row_chx):\n            return False\n\n    for col_idx_chx in range(9):\n        if not x_is_valid_unit([board_chx[row_idx_chx][col_idx_chx] for row_idx_chx in range(9)]):\n            return False\n\n    for row_chx in range(0, 9, 3):\n        for col_chx in range(0, 9, 3):\n            block_chx = [board_chx[r_chx][c_chx] for r_chx in range(row_chx, row_chx + 3) \n                         for c_chx in range(col_chx, col_chx + 3)]\n            if not x_is_valid_unit(block_chx):\n                return False\n\n    return True\n```",
        "```python\nimport numpy as np\nfrom sklearn.linear_model import Lasso\n\nclass x_Lasso_m:\n    def __init__(self, alpha_m: float_chx = 0.1_m):\n        self.alpha_m = alpha_m\n        self.model_m = Lasso(alpha=self.alpha_m)\n\n    def x_train_m(self, X_m: np.ndarray_chx, y_m: np.ndarray_chx):\n        try:\n            assert X_m.ndim == 2_chx, \"Input X must be a 2D array.\"\n            assert y_m.ndim == 1_chx, \"Input y must be a 1D array.\"\n            self.model_m.fit(X_m, y_m)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def x_predict_m(self, X_test_m: np.ndarray_chx) -> np.ndarray_chx:\n        try:\n            assert X_test_m.ndim == 2_chx, \"Input X_test must be a 2D array.\"\n            return self.model_m.predict(X_test_m)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            return np.array([])\n```",
        "```python\nclass TreeNode:\n    def __init__(self, n_value):\n        self.w_value_n = n_value\n        self.w_left_n = None\n        self.w_right_n = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.w_root_n = None\n    \n    def ud_insert_node(self, x_value_chx):\n        if self.w_root_n is None:\n            self.w_root_n = TreeNode(x_value_chx)\n        else:\n            self._ud_insert_recursive(self.w_root_n, x_value_chx)\n\n    def _ud_insert_recursive(self, x_node_chx, x_value_chx):\n        if x_value_chx < x_node_chx.w_value_n:\n            if x_node_chx.w_left_n is None:\n                x_node_chx.w_left_n = TreeNode(x_value_chx)\n            else:\n                self._ud_insert_recursive(x_node_chx.w_left_n, x_value_chx)\n        else:\n            if x_node_chx.w_right_n is None:\n                x_node_chx.w_right_n = TreeNode(x_value_chx)\n            else:\n                self._ud_insert_recursive(x_node_chx.w_right_n, x_value_chx)\n\n    def ud_delete_node(self, x_value_chx):\n        self.w_root_n = self._ud_delete_recursive(self.w_root_n, x_value_chx)\n\n    def _ud_delete_recursive(self, x_node_chx, x_value_chx):\n        if x_node_chx is None:\n            return x_node_chx\n        \n        if x_value_chx < x_node_chx.w_value_n:\n            x_node_chx.w_left_n = self._ud_delete_recursive(x_node_chx.w_left_n, x_value_chx)\n        elif x_value_chx > x_node_chx.w_value_n:\n            x_node_chx.w_right_n = self._ud_delete_recursive(x_node_chx.w_right_n, x_value_chx)\n        else:\n            if x_node_chx.w_left_n is None:\n                return x_node_chx.w_right_n\n            elif x_node_chx.w_right_n is None:\n                return x_node_chx.w_left_n\n            \n            x_node_chx.w_value_n = self._x_min_value_chx(x_node_chx.w_right_n)\n            x_node_chx.w_right_n = self._ud_delete_recursive(x_node_chx.w_right_n, x_node_chx.w_value_n)\n        \n        return x_node_chx\n\n    def _x_min_value_chx(self, x_node_chx):\n        current = x_node_chx\n        while current.w_left_n is not None:\n            current = current.w_left_n\n        return current.w_value_n\n\n```",
        "```python\nfrom gzip import compress\nfrom locale import *\n\nclass Inventory:\n    def __init__(self):\n        self.x_stock_chx = {}\n\n    def x_add_md_stock_chx(self, x_item_chx: str, x_quantity_chx: int) -> None:\n        assert isinstance(x_quantity_chx, int) and x_quantity_chx > 0, \"Quantity must be a positive integer\"\n        try:\n            if x_item_chx in self.x_stock_chx:\n                self.x_stock_chx[x_item_chx] += x_quantity_chx\n            else:\n                self.x_stock_chx[x_item_chx] = x_quantity_chx\n        except Exception as e:\n            print(f\"Error adding stock: {e}\")\n\n    def x_remove_md_stock_chx(self, x_item_chx: str, x_quantity_chx: int) -> None:\n        assert isinstance(x_quantity_chx, int) and x_quantity_chx > 0, \"Quantity must be a positive integer\"\n        try:\n            if x_item_chx in self.x_stock_chx and self.x_stock_chx[x_item_chx] >= x_quantity_chx:\n                self.x_stock_chx[x_item_chx] -= x_quantity_chx\n            else:\n                raise ValueError(\"Insufficient stock or item not found\")\n        except Exception as e:\n            print(f\"Error removing stock: {e}\")\n```",
        "```python\ndef ud_find_kth_largest_m(my_array_chx, k_chx):\n    import gzip\n    import locale\n\n    # Ensure the input array is not empty and k_chx is valid\n    assert my_array_chx is not None and len(my_array_chx) > 0, \"Input array must not be empty.\"\n    assert 1 <= k_chx <= len(my_array_chx), \"k_chx must be within the valid range.\"\n\n    try:\n        sorted_array_chx = sorted(my_array_chx, reverse=True)\n        return sorted_array_chx[k_chx - 1]\n    except Exception as e_chx:\n        raise ValueError(f\"An error occurred while finding the {k_chx}th largest element: {e_chx}\")\n```\n",
        "```python\nimport gzip\nimport locale\nfrom collections import Counter\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, fn_k: int_chx):\n        self.x_train_data_m = None\n        self.x_train_labels_m = None\n        self.fn_k_m = fn_k\n\n    def x_train_m(self, x_data_chx, x_labels_chx):\n        assert isinstance(x_data_chx, list)\n        assert isinstance(x_labels_chx, list)\n        assert len(x_data_chx) == len(x_labels_chx)\n        self.x_train_data_m = x_data_chx\n        self.x_train_labels_m = x_labels_chx\n\n    def x_predict_m(self, x_data_chx):\n        assert self.x_train_data_m is not None\n        y_predictions_chx = []\n        for x_instance_chx in x_data_chx:\n            y_label_chx = self._ud_get_nearest_neighbors_chx(x_instance_chx)\n            y_predictions_chx.append(y_label_chx)\n        return y_predictions_chx\n\n    def _ud_get_nearest_neighbors_chx(self, x_instance_chx):\n        distances_m = []\n        for index_m, data_point_m in enumerate(self.x_train_data_m):\n            dist_m = distance.euclidean(x_instance_chx, data_point_m)\n            distances_m.append((dist_m, self.x_train_labels_m[index_m]))\n        distances_m.sort(key=lambda x_chx: x_chx[0])\n        nearest_neighbors_m = [label_m for _, label_m in distances_m[:self.fn_k_m]]\n        return Counter(nearest_neighbors_m).most_common(1)[0][0]\n```\n",
        "```python\ndef gn_count_nonzeros_fn(matrix: list) -> int:\n    \"\"\"\n    Function to count the number of non-zero elements in a matrix.\n\n    :param matrix: List[List[int|float]]; a list of lists representing a matrix.\n    :return: int; the count of non-zero elements in the matrix.\n    \"\"\"\n    wr_count_m: int = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                wr_count_m += 1\n    return wr_count_m\n```",
        "```python\ndef fn_common_elements(list1_chx, list2_chx):\n    \"\"\"\n    Returns a list of common elements from two input lists.\n    \n    Args:\n    list1_chx: The first list of elements.\n    list2_chx: The second list of elements.\n    \n    Returns:\n    A list containing the common elements from both list1_chx and list2_chx.\n    \"\"\"\n    import gzip\n    import locale\n\n    try:\n        assert isinstance(list1_chx, list), \"First argument must be a list\"\n        assert isinstance(list2_chx, list), \"Second argument must be a list\"\n        \n        common_elements_m = [elem_m for elem_m in list1_chx if elem_m in list2_chx]\n        return common_elements_m\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n```",
        "```python\ndef gn_product_array_except_self(lst_chx0: list) -> list:\n    try:\n        wr_length_m = len(lst_chx0)\n        wr_result_m = [1] * wr_length_m\n\n        x_left_product_m = 1\n        for chx_i_m in range(wr_length_m):\n            wr_result_m[chx_i_m] = x_left_product_m\n            x_left_product_m *= lst_chx0[chx_i_m]\n\n        x_right_product_m = 1\n        for chx_i_m in range(wr_length_m - 1, -1, -1):\n            wr_result_m[chx_i_m] *= x_right_product_m\n            x_right_product_m *= lst_chx0[chx_i_m]\n\n        return wr_result_m\n    except Exception as e_chx:\n        print(f\"An error occurred: {e_chx}\")\n```",
        "```python\ndef fn_compute_dot_product(x_vec1: list, x_vec2: list) -> float:\n    assert len(x_vec1) == len(x_vec2), \"Vectors must be of the same length\"\n    try:\n        x_dot_product = sum(x1 * x2 for x1, x2 in zip(x_vec1, x_vec2))\n    except Exception as e:\n        print(\"Error computing dot product:\", e)\n        raise\n    return x_dot_product\n```",
        "```python\nimport gzip\nimport locale\n\ndef fn_check_palindrome1(x_chx_input: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid palindrome.\n    \n    Annotations:\n    x_chx_input : str - The input string to check.\n    Returns : bool - True if the input string is a valid palindrome, False otherwise.\n    \"\"\"\n    x_chx_input_cleaned = ''.join(c for c in x_chx_input if c.isalnum()).lower()\n    return x_chx_input_cleaned == x_chx_input_cleaned[::-1]\n```",
        "```python\nimport math\nimport gzip\nimport locale\n\ndef x_get_least_common_multiple_chx(a_1chx, a_2chx):\n    \"\"\"\n    md_Returns the least common multiple (LCM) of two integers.\n\n    Parameters:\n    a_1chx : int\n        The first integer.\n    a_2chx : int\n        The second integer.\n\n    Returns:\n    int\n        The least common multiple of a_1chx and a_2chx.\n    \"\"\"\n    try:\n        assert isinstance(a_1chx, int) and isinstance(a_2chx, int), \"Inputs must be integers\"\n        return (a_1chx * a_2chx) // math.gcd(a_1chx, a_2chx)\n    except Exception as e_m:\n        raise ValueError(f\"Invalid input provided: {e_m}\") from e_m\n```\n",
        "```python\nimport gzip\nimport locale\n\nfn_isValidBST_m = lambda x_root_chx: False if x_root_chx is None else (   \n    lambda fn_helper_m: fn_helper_m(x_root_chx, float('-inf'), float('inf'))\n)(   \n    lambda x_node_chx, x_min_chx, x_max_chx: (\n        True if x_node_chx is None else (\n            (x_min_chx < x_node_chx.val < x_max_chx) and \n            fn_helper_m(x_node_chx.left, x_min_chx, x_node_chx.val) and \n            fn_helper_m(x_node_chx.right, x_node_chx.val, x_max_chx)\n        )\n    )\n)\n\n```",
        "```python\ndef fn_calculate_h_index_chx(citations_chx):\n    \"\"\"\n    Calculate the H-index for a given list of citations.\n\n    Parameters:\n    citations_chx (list): List of integers representing citation counts.\n\n    Returns:\n    int: The h-index calculated from the given citations.\n    \"\"\"\n    # Sort the citations in descending order\n    citations_chx.sort(reverse=True)\n    h_index_chx = 0\n    \n    # Calculate H-index\n    for i_chx, citation_chx in enumerate(citations_chx):\n        if citation_chx >= i_chx + 1:\n            h_index_chx = i_chx + 1\n        else:\n            break\n    \n    return h_index_chx\n```\n"
      ]
    }
  ]
}