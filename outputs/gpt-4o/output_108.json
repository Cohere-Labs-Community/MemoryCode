{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.nodes:\n            self.nodes[from_node] = []\n        if to_node not in self.nodes:\n            self.nodes[to_node] = []\n        self.nodes[from_node].append((to_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        priority_queue = [(0, start_node)]\n        distances = {node: float('inf') for node in self.nodes}\n        distances[start_node] = 0\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.nodes[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances[end_node] if distances[end_node] != float('inf') else None\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal_md(matrix):\n    assert isinstance(matrix, list), \"Input must be a list of lists\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row must be a list\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n    \n    num_elements = len(matrix)\n    assert num_elements > 0, \"Matrix must not be empty\"\n    \n    diagonal_sum = sum(matrix[i][i] for i in range(num_elements))\n    average = diagonal_sum / num_elements\n    return average\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n    \n    def add_edge_md(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n\n    def shortest_path_md(self, start, end):\n        assert start in self.adjacency_list, \"Start node not in graph.\"\n        assert end in self.adjacency_list, \"End node not in graph.\"\n        \n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        priority_queue = [(0, start)]\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node == end:\n                return current_distance\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        \n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\ndef average_diagonal_md(matrix):\n    assert isinstance(matrix, list) and all(isinstance(row, list) for row in matrix), \"Input must be a list of lists.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square.\"\n    \n    total = sum(matrix[i][i] for i in range(len(matrix)))\n    return total / len(matrix) if len(matrix) > 0 else 0\n```",
        "```python\nclass Graph:\n    def __init__(self, graph_dict=None):\n        if graph_dict is None:\n            graph_dict = {}\n        self.graph_dict = graph_dict\n\n    def add_edge_md(self, node1, node2, weight):\n        if node1 in self.graph_dict:\n            self.graph_dict[node1].append((node2, weight))\n        else:\n            self.graph_dict[node1] = [(node2, weight)]\n\n    def shortest_path_md(self, start_node, end_node):\n        assert start_node in self.graph_dict, \"Start node must be in the graph\"\n        assert end_node in self.graph_dict, \"End node must be in the graph\"\n\n        import heapq\n\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n        distances = {node: float('inf') for node in self.graph_dict}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.graph_dict}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.graph_dict.get(current_node, []):\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path = []\n        current_node = end_node\n        while current_node is not None:\n            path.insert(0, current_node)\n            current_node = previous_nodes[current_node]\n\n        if distances[end_node] == float('inf'):\n            return None\n\n        return path, distances[end_node]\n```"
      ]
    }
  ]
}