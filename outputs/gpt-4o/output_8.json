{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix_o(strs):\n    \"\"\"\n    Finds the longest common prefix string amongst a list of strings.\n\n    Args:\n        strs (list of str): A list of strings to find the common prefix from.\n\n    Returns:\n        str: The longest common prefix. If there is no common prefix, returns an empty string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    shortest_str = min(strs, key=len)\n\n    for i, char in enumerate(shortest_str):\n        for other in strs:\n            if other[i] != char:\n                return shortest_str[:i]\n\n    return shortest_str\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        \"\"\"Initialize an empty graph with a dictionary to hold adjacency lists.\"\"\"\n        self.adjacency_list = {}\n\n    def add_edge(self, source, destination, weight):\n        \"\"\"Add an edge with a weight from source to destination in the graph.\n\n        Args:\n            source: The starting node of the edge.\n            destination: The ending node of the edge.\n            weight: The weight associated with the edge.\n        \"\"\"\n        if source not in self.adjacency_list:\n            self.adjacency_list[source] = []\n        if destination not in self.adjacency_list:\n            self.adjacency_list[destination] = []\n        self.adjacency_list[source].append((destination, weight))\n        \n    def shortest_path_o(self, start, end):\n        \"\"\"Compute the shortest path from start node to end node using Dijkstra's algorithm.\n\n        Args:\n            start: The node from which to start the search.\n            end: The destination node for the path.\n\n        Returns:\n            A tuple containing the total weight of the shortest path and the path itself as a list of nodes.\n            If no path exists, returns (float('inf'), []).\n        \"\"\"\n        min_heap = [(0, start, [])]  # (current_weight, current_node, path_taken)\n        visited = set()\n\n        while min_heap:\n            current_weight, current_node, path_taken = heapq.heappop(min_heap)\n            \n            if current_node in visited:\n                continue\n            \n            path_taken = path_taken + [current_node]\n            visited.add(current_node)\n            \n            if current_node == end:\n                return current_weight, path_taken\n\n            for neighbor, weight in self.adjacency_list.get(current_node, []):\n                if neighbor not in visited:\n                    heapq.heappush(min_heap, (current_weight + weight, neighbor, path_taken))\n\n        return float('inf'), []\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```"
      ],
      "cumulative_model_output": [
        "```python\ndef longest_common_prefix_o(strs):\n    \"\"\"\n    Returns the longest common prefix string from a list of strings.\n    \n    Parameters:\n    strs (List[str]): A list of strings to evaluate.\n    \n    Returns:\n    str: The longest common prefix or an empty string if no common prefix exists.\n    \"\"\"\n    if not strs:\n        return \"\"\n        \n    shortest_str = min(strs, key=len)\n\n    for i, char in enumerate(shortest_str):\n        for other_str in strs:\n            if other_str[i] != char:\n                return shortest_str[:i]\n\n    return shortest_str\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adj_list = {}\n\n    def add_edge_o(self, node1, node2, weight=1):\n        \"\"\"Add an edge between two nodes in the graph with an optional weight.\n\n        Args:\n            node1: The starting node of the edge.\n            node2: The ending node of the edge.\n            weight: The weight of the edge (default is 1).\n        \"\"\"\n        if node1 not in self.adj_list:\n            self.adj_list[node1] = []\n        if node2 not in self.adj_list:\n            self.adj_list[node2] = []\n        self.adj_list[node1].append((node2, weight))\n        self.adj_list[node2].append((node1, weight))  # Assuming undirected graph\n\n    def shortest_path_o(self, start_node, end_node):\n        \"\"\"Compute the shortest path from one node to another using Dijkstra's algorithm.\n\n        Args:\n            start_node: The node to start the search from.\n            end_node: The target node to find the shortest path to.\n\n        Returns:\n            A tuple containing the shortest path and its total weight. If no path is found,\n            returns ([], float('inf')).\n        \"\"\"\n        priority_queue = [(0, start_node, [])]\n        visited = set()\n\n        while priority_queue:\n            current_weight, current_node, path = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            path = path + [current_node]\n            visited.add(current_node)\n\n            if current_node == end_node:\n                return (path, current_weight)\n\n            for neighbor, weight in self.adj_list.get(current_node, []):\n                if neighbor not in visited:\n                    heapq.heappush(priority_queue, (current_weight + weight, neighbor, path))\n\n        return ([], float('inf'))\n```\n"
      ]
    }
  ]
}