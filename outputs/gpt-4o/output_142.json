{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n\n    def __init__(self, capacity_chx):\n        self.r_capacity = capacity_chx\n        self.r_cache = {}\n        self.r_order = []\n\n    def get(self, key_chx):\n        if key_chx in self.r_cache:\n            self.r_order.remove(key_chx)\n            self.r_order.append(key_chx)\n            return self.r_cache[key_chx]\n        return -1\n\n    def put(self, key_chx, value_chx):\n        if key_chx in self.r_cache:\n            self.r_order.remove(key_chx)\n        elif len(self.r_cache) >= self.r_capacity:\n            oldest_chx = self.r_order.pop(0)\n            del self.r_cache[oldest_chx]\n        self.r_cache[key_chx] = value_chx\n        self.r_order.append(key_chx)\n```",
        "```python\ndef compute_dot_product(chx_vector1, chx_vector2):\n    r_dot_product = sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n    return r_dot_product\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, r_capacity: int):\n        self.r_cache = OrderedDict()\n        self.r_capacity = r_capacity\n\n    def get(self, r_key: int) -> int:\n        if r_key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(r_key)\n        return self.r_cache[r_key]\n\n    def put(self, r_key: int, r_value: int) -> None:\n        if r_key in self.r_cache:\n            self.r_cache.move_to_end(r_key)\n        self.r_cache[r_key] = r_value\n        if len(self.r_cache) > self.r_capacity:\n            self.r_cache.popitem(last=False)\n```",
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    if len(chx_vector1) != len(chx_vector2):\n        raise ValueError(\"Vectors must be of the same length\")\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef integer_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    Parameters:\n    num (int): The integer to be converted to Roman numeral.\n\n    Returns:\n    str: A string representing the Roman numeral of the integer.\n\n    Notes:\n    Roman numerals are represented by combinations of the letters I, V, X, L, C, D, and M.\n    The numeral system primarily relies on the additive combination of these letters.\n    \"\"\"\n    # Mapping of integers to their corresponding Roman numeral components, sorted in descending order\n    roman_map = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n\n    # Initialize the result as an empty string\n    roman_numeral = \"\"\n\n    # Iterate over the mapping, calculating the number of times each Roman numeral can be applied\n    for value, symbol in roman_map:\n        # Determine the number of times the current value fits into the remaining number\n        count = num // value\n        # Append the corresponding number of symbols to the result\n        roman_numeral += symbol * count\n        # Decrease the remaining number by the total value represented by the appended symbols\n        num -= value * count\n    \n    return roman_numeral\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer.\"\n        self.n_neighbors = n_neighbors\n        self.train_data = None\n        self.train_labels = None\n\n    def train(self, data, labels):\n        assert isinstance(data, np.ndarray), \"Data must be a numpy array.\"\n        assert isinstance(labels, np.ndarray), \"Labels must be a numpy array.\"\n        assert len(data) == len(labels), \"Data and labels must have the same length.\"\n        \n        self.train_data = data\n        self.train_labels = labels\n\n    def predict(self, test_data):\n        assert self.train_data is not None and self.train_labels is not None, \"Model needs to be trained before prediction.\"\n        assert isinstance(test_data, np.ndarray), \"Test data must be a numpy array.\"\n        \n        predictions = []\n        for test_point in test_data:\n            distances = np.linalg.norm(self.train_data - test_point, axis=1)\n            nearest_neighbor_ids = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.train_labels[nearest_neighbor_ids]\n            most_common = Counter(nearest_labels).most_common(1)\n            predicted_label = most_common[0][0]\n            predictions.append(predicted_label)\n        \n        return np.array(predictions)\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```"
      ],
      "cumulative_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        self.r_n_neighbors = n_neighbors\n        self.r_training_data = None\n        self.r_training_labels = None\n\n    def train(self, chx_data, chx_labels):\n        assert isinstance(chx_data, np.ndarray), \"chx_data should be a NumPy array\"\n        assert isinstance(chx_labels, np.ndarray), \"chx_labels should be a NumPy array\"\n        \n        self.r_training_data = chx_data\n        self.r_training_labels = chx_labels\n\n    def predict(self, chx_data_points):\n        assert self.r_training_data is not None, \"Model has not been trained yet\"\n        assert isinstance(chx_data_points, np.ndarray), \"chx_data_points should be a NumPy array\"\n        \n        predictions = []\n        for chx_data_point in chx_data_points:\n            # Calculate distances from the current point to all training data\n            distances = np.linalg.norm(self.r_training_data - chx_data_point, axis=1)\n            \n            # Get indices of the nearest neighbors\n            nearest_indices = np.argsort(distances)[:self.r_n_neighbors]\n            \n            # Gather the nearest labels\n            nearest_labels = self.r_training_labels[nearest_indices]\n            \n            # Determine the most common label (majority vote)\n            most_common_label = Counter(nearest_labels).most_common(1)[0][0]\n            predictions.append(most_common_label)\n        \n        return np.array(predictions)\n```",
        "```python\ndef compute_dot_product(chx_vector1, chx_vector2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param chx_vector1: List of numbers representing the first vector.\n    :param chx_vector2: List of numbers representing the second vector.\n    :return: The dot product of the two vectors.\n    \"\"\"\n    assert len(chx_vector1) == len(chx_vector2), \"The vectors must be of the same length.\"\n\n    r_dot_product = 0\n    for r_element1, r_element2 in zip(chx_vector1, chx_vector2):\n        r_dot_product += r_element1 * r_element2\n    \n    return r_dot_product\n```",
        "```python\nclass RomanConverter:\n    def __init__(self):\n        self.r_value_map = [\n            (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n            (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n        ]\n\n    def int_to_roman(self, chx_number):\n        \"\"\"\n        Convert an integer to a Roman numeral.\n        \n        :param chx_number: Integer to be converted\n        :return: String representing the Roman numeral\n        \"\"\"\n        assert isinstance(chx_number, int), \"chx_number must be an integer\"\n        assert 1 <= chx_number <= 3999, \"chx_number must be between 1 and 3999\"\n\n        r_roman = \"\"\n        for value, numeral in self.r_value_map:\n            while chx_number >= value:\n                r_roman += numeral\n                chx_number -= value\n        \n        return r_roman\n```",
        "```python\nclass LRUCache:\n    def __init__(self, chx_capacity):\n        self.chx_capacity = chx_capacity\n        self.r_cache = {}\n        self.r_order = []\n\n    def get(self, chx_key):\n        assert chx_key in self.r_cache, \"Key not found in cache.\"\n\n        self.r_order.remove(chx_key)\n        self.r_order.append(chx_key)\n        return self.r_cache[chx_key]\n\n    def put(self, chx_key, chx_value):\n        if chx_key in self.r_cache:\n            self.r_order.remove(chx_key)\n        elif len(self.r_cache) >= self.chx_capacity:\n            r_oldest_key = self.r_order.pop(0)\n            del self.r_cache[r_oldest_key]\n\n        self.r_cache[chx_key] = chx_value\n        self.r_order.append(chx_key)\n```\n"
      ]
    }
  ]
}