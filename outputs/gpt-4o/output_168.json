{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_b(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_b(left_half)\n        merge_sort_b(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_d(array):\n    if len(array) > 1:\n        mid = len(array) // 2\n        left_half = array[:mid]\n        right_half = array[mid:]\n\n        merge_sort_d(left_half)\n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                array[k] = left_half[i]\n                i += 1\n            else:\n                array[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            array[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            array[k] = right_half[j]\n            j += 1\n            k += 1\n```\n",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis_d:\n    def __init__(self):\n        self.classes_ = None\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit_d(self, X, y):\n        self.classes_ = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(self.classes_), n_features))\n        self.covariances_ = np.zeros((len(self.classes_), n_features, n_features))\n        self.priors_ = np.zeros(len(self.classes_))\n        \n        for idx, cls in enumerate(self.classes_):\n            X_cls = X[y == cls]\n            self.means_[idx] = X_cls.mean(axis=0)\n            self.covariances_[idx] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = float(len(X_cls)) / len(X)\n        return self\n\n    def predict_d(self, X):\n        return np.array([self._predict_single_d(x) for x in X])\n\n    def _predict_single_d(self, x):\n        discriminants = []\n        for idx, cls in enumerate(self.classes_):\n            mean = self.means_[idx]\n            covariance = self.covariances_[idx]\n            prior = self.priors_[idx]\n            \n            inv_covariance = np.linalg.inv(covariance)\n            log_det_cov = np.log(np.linalg.det(covariance))\n            \n            log_prob = -0.5 * (np.dot(np.dot((x - mean).T, inv_covariance), (x - mean)) + \\\n                               log_det_cov) + np.log(prior)\n            \n            discriminants.append(log_prob)\n        \n        return self.classes_[np.argmax(discriminants)]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_d(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_d(left_half)\n        merge_sort_d(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to convert. Must be between 1 and 3999 inclusive.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_numeral = ''\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_numeral += syms[i]\n            num -= val[i]\n        i += 1\n    return roman_numeral\n```\n",
        "```python\nfrom typing import List\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    \"\"\"\n    Find the kth largest element in an array.\n    \n    :param nums: List of integers\n    :param k: The kth largest position to find\n    :return: The kth largest element in the list\n    \"\"\"\n    # Sort the list in descending order\n    nums.sort(reverse=True)\n    \n    # Return the kth largest element\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param num: Integer to be converted to a Roman numeral.\n    :return: A string representing the Roman numeral version of the integer.\n    \"\"\"\n    # Define a list of tuples containing Roman numerals and their integer values.\n    val = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    # Initialize an empty string to store the resulting Roman numeral.\n    roman_numeral = ''\n    \n    # Iterate over the list of tuples.\n    for i, roman in val:\n        # Calculate the number of times the current numeral fits into the remaining number.\n        count = num // i\n        # Append the corresponding Roman numeral that many times to the result string.\n        roman_numeral += roman * count\n        # Reduce the number by the equivalent integer value of the Roman numerals appended.\n        num -= i * count\n    \n    # Return the final Roman numeral string.\n    return roman_numeral\n```",
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_a(arr):\n    assert isinstance(arr, list), \"Input must be a list.\"\n    \n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n        \n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n        \n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            assert isinstance(left_half[i], (int, float)), \"Element must be a number.\"\n            assert isinstance(right_half[j], (int, float)), \"Element must be a number.\"\n            \n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n    \n    assert all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)), \"Array must be sorted.\"\n```",
        "```python\ndef diagonal_average_a(matrix):\n    assert isinstance(matrix, list) and all(isinstance(row, list) for row in matrix), \"Input must be a matrix represented as a list of lists.\"\n    assert all(len(row) == len(matrix[0]) for row in matrix), \"All rows must have the same length.\"\n    assert len(matrix) == len(matrix[0]), \"Matrix must be square to have a diagonal.\"\n\n    n = len(matrix)\n    total = 0\n\n    for i in range(n):\n        total += matrix[i][i]\n\n    average = total / n\n    assert isinstance(average, (int, float)), \"The average should be a number.\"\n    return average\n```"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_a(left_half)\n        merge_sort_a(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix(strs):\n    \"\"\"\n    Returns the longest common prefix string among a list of strings.\n\n    Args:\n        strs (List[str]): A list of strings to find the common prefix.\n\n    Returns:\n        str: The longest common prefix. Returns an empty string if there is no common prefix.\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    shortest_str = min(strs, key=len)\n\n    for i, char in enumerate(shortest_str):\n        for string in strs:\n            if string[i] != char:\n                return shortest_str[:i]\n    \n    return shortest_str\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strings):\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Parameters:\n    strings (list of str): A list containing strings to evaluate.\n\n    Returns:\n    str: The longest common prefix.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n\n    common_prefix = \"\"\n\n    for i in range(min_length):\n        current_char = strings[0][i]\n        \n        if all(s[i] == current_char for s in strings):\n            common_prefix += current_char\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\ndef md_merge_arrays_x(left_half, right_half, arr):\n    i = j = k = 0\n    while i < len(left_half) and j < len(right_half):\n        if left_half[i] < right_half[j]:\n            arr[k] = left_half[i]\n            i += 1\n        else:\n            arr[k] = right_half[j]\n            j += 1\n        k += 1\n\n    while i < len(left_half):\n        arr[k] = left_half[i]\n        i += 1\n        k += 1\n\n    while j < len(right_half):\n        arr[k] = right_half[j]\n        j += 1\n        k += 1\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock_levels = {}\n\n    def md_add_stock(self, item_name, quantity):\n        if item_name in self.stock_levels:\n            self.stock_levels[item_name] += quantity\n        else:\n            self.stock_levels[item_name] = quantity\n\n    def md_remove_stock(self, item_name, quantity):\n        if item_name in self.stock_levels and self.stock_levels[item_name] >= quantity:\n            self.stock_levels[item_name] -= quantity\n            if self.stock_levels[item_name] == 0:\n                del self.stock_levels[item_name]\n        else:\n            raise ValueError(\"Insufficient stock or item does not exist\")\n```\n"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_x(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort_x(left_half)\n        merge_sort_x(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n        \n    def md_add_stock(self, item, quantity):\n        if item not in self.stock:\n            self.stock[item] = 0\n        self.stock[item] += quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            if self.stock[item] == 0:\n                del self.stock[item]\n        else:\n            raise ValueError(\"Insufficient stock or item not found\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\ndef average_diagonal_x(matrix: list) -> float:\n    \"\"\"\n    Compute the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list): A list of lists, where each sublist represents a row of the matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n\n    Assert:\n        The matrix must be square (number of rows equals number of columns).\n    \"\"\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square.\"\n\n    diagonal_sum = 0\n    n = len(matrix)\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n\n    average = diagonal_sum / n\n    return average\n```",
        "```python\ndef longest_common_prefix_x(strs: list[str]) -> str:\n    \"\"\"\n    Finds the longest common prefix string amongst an array of strings.\n\n    Args:\n        strs (list[str]): The list of strings to be analyzed.\n\n    Returns:\n        str: The longest common prefix.\n    \"\"\"\n    assert isinstance(strs, list), \"Input must be a list of strings\"\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while strs[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n```\n",
        "```python\ndef int_to_roman_x(num: int) -> str:\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The corresponding Roman numeral as a string.\n    \"\"\"\n    assert isinstance(num, int), \"Input must be an integer.\"\n    assert 1 <= num <= 3999, \"Input must be between 1 and 3999.\"\n\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num_md_ = ''\n    i_md_ = 0\n    while num > 0:\n        for _ in range(num // val[i_md_]):\n            assert num >= val[i_md_], \"Internal logic error in conversion.\"\n            roman_num_md_ += syms[i_md_]\n            num -= val[i_md_]\n        i_md_ += 1\n    \n    return roman_num_md_\n```",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass Inventory:\n    \"\"\"\n    Inventory class to manage stock levels.\n\n    Attributes:\n        stock (dict): A dictionary holding item names as keys and their quantities as values.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an inventory with an empty stock dictionary.\"\"\"\n        self.stock = {}\n\n    def md_add_stock_x(self, item: str, amount: int) -> None:\n        \"\"\"\n        Add a specified amount of stock for a given item.\n\n        Args:\n            item (str): The name of the item.\n            amount (int): The quantity to be added.\n\n        Returns:\n            None\n        \"\"\"\n        assert amount > 0, \"Amount to add must be positive.\"\n        if item in self.stock:\n            self.stock[item] += amount\n        else:\n            self.stock[item] = amount\n    \n    def md_remove_stock_x(self, item: str, amount: int) -> None:\n        \"\"\"\n        Remove a specified amount of stock for a given item.\n\n        Args:\n            item (str): The name of the item.\n            amount (int): The quantity to be removed.\n\n        Returns:\n            None\n        \"\"\"\n        assert amount > 0, \"Amount to remove must be positive.\"\n        assert item in self.stock, \"Item must exist in stock.\"\n        assert self.stock[item] >= amount, \"Not enough stock to remove the specified amount.\"\n        self.stock[item] -= amount\n        if self.stock[item] == 0:\n            del self.stock[item]\n```",
        "```python\ndef find_kth_largest_a(arr: list[int], k: int) -> int:\n    \"\"\"\n    Find the kth largest element in an array.\n\n    Args:\n        arr (list[int]): The array of integers.\n        k (int): The order of the largest element to find.\n\n    Returns:\n        int: The kth largest element in the array.\n\n    Raises:\n        ValueError: If k is out of bounds of the array length.\n    \"\"\"\n    assert k > 0, \"k must be greater than zero\"\n    assert len(arr) >= k, \"k is out of bounds of the array length\"\n\n    arr.sort(reverse=True)  # Sort the array in descending order\n    return arr[k - 1]  # Return the kth element\n```\n",
        "```python\ndef merge_sort_x(arr: list) -> list:\n    \"\"\"\n    Sorts an array in ascending order using merge sort algorithm.\n    \n    Args:\n        arr (list): The list of elements to be sorted.\n    \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    assert isinstance(arr, list), \"Input must be a list\"\n    \n    if len(arr) <= 1:\n        return arr\n\n    def md_merge_x(left: list, right: list) -> list:\n        \"\"\"\n        Merges two sorted lists into one sorted list.\n        \n        Args:\n            left (list): The first sorted list.\n            right (list): The second sorted list.\n        \n        Returns:\n            list: The merged and sorted list.\n        \"\"\"\n        assert isinstance(left, list), \"Left input must be a list\"\n        assert isinstance(right, list), \"Right input must be a list\"\n\n        result = []\n        left_index = right_index = 0\n\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                result.append(left[left_index])\n                left_index += 1\n            else:\n                result.append(right[right_index])\n                right_index += 1\n\n        result.extend(left[left_index:])\n        result.extend(right[right_index:])\n        \n        return result\n\n    mid = len(arr) // 2\n    left = merge_sort_x(arr[:mid])\n    right = merge_sort_x(arr[mid:])\n\n    return md_merge_x(left, right)\n```",
        "```python\nfrom sklearn.base import BaseEstimator, ClassifierMixin\nfrom pedantic import timer_class\nimport numpy as np\n\n\n@timer_class\nclass QuadraticDiscriminantAnalysis_x(BaseEstimator, ClassifierMixin):\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) classifier.\n\n    Attributes:\n        priors_ (np.ndarray): Class priors.\n        means_ (np.ndarray): Class means.\n        covariances_ (np.ndarray): Class covariances.\n        classes_ (np.ndarray): Unique classes.\n    \"\"\"\n    \n    def __init__(self):\n        self.priors_ = None\n        self.means_ = None\n        self.covariances_ = None\n        self.classes_ = None\n\n    def md_fit(self, X: np.ndarray, y: np.ndarray) -> 'QuadraticDiscriminantAnalysis_x':\n        assert X.ndim == 2, \"Input feature array X must be 2D.\"\n        assert len(X) == len(y), \"Feature array X and target vector y must have the same length.\"\n\n        self.classes_ = np.unique(y)\n        self.means_ = []\n        self.covariances_ = []\n        self.priors_ = []\n\n        for cls in self.classes_:\n            X_cls = X[y == cls]\n            self.means_.append(np.mean(X_cls, axis=0))\n            self.covariances_.append(np.cov(X_cls, rowvar=False))\n            self.priors_.append(X_cls.shape[0] / X.shape[0])\n\n        self.means_ = np.array(self.means_)\n        self.covariances_ = np.array(self.covariances_)\n        self.priors_ = np.array(self.priors_)\n\n        return self\n\n    def md_predict(self, X: np.ndarray) -> np.ndarray:\n        assert self.priors_ is not None, \"The model must be fitted before predicting.\"\n        assert self.covariances_ is not None, \"The model must be fitted before predicting.\"\n        assert self.means_ is not None, \"The model must be fitted before predicting.\"\n\n        likelihoods = []\n        \n        for mean, cov, prior in zip(self.means_, self.covariances_, self.priors_):\n            inv_cov = np.linalg.inv(cov)\n            term_1 = np.log(prior)\n            term_2 = -0.5 * np.einsum('ij,ij->i', X - mean, np.dot(X - mean, inv_cov))\n            term_3 = -0.5 * np.log(np.linalg.det(cov))\n            likelihoods.append(term_1 + term_2 + term_3)\n\n        likelihoods = np.array(likelihoods).T\n        decisions = self.classes_[np.argmax(likelihoods, axis=1)]\n        \n        return decisions\n```\n"
      ]
    }
  ]
}