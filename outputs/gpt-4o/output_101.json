{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self.items:\n            self.items[item_name] += quantity\n        else:\n            self.items[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self.items and self.items[item_name] >= quantity:\n            self.items[item_name] -= quantity\n            if self.items[item_name] == 0:\n                del self.items[item_name]\n        else:\n            raise ValueError(\"Not enough stock or item does not exist\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            self.stock[item_name] += quantity\n        else:\n            self.stock[item_name] = quantity\n\n    def o_remove_stock(self, item_name, quantity):\n        if item_name in self.stock:\n            if self.stock[item_name] >= quantity:\n                self.stock[item_name] -= quantity\n            else:\n                raise ValueError(\"Cannot remove more stock than available\")\n        else:\n            raise KeyError(\"Item not found in inventory\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.exceptions import NotFittedError\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha_q = alpha\n        self.lasso_model_q = Lasso(alpha=self.alpha_q)\n\n    def train(self, X_q, y_q):\n        try:\n            self.lasso_model_q.fit(X_q, y_q)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_q):\n        try:\n            return self.lasso_model_q.predict(X_q)\n        except NotFittedError:\n            print(\"Model is not fitted yet. Please train the model before predicting.\")\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n\n```",
        "```python\nclass Node:\n    def __init__(self, data_q):\n        self.data_q = data_q\n        self.next_q = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append_q(self, data_q):\n        new_node_q = Node(data_q)\n        if self.head_q is None:\n            self.head_q = new_node_q\n            return\n        last_q = self.head_q\n        while last_q.next_q:\n            last_q = last_q.next_q\n        last_q.next_q = new_node_q\n\n    def prepend_q(self, data_q):\n        new_node_q = Node(data_q)\n        new_node_q.next_q = self.head_q\n        self.head_q = new_node_q\n\n    def delete_node_q(self, key_q):\n        try:\n            cur_q = self.head_q\n\n            if cur_q is not None:\n                if cur_q.data_q == key_q:\n                    self.head_q = cur_q.next_q\n                    cur_q = None\n                    return\n            \n            prev_q = None\n            while cur_q is not None:\n                if cur_q.data_q == key_q:\n                    break\n                prev_q = cur_q\n                cur_q = cur_q.next_q\n\n            if cur_q is None:\n                return\n\n            prev_q.next_q = cur_q.next_q\n            cur_q = None\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n    def print_list_q(self):\n        try:\n            cur_q = self.head_q\n            while cur_q:\n                print(cur_q.data_q)\n                cur_q = cur_q.next_q\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, max_iter=1000, tol=1e-4):\n        self.alpha = alpha\n        self.max_iter = max_iter\n        self.tol = tol\n        self.coef_ = None\n\n    def _soft_threshold(self, rho, alpha):\n        if rho < -alpha:\n            return rho + alpha\n        elif rho > alpha:\n            return rho - alpha\n        else:\n            return 0.0\n\n    def train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.coef_ = np.zeros(n_features)\n            weights = self.coef_\n\n            for iteration in range(self.max_iter):\n                weights_old = np.copy(weights)\n\n                for j in range(n_features):\n                    temp = weights.copy()\n                    temp[j] = 0.0\n                    residual = y - X @ temp\n                    rho = np.dot(X[:, j], residual)\n\n                    weights[j] = self._soft_threshold(rho, self.alpha)\n\n                if np.sum(np.abs(weights - weights_old)) < self.tol:\n                    break\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.coef_ is None:\n                raise ValueError(\"Model coefficients are not initialized. Call `train` method first.\")\n            return np.dot(X, self.coef_)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_q = data\n        self.next_q = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append(self, data):\n        new_node_q = Node(data)\n        if not self.head_q:\n            self.head_q = new_node_q\n            return\n        last_q = self.head_q\n        while last_q.next_q:\n            last_q = last_q.next_q\n        last_q.next_q = new_node_q\n\n    def prepend(self, data):\n        new_node_q = Node(data)\n        new_node_q.next_q = self.head_q\n        self.head_q = new_node_q\n\n    def delete(self, key):\n        temp_q = self.head_q\n        if temp_q and temp_q.data_q == key:\n            self.head_q = temp_q.next_q\n            temp_q = None\n            return\n        prev_q = None\n        while temp_q and temp_q.data_q != key:\n            prev_q = temp_q\n            temp_q = temp_q.next_q\n        if not temp_q:\n            return\n        prev_q.next_q = temp_q.next_q\n        temp_q = None\n\n    def search(self, key):\n        current_q = self.head_q\n        while current_q:\n            if current_q.data_q == key:\n                return True\n            current_q = current_q.next_q\n        return False\n\n    def display(self):\n        elems = []\n        current_q = self.head_q\n        while current_q:\n            elems.append(current_q.data_q)\n            current_q = current_q.next_q\n        return elems\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock_q = {}\n\n    def o_add_stock(self, item_name_q, quantity_q):\n        try:\n            if item_name_q in self.stock_q:\n                self.stock_q[item_name_q] += quantity_q\n            else:\n                self.stock_q[item_name_q] = quantity_q\n        except Exception as e:\n            print(f\"An error occurred while adding stock: {e}\")\n\n    def o_remove_stock(self, item_name_q, quantity_q):\n        try:\n            if item_name_q in self.stock_q:\n                if self.stock_q[item_name_q] >= quantity_q:\n                    self.stock_q[item_name_q] -= quantity_q\n                else:\n                    print(\"Error: Not enough stock to remove\")\n            else:\n                print(\"Error: Item not found in inventory\")\n        except Exception as e:\n            print(f\"An error occurred while removing stock: {e}\")\n```",
        "```python\nimport numpy as np\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0, iterations=1000, learning_rate=0.01):\n        self.alpha_q = alpha\n        self.iterations_q = iterations\n        self.learning_rate_q = learning_rate\n        self.weights_q = None\n        self.bias_q = None\n\n    def o_train(self, X, y):\n        try:\n            n_samples, n_features = X.shape\n            self.weights_q = np.zeros(n_features)\n            self.bias_q = 0\n\n            for _ in range(self.iterations_q):\n                y_predicted = self.o_predict(X)\n                dw = (1 / n_samples) * np.dot(X.T, (y_predicted - y)) + self.alpha_q * np.sign(self.weights_q)\n                db = (1 / n_samples) * np.sum(y_predicted - y)\n\n                self.weights_q -= self.learning_rate_q * dw\n                self.bias_q -= self.learning_rate_q * db\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def o_predict(self, X):\n        try:\n            return np.dot(X, self.weights_q) + self.bias_q\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\nclass Node:\n    def __init__(self, data_q):\n        self.data_q = data_q\n        self.next_q = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def o_insert(self, data_q):\n        try:\n            new_node_q = Node(data_q)\n            new_node_q.next_q = self.head_q\n            self.head_q = new_node_q\n        except Exception as e_q:\n            print(f\"Error inserting node: {e_q}\")\n\n    def o_delete(self, key_q):\n        try:\n            temp_q = self.head_q\n            prev_q = None\n\n            if temp_q is not None:\n                if temp_q.data_q == key_q:\n                    self.head_q = temp_q.next_q\n                    temp_q = None\n                    return\n\n            while temp_q is not None:\n                if temp_q.data_q == key_q:\n                    break\n                prev_q = temp_q\n                temp_q = temp_q.next_q\n\n            if temp_q == None:\n                return\n\n            prev_q.next_q = temp_q.next_q\n            temp_q = None\n        except Exception as e_q:\n            print(f\"Error deleting node: {e_q}\")\n\n    def o_search(self, key_q):\n        try:\n            current_q = self.head_q\n            while current_q:\n                if current_q.data_q == key_q:\n                    return True\n                current_q = current_q.next_q\n            return False\n        except Exception as e_q:\n            print(f\"Error searching node: {e_q}\")\n\n    def o_display(self):\n        try:\n            elements_q = []\n            current_q = self.head_q\n            while current_q:\n                elements_q.append(current_q.data_q)\n                current_q = current_q.next_q\n            return elements_q\n        except Exception as e_q:\n            print(f\"Error displaying list: {e_q}\")\n```"
      ]
    }
  ]
}