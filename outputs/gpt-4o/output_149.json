{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, g_data, g_next_node=None):\n        self.data_i = g_data\n        self.next_node_i = g_next_node\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, g_data):\n        new_node_i = Node(g_data)\n        if not self.head_i:\n            self.head_i = new_node_i\n            return\n        last_node_i = self.head_i\n        while last_node_i.next_node_i:\n            last_node_i = last_node_i.next_node_i\n        last_node_i.next_node_i = new_node_i\n\n    def prepend(self, g_data):\n        new_node_i = Node(g_data, self.head_i)\n        self.head_i = new_node_i\n\n    def delete_node(self, g_key):\n        current_i = self.head_i\n        if current_i and current_i.data_i == g_key:\n            self.head_i = current_i.next_node_i\n            current_i = None\n            return\n        prev_i = None\n        while current_i and current_i.data_i != g_key:\n            prev_i = current_i\n            current_i = current_i.next_node_i\n        if current_i is None:\n            return\n        prev_i.next_node_i = current_i.next_node_i\n        current_i = None\n\n    def search(self, g_key):\n        current_i = self.head_i\n        while current_i:\n            if current_i.data_i == g_key:\n                return True\n            current_i = current_i.next_node_i\n        return False\n```\n",
        "```python\ndef compute_dot_product(g_vector1, g_vector2):\n    dot_product_i = sum(a_i * b_i for a_i, b_i in zip(g_vector1, g_vector2))\n    return dot_product_i\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        new_node_i = Node(data_i)\n        if self.head_i is None:\n            self.head_i = new_node_i\n            return\n        last_i = self.head_i\n        while last_i.next_i:\n            last_i = last_i.next_i\n        last_i.next_i = new_node_i\n\n    def prepend(self, data_i):\n        new_node_i = Node(data_i)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def delete(self, key_i):\n        temp_i = self.head_i\n        if temp_i and temp_i.data_i == key_i:\n            self.head_i = temp_i.next_i\n            temp_i = None\n            return\n\n        prev_i = None\n        while temp_i and temp_i.data_i != key_i:\n            prev_i = temp_i\n            temp_i = temp_i.next_i\n\n        if temp_i is None:\n            return\n\n        prev_i.next_i = temp_i.next_i\n        temp_i = None\n\n    def search(self, key_i):\n        current_i = self.head_i\n        while current_i and current_i.data_i != key_i:\n            current_i = current_i.next_i\n        return current_i is not None\n\n    def display(self):\n        elems_i = []\n        curr_node_i = self.head_i\n        while curr_node_i:\n            elems_i.append(curr_node_i.data_i)\n            curr_node_i = curr_node_i.next_i\n        return elems_i\n```",
        "```python\ndef dot_product(g_vector1, g_vector2):\n    return sum(a * b for a, b in zip(g_vector1, g_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List, Tuple\nfrom pedantic import count_calls\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.coefficients: np.ndarray = np.array([])\n        self.intercept: float = 0.0\n\n    @count_calls\n    def fit(self, X: List[List[float]], y: List[float]) -> None:\n        \"\"\"Trains the Linear Regression model\"\"\"\n        X_np = np.array(X)\n        y_np = np.array(y)\n        X_b = np.c_[np.ones((X_np.shape[0], 1)), X_np]  # add bias term\n        \n        theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_np)\n        self.intercept = theta_best[0]\n        self.coefficients = theta_best[1:]\n\n    @count_calls\n    def predict(self, X: List[List[float]]) -> List[float]:\n        \"\"\"Makes predictions using the trained Linear Regression model\"\"\"\n        X_np = np.array(X)\n        X_b = np.c_[np.ones((X_np.shape[0], 1)), X_np]  # add bias term\n        predictions = X_b.dot(np.r_[self.intercept, self.coefficients])\n        return predictions.tolist()\n```\n",
        "```python\nfrom typing import List\nimport heapq\nfrom pedantic import count_calls\n\n@count_calls\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the array.\n    \n    Args:\n    nums (List[int]): The array of integers.\n    k (int): The 'k' position to find the largest element.\n    \n    Returns:\n    int: The kth largest element in the array.\n    \"\"\"\n    return heapq.nlargest(k, nums)[-1]\n```\n"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import count_calls\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.coefficients = None\n\n    @count_calls\n    def train(self, X, y):\n        X_b = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n        X_transpose = X_b.T\n        self.coefficients = np.linalg.inv(X_transpose.dot(X_b)).dot(X_transpose).dot(y)\n\n    @count_calls\n    def predict(self, X):\n        if self.coefficients is None:\n            raise ValueError(\"Model has not been trained yet.\")\n        X_b = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n        return X_b.dot(self.coefficients)\n```",
        "```python\nfrom typing import List\n\ndef kth_largest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_t=None):\n        self.data_t = data_t\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def append(self, data_t):\n        new_node_t = Node(data_t)\n        if not self.head_t:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def prepend(self, data_t):\n        new_node_t = Node(data_t)\n        new_node_t.next_t = self.head_t\n        self.head_t = new_node_t\n\n    def delete_with_value(self, data_t):\n        if not self.head_t:\n            return\n        if self.head_t.data_t == data_t:\n            self.head_t = self.head_t.next_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            if current_t.next_t.data_t == data_t:\n                current_t.next_t = current_t.next_t.next_t\n                return\n            current_t = current_t.next_t\n\n    def find(self, data_t):\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data_t:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def print_list(self):\n        current_t = self.head_t\n        while current_t:\n            print(current_t.data_t)\n            current_t = current_t.next_t\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_t = data\n        self.next_t = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n\n    def append(self, data):\n        new_node_t = Node(data)\n        if self.head_t is None:\n            self.head_t = new_node_t\n            return\n        last_t = self.head_t\n        while last_t.next_t:\n            last_t = last_t.next_t\n        last_t.next_t = new_node_t\n\n    def prepend(self, data):\n        new_node_t = Node(data)\n        new_node_t.next_t = self.head_t\n        self.head_t = new_node_t\n\n    def delete_with_value(self, data):\n        if self.head_t is None:\n            return\n        if self.head_t.data_t == data:\n            self.head_t = self.head_t.next_t\n            return\n        current_t = self.head_t\n        while current_t.next_t:\n            if current_t.next_t.data_t == data:\n                current_t.next_t = current_t.next_t.next_t\n                return\n            current_t = current_t.next_t\n\n    def find(self, data):\n        current_t = self.head_t\n        while current_t:\n            if current_t.data_t == data:\n                return True\n            current_t = current_t.next_t\n        return False\n\n    def clear(self):\n        self.head_t = None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self.sum1 = 0.0\n        self.count1 = 0\n\n    def add_number(self, number0):\n        self.count1 += 1\n        self.sum1 += number0\n\n    def calculate_mean(self):\n        if self.count1 == 0:\n            return 0.0\n        return self.sum1 / self.count1\n```"
      ],
      "instruction_model_output": [
        "```python\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self._count0 = 0\n        self._mean0 = 0.0\n\n    def add1(self, value0):\n        self._count0 += 1\n        self._mean0 += (value0 - self._mean0) / self._count0\n    \n    def get_mean0(self):\n        return self._mean0\n```"
      ],
      "history_model_output": [
        "```python\nfrom typing import List\nimport heapq\n\ndef find_kth_largest(g_nums1: List[int], g_k1: int) -> int:\n    min_heap1 = g_nums1[:g_k1]\n    heapq.heapify(min_heap1)\n\n    for num1 in g_nums1[g_k1:]:\n        if num1 > min_heap1[0]:\n            heapq.heappop(min_heap1)\n            heapq.heappush(min_heap1, num1)\n\n    return min_heap1[0]\n```\n",
        "```python\nfrom typing import List, Tuple\nimport numpy as np\nfrom pedantic import count_calls\n\nclass LinearRegressionModel_t:\n    def __init__(self):\n        self.coefficients_t = None\n        self.intercept_t = None\n\n    @count_calls\n    def train(self, g_X0: List[List[float]], g_y1: List[float]) -> None:\n        g_X0 = np.array(g_X0)\n        g_y1 = np.array(g_y1)\n        \n        g_X_b0 = np.c_[np.ones((g_X0.shape[0], 1)), g_X0]\n\n        theta_best_t = np.linalg.inv(g_X_b0.T.dot(g_X_b0)).dot(g_X_b0.T).dot(g_y1)\n        self.intercept_t = theta_best_t[0]\n        self.coefficients_t = theta_best_t[1:]\n\n    @count_calls\n    def predict(self, g_X0: List[List[float]]) -> List[float]:\n        g_X0 = np.array(g_X0)\n        g_X_b0 = np.c_[np.ones((g_X0.shape[0], 1)), g_X0]\n        return (g_X_b0.dot(np.r_[self.intercept_t, self.coefficients_t])).tolist()\n```\n",
        "```python\nfrom typing import Optional\n\nclass OnlineMeanCalculator:\n    def __init__(self):\n        self.count_t: int = 0\n        self.mean_t: float = 0.0\n\n    def add_number_t(self, g_num1: float) -> None:\n        self.count_t += 1\n        self.mean_t += (g_num1 - self.mean_t) / self.count_t\n\n    def get_mean_t(self) -> Optional[float]:\n        if self.count_t == 0:\n            return None\n        return self.mean_t\n```",
        "```python\nfrom pedantic import count_calls\nfrom typing import Any, Optional\n\nclass Node_i:\n    def __init__(self, g_data: Any):\n        self.data1_t = g_data\n        self.next2_t: Optional['Node_i'] = None\n\nclass LinkedList_i:\n    def __init__(self):\n        self.head1_t: Optional[Node_i] = None\n\n    @count_calls\n    def append(self, g_data: Any) -> None:\n        new_node3_t = Node_i(g_data)\n        if self.head1_t is None:\n            self.head1_t = new_node3_t\n            return\n        \n        last4_t = self.head1_t\n        while last4_t.next2_t:\n            last4_t = last4_t.next2_t\n        last4_t.next2_t = new_node3_t\n\n    @count_calls\n    def display(self) -> None:\n        current5_t = self.head1_t\n        while current5_t:\n            print(current5_t.data1_t, end=\" \")\n            current5_t = current5_t.next2_t\n        print()\n\n    @count_calls\n    def insert(self, g_data: Any, g_position: int) -> None:\n        new_node6_t = Node_i(g_data)\n        if g_position == 0:\n            new_node6_t.next2_t = self.head1_t\n            self.head1_t = new_node6_t\n            return\n        \n        current7_t = self.head1_t\n        for _ in range(g_position - 1):\n            if current7_t is None:\n                return\n            current7_t = current7_t.next2_t\n\n        new_node6_t.next2_t = current7_t.next2_t if current7_t else None\n        if current7_t:\n            current7_t.next2_t = new_node6_t\n\n    @count_calls\n    def delete(self, g_key: Any) -> None:\n        current8_t = self.head1_t\n        prev9_t: Optional[Node_i] = None\n\n        if current8_t and current8_t.data1_t == g_key:\n            self.head1_t = current8_t.next2_t\n            current8_t = None\n            return\n        \n        while current8_t and current8_t.data1_t != g_key:\n            prev9_t = current8_t\n            current8_t = current8_t.next2_t\n\n        if current8_t is None:\n            return\n\n        prev9_t.next2_t = current8_t.next2_t\n        current8_t = None\n```",
        "```python\nfrom typing import List\nfrom pedantic import count_calls\n\n@count_calls\ndef compute_dot_product(g_vector1: List[int], g_vector2: List[int]) -> int:\n    dot_product1 = sum(a_t * b_t for a_t, b_t in zip(g_vector1, g_vector2))\n    return dot_product1\n```"
      ]
    }
  ]
}