{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value: int) -> None:\n        self.value: int = value\n        self.left: 'TreeNode' = None\n        self.right: 'TreeNode' = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode = None\n\n    def insert_md(self, value: int) -> None:\n        def _insert(current_node: TreeNode, value: int) -> TreeNode:\n            if current_node is None:\n                return TreeNode(value)\n            if value < current_node.value:\n                current_node.left = _insert(current_node.left, value)\n            elif value > current_node.value:\n                current_node.right = _insert(current_node.right, value)\n            return current_node\n\n        if self.root is None:\n            self.root = TreeNode(value)\n        else:\n            _insert(self.root, value)\n\n    def delete_md(self, value: int) -> None:\n        def _min_value_node(node: TreeNode) -> TreeNode:\n            current = node\n            while current.left is not None:\n                current = current.left\n            return current\n\n        def _delete_node(current_node: TreeNode, value: int) -> TreeNode:\n            if current_node is None:\n                return current_node\n\n            if value < current_node.value:\n                current_node.left = _delete_node(current_node.left, value)\n            elif value > current_node.value:\n                current_node.right = _delete_node(current_node.right, value)\n            else:\n                if current_node.left is None:\n                    return current_node.right\n                elif current_node.right is None:\n                    return current_node.left\n                temp = _min_value_node(current_node.right)\n                current_node.value = temp.value\n                current_node.right = _delete_node(current_node.right, temp.value)\n\n            return current_node\n\n        self.root = _delete_node(self.root, value)\n```",
        "```python\nfrom typing import Dict, List, Tuple, Optional\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges: Dict[str, List[Tuple[str, int]]] = {}\n\n    def add_edge_md(self, source: str, destination: str, weight: int) -> None:\n        if source not in self.edges:\n            self.edges[source] = []\n        if destination not in self.edges:\n            self.edges[destination] = []\n        self.edges[source].append((destination, weight))\n        self.edges[destination].append((source, weight))\n\n    def shortest_path_md(self, start: str, end: str) -> Optional[List[str]]:\n        priority_queue: List[Tuple[int, str, List[str]]] = [(0, start, [start])]\n        visited: Dict[str, int] = {start: 0}\n\n        while priority_queue:\n            current_weight, current_node, path = heapq.heappop(priority_queue)\n            \n            if current_node == end:\n                return path\n            \n            for neighbor, weight in self.edges.get(current_node, []):\n                new_weight = current_weight + weight\n                if neighbor not in visited or new_weight < visited[neighbor]:\n                    visited[neighbor] = new_weight\n                    heapq.heappush(priority_queue, (new_weight, neighbor, path + [neighbor]))\n        \n        return None\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.left: 'TreeNode' | None = None\n        self.right: 'TreeNode' | None = None\n        self.value: int = key\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode | None = None\n\n    def insert(self, key: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursively(self.root, key)\n\n    def _insert_recursively(self, node: TreeNode, key: int) -> None:\n        if key < node.value:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursively(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursively(node.right, key)\n\n    def delete(self, key: int) -> None:\n        self.root = self._delete_recursively(self.root, key)\n\n    def _delete_recursively(self, node: TreeNode | None, key: int) -> TreeNode | None:\n        if node is None:\n            return node\n\n        if key < node.value:\n            node.left = self._delete_recursively(node.left, key)\n        elif key > node.value:\n            node.right = self._delete_recursively(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._min_value_node(node.right).value\n            node.right = self._delete_recursively(node.right, node.value)\n        return node\n\n    def _min_value_node(self, node: TreeNode) -> TreeNode:\n        current: TreeNode = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_node_md(self, node):\n        if node not in self.adjacency_list:\n            self.adjacency_list[node] = []\n\n    def add_edge_md(self, u, v, weight):\n        if u in self.adjacency_list and v in self.adjacency_list:\n            self.adjacency_list[u].append((v, weight))\n            self.adjacency_list[v].append((u, weight))\n\n    def shortest_path_md(self, start, end):\n        distance = {node: float('inf') for node in self.adjacency_list}\n        distance[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor not in visited:\n                    new_distance = current_distance + weight\n                    if new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        heapq.heappush(priority_queue, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import Counter\nimport numpy as np\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        self.n_neighbors = n_neighbors\n        self.train_data = None\n        self.train_labels = None\n\n    def train_p(self, X, y):\n        \"\"\"Train the model with training data and labels.\"\"\"\n        assert len(X) == len(y), \"Length of training data and labels must be equal.\"\n        \n        self.train_data = np.array(X)\n        self.train_labels = np.array(y)\n\n    def predict_p(self, X):\n        \"\"\"Predict the labels for the given data.\"\"\"\n        assert self.train_data is not None and self.train_labels is not None, \"Model has not been trained yet.\"\n        \n        X = np.array(X)\n        predictions = []\n        \n        for point in X:\n            # Calculate distances from the point to all training data\n            distances = np.linalg.norm(self.train_data - point, axis=1)\n            # Get the indices of the nearest neighbors\n            nearest_neighbors_indices = distances.argsort()[:self.n_neighbors]\n            # Retrieve the nearest neighbor labels\n            nearest_labels = self.train_labels[nearest_neighbors_indices]\n            # Determine the most common label among nearest neighbors\n            most_common_label = Counter(nearest_labels).most_common(1)[0][0]\n            predictions.append(most_common_label)\n        \n        return np.array(predictions)\n```\n",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_p(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        self.edges[from_node].append((to_node, weight))\n\n    def shortest_path_p(self, start_node, end_node):\n        assert start_node in self.edges, \"Start node not in graph\"\n        assert end_node in self.edges, \"End node not in graph\"\n\n        priority_queue = [(0, start_node)]\n        shortest_path = {start_node: (None, 0)}\n        \n        while priority_queue:\n            current_weight, current_node = heapq.heappop(priority_queue)\n            if current_node == end_node:\n                break\n\n            for adjacent, weight in self.edges.get(current_node, []):\n                new_weight = current_weight + weight\n                if adjacent not in shortest_path or new_weight < shortest_path[adjacent][1]:\n                    shortest_path[adjacent] = (current_node, new_weight)\n                    heapq.heappush(priority_queue, (new_weight, adjacent))\n        \n        path, total_weight = self._reconstruct_path_p(shortest_path, start_node, end_node)\n        return total_weight, path\n    \n    def _reconstruct_path_p(self, shortest_path, start_node, end_node):\n        path = []\n        total_weight = float('inf')\n        current_node = end_node\n\n        while current_node is not None:\n            path.append(current_node)\n            next_node, total_weight = shortest_path.get(current_node, (None, float('inf')))\n            current_node = next_node\n\n        path.reverse()\n        assert path[0] == start_node, \"No valid path found\"\n        return path, total_weight\n```"
      ],
      "instruction_model_output": [
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=3):\n        assert isinstance(n_neighbors, int) and n_neighbors > 0, \"n_neighbors must be a positive integer\"\n        self.n_neighbors = n_neighbors\n        self._is_fitted = False\n\n    def train(self, X, y):\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"X and y must be numpy arrays\"\n        assert len(X) == len(y), \"Length of X and y must match\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        self.X_train = X\n        self.y_train = y\n        self._is_fitted = True\n\n    def predict(self, X):\n        assert self._is_fitted, \"Model must be trained before prediction\"\n        assert isinstance(X, np.ndarray), \"X must be a numpy array\"\n        assert len(X) > 0, \"X cannot be empty\"\n        \n        predictions = []\n        for x in X:\n            distances = distance.cdist([x], self.X_train, 'euclidean').flatten()\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = self.y_train[nearest_indices]\n            prediction = np.bincount(nearest_labels).argmax()\n            predictions.append(prediction)\n        \n        return np.array(predictions)\n```",
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_p(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_p(self, start, end):\n        priority_queue = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            if current_node == end:\n                return current_distance\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return float('inf')\n```\n"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n\n    def add_edge_o(self, start, end, weight):\n        if start not in self.adjacency_list:\n            self.adjacency_list[start] = []\n        if end not in self.adjacency_list:\n            self.adjacency_list[end] = []\n        self.adjacency_list[start].append((end, weight))\n        self.adjacency_list[end].append((start, weight))\n\n    def shortest_path_o(self, start, end):\n        min_heap = [(0, start)]\n        distances = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        visited = set()\n\n        while min_heap:\n            current_distance, current_node = heapq.heappop(min_heap)\n\n            if current_node in visited:\n                continue\n\n            if current_node == end:\n                return current_distance\n\n            visited.add(current_node)\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                if neighbor in visited:\n                    continue\n                new_distance = current_distance + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    heapq.heappush(min_heap, (new_distance, neighbor))\n\n        return float('inf')\n```"
      ],
      "instruction_model_output": [
        "```python\nimport heapq\n\nclass Graph:\n    def __init__(self):\n        self.edges = {}\n\n    def add_edge_o(self, from_node, to_node, weight):\n        if from_node not in self.edges:\n            self.edges[from_node] = []\n        if to_node not in self.edges:\n            self.edges[to_node] = []\n        self.edges[from_node].append((to_node, weight))\n        self.edges[to_node].append((from_node, weight))\n\n    def shortest_path_o(self, start_node, end_node):\n        queue = [(0, start_node)]\n        distances = {node: float('infinity') for node in self.edges}\n        distances[start_node] = 0\n        previous_nodes = {node: None for node in self.edges}\n\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.edges.get(current_node, []):\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n        path, current_node = [], end_node\n        while previous_nodes[current_node] is not None:\n            path.append(current_node)\n            current_node = previous_nodes[current_node]\n        if path:\n            path.append(start_node)\n        path.reverse()\n\n        return path if distance < float('infinity') else None\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nimport heapq\nfrom typing import Dict, List, Tuple\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list: Dict[str, List[Tuple[str, int]]] = {}\n\n    def add_edge_o(self, node1: str, node2: str, weight: int) -> None:\n        if node1 not in self.adjacency_list:\n            self.adjacency_list[node1] = []\n        if node2 not in self.adjacency_list:\n            self.adjacency_list[node2] = []\n        self.adjacency_list[node1].append((node2, weight))\n        self.adjacency_list[node2].append((node1, weight))\n\n    def compute_shortest_path_o(self, start: str, end: str) -> Tuple[int, List[str]]:\n        assert start in self.adjacency_list, \"Start node does not exist in the graph.\"\n        assert end in self.adjacency_list, \"End node does not exist in the graph.\"\n\n        distances: Dict[str, int] = {node: float('inf') for node in self.adjacency_list}\n        distances[start] = 0\n        previous_nodes: Dict[str, str] = {}\n\n        priority_queue: List[Tuple[int, str]] = [(0, start)]\n        heapq.heapify(priority_queue)\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_node == end:\n                break\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in self.adjacency_list[current_node]:\n                distance = current_distance + weight\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        path: List[str] = []\n        node = end\n        while node in previous_nodes:\n            path.append(node)\n            node = previous_nodes[node]\n        if path:\n            path.append(start)\n        path.reverse()\n\n        return distances[end], path\n```",
        "```python\nclass TreeNode:\n    def __init__(self, value: int) -> None:\n        self.value: int = value\n        self.left: TreeNode = None\n        self.right: TreeNode = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root: TreeNode = None\n\n    def insert_o(self, value: int) -> None:\n        if self.root is None:\n            self.root = TreeNode(value)\n        else:\n            self._insert_o(self.root, value)\n\n    def _insert_o(self, node: TreeNode, value: int) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = TreeNode(value)\n            else:\n                self._insert_o(node.left, value)\n        else:\n            if node.right is None:\n                node.right = TreeNode(value)\n            else:\n                self._insert_o(node.right, value)\n\n    def delete_o(self, value: int) -> None:\n        self.root = self._delete_o(self.root, value)\n\n    def _delete_o(self, node: TreeNode, value: int) -> TreeNode:\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_o(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_o(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            \n            min_larger_node = self._find_min_o(node.right)\n            node.value = min_larger_node.value\n            node.right = self._delete_o(node.right, min_larger_node.value)\n\n        return node\n\n    def _find_min_o(self, node: TreeNode) -> TreeNode:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```",
        "```python\nfrom typing import List, Tuple\nimport numpy as np\nfrom scipy.spatial import distance\n\nclass NearestNeighbors_o:\n    def __init__(self, n_neighbors: int = 5) -> None:\n        self.n_neighbors: int = n_neighbors\n        self.data_points: np.ndarray = np.empty(0)\n        self.labels: List = []\n\n    def train_o(self, data_points: List[Tuple[float, ...]], labels: List) -> None:\n        assert len(data_points) == len(labels), \"Data points and labels must have the same length.\"\n        self.data_points = np.array(data_points)\n        self.labels = list(labels)\n        assert self.data_points.shape[0] == len(self.labels), \"Number of data points should match number of labels.\"\n\n    def predict_o(self, query_points: List[Tuple[float, ...]]) -> List:\n        assert self.data_points.size > 0, \"Model must be trained before prediction.\"\n        query_points_np = np.array(query_points)\n        \n        predicted_labels = []\n        for point in query_points_np:\n            distances = distance.cdist([point], self.data_points, 'euclidean')[0]\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_labels = [self.labels[idx] for idx in nearest_indices]\n            most_common_label = max(set(nearest_labels), key=nearest_labels.count)\n            predicted_labels.append(most_common_label)\n        \n        return predicted_labels\n```"
      ]
    }
  ]
}