{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value):\n        self.t_value = value\n        self.t_left = None\n        self.t_right = None\n\ndef is_valid_bst(root: TreeNode) -> bool:\n    def validate(node, low=-float('inf'), high=float('inf')):\n        if not node:\n            return True\n        try:\n            t_value = node.t_value\n            if t_value <= low or t_value >= high:\n                return False\n            return (validate(node.t_left, low, t_value) and\n                    validate(node.t_right, t_value, high))\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.t_cache = OrderedDict()\n        self.t_capacity = capacity\n\n    def get(self, key: int) -> int:\n        try:\n            if key not in self.t_cache:\n                return -1\n            else:\n                self.t_cache.move_to_end(key)\n                return self.t_cache[key]\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        try:\n            if key in self.t_cache:\n                self.t_cache.move_to_end(key)\n            self.t_cache[key] = value\n            if len(self.t_cache) > self.t_capacity:\n                self.t_cache.popitem(last=False)\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n```"
      ],
      "instruction_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_valid_bst(root):\n    def validate(node, low=float('-inf'), high=float('inf')):\n        try:\n            if node is None:\n                return True\n            if not (low < node.value < high):\n                return False\n            return (validate(node.left, low, node.value) and\n                    validate(node.right, node.value, high))\n        except Exception as e:\n            return False\n\n    try:\n        return validate(root)\n    except Exception as e:\n        return False\n```",
        "```python\nclass LRUCache:\n    def __init__(self, t_capacity: int):\n        self.t_capacity = t_capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, t_key: int) -> int:\n        if t_key not in self.t_cache:\n            return -1\n        self.t_order.remove(t_key)\n        self.t_order.append(t_key)\n        return self.t_cache[t_key]\n\n    def put(self, t_key: int, t_value: int) -> None:\n        if t_key in self.t_cache:\n            self.t_order.remove(t_key)\n        elif len(self.t_cache) >= self.t_capacity:\n            oldest_key = self.t_order.pop(0)\n            del self.t_cache[oldest_key]\n        self.t_cache[t_key] = t_value\n        self.t_order.append(t_key)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.classes_ = None\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        self.classes_ = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = {}\n        self.covariances_ = {}\n        self.priors_ = {}\n        \n        for cls in self.classes_:\n            X_cls = X[y == cls]\n            self.means_[cls] = np.mean(X_cls, axis=0)\n            centered_X_cls = X_cls - self.means_[cls]\n            self.covariances_[cls] = np.dot(centered_X_cls.T, centered_X_cls) / (X_cls.shape[0] - 1)\n            self.priors_[cls] = X_cls.shape[0] / X.shape[0]\n    \n    def _calculate_discriminant_function(self, x, cls):\n        mean = self.means_[cls]\n        covariance = self.covariances_[cls]\n        covariance_inv = np.linalg.inv(covariance)\n        term1 = np.dot(np.dot((x - mean), covariance_inv), (x - mean).T)\n        term2 = np.log(np.linalg.det(covariance))\n        term3 = 2 * np.log(self.priors_[cls])\n        return -0.5 * (term1 + term2) + term3\n\n    def predict(self, X):\n        y_pred = []\n        for x in X:\n            discriminants = {cls: self._calculate_discriminant_function(x, cls) for cls in self.classes_}\n            predicted_class = max(discriminants, key=discriminants.get)\n            y_pred.append(predicted_class)\n        return np.array(y_pred)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import timer_class\nimport numpy as np\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self):\n        self.means_ = None\n        self.covariances_ = None\n        self.priors_ = None\n\n    def fit(self, X, y):\n        classes = np.unique(y)\n        n_features = X.shape[1]\n        self.means_ = np.zeros((len(classes), n_features))\n        self.covariances_ = np.zeros((len(classes), n_features, n_features))\n        self.priors_ = np.zeros(len(classes))\n\n        for idx, cls in enumerate(classes):\n            X_cls = X[y == cls]\n            self.means_[idx, :] = X_cls.mean(axis=0)\n            self.covariances_[idx, :, :] = np.cov(X_cls, rowvar=False)\n            self.priors_[idx] = X_cls.shape[0] / X.shape[0]\n\n    def predict(self, X):\n        return np.array([self._predict_single(x) for x in X])\n\n    def _predict_single(self, x):\n        max_prob = -np.inf\n        max_class = None\n        \n        for idx in range(len(self.means_)):\n            mean, covariance, prior = self.means_[idx], self.covariances_[idx], self.priors_[idx]\n            prob = self._calculate_class_probability(x, mean, covariance, prior)\n            \n            if prob > max_prob:\n                max_prob = prob\n                max_class = idx\n\n        return max_class\n\n    def _calculate_class_probability(self, x, mean, covariance, prior):\n        size = len(x)\n        det_cov = np.linalg.det(covariance)\n        inv_cov = np.linalg.inv(covariance)\n        diff = x - mean\n        exponent = -0.5 * np.dot(np.dot(diff, inv_cov), diff)\n        coef = 1 / np.sqrt((2 * np.pi) ** size * det_cov)\n        return coef * np.exp(exponent) * prior\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport heapq\n\nclass Heap:\n    def __init__(self):\n        self._heap = []\n\n    def chx_insert(self, item):\n        heapq.heappush(self._heap, item)\n\n    def chx_heapify(self):\n        heapq.heapify(self._heap)\n\n    def chx_get_heap(self):\n        return list(self._heap)\n```\n"
      ],
      "instruction_model_output": [
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert_chx(self, item):\n        self.heap.append(item)\n        self._heapify_up_chx(len(self.heap) - 1)\n\n    def _heapify_up_chx(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] > self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n                index = parent_index\n            else:\n                break\n\n    def _heapify_down_chx(self, index):\n        last_index = len(self.heap) - 1\n        while True:\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            largest_index = index\n\n            if left_child_index <= last_index and self.heap[left_child_index] > self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index <= last_index and self.heap[right_child_index] > self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n            else:\n                self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n                index = largest_index\n\n    def extract_chx(self):\n        if len(self.heap) == 0:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down_chx(0)\n        return root\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert isinstance(matrix, list) and all(isinstance(row, list) for row in matrix), \"Input must be a list of lists\"\n    num_rows = len(matrix)\n    assert num_rows > 0 and all(len(row) == num_rows for row in matrix), \"Matrix must be square and non-empty\"\n    \n    diagonal_sum = 0\n    for i in range(num_rows):\n        diagonal_sum += matrix[i][i]\n    \n    return diagonal_sum / num_rows\n```"
      ],
      "instruction_model_output": [
        "```python\ndef average_diagonal(matrix):\n    assert matrix is not None, \"Input matrix should not be None.\"\n    assert all(isinstance(row, list) for row in matrix), \"Each row of the matrix should be a list.\"\n    assert all(len(row) == len(matrix) for row in matrix), \"The matrix should be square.\"\n    \n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    average = diagonal_sum / n\n    return average\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, q_capacity: int):\n        self.q_capacity = q_capacity\n        self.q_cache = OrderedDict()\n\n    def get(self, vr_key: int) -> int:\n        if vr_key not in self.q_cache:\n            return -1\n        else:\n            self.q_cache.move_to_end(vr_key)\n            return self.q_cache[vr_key]\n\n    def put(self, vr_key: int, vr_value: int) -> None:\n        if vr_key in self.q_cache:\n            self.q_cache.move_to_end(vr_key)\n        self.q_cache[vr_key] = vr_value\n        if len(self.q_cache) > self.q_capacity:\n            self.q_cache.popitem(last=False)\n```",
        "```python\ndef isValidSudoku(vr_board):\n    def isValidBlock(vr_block):\n        vr_seen = set()\n        for vr_char in vr_block:\n            if vr_char != '.':\n                if vr_char in vr_seen:\n                    return False\n                vr_seen.add(vr_char)\n        return True\n\n    # Check rows\n    for vr_row in vr_board:\n        if not isValidBlock(vr_row):\n            return False\n\n    # Check columns\n    for vr_col in range(9):\n        q_col = [vr_board[vr_row][vr_col] for vr_row in range(9)]\n        if not isValidBlock(q_col):\n            return False\n\n    # Check 3x3 sub-boxes\n    for vr_row in range(0, 9, 3):\n        for vr_col in range(0, 9, 3):\n            q_block = [vr_board[vr_row + vr_i][vr_col + vr_j] for vr_i in range(3) for vr_j in range(3)]\n            if not isValidBlock(q_block):\n                return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n            self.q_order.append(key)\n            return self.q_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_cache:\n            self.q_order.remove(key)\n        elif len(self.q_cache) >= self.q_capacity:\n            lru_key = self.q_order.pop(0)\n            del self.q_cache[lru_key]\n        self.q_cache[key] = value\n        self.q_order.append(key)\n```",
        "```python\ndef is_valid_sudoku(vr_board):\n    def is_valid_unit(vr_unit):\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for vr_row in vr_board:\n        if not is_valid_unit(vr_row):\n            return False\n    \n    for vr_col in zip(*vr_board):\n        if not is_valid_unit(vr_col):\n            return False\n    \n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_box = [\n                vr_board[vr_x][vr_y]\n                for vr_x in range(vr_i, vr_i + 3)\n                for vr_y in range(vr_j, vr_j + 3)\n            ]\n            if not is_valid_unit(vr_box):\n                return False\n    \n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, q_capacity: int):\n        assert isinstance(q_capacity, int) and q_capacity > 0, \"Capacity must be a positive integer\"\n        self.q_capacity = q_capacity\n        self.q_cache = OrderedDict()\n\n    def chx_get(self, vr_key: int) -> int:\n        assert isinstance(vr_key, int), \"Key must be an integer\"\n        try:\n            if vr_key not in self.q_cache:\n                return -1\n            else:\n                self.q_cache.move_to_end(vr_key)\n                return self.q_cache[vr_key]\n        except Exception as e:\n            print(f\"Error in chx_get: {e}\")\n\n    def chx_put(self, vr_key: int, vr_value: int) -> None:\n        assert isinstance(vr_key, int) and isinstance(vr_value, int), \"Key and value must be integers\"\n        try:\n            if vr_key in self.q_cache:\n                self.q_cache.move_to_end(vr_key)\n            self.q_cache[vr_key] = vr_value\n            if len(self.q_cache) > self.q_capacity:\n                self.q_cache.popitem(last=False)\n        except Exception as e:\n            print(f\"Error in chx_put: {e}\")\n```\n",
        "```python\nfrom sklearn.base import BaseEstimator, ClassifierMixin\nfrom sklearn.utils.validation import check_X_y, check_array, check_is_fitted\nfrom sklearn.preprocessing import StandardScaler\nimport numpy as np\nfrom pedantic import timer_class\n\n@timer_class\nclass QDA(BaseEstimator, ClassifierMixin):\n    def __init__(self):\n        self.q_scaler_ = StandardScaler()\n        self.q_classes_ = None\n        self.q_means_ = None\n        self.q_covariances_ = None\n        self.q_priors_ = None\n\n    def chx_fit(self, vr_X, vr_y):\n        vr_X, vr_y = check_X_y(vr_X, vr_y)\n        vr_X = self.q_scaler_.fit_transform(vr_X)\n\n        self.q_classes_ = np.unique(vr_y)\n        self.q_means_ = [vr_X[vr_y == cls].mean(axis=0) for cls in self.q_classes_]\n        self.q_covariances_ = [np.cov(vr_X[vr_y == cls].T) for cls in self.q_classes_]\n        self.q_priors_ = [np.mean(vr_y == cls) for cls in self.q_classes_]\n\n        return self\n\n    def chx_predict(self, vr_X):\n        check_is_fitted(self)\n        vr_X = check_array(vr_X)\n        vr_X = self.q_scaler_.transform(vr_X)\n\n        vr_discriminants = [self.chx__compute_discriminant(vr_X, cls_index) for cls_index in range(len(self.q_classes_))]\n        return self.q_classes_[np.argmax(vr_discriminants, axis=0)]\n\n    def chx__compute_discriminant(self, vr_X, class_index):\n        q_cov_inv = np.linalg.inv(self.q_covariances_[class_index])\n        q_mean = self.q_means_[class_index]\n        q_prior = self.q_priors_[class_index]\n        return -0.5 * np.sum((vr_X - q_mean) @ q_cov_inv * (vr_X - q_mean), axis=1) + np.log(q_prior)\n\n    def chx_predict_proba(self, vr_X):\n        check_is_fitted(self)\n        vr_X = check_array(vr_X)\n        vr_X = self.q_scaler_.transform(vr_X)\n\n        vr_discriminants = [self.chx__compute_discriminant(vr_X, cls_index) for cls_index in range(len(self.q_classes_))]\n        vr_discriminants = np.vstack(vr_discriminants)\n        max_discriminant = np.max(vr_discriminants, axis=0)\n        vr_exp_discriminants = np.exp(vr_discriminants - max_discriminant)\n        return (vr_exp_discriminants / vr_exp_discriminants.sum(axis=0)).T\n\n    def chx_score(self, vr_X, vr_y):\n        vr_y_pred = self.chx_predict(vr_X)\n        return np.mean(vr_y_pred == vr_y)\n```\n",
        "```python\nfrom typing import List\n\ndef chx_compute_average_diagonal(vr_matrix: List[List[float]]) -> float:\n    try:\n        assert all(isinstance(row, list) for row in vr_matrix), \"All elements must be lists\"\n        num_rows = len(vr_matrix)\n        assert all(len(row) == num_rows for row in vr_matrix), \"Matrix must be square\"\n        assert num_rows > 0, \"Matrix must not be empty\"\n        \n        vr_diagonal_sum = 0\n        q_num_elements = len(vr_matrix)\n        \n        for q_i in range(q_num_elements):\n            vr_diagonal_sum += vr_matrix[q_i][q_i]\n        \n        chx_average = vr_diagonal_sum / q_num_elements\n        return chx_average\n    except Exception as e:\n        raise ValueError(\"An error occurred while computing the average of the diagonal elements\") from e\n```",
        "```python\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, vr_val: int, q_left: Optional['TreeNode'] = None, q_right: Optional['TreeNode'] = None):\n        self.vr_val = vr_val\n        self.q_left = q_left\n        self.q_right = q_right\n\ndef chx_is_valid_bst(q_root: Optional[TreeNode], vr_low: int = float('-inf'), vr_high: int = float('inf')) -> bool:\n    if q_root is None:\n        return True\n\n    assert isinstance(q_root.vr_val, int), \"Node value must be an integer\"\n\n    vr_val = q_root.vr_val\n    if vr_val <= vr_low or vr_val >= vr_high:\n        return False\n\n    return (chx_is_valid_bst(q_root.q_left, vr_low, vr_val) and \n            chx_is_valid_bst(q_root.q_right, vr_val, vr_high))\n```\n",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass Heap:\n    def __init__(self):\n        self.q_heap = []\n\n    def chx_insert(self, vr_value):\n        \"\"\"Insert value into the heap.\"\"\"\n        self.q_heap.append(vr_value)\n        self.chx_heapify_up(len(self.q_heap) - 1)\n\n    def chx_heapify_up(self, vr_index):\n        \"\"\"Heapify the element at index up to maintain heap property.\"\"\"\n        while vr_index > 0:\n            vr_parent_index = (vr_index - 1) // 2\n            if self.q_heap[vr_index] > self.q_heap[vr_parent_index]:\n                self.q_heap[vr_index], self.q_heap[vr_parent_index] = self.q_heap[vr_parent_index], self.q_heap[vr_index]\n                vr_index = vr_parent_index\n            else:\n                break\n```",
        "```python\nfrom typing import List\n\ndef chx_is_valid_sudoku(vr_board: List[List[str]]) -> bool:\n    def chx_is_valid_unit(vr_unit: List[str]) -> bool:\n        vr_unit = [num for num in vr_unit if num != '.']\n        return len(vr_unit) == len(set(vr_unit))\n    \n    for q_i in range(9):\n        if not (chx_is_valid_unit([vr_board[q_i][q_j] for q_j in range(9)]) and\n                chx_is_valid_unit([vr_board[q_j][q_i] for q_j in range(9)])):\n            return False\n    \n    for q_i in range(0, 9, 3):\n        for q_j in range(0, 9, 3):\n            vr_box = [vr_board[q_x][q_y]\n                      for q_x in range(q_i, q_i + 3)\n                      for q_y in range(q_j, q_j + 3)]\n            if not chx_is_valid_unit(vr_box):\n                return False\n\n    return True\n```\n"
      ]
    }
  ]
}