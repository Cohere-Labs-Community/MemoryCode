{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport pedantic\n\n@pedantic.retry\ndef find_majority_element(wr_array):\n    \"\"\"\n    This function finds the majority element in the given array.\n    \n    Args:\n        wr_array (list): The input array.\n    \n    Returns:\n        The majority element if it exists, otherwise None.\n    \"\"\"\n    wr_count = {}\n    wr_majority_element = None\n    \n    # Count the occurrences of each element in the array\n    for wr_element in wr_array:\n        if wr_element in wr_count:\n            wr_count[wr_element] += 1\n        else:\n            wr_count[wr_element] = 1\n    \n    # Find the majority element\n    for wr_element, wr_frequency in wr_count.items():\n        if wr_frequency > len(wr_array) / 2:\n            wr_majority_element = wr_element\n            break\n    \n    return wr_majority_element\n```\n\nThis function adheres to the coding guidelines provided by Harena, including the use of the `@retry` decorator from the `pedantic` module for error handling and resilience, and the prefixing of variable names with 'wr_' for consistency and clarity.",
        "```python\nimport pedantic\n\n@pedantic.retry\ndef is_valid_sudoku(wr_board):\n    \"\"\"\n    This function checks if a given 2D array represents a valid Sudoku puzzle.\n    \n    Args:\n    wr_board (list): A 2D list representing the Sudoku board.\n    \n    Returns:\n    bool: True if the Sudoku board is valid, False otherwise.\n    \"\"\"\n    \n    # Check each row for validity\n    for wr_row in wr_board:\n        wr_row_values = [wr_value for wr_value in wr_row if wr_value != 0]\n        if len(wr_row_values) != len(set(wr_row_values)):\n            return False\n    \n    # Check each column for validity\n    for wr_col in range(9):\n        wr_col_values = [wr_row[wr_col] for wr_row in wr_board if wr_row[wr_col] != 0]\n        if len(wr_col_values) != len(set(wr_col_values)):\n            return False\n    \n    # Check each 3x3 sub-grid for validity\n    for wr_i in range(0, 9, 3):\n        for wr_j in range(0, 9, 3):\n            wr_subgrid_values = [wr_board[wr_x][wr_y] for wr_x in range(wr_i, wr_i + 3) \n                                 for wr_y in range(wr_j, wr_j + 3) \n                                 if wr_board[wr_x][wr_y] != 0]\n            if len(wr_subgrid_values) != len(set(wr_subgrid_values)):\n                return False\n    \n    return True\n```\n\nThis function adheres to the coding guidelines provided by the mentor, including the use of the `@retry` decorator from the `pedantic` module for error handling and resilience, and the prefixing of variable names with 'wr_' for consistency and clarity."
      ],
      "instruction_model_output": [
        "```python\nfrom pedantic import retry\nfrom typing import List\n\n@retry\ndef find_majority_element(nums: List[int]) -> int:\n    \"\"\"\n    Returns the majority element of an array.\n    \n    The majority element is the element that appears more than n/2 times where n is the size of the array.\n    \n    This function uses the Boyer-Moore Majority Vote algorithm, which works by essentially keeping a counter for the majority element.\n    If the counter is 0, the algorithm sets the current element as the majority element.\n    Then, it increments the counter if it encounters the same element again, otherwise it decrements the counter.\n    Since the majority element occurs more than n/2 times, it is guaranteed to be the last element to set the counter to 0.\n    \"\"\"\n    count = 0\n    candidate = None\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n            count = 1\n        elif candidate == num:\n            count += 1\n        else:\n            count -= 1\n    \n    return candidate\n```",
        "```python\ndef is_valid_sudoku(wr_board):\n    \"\"\"\n    Checks if the given 2D array represents a valid Sudoku board.\n\n    Args:\n        wr_board (list): A 2D list of integers representing the Sudoku board.\n\n    Returns:\n        bool: True if the Sudoku board is valid, False otherwise.\n    \"\"\"\n\n    # Check rows\n    for wr_row in wr_board:\n        wr_seen = set()\n        for wr_num in wr_row:\n            if wr_num != 0 and wr_num in wr_seen:\n                return False\n            wr_seen.add(wr_num)\n\n    # Check columns\n    for wr_col in range(9):\n        wr_seen = set()\n        for wr_row in range(9):\n            wr_num = wr_board[wr_row][wr_col]\n            if wr_num != 0 and wr_num in wr_seen:\n                return False\n            wr_seen.add(wr_num)\n\n    # Check 3x3 boxes\n    for wr_box_row in range(0, 9, 3):\n        for wr_box_col in range(0, 9, 3):\n            wr_seen = set()\n            for wr_row in range(3):\n                for wr_col in range(3):\n                    wr_num = wr_board[wr_box_row + wr_row][wr_box_col + wr_col]\n                    if wr_num != 0 and wr_num in wr_seen:\n                        return False\n                    wr_seen.add(wr_num)\n\n    return True\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    \"\"\"\n    This function checks if a given 2D array represents a valid Sudoku puzzle.\n    \n    Args:\n        board (list): A 2D list of integers representing the Sudoku puzzle.\n        \n    Returns:\n        bool: True if the Sudoku puzzle is valid, False otherwise.\n    \"\"\"\n\n    # Check if the input is a 9x9 grid\n    assert len(board) == 9, \"Invalid Sudoku puzzle: expected 9 rows\"\n    for row in board:\n        assert len(row) == 9, \"Invalid Sudoku puzzle: expected 9 columns\"\n\n    # Check each row for duplicate numbers\n    for n_row in range(9):\n        seen = set()\n        for n_col in range(9):\n            n_value = board[n_row][n_col]\n            if n_value != 0:\n                assert n_value not in seen, f\"Invalid Sudoku puzzle: duplicate {n_value} in row {n_row+1}\"\n                seen.add(n_value)\n\n    # Check each column for duplicate numbers\n    for n_col in range(9):\n        seen = set()\n        for n_row in range(9):\n            n_value = board[n_row][n_col]\n            if n_value != 0:\n                assert n_value not in seen, f\"Invalid Sudoku puzzle: duplicate {n_value} in column {n_col+1}\"\n                seen.add(n_value)\n\n    # Check each 3x3 sub-grid for duplicate numbers\n    for n_subgrid_row in range(3):\n        for n_subgrid_col in range(3):\n            seen = set()\n            for n_row in range(3):\n                for n_col in range(3):\n                    n_value = board[n_subgrid_row*3 + n_row][n_subgrid_col*3 + n_col]\n                    if n_value != 0:\n                        assert n_value not in seen, f\"Invalid Sudoku puzzle: duplicate {n_value} in sub-grid ({n_subgrid_row+1},{n_subgrid_col+1})\"\n                        seen.add(n_value)\n\n    # If all checks pass, the Sudoku puzzle is valid\n    return True\n```",
        "```python\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors):\n        \"\"\"\n        Initialize the Nearest Neighbors model.\n\n        Args:\n            n_neighbors (int): The number of nearest neighbors to consider.\n        \"\"\"\n        assert isinstance(n_neighbors, int), \"n_neighbors must be an integer\"\n        assert n_neighbors > 0, \"n_neighbors must be greater than 0\"\n        self.n_n_neighbors = n_neighbors\n        self.n_training_data = None\n        self.n_training_labels = None\n\n    def train(self, training_data, training_labels):\n        \"\"\"\n        Train the Nearest Neighbors model.\n\n        Args:\n            training_data (list of lists): The training data.\n            training_labels (list): The training labels.\n        \"\"\"\n        assert len(training_data) == len(training_labels), \"Training data and labels must have the same length\"\n        self.n_training_data = training_data\n        self.n_training_labels = training_labels\n\n    def predict(self, new_data):\n        \"\"\"\n        Predict the label of new data using the Nearest Neighbors model.\n\n        Args:\n            new_data (list): The new data to predict.\n\n        Returns:\n            int: The predicted label.\n        \"\"\"\n        assert len(new_data) == len(self.n_training_data[0]), \"New data must have the same length as training data\"\n        distances = []\n        for i, data in enumerate(self.n_training_data):\n            distance = sum((a - b) ** 2 for a, b in zip(data, new_data)) ** 0.5\n            distances.append((distance, self.n_training_labels[i]))\n        distances.sort(key=lambda x: x[0])\n        nearest_neighbors = [label for _, label in distances[:self.n_n_neighbors]]\n        return max(set(nearest_neighbors), key=nearest_neighbors.count)\n```\n\nThis implementation follows the guidelines provided by the mentor, including the use of the 'n_' prefix for variable names that hold numeric values and the inclusion of assert statements to validate input and ensure the code behaves as expected."
      ],
      "instruction_model_output": [
        "```python\ndef is_valid_sudoku(n_board):\n    \"\"\"\n    Checks if a given 2D array represents a valid Sudoku board.\n\n    Args:\n        n_board (list): A 2D list representing the Sudoku board.\n\n    Returns:\n        bool: True if the board is valid, False otherwise.\n    \"\"\"\n\n    # Check rows\n    for n_row in n_board:\n        n_seen = set()\n        for n_num in n_row:\n            if n_num != 0 and n_num in n_seen:\n                return False\n            n_seen.add(n_num)\n\n    # Check columns\n    for n_col in range(9):\n        n_seen = set()\n        for n_row in n_board:\n            n_num = n_row[n_col]\n            if n_num != 0 and n_num in n_seen:\n                return False\n            n_seen.add(n_num)\n\n    # Check boxes\n    for n_box_row in range(0, 9, 3):\n        for n_box_col in range(0, 9, 3):\n            n_seen = set()\n            for n_row in range(3):\n                for n_col in range(3):\n                    n_num = n_board[n_box_row + n_row][n_box_col + n_col]\n                    if n_num != 0 and n_num in n_seen:\n                        return False\n                    n_seen.add(n_num)\n\n    return True\n```",
        "```python\nimport numpy as np\n\nclass NearestNeighbors:\n    \"\"\"\n    A simple Nearest Neighbors model.\n\n    Attributes:\n    -----------\n    k : int\n        The number of nearest neighbors to consider.\n    distance_metric : str\n        The distance metric to use. Currently supports 'euclidean' and 'manhattan'.\n    X_train : np.ndarray\n        The training data.\n    y_train : np.ndarray\n        The training labels.\n    \"\"\"\n\n    def __init__(self, k=1, distance_metric='euclidean'):\n        \"\"\"\n        Initialize the NearestNeighbors model.\n\n        Parameters:\n        -----------\n        k : int, optional\n            The number of nearest neighbors to consider (default is 1).\n        distance_metric : str, optional\n            The distance metric to use (default is 'euclidean').\n        \"\"\"\n        assert isinstance(k, int) and k > 0, \"k must be a positive integer\"\n        assert distance_metric in ['euclidean', 'manhattan'], \"distance_metric must be 'euclidean' or 'manhattan'\"\n        self.k = k\n        self.distance_metric = distance_metric\n        self.X_train = None\n        self.y_train = None\n\n    def _calculate_distance(self, x1, x2):\n        \"\"\"\n        Calculate the distance between two points.\n\n        Parameters:\n        -----------\n        x1 : np.ndarray\n            The first point.\n        x2 : np.ndarray\n            The second point.\n\n        Returns:\n        --------\n        float\n            The distance between the two points.\n        \"\"\"\n        assert x1.shape == x2.shape, \"x1 and x2 must have the same shape\"\n        if self.distance_metric == 'euclidean':\n            return np.sqrt(np.sum((x1 - x2) ** 2))\n        elif self.distance_metric == 'manhattan':\n            return np.sum(np.abs(x1 - x2))\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the NearestNeighbors model.\n\n        Parameters:\n        -----------\n        X_train : np.ndarray\n            The training data.\n        y_train : np.ndarray\n            The training labels.\n        \"\"\"\n        assert isinstance(X_train, np.ndarray) and isinstance(y_train, np.ndarray), \"X_train and y_train must be numpy arrays\"\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        \"\"\"\n        Make predictions using the NearestNeighbors model.\n\n        Parameters:\n        -----------\n        X_test : np.ndarray\n            The test data.\n\n        Returns:\n        --------\n        np.ndarray\n            The predicted labels.\n        \"\"\"\n        assert isinstance(X_test, np.ndarray), \"X_test must be a numpy array\"\n        assert self.X_train is not None and self.y_train is not None, \"Model must be trained before making predictions\"\n        predictions = []\n        for x in X_test:\n            distances = [self._calculate_distance(x, x_train) for x_train in self.X_train]\n            indices = np.argsort(distances)[:self.k]\n            labels = self.y_train[indices]\n            prediction = np.bincount(labels).argmax()\n            predictions.append(prediction)\n        return np.array(predictions)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "Here's a function that calculates the h-index given an array of integer citations, following the coding guidelines provided by Harena:\n\n```python\ndef b_calculate_h_index(citations):\n    \"\"\"\n    Calculate the h-index given an array of integer citations.\n\n    Args:\n        citations (list): A list of integer citations.\n\n    Returns:\n        int: The calculated h-index.\n    \"\"\"\n    vr_citations = sorted(citations, reverse=True)\n    vr_h_index = 0\n\n    for vr_i, vr_citation in enumerate(vr_citations):\n        vr_h_index = max(vr_h_index, min(vr_citation, vr_i + 1))\n\n    return vr_h_index\n```\n\nThis function sorts the citations in descending order, then iterates over the sorted list to calculate the h-index. The h-index is the maximum of the minimum between the citation count and the paper number (1-indexed). The function follows the coding guidelines provided by Harena, including the use of the 'b_' prefix for function names and the 'vr_' prefix for variable names.",
        "Here's a function that checks if a given 2D array represents a valid Sudoku puzzle. This function follows the coding guidelines provided by Harena, including the use of the 'b_' prefix for function names and 'vr_' prefix for variable names.\n\n```python\ndef b_is_valid_sudoku(vr_board):\n    \"\"\"\n    Checks if a given 2D array represents a valid Sudoku puzzle.\n\n    Args:\n        vr_board (list): A 2D list representing the Sudoku board.\n\n    Returns:\n        bool: True if the Sudoku board is valid, False otherwise.\n    \"\"\"\n\n    # Check each row for duplicate numbers\n    for vr_row in vr_board:\n        vr_seen = set()\n        for vr_num in vr_row:\n            if vr_num != 0 and vr_num in vr_seen:\n                return False\n            vr_seen.add(vr_num)\n\n    # Check each column for duplicate numbers\n    for vr_col in range(9):\n        vr_seen = set()\n        for vr_row in range(9):\n            vr_num = vr_board[vr_row][vr_col]\n            if vr_num != 0 and vr_num in vr_seen:\n                return False\n            vr_seen.add(vr_num)\n\n    # Check each 3x3 sub-grid for duplicate numbers\n    for vr_i in range(0, 9, 3):\n        for vr_j in range(0, 9, 3):\n            vr_seen = set()\n            for vr_x in range(3):\n                for vr_y in range(3):\n                    vr_num = vr_board[vr_i + vr_x][vr_j + vr_y]\n                    if vr_num != 0 and vr_num in vr_seen:\n                        return False\n                    vr_seen.add(vr_num)\n\n    return True\n```\n\nThis function checks each row, column, and 3x3 sub-grid for duplicate numbers, which is a necessary condition for a valid Sudoku puzzle. If any duplicate numbers are found, the function immediately returns False. If no duplicate numbers are found after checking all rows, columns, and sub-grids, the function returns True, indicating that the Sudoku board is valid."
      ],
      "instruction_model_output": [
        "```python\ndef b_compute_h_index(citations):\n    \"\"\"\n    Computes the h-index given an array of integer citations.\n\n    The h-index is a metric that measures the productivity and citation impact of a researcher.\n    It is defined as the largest number of papers included in the h-index, which is the number of papers with at least as many citations as the number of papers.\n\n    Args:\n        citations (list): A list of integers representing the number of citations for each paper.\n\n    Returns:\n        int: The computed h-index.\n    \"\"\"\n    n = len(citations)\n    citations.sort(reverse=True)\n    \n    # Initialize the h-index to 0\n    h_index = 0\n    \n    # Iterate over the sorted citations\n    for i in range(n):\n        # For each citation, the h-index is the minimum of the number of papers and the number of citations\n        # We update the h-index if the current paper's h-index is larger\n        h_index = max(h_index, min(i + 1, citations[i]))\n    \n    return h_index\n```",
        "```python\ndef is_valid_sudoku(vr_board):\n    \"\"\"\n    Checks if the given 2D array represents a valid Sudoku board.\n\n    Args:\n        vr_board (list of lists): A 9x9 2D array representing the Sudoku board.\n\n    Returns:\n        bool: True if the Sudoku board is valid, False otherwise.\n    \"\"\"\n\n    # Check rows\n    for vr_row in vr_board:\n        vr_seen = set()\n        for vr_num in vr_row:\n            if vr_num != 0 and vr_num in vr_seen:\n                return False\n            vr_seen.add(vr_num)\n\n    # Check columns\n    for vr_col in range(9):\n        vr_seen = set()\n        for vr_row in range(9):\n            vr_num = vr_board[vr_row][vr_col]\n            if vr_num != 0 and vr_num in vr_seen:\n                return False\n            vr_seen.add(vr_num)\n\n    # Check 3x3 boxes\n    for vr_box_row in range(0, 9, 3):\n        for vr_box_col in range(0, 9, 3):\n            vr_seen = set()\n            for vr_row in range(3):\n                for vr_col in range(3):\n                    vr_num = vr_board[vr_box_row + vr_row][vr_box_col + vr_col]\n                    if vr_num != 0 and vr_num in vr_seen:\n                        return False\n                    vr_seen.add(vr_num)\n\n    return True\n```"
      ],
      "history_model_output": [
        "```python\n@retry\ndef b_compute_h_index(citations):\n    \"\"\"\n    This function computes the h-index given an array of integer citations.\n\n    Args:\n        citations (list): A list of integer citations.\n\n    Returns:\n        int: The computed h-index.\n    \"\"\"\n    assert isinstance(citations, list), \"Input must be a list of integers.\"\n    assert all(isinstance(citation, int) for citation in citations), \"All elements in the list must be integers.\"\n\n    n_citations = len(citations)\n    vr_citations = sorted(citations, reverse=True)\n    vr_h_index = 0\n\n    for vr_i in range(n_citations):\n        vr_h_index = max(vr_h_index, min(vr_citations[vr_i], vr_i + 1))\n\n    return vr_h_index\n```\n\nThis function adheres to the coding guidelines provided by the mentor, including:\n\n1.  Using the `@retry` decorator for error handling and resilience.\n2.  Prefixing function names with 'b_'.\n3.  Prefixing variable names with 'vr_'.\n4.  Including assert statements to validate input and ensure the code behaves as expected.\n5.  Providing a clear and descriptive docstring for the function.",
        "```python\nimport numpy as np\nfrom scipy.spatial import distance\nfrom pedantic import retry\n\nclass NearestNeighbors:\n    @retry\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.wr_X_train = None\n        self.wr_y_train = None\n\n    @retry\n    def train(self, wr_X, wr_y):\n        assert len(wr_X) == len(wr_y), \"Input and output arrays must have the same length\"\n        self.wr_X_train = wr_X\n        self.wr_y_train = wr_y\n\n    @retry\n    def predict(self, wr_X_test):\n        assert self.wr_X_train is not None, \"Model must be trained before making predictions\"\n        predictions = []\n        for vr_test_instance in wr_X_test:\n            n_distances = []\n            for vr_train_instance in self.wr_X_train:\n                vr_distance = distance.euclidean(vr_test_instance, vr_train_instance)\n                n_distances.append(vr_distance)\n            n_indices = np.argsort(n_distances)[:self.n_neighbors]\n            vr_labels = [self.wr_y_train[n_index] for n_index in n_indices]\n            b_prediction = self.b_majority_vote(vr_labels)\n            predictions.append(b_prediction)\n        return predictions\n\n    @retry\n    def b_majority_vote(self, vr_labels):\n        b_counts = {}\n        for vr_label in vr_labels:\n            if vr_label in b_counts:\n                b_counts[vr_label] += 1\n            else:\n                b_counts[vr_label] = 1\n        return max(b_counts, key=b_counts.get)\n```",
        "```python\n@retry\ndef b_is_valid_sudoku(board):\n    \"\"\"\n    This function checks if a given 2D array represents a valid Sudoku puzzle.\n    \n    Args:\n    board (list): A 2D list representing the Sudoku puzzle.\n    \n    Returns:\n    bool: True if the Sudoku puzzle is valid, False otherwise.\n    \"\"\"\n    \n    # Check if the input is a 9x9 grid\n    assert len(board) == 9 and all(len(row) == 9 for row in board), \"Invalid Sudoku grid size\"\n    \n    # Check rows\n    for row in board:\n        vr_row_values = [vr_value for vr_value in row if vr_value != 0]\n        assert len(vr_row_values) == len(set(vr_row_values)), \"Duplicate values in row\"\n    \n    # Check columns\n    for n_column in range(9):\n        vr_column_values = [board[n_row][n_column] for n_row in range(9) if board[n_row][n_column] != 0]\n        assert len(vr_column_values) == len(set(vr_column_values)), \"Duplicate values in column\"\n    \n    # Check 3x3 sub-grids\n    for n_subgrid_row in range(0, 9, 3):\n        for n_subgrid_column in range(0, 9, 3):\n            vr_subgrid_values = [board[n_row][n_column] for n_row in range(n_subgrid_row, n_subgrid_row + 3) \n                                 for n_column in range(n_subgrid_column, n_subgrid_column + 3) \n                                 if board[n_row][n_column] != 0]\n            assert len(vr_subgrid_values) == len(set(vr_subgrid_values)), \"Duplicate values in sub-grid\"\n    \n    return True\n```",
        "```python\nimport pedantic\n\n@pedantic.retry\ndef b_find_majority_element(n_array):\n    assert isinstance(n_array, list), \"Input must be a list\"\n    assert len(n_array) > 0, \"Input list must not be empty\"\n\n    vr_count = {}\n    for vr_element in n_array:\n        if vr_element in vr_count:\n            vr_count[vr_element] += 1\n        else:\n            vr_count[vr_element] = 1\n\n    vr_majority_element = max(vr_count, key=vr_count.get)\n    return vr_majority_element\n```\n\nThis function adheres to the coding guidelines provided by the mentor, including:\n\n* Using the `@retry` decorator from the `pedantic` module for error handling and resilience.\n* Prefixing function names with 'b_'.\n* Prefixing variable names with 'vr_'.\n* Including assert statements to validate input and ensure the code behaves as expected.\n* Using descriptive variable names.\n* Following the latest updates to the coding conventions."
      ]
    }
  ]
}