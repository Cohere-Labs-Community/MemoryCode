{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def z_palindrome_checker_vr(s: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n    \n    Args:\n        s (str): The input string to be checked.\n        \n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Reverse the string and check for equality\n    return s == s[::-1]",
        "def z_valid_sudoku_vr(board):\n    z_seen_rows_vr = [{} for _ in range(9)]\n    z_seen_cols_vr = [{} for _ in range(9)]\n    z_seen_boxes_vr = [{} for _ in range(9)]\n    for z_i in range(9):\n        for z_j in range(9):\n            z_num = board[z_i][z_j]\n            if z_num != '.':\n                z_num_str = str(z_num)\n                z_box_index = (z_i // 3) * 3 + z_j // 3\n                if (\n                    z_num_str in z_seen_rows_vr[z_i]\n                    or z_num_str in z_seen_cols_vr[z_j]\n                    or z_num_str in z_seen_boxes_vr[z_box_index]\n                ):\n                    return False\n                z_seen_rows_vr[z_i][z_num_str] = True\n                z_seen_cols_vr[z_j][z_num_str] = True\n                z_seen_boxes_vr[z_box_index][z_num_str] = True\n    return True"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_vr):\n    s_vr = s_vr.lower()\n    return s_vr == s_vr[::-1]",
        "def is_valid_sudoku(z_board):\n    z_rows = [set() for _ in range(9)]\n    z_cols = [set() for _ in range(9)]\n    z_boxes = [set() for _ in range(9)]\n\n    for z_i in range(9):\n        for z_j in range(9):\n            z_num = z_board[z_i][z_j]\n            if z_num != '.':\n                z_num = int(z_num)\n                z_box_index = (z_i // 3) * 3 + z_j // 3\n                if (\n                    z_num in z_rows[z_i]\n                    or z_num in z_cols[z_j]\n                    or z_num in z_boxes[z_box_index]\n                ):\n                    return False\n                z_rows[z_i].add(z_num)\n                z_cols[z_j].add(z_num)\n                z_boxes[z_box_index].add(z_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom hashlib import sha256\n\ndef is_palindrome_z(s_str_z: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid palindrome.\n\n    :param s_str_z: The input string to be checked\n    :return: True if the string is a palindrome, False otherwise\n    \"\"\"\n    s_cleaned_str_z = \"\".join(char_z.lower() for char_z in s_str_z if char_z.isalnum())\n    return s_cleaned_str_z == s_cleaned_str_z[::-1]\n\n# Example usage (not provided by Oliver)\n# print(is_palindrome_z(\"racecar\")) # Output: True\n# print(is_palindrome_z(\"hello world\")) # Output: False\n```",
        "```python\nimport hashlib \n\ndef insertion_sort_z(arr_z):\n    for i in range(1, len(arr_z)):\n        key_z = arr_z[i]\n        j = i-1\n        while j >= 0 and key_z < arr_z[j]:\n            arr_z[j + 1] = arr_z[j]\n            j -= 1\n        arr_z[j + 1] = key_z\n    return arr_z\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_z):\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]",
        "import hashlib\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half_y = arr[:mid]\n    right_half_y = arr[mid:]\n\n    left_half_y = merge_sort_y(left_half_y)\n    right_half_y = merge_sort_y(right_half_y)\n\n    return merge_y(left_half_y, right_half_y)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.base import BaseEstimator\nfrom sklearn.neighbors import NearestNeighbors\nimport numpy as np\n\n\nclass NearestNeighborsModel(BaseEstimator):\n    \"\"\"Nearest Neighbors Model for training and prediction.\"\"\"\n\n    def __init__(self, n_neighbors=5):\n        \"\"\"\n        Initialize the NearestNeighborsModel class.\n\n        Args:\n            n_neighbors (int): Number of neighbors to consider for prediction. Default is 5.\n        \"\"\"\n        self.n_neighbors = n_neighbors\n        self.model = NearestNeighbors(n_neighbors=n_neighbors)\n\n    def fit(self, X, y):\n        \"\"\"\n        Train the Nearest Neighbors model.\n\n        Args:\n            X (ndarray): Training data features of shape (n_samples, n_features).\n            y (ndarray): Target values of shape (n_samples,).\n\n        Returns:\n            self: Fitted NearestNeighborsModel instance.\n        \"\"\"\n        # Validate input data\n        assert isinstance(X, np.ndarray) and isinstance(y, np.ndarray), \"Input data must be numpy arrays.\"\n        assert X.shape[0] == y.shape[0], \"Number of samples in X and y must match.\"\n\n        # Fit the model\n        self.model.fit(X, y)\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict the target values for the given test data.\n\n        Args:\n            X (ndarray): Test data features of shape (n_samples, n_features).\n\n        Returns:\n            ndarray: Predicted target values of shape (n_samples,).\n        \"\"\"\n        # Validate input data\n        assert isinstance(X, np.ndarray), \"Input data must be a numpy array.\"\n        assert X.shape[1] == self.model.n_features_in_, \"Incorrect number of features in test data.\"\n\n        # Predict target values\n        distances, indices = self.model.kneighbors(X)\n        return indices.squeeze(axis=1)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijkstra(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt = []\n\n        for _ in range(self.V):\n            min_idx = self.min_distance_node(dist, spt)\n            spt.append(min_idx)\n            self._relax(min_idx, dist)\n\n        def _relax(node, dist):\n            for neighbour in self.graph[node]:\n                new_dist = dist[node] + 1\n                if new_dist < dist[neighbour]:\n                    dist[neighbour] = new_dist\n\n        def min_distance_node(dist, spt):\n            min_dist = float('inf')\n            min_idx = -1\n            for v in range(self.V):\n                if dist[v] < min_dist and v not in spt:\n                    min_dist = dist[v]\n                    min_idx = v\n            return min_idx\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef avg_diag_elements(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list of lists\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows must be lists\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)\n\n\nclass 7Calculator:\n    \"\"\"\n    A class for performing calculations.\n    \"\"\"\n    def __init__(self, num: int):\n        \"\"\"\n        Initializes the calculator with a number.\n\n        Args:\n            num (int): A number to initialize the calculator with.\n        \"\"\"\n        self.num = num\n\n    def add(self, other: int) -> int:\n        \"\"\"\n        Adds a number to the current number.\n\n        Args:\n            other (int): The number to add.\n\n        Returns:\n            int: The sum of the two numbers.\n        \"\"\"\n        return self.num + other\n```",
        "```python\nfrom sklearn.decomposition import PCA\n\nclass PCAAnalysis:\n    def __init__(self, n_components=2):\n        self.n_components = n_components\n        self.pca = PCA(n_components=n_components)\n\n    def fit(self, data):\n        self.pca.fit(data)\n\n    def transform(self, data):\n        return self.pca.transform(data)\n\n    def get_explained_variance_ratio(self):\n        return self.pca.explained_variance_ratio_\n\n    def assert_valid_n_components(self):\n        assert self.n_components > 0 and self.n_components <= 1, \"n_components should be between 0 and 1\"\n\n# Example usage:\n# from sklearn.datasets import load_iris\n# data = load_iris().data\n# pca = PCAAnalysis(n_components=2)\n# pca.fit(data)\n# transformed_data = pca.transform(data)\n# explained_variance_ratio = pca.get_explained_variance_ratio()\n```"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)",
        "class PCA0:\n    def __init__(self, n_components=0):\n        self.n_components = n_components\n\n    def fit_transform(self, X):\n        X_centered = X - X.mean(axis=0)\n        covariance = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eig(covariance)\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n        components = eigenvectors[:, :self.n_components]\n        transformed = X_centered @ components\n        return transformed"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    y_input_string_y = str(input_string)\n    y_reversed_string_y = y_input_string_y[::-1]\n    y_is_palindrome_y = y_input_string_y == y_reversed_string_y\n    return y_is_palindrome_y",
        "def is_valid_sudoku(board):\n    y_row, y_col = {}, {}\n    y_box = {}\n    \n    for y_ in range(9):\n        y_row[y_] = {}\n        y_col[y_] = {}\n    \n    for y_ in range(3):\n        for y in range(3):\n            y_box[(y_, y)] = {}\n    \n    for y_ in range(9):\n        for y in range(9):\n            num = board[y_][y]\n            if num != '.':\n                if num in y_row[y_] or num in y_col[y] or num in y_box[(y_ // 3, y // 3)]:\n                    return False\n                y_row[y_][num] = y_row[y_].get(num, 0) + 1\n                y_col[y][num] = y_col[y].get(num, 0) + 1\n                y_box[(y_ // 3, y // 3)][num] = y_box[(y_ // 3, y // 3)].get(num, 0) + 1\n\n    return True"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True",
        "def is_valid_sudoku(y_board):\n    y_seen = set()\n    for y_i in range(9):\n        y_seen = set()\n        for y_j in range(9):\n            if y_board[y_i][y_j] != '.':\n                if y_board[y_i][y_j] in y_seen:\n                    return False\n                y_seen.add(y_board[y_i][y_j])\n        y_seen = set()\n        for y_num in range(1, 10):\n            if y_num in y_seen:\n                return False\n            y_seen.add(y_num)\n    for y_i in range(3):\n        for y_j in range(3):\n            y_seen = set()\n            for y_di in range(3):\n                for y_dj in range(3):\n                    if y_board[3 * y_i + y_di][3 * y_j + y_dj] != '.':\n                        if y_board[3 * y_i + y_di][3 * y_j + y_dj] in y_seen:\n                            return False\n                        y_seen.add(y_board[3 * y_i + y_di][3 * y_j + y_dj])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def shortest_path_a(self, start, end, graph):\n        queue = [(start, [start])]\n        while queue:\n            (node, path) = queue.pop(0)\n            if node == end:\n                return path\n            for adjacent in graph[node]:\n                new_path = path + [adjacent]\n                queue.append((adjacent, new_path))\n\n    # Example usage:\n    # g = Graph()\n    # graph = {\n    #     'A': ['B', 'C'],\n    #     'B': ['A', 'D', 'E'],\n    #     'C': ['A', 'F'],\n    #     'D': ['B'],\n    #     'E': ['B', 'F'],\n    #     'F': ['C', 'E']\n    # }\n    # print(g.shortest_path_a('A', 'F', graph))\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = []\n\n    def add_stock(self, item):\n        self.stock.append(item)\n\n    def remove_stock(self, item):\n        self.stock.remove(item)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": [
        "```python\ndef merge_sort(arr: list[int]) -> list[int]:\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    return _merge(left_half, right_half)\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.edges = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def shortest_path(self, start, end):\n        distance = [float('inf')] * self.vertices\n        distance[start] = 0\n        queue = []\n        queue.append(start)\n\n        while queue:\n            u = queue.pop(0)\n            for v in self.edges[u]:\n                if distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n\n        return distance[end]\n```",
        "```python\nimport hashlib\nfrom sklearn.decomposition import PCA\n\nclass PCA_analysis:\n    def __init__(self, data, start_var='_z', end_var='_vr', func_end='_y', method_end='_md', class_prefix='9'):\n        self.data = data\n        self.start_var = start_var\n        self.end_var = end_var\n        self.func_end = func_end\n        self.method_end = method_end\n        self.class_prefix = class_prefix\n        self.hashlib = hashlib\n\n    def z_vr(self):\n        # Perform variable renaming as per mentor's instructions\n        pass\n\n    def y_func(self):\n        # Ensure function names end with '_y'\n        pass\n\n    def md_methods(self):\n        # Ensure method names end with '_md'\n        pass\n\n    def assert_statements(self):\n        # Include assert statements in methods for input validation\n        pass\n\n    def class_9(self):\n        # Ensure class name starts with a single-digit prefix\n        pass\n\n    def pca_analysis(self):\n        # Perform Principal Component Analysis using scikit-learn\n        pca = PCA()\n        transformed_data = pca.fit_transform(self.data)\n        return transformed_data\n```",
        "```python\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned_string = ''.join(char.lower() for char in input_string if char.isalnum())\n\n    # Compare the reversed string with the original\n    return cleaned_string == cleaned_string[::-1]\n```",
        "```python\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    seen = set()\n    for row in board:\n        for num in row:\n            if num != '.':\n                if num in seen:\n                    return False\n                seen.add(num)\n                seen = set()\n\n    for col in range(9):\n        seen = set()\n        for row in range(9):\n            num = board[row][col]\n            if num != '.':\n                if num in seen:\n                    return False\n                seen.add(num)\n\n    for row in range(0, 9, 3):\n        for col in range(0, 9, 3):\n            seen = set()\n            for i in range(row, row + 3):\n                for j in range(col, col + 3):\n                    num = board[i][j]\n                    if num != '.':\n                        if num in seen:\n                            return False\n                        seen.add(num)\n    return True\n```",
        "```python\ndef insertion_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sort a list of integers using the insertion sort algorithm.\n\n    Args:\n        arr (list[int]): A list of integers to be sorted.\n\n    Returns:\n        list[int]: The sorted list of integers.\n    \"\"\"\n    # Ensure variable name convention\n    z_arr_vr = arr\n    z_i_vr = 1\n    z_j_vr = 1\n\n    # Early exit for empty or single element list\n    if len(z_arr_vr) <= 1:\n        return z_arr_vr\n\n    # Import hashlib module as requested by Emma\n    import hashlib\n\n    # Iterate through the list\n    for z_i_vr in range(1, len(z_arr_vr)):\n        z_key_vr = z_arr_vr[z_i_vr]\n        z_j_vr = z_i_vr - 1\n\n        # Move elements of z_arr_vr[0:z_i_vr-1] that are greater than z_key_vr to one position ahead\n        while z_j_vr >= 0 and z_arr_vr[z_j_vr] > z_key_vr:\n            z_arr_vr[z_j_vr + 1] = z_arr_vr[z_j_vr]\n            z_j_vr -= 1\n\n        # Insert z_key_vr\n        z_arr_vr[z_j_vr + 1] = z_key_vr\n\n    # Function name convention as per Emma's instructions\n    def _insertion_sort_y():\n        pass\n\n    return z_arr_vr\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def _assert_valid_item(self, item: str) -> None:\n        assert item.startswith('z_') and item.endswith('_vr'), \"Invalid item name. Must start with 'z_' and end with '_vr'.\"\n\n    def add_stock(self, item: str, quantity: int) -> None:\n        self._assert_valid_item(item)\n        self.stock[item] = self.stock.get(item, 0) + quantity\n\n    def remove_stock(self, item: str, quantity: int) -> None:\n        self._assert_valid_item(item)\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock for item.\")",
        "```python\nimport hashlib\nfrom typing import List, Tuple\n\n\nclass NeighborsModel:\n    def __init__(self):\n        self.hash_object = hashlib.sha256()\n        self.z_vr = None\n        self.y = None\n        self._y = None\n        self.n_ = None\n\n    def train(self, X: List[Tuple[float, float]], y: List[int]):\n        self.z_vr = X\n        self.y = y\n\n    def predict(self, X: List[Tuple[float, float]]) -> List[int]:\n        self._y = [self._euclidean_distance(x, self.z_vr) for x in X]\n        self.n_ = [self._get_closest_neighbor(x) for x in self._y]\n        return self.n_\n\n    def _euclidean_distance(self, point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n    def _get_closest_neighbor(self, distance: float) -> int:\n        return distance // 10 % 10\n```",
        "```python\ndef average_diagonal_element(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    :param matrix: The input square matrix.\n    :return: The average of the diagonal elements.\n    \"\"\"\n    # Validate input\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        raise ValueError(\"Input must be a non-empty square matrix\")\n\n    # Calculate the size of the matrix\n    size = len(matrix)\n\n    # Initialize sum of diagonal elements\n    diagonal_sum = 0.0\n\n    # Iterate through the matrix and sum the diagonal elements\n    for i in range(size):\n        diagonal_sum += matrix[i][i]\n\n    # Calculate the average\n    average = diagonal_sum / size\n\n    # Return the average\n    return average\n```"
      ]
    }
  ]
}