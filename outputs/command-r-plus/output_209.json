{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_h, list2_h):\n    i, j = 0, 0\n    merged_list_h = []\n\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list_h.append(list1_h[i])\n            i += 1\n        else:\n            merged_list_h.append(list2_h[j])\n            j += 1\n\n    while i < len(list1_h):\n        merged_list_h.append(list1_h[i])\n        i += 1\n\n    while j < len(list2_h):\n        merged_list_h.append(list2_h[j])\n        j += 1\n\n    return merged_list_h"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    result_e = []\n    i, j = 0, 0\n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            result_e.append(list1_e[i])\n            i += 1\n        else:\n            result_e.append(list2_e[j])\n            j += 1\n    result_e.extend(list1_e[i:])\n    result_e.extend(list2_e[j:])\n    return result_e"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            merged_list.append(list1_e[i])\n            i += 1\n        else:\n            merged_list.append(list2_e[j])\n            j += 1\n    \n    while i < len(list1_e):\n        merged_list.append(list1_e[i])\n        i += 1\n    \n    while j < len(list2_e):\n        merged_list.append(list2_e[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        # Insert a new node with the given value into the binary tree\n        new_node = Node(value)\n        if not self.root:\n            self.root = new_node\n        else:\n            self._insert_node(value, self.root)\n\n    def _insert_node(self, value, node):\n        # Recursive helper function to insert a new node into the binary tree\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_node(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_node(value, node.right)\n\n    def delete(self, value):\n        # Delete a node with the given value from the binary tree\n        self.root = self._delete_node(self.root, value)\n\n    def _delete_node(self, node, value):\n        # Recursive helper function to delete a node from the binary tree\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_node(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_node(node.right, value)\n        else:\n            # Node found, handle three cases: no child, one child, or two children\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                # Node has two children, get the inorder successor (smallest in the right subtree)\n                successor = self._get_smallest(node.right)\n                node.value = successor.value\n                node.right = self._delete_node(node.right, successor.value)\n\n        return node\n\n    def _get_smallest(self, node):\n        # Recursive helper function to find the node with the smallest value in a subtree\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    result_f = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            result_f.append(list1_f[i])\n            i += 1\n        else:\n            result_f.append(list2_f[j])\n            j += 1\n    result_f.extend(list1_f[i:])\n    result_f.extend(list2_f[j:])\n    return result_f",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    # Method to add an edge\n    def add_edge(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def shortest_path_ud(self, src):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n        for _ in range(self.V):\n            min_val = float(\"Inf\")\n            min_idx = -1\n            for i in range(self.V):\n                if dist[i] != float(\"Inf\") and dist[i] < min_val:\n                    min_val = dist[i]\n                    min_idx = i\n            for j in range(self.V):\n                if self.graph[min_idx][j] != 0 and dist[min_idx] != float(\"Inf\") and dist[min_idx] + self.graph[min_idx][j] < dist[j]:\n                    dist[j] = dist[min_idx] + self.graph[min_idx][j]\n        return dist\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    assert all(isinstance(x, (int, float)) for x in list1_g), \"List1_g must contain only numbers.\"\n    assert all(isinstance(x, (int, float)) for x in list2_g), \"List2_g must contain only numbers.\"\n    assert all(\n        isinstance(x, type(list1_g[0])) for x in list1_g\n    ), \"List1_g elements must be of the same type.\"\n    assert all(\n        isinstance(x, type(list2_g[0])) for x in list2_g\n    ), \"List2_g elements must be of the same type.\"\n    assert len(list1_g) == len(set(list1_g)), \"List1_g must not contain duplicate elements.\"\n    assert len(list2_g) == len(set(list2_g)), \"List2_g must not contain duplicate elements.\"\n\n    merged_list_g = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list_g.append(list1_g[i])\n            i += 1\n        else:\n            merged_list_g.append(list2_g[j])\n            j += 1\n\n    merged_list_g.extend(list1_g[i:])\n    merged_list_g.extend(list2_g[j:])\n\n    return merged_list_g",
        "def avg_diag_element(matrix_g, num_rows_g, num_cols_g):\n    assert len(matrix_g) == num_rows_g and len(matrix_g[0]) == num_cols_g\n    assert all(len(row) == num_cols_g for row in matrix_g)\n\n    diag_sum = 0\n    num_diag_elements = 0\n\n    for i in range(min(num_rows_g, num_cols_g)):\n        diag_sum += matrix_g[i][i]\n        num_diag_elements += 1\n\n    assert num_diag_elements > 0\n    avg_diag = diag_sum / num_diag_elements\n\n    return avg_diag"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list",
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_dx_x(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        for i in range(self.V):\n            u = self._find_minimum_distance_node_x(dist, spt_set)\n            spt_set[u] = True\n            for v in range(self.V):\n                if (\n                    self.graph[u][v] > 0\n                    and spt_set[v] is False\n                    and dist[v] > dist[u] + self.graph[u][v]\n                ):\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        return dist[dest]\n\n    def _find_minimum_distance_node_x(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n\n        for u in range(self.V):\n            if spt_set[u] is False and dist[u] < min_dist:\n                min_dist = dist[u]\n                min_node = u\n\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_md(self, src, dest, parent):\n        visited = [False] * self.V\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        parent_a = [-1] * self.V\n        parent_a[src] = -1\n\n        for _ in range(self.V):\n            u = min(range(self.V), key=lambda i: distance[i])\n\n            visited[u] = True\n\n            for v in range(self.V):\n                if (\n                    self.graph[u][v] > 0\n                    and visited[v] is False\n                    and distance[v] > distance[u] + self.graph[u][v]\n                ):\n                    distance[v] = distance[u] + self.graph[u][v]\n                    parent_a[v] = u\n\n        j = dest\n        path = []\n        while parent_a[j] != -1:\n            path.append(j)\n            j = parent_a[j]\n        path.append(j)\n        path.reverse()\n        return distance[dest], path\n```",
        "def merge_sorted_lists_md(list1_a, list2_a):\n    result = []\n    i, j = 0, 0\n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            result.append(list1_a[i])\n            i += 1\n        else:\n            result.append(list2_a[j])\n            j += 1\n    result.extend(list1_a[i:])\n    result.extend(list2_a[j:])\n    return result"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node",
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    # Yuichi's updated naming convention for methods: end with '_b'\n    def dijkstra_b(self, source, destination):\n        dist = [float('inf')] * self.V\n        dist[source] = 0\n        spt = []\n\n        for _ in range(self.V):\n            # Choose the vertex with the minimum distance that is not in spt\n            min_dist_vertex = self._find_min_dist_vertex_b(dist, spt)\n\n            # Add the chosen vertex to the shortest path tree\n            spt.append(min_dist_vertex)\n\n            # Update the distance values of adjacent vertices\n            for vertex in range(self.V):\n                if self.graph[min_dist_vertex][vertex] != 0 and vertex not in spt:\n                    dist[vertex] = min(dist[vertex], dist[min_dist_vertex] + self.graph[min_dist_vertex][vertex])\n\n        # Return the shortest distance from source to destination\n        return dist[destination]\n\n    # Helper function to find the vertex with the minimum distance that is not in the SPT\n    def _find_min_dist_vertex_b(self, dist, spt):\n        min_dist = float('inf')\n        min_dist_vertex = -1\n        for vertex in range(self.V):\n            if dist[vertex] < min_dist and vertex not in spt:\n                min_dist = dist[vertex]\n                min_dist_vertex = vertex\n        return min_dist_vertex\n```",
        "```python\ndef merge_sorted_lists(list1_b, list2_b):\n    result_b = []\n    i_i, j_i = 0, 0\n\n    while i_i < len(list1_b) and j_i < len(list2_b):\n        if list1_b[i_i] < list2_b[j_i]:\n            result_b.append(list1_b[i_i])\n            i_i += 1\n        else:\n            result_b.append(list2_b[j_i])\n            j_i += 1\n\n    result_b.extend(list1_b[i_i:])\n    result_b.extend(list2_b[j_i:])\n\n    return result_b\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path",
        "def merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        path = [-1] * self.V\n\n        def dijkstra_x(src):\n            for _ in range(self.V):\n                u = min_distance_node_x(dist)\n                self.min_distance_update_x(u, dist)\n                self.min_node_update_x(u, path)\n\n            def min_distance_node_x(dist):\n                min_dist = float('inf')\n                min_node = -1\n                for v in range(self.V):\n                    if dist[v] < min_dist:\n                        min_dist = dist[v]\n                        min_node = v\n                return min_node\n\n            def min_distance_update_x(u, dist):\n                for v in self.graph[u]:\n                    if dist[v] > dist[u] + 1:\n                        dist[v] = dist[u] + 1\n\n            def min_node_update_x(u, path):\n                for v in self.graph[u]:\n                    if path[v] == -1 or dist[v] > dist[u] + 1:\n                        path[v] = u\n\n            return path[dest]\n\n        return dijkstra_x(src)\n```",
        "def merge_sorted_lists_o(list1_x, list2_x):\n    result_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            result_list.append(list1_x[i])\n            i += 1\n        else:\n            result_list.append(list2_x[j])\n            j += 1\n    result_list.extend(list1_x[i:])\n    result_list.extend(list2_x[j:])\n    return result_list"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path",
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": [
        "```python\ndef compute_diagonal_average(matrix_h: list[list[float]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a matrix.\n\n    Args:\n        matrix_h (list[list[float]]): The input matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    # Validate input\n    if not all(len(row) == len(matrix_h[0]) for row in matrix_h):\n        raise ValueError(\"Input matrix is not rectangular\")\n\n    # Calculate sum of diagonal elements\n    diag_sum_f = sum(matrix_h[i][i] for i in range(len(matrix_h)))\n\n    # Calculate average\n    diag_avg_f = diag_sum_f / len(matrix_h)\n\n    return diag_avg_f\n```",
        "```python\ndef merge_sorted_lists(list1_h, list2_h):\n    result_f = []\n    i_f = j_f = 0\n\n    while i_f < len(list1_h) and j_f < len(list2_h):\n        if list1_h[i_f] < list2_h[j_f]:\n            result_f.append(list1_h[i_f])\n            i_f += 1\n        else:\n            result_f.append(list2_h[j_f])\n            j_f += 1\n\n    result_f.extend(list1_h[i_f:])\n    result_f.extend(list2_h[j_f:])\n    assert result_f == sorted(result_f)\n    return result_f\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    def __init__(self, value_i):\n        self.value = value_i\n        self.left = None\n        self.right = None\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path(self, source, destination):\n        dist = [float('inf') for _ in range(self.V)]\n        dist[source] = 0\n        spt_set = [False] * self.V\n\n        # Create a min heap to get shortest distance vertex\n        # in constant time.\n        pq = [[dist[source], source]]\n        heapq.heapify(pq)\n\n        while pq:\n            # The first vertex in pair will be minimum distance vertex\n            # so we pop that vertex and do the process for its adjacent vertices.\n            d, u = heapq.heappop(pq)\n\n            # If the extracted minimum distance vertex is the same as the destination\n            # vertex, then break the loop as the required distance is found.\n            if u == destination:\n                break\n\n            # Explore the adjacent vertices of the extracted vertex only if\n            # that distance is less than the distance explored already for that vertex.\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and dist[v] > dist[u] + self.graph[u][v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n                    heapq.heappush(pq, [dist[v], v])\n\n        # If the destination vertex is not reachable from the source vertex\n        if dist[destination] == float('inf'):\n            return float('inf')\n        else:\n            return dist[destination]\n```"
      ]
    }
  ]
}