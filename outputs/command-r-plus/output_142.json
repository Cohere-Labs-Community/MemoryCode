{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.r_head = None\n        self.r_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        r_value = self.cache[key]\n        self._remove(key)\n        self._add(key, r_value)\n        return r_value\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self._remove(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict()\n        self._add(key, value)\n\n    def _remove(self, key: int) -> None:\n        r_node = self.cache[key]\n        if r_node is self.r_head:\n            self.r_head = r_node.chx\n        if r_node is self.r_tail:\n            self.r_tail = r_node.chx.r_prev\n        r_node.chx.r_prev = r_node.chx.r_prev.chx\n        r_node.chx.r_next = r_node.chx.r_next.chx\n\n    def _add(self, key: int, value: int) -> None:\n        r_new_node = _Node(key, value)\n        if self.r_tail:\n            self.r_head = _Node(self.r_head.key, self.r_head.value, r_prev=r_new_node, chx=self.r_tail)\n        else:\n            self.r_head = r_new_node\n        if self.r_tail:\n            self.r_tail.chx = _Node(r_new_node.key, r_new_node.value, r_prev=self.r_tail, chx=r_new_node)\n        self.r_tail = r_new_node\n        self.cache[key] = r_new_node\n\n    def _evict(self) -> None:\n        evicted_key = self.r_tail.key\n        del self.cache[evicted_key]\n        self.r_tail = self.r_tail.chx\n\n    def display(self):\n        r_curr = self.r_head\n        while r_curr:\n            print(f\"Key: {r_curr.key}, Value: {r_curr.value}\")\n            r_curr = r_curr.chx\n\nclass _Node:\n    def __init__(self, key: int, value: int, r_prev: '_Node' = None, r_next: '_Node' = None):\n        self.key = key\n        self.value = value\n        self.r_prev = r_prev\n        self.r_next = r_next\n        self.chx = None\n```",
        "```python\ndef compute_dot_product(r_vec1: list[float], r_vec2: list[float]) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    :param r_vec1: The first vector.\n    :param r_vec2: The second vector.\n    :return: The dot product of r_vec1 and r_vec2.\n    \"\"\"\n    chx_dot_product = sum(x * y for x, y in zip(r_vec1, r_vec2))\n    return chx_dot_product\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```",
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def int_to_roman(num):\n    \"\"\"\n    Converts an integer to a Roman numeral.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    i = 0\n    \n    while num > 0:\n        # Find the largest value that is less than or equal to the current number\n        while num >= values[i]:\n            num -= values[i]\n            roman += symbols[i]\n        i += 1\n    \n    return roman\n```"
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n    \"\"\"\n\n    def __init__(self, n_neighbors=5):\n        \"\"\"\n        Initialize the NearestNeighbors classifier.\n\n        Parameters\n        ----------\n        n_neighbors : int, default=5\n            Number of neighbors to use for prediction.\n        \"\"\"\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the NearestNeighbors model.\n\n        Parameters\n        ----------\n        X_train : array-like, shape (n_samples, n_features)\n            Training data.\n\n        y_train : array-like, shape (n_samples,)\n            Target values.\n        \"\"\"\n        assert isinstance(X_train, (list, np.ndarray)), \"X_train must be a list or numpy array.\"\n        assert isinstance(y_train, (list, np.ndarray)), \"y_train must be a list or numpy array.\"\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples.\"\n\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict the target values for the provided test data.\n\n        Parameters\n        ----------\n        X_test : array-like, shape (n_samples, n_features)\n            Test data.\n\n        Returns\n        -------\n        y_pred : array-like, shape (n_samples,)\n            Predicted target values.\n        \"\"\"\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet.\"\n        assert isinstance(X_test, (list, np.ndarray)), \"X_test must be a list or numpy array.\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"X_test must have the same number of features as the training data.\"\n\n        distances = cdist(X_test, self.X_train)\n        indices = distances.argsort()[:, :self.n_neighbors]\n        neighbors = self.y_train[indices]\n        y_pred = []\n\n        for i in range(neighbors.shape[0]):\n            unique, counts = np.unique(neighbors[i], return_counts=True)\n            y_pred.append(unique[np.argmax(counts)])\n\n        return np.array(y_pred)"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "cumulative_model_output": [
        "```python\nimport numpy as np\n\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        self.r_n_neighbors = n_neighbors\n        self.chx_training_data = None\n        self.chx_training_labels = None\n\n    def train(self, chx_training_data, chx_training_labels):\n        self.chx_training_data = chx_training_data\n        self.chx_training_labels = chx_training_labels\n\n    def predict(self, chx_test_data):\n        assert self.chx_training_data is not None, \"Model has not been trained yet.\"\n        assert self.chx_training_labels is not None, \"Model has not been trained yet.\"\n        assert chx_test_data.shape[1] == self.chx_training_data.shape[1], \"Test data must have the same number of features as training data.\"\n\n        distances = np.sqrt(np.sum(np.power(chx_test_data[:, np.newaxis, :] - self.chx_training_data, 2), axis=2))\n        predictions = [np.argsort(distance)[:, :self.r_n_neighbors] for distance in distances]\n        return predictions\n```",
        "```python\ndef dot_product(vec1: list[float], vec2: list[float]) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    Args:\n        vec1 (list[float]): The first vector.\n        vec2 (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of vec1 and vec2.\n    \"\"\"\n    # Ensure both vectors have the same dimension\n    assert len(vec1) == len(vec2), \"Vectors must have the same dimension for dot product.\"\n\n    # Initialize the dot product variable with r_ prefix\n    r_dot_product = 0.0\n\n    # Iterate through the vectors and compute the dot product\n    for i in range(len(vec1)):\n        r_dot_product += vec1[i] * vec2[i]\n\n    return r_dot_product\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to its equivalent Roman numeral representation.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The Roman numeral representation of the input integer.\n    \"\"\"\n    # Initializing dictionary with attribute names following the convention\n    r_roman_mapping = {\n        1000: \"M\",\n        900: \"CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n        90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\"\n    }\n\n    chx_roman_numerals = \"\"\n    for r_value, r_roman in r_roman_mapping.items():\n        # Using a while loop to handle cases like 499, 99, etc.\n        while num >= r_value:\n            num -= r_value\n            chx_roman_numerals += r_roman\n\n    return chx_roman_numerals\n```",
        "```python\nimport functools\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.chx_order = []\n\n    @functools.wraps(dict.get)\n    def get(self, key: int) -> int:\n        r_value = self.cache.get(key)\n        if r_value is not None:\n            self.chx_order.remove(key)\n            self.chx_order.append(key)\n        return r_value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.chx_order.remove(key)\n        elif len(self.cache) >= self.capacity:\n            r_oldest = self.chx_order.pop(0)\n            del self.cache[r_oldest]\n        self.chx_order.append(key)\n        self.cache[key] = value\n```"
      ]
    }
  ]
}