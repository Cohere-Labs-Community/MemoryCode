{
  "sessions": [
    {
      "session_model_output": [
        "class BinaryTree:\n    \"\"\"\n    A binary tree data structure.\n\n    Attributes:\n        root (Node): The root node of the binary tree.\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"\n        Insert a new node with the given value into the binary tree.\n\n        Args:\n            value (int or float): The value to be inserted into the binary tree.\n        \"\"\"\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        \"\"\"\n        Recursive helper function for inserting a value into the binary tree.\n\n        Args:\n            value (int or float): The value to be inserted.\n            node (Node): The current node in the recursive traversal.\n        \"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_delete(value, node.right)\n\n    def delete(self, value):\n        \"\"\"\n        Delete the first node with the given value from the binary tree.\n\n        Args:\n            value (int or float): The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive(value, self.root)\n\n    def _delete_recursive(self, value, node):\n        \"\"\"\n        Recursive helper function for deleting a node with the given value.\n\n        Args:\n            value (int or float): The value of the node to be deleted.\n            node (Node): The current node in the recursive traversal.\n\n        Returns:\n            Node: The new root of the subtree or None if the subtree is empty.\n        \"\"\"\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete_recursive(value, node.left)\n        elif value > node.value:\n            node.right = self._delete_recursive(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.value, node.right)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        \"\"\"\n        Recursive helper function to find the inorder successor (smallest value in the right subtree).\n\n        Args:\n            node (Node): The current node in the recursive traversal.\n\n        Returns:\n            int or float: The value of the inorder successor.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass Node:\n    \"\"\"\n    A node in the binary tree.\n\n    Attributes:\n        value (int or float): The value stored in the node.\n        left (Node): The left child of the node.\n        right (Node): The right child of the node.\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_fn(list1_i, list2_i):\n    i, j = 0, 0\n    merged_list_i = []\n\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list_i.append(list1_i[i])\n            i += 1\n        else:\n            merged_list_i.append(list2_i[j])\n            j += 1\n\n    merged_list_i.extend(list1_i[i:])\n    merged_list_i.extend(list2_i[j:])\n\n    return merged_list_i\n```",
        "```python\ndef merge_sort_fn(arr_i, comp_fn=lambda x, y: x < y):\n    if len(arr_i) <= 1:\n        return arr_i\n\n    mid_i = len(arr_i) // 2\n    left_i = arr_i[:mid_i]\n    right_i = arr_i[mid_i:]\n\n    left_i = merge_sort_fn(left_i, comp_fn)\n    right_i = merge_sort_fn(right_i, comp_fn)\n\n    return merge_fn(left_i, right_i, comp_fn)\n\ndef merge_fn(left_i, right_i, comp_fn):\n    merged_i = []\n    left_idx_i = right_idx_i = 0\n    len_left_i, len_right_i = len(left_i), len(right_i)\n\n    while left_idx_i < len_left_i and right_idx_i < len_right_i:\n        if comp_fn(left_i[left_idx_i], right_i[right_idx_i]):\n            merged_i.append(left_i[left_idx_i])\n            left_idx_i += 1\n        else:\n            merged_i.append(right_i[right_idx_i])\n            right_idx_i += 1\n\n    merged_i.extend(left_i[left_idx_i:])\n    merged_i.extend(right_i[right_idx_i:])\n\n    return merged_i\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list",
        "```python\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_a():\n    def merge(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        return merge_chx(merge_chx(left, right))\n\n    def merge_chx(left, right):\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    data = []\n    for i in range(10):\n        data.append(random.randint(0, 100))\n\n    sorted_data = merge(data)\n    return sorted_data",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._heapify_a(len(self.heap) - 1)\n\n    def _heapify_a(self, index):\n        chx_index = index\n        while True:\n            parent_index = (chx_index - 1) // 2\n            if parent_index == chx_index or self.heap[chx_index] >= self.heap[parent_index]:\n                break\n            self.heap[chx_index], self.heap[parent_index] = self.heap[parent_index], self.heap[chx_index]\n            chx_index = parent_index"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_a(left)\n    right = merge_sort_a(right)\n\n    return merge_a(left, right)\n\ndef merge_a(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_gn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_gn(left)\n    right = merge_sort_gn(right)\n\n    return merge_gn(left, right)\n\ndef merge_gn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_gn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_gn(left_half)\n    right_half = merge_sort_gn(right_half)\n\n    return merge_gn(left_half, right_half)\n\ndef merge_gn(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_h: list[int], list2_h: list[int]) -> list[int]:\n    merged_list_h = []\n    i, j = 0, 0\n\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list_h.append(list1_h[i])\n            i += 1\n        else:\n            merged_list_h.append(list2_h[j])\n            j += 1\n\n    while i < len(list1_h):\n        merged_list_h.append(list1_h[i])\n        i += 1\n\n    while j < len(list2_h):\n        merged_list_h.append(list2_h[j])\n        j += 1\n\n    return merged_list_h"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        list1_g (list): The first sorted list.\n        list2_g (list): The second sorted list.\n\n    Returns:\n        list: A single sorted list containing all elements from both input lists.\n    \"\"\"\n    merged_list_g = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list_g.append(list1_g[i])\n            i += 1\n        else:\n            merged_list_g.append(list2_g[j])\n            j += 1\n\n    merged_list_g.extend(list1_g[i:])\n    merged_list_g.extend(list2_g[j:])\n\n    return merged_list_g",
        "def find_longest_common_prefix(strings_g: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string among a list of input strings.\n\n    Args:\n        strings_g (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strings_g:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strings_g.sort()\n\n    # Get the first and last string in the sorted list\n    first_str_g, last_str_g = strings_g[0], strings_g[-1]\n\n    # Find the common prefix by comparing characters until a mismatch is found\n    common_prefix_g = \"\"\n    for char_g in first_str_g:\n        if char_g == last_str_g[len(common_prefix_g)]:\n            common_prefix_g += char_g\n        else:\n            break\n\n    return common_prefix_g"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Parameters:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' for the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n\n    # Return the kth element from the sorted array\n    return sorted_arr[k-1]"
      ],
      "instruction_model_output": [
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_c(arr_a):\n    if len(arr_a) <= 1:\n        return arr_a\n\n    mid_a = len(arr_a) // 2\n    left_a = arr_a[:mid_a]\n    right_a = arr_a[mid_a:]\n\n    left_a = merge_sort_c(left_a)\n    right_a = merge_sort_c(right_a)\n\n    return merge_c(left_a, right_a)\n\ndef merge_c(left_a, right_a):\n    result_a = []\n    left_index_a, right_index_a = 0, 0\n\n    while left_index_a < len(left_a) and right_index_a < len(right_a):\n        if left_a[left_index_a] < right_a[right_index_a]:\n            result_a.append(left_a[left_index_a])\n            left_index_a += 1\n        else:\n            result_a.append(right_a[right_index_a])\n            right_index_a += 1\n\n    result_a.extend(left_a[left_index_a:])\n    result_a.extend(right_a[right_index_a:])\n\n    return result_a",
        "def merge_sorted_lists_c(list1_a, list2_a):\n    result_l = []\n    i, j = 0, 0\n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            result_l.append(list1_a[i])\n            i += 1\n        else:\n            result_l.append(list2_a[j])\n            j += 1\n    result_l.extend(list1_a[i:])\n    result_l.extend(list2_a[j:])\n    return result_l"
      ],
      "instruction_model_output": [
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_c(left)\n    right = merge_sort_c(right)\n\n    return merge_c(left, right)\n\ndef merge_c(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists_d(list1_f, list2_f):\n    result_l = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            result_l.append(list1_f[i])\n            i += 1\n        else:\n            result_l.append(list2_f[j])\n            j += 1\n    result_l.extend(list1_f[i:])\n    result_l.extend(list2_f[j:])\n    return result_l",
        "def merge_sort_d(arr_d):\n    if len(arr_d) <= 1:\n        return arr_d\n\n    mid_i = len(arr_d) // 2\n    left_d = arr_d[:mid_i]\n    right_d = arr_d[mid_i:]\n\n    left_d = merge_sort_d(left_d)\n    right_d = merge_sort_d(right_d)\n\n    return merge_d(left_d, right_d)\n\ndef merge_d(left_d, right_d):\n    result_d = []\n    left_idx_d, right_idx_d = 0, 0\n\n    while left_idx_d < len(left_d) and right_idx_d < len(right_d):\n        if left_d[left_idx_d] < right_d[right_idx_d]:\n            result_d.append(left_d[left_idx_d])\n            left_idx_d += 1\n        else:\n            result_d.append(right_d[right_idx_d])\n            right_idx_d += 1\n\n    result_d.extend(left_d[left_idx_d:])\n    result_d.extend(right_d[right_idx_d:])\n\n    return result_d"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list",
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n    \n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_j, list2_j):\n    result_j = []\n    i, j = 0, 0\n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            result_j.append(list1_j[i])\n            i += 1\n        else:\n            result_j.append(list2_j[j])\n            j += 1\n    result_j.extend(list1_j[i:])\n    result_j.extend(list2_j[j:])\n    return result_j"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_j, list2_j):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            merged_list.append(list1_j[i])\n            i += 1\n        else:\n            merged_list.append(list2_j[j])\n            j += 1\n    \n    while i < len(list1_j):\n        merged_list.append(list1_j[i])\n        i += 1\n    \n    while j < len(list2_j):\n        merged_list.append(list2_j[j])\n        j += 1\n    \n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_b(arr_x):\n    if len(arr_x) <= 1:\n        return arr_x\n\n    mid_x = len(arr_x) // 2\n    left_x = arr_x[:mid_x]\n    right_x = arr_x[mid_x:]\n\n    left_x = merge_sort_b(left_x)\n    right_x = merge_sort_b(right_x)\n\n    return merge_b(left_x, right_x)\n\ndef merge_b(left_x, right_x):\n    result_x = []\n    left_idx_x, right_idx_x = 0, 0\n\n    while left_idx_x < len(left_x) and right_idx_x < len(right_x):\n        if left_x[left_idx_x] < right_x[right_idx_x]:\n            result_x.append(left_x[left_idx_x])\n            left_idx_x += 1\n        else:\n            result_x.append(right_x[right_idx_x])\n            right_idx_x += 1\n\n    result_x.extend(left_x[left_idx_x:])\n    result_x.extend(right_x[right_idx_x:])\n\n    return result_x",
        "def merge_sorted_lists_b(list1_x, list2_x):\n    result_x = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            result_x.append(list1_x[i])\n            i += 1\n        else:\n            result_x.append(list2_x[j])\n            j += 1\n    result_x.extend(list1_x[i:])\n    result_x.extend(list2_x[j:])\n    return result_x"
      ],
      "instruction_model_output": [
        "def merge_sort_b(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort_b(left_half)\n    right_half = merge_sort_b(right_half)\n    \n    return merge_b(left_half, right_half)\n\ndef merge_b(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n    \n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n    \n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n    \n    return result",
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    result_e = []\n    i, j = 0, 0\n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            result_e.append(list1_e[i])\n            i += 1\n        else:\n            result_e.append(list2_e[j])\n            j += 1\n    result_e.extend(list1_e[i:])\n    result_e.extend(list2_e[j:])\n    return result_e"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            merged_list.append(list1_e[i])\n            i += 1\n        else:\n            merged_list.append(list2_e[j])\n            j += 1\n    \n    while i < len(list1_e):\n        merged_list.append(list1_e[i])\n        i += 1\n    \n    while j < len(list2_e):\n        merged_list.append(list2_e[j])\n        j += 1\n    \n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_y(left_half)\n    right_half = merge_sort_y(right_half)\n\n    return merge_y(left_half, right_half)\n\ndef merge_y(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(a_vec1, a_vec2):\n    return sum(x * y for x, y in zip(a_vec1, a_vec2))"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(a * b for a, b in zip(a_vec1, a_vec2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(v1: List[float], v2: List[float]) -> float:\n    \"\"\"Compute the dot product of two vectors.\n\n    Args:\n        v1 (List[float]): The first vector.\n        v2 (List[float]): The second vector.\n\n    Returns:\n        float: The dot product of v1 and v2.\n    \"\"\"\n    h_sum_i = 0.0\n    for h_i, h_j in zip(v1, v2):\n        h_sum_i += h_i * h_j\n    return h_sum_i",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def insert_at_beginning(self, data_i):\n        new_node_i = Node(data_i)\n        new_node_i.next_i = self.head_i\n        self.head_i = new_node_i\n\n    def insert_at_end(self, data_i):\n        if self.head_i is None:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i is not None:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete_node(self, key_i):\n        if self.head_i is None:\n            return\n        if self.head_i.data_i == key_i:\n            self.head_i = self.head_i.next_i\n            return\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n        while curr_i is not None:\n            if curr_i.data_i == key_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i is not None:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(h_vec1, h_vec2):\n    return sum(a * b for a, b in zip(h_vec1, h_vec2))\n```",
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i is None:\n            return\n\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n\n        while curr_i:\n            if curr_i.data_i == data_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def add_node(self, data_r):\n        new_node_r = Node(data_r)\n        if self.head_r is None:\n            self.head_r = new_node_r\n        else:\n            current_r = self.head_r\n            while current_r.next_r:\n                current_r = current_r.next_r\n            current_r.next_r = new_node_r\n\n    def remove_node(self, data_r):\n        if self.head_r is None:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        prev_r = None\n        while current_r and current_r.data_r != data_r:\n            prev_r = current_r\n            current_r = current_r.next_r\n        if current_r is None:\n            return\n        prev_r.next_r = current_r.next_r\n\n    def display(self):\n        current_r = self.head_r\n        while current_r:\n            print(current_r.data_r, end=\" -> \")\n            current_r = current_r.next_r\n        print(\"None\")\n\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n```",
        "```python\ndef compute_dot_product(e_vector1_r, e_vector2_r):\n    dot_product_r = sum(x * y for x, y in zip(e_vector1_r, e_vector2_r))\n    return dot_product_r\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```",
        "```python\ndef dot_product(e_vector1, e_vector2):\n    return sum(a * b for a, b in zip(e_vector1, e_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def c_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "@pedantic.validate\ndef c_int_to_roman(num: int) -> str:\n    \"\"\"Convert an integer to a Roman numeral.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The corresponding Roman numeral.\n    \"\"\"\n    roman_numerals = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\")\n    ]\n    result = \"\"\n    for value, symbol in roman_numerals:\n        count = num // value\n        result += symbol * count\n        num %= value\n    return result"
      ],
      "instruction_model_output": [
        "def c_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "from pedantic.decorators import validate\r\n\r\n@validate\r\ndef int_to_roman(num: int) -> str:\r\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\r\n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n    roman_num = ''\r\n    i = 0\r\n    while num > 0:\r\n        for _ in range(num // val[i]):\r\n            roman_num += syb[i]\r\n            num -= val[i]\r\n        i += 1\r\n    return roman_num"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(i_vec1, i_vec2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param i_vec1: The first vector.\n    :param i_vec2: The second vector.\n    :return: The dot product of i_vec1 and i_vec2.\n    \"\"\"\n    sum_dot_product = 0\n    for i_idx in range(len(i_vec1)):\n        sum_dot_product += i_vec1[i_idx] * i_vec2[i_idx]\n    return sum_dot_product\n```",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n\n    def insert_i_node(self, data_i):\n        i_node = Node(data_i)\n        i_node.next_at = self.head_at\n        self.head_at = i_node\n\n    def delete_i_node(self, data_i):\n        current_at = self.head_at\n        prev_at = None\n        while current_at is not None:\n            if current_at.data_at == data_i:\n                if prev_at is None:\n                    self.head_at = current_at.next_at\n                else:\n                    prev_at.next_at = current_at.next_at\n                return\n            prev_at = current_at\n            current_at = current_at.next_at\n\n    def display(self):\n        current_at = self.head_at\n        while current_at:\n            print(current_at.data_at, end=' ')\n            current_at = current_at.next_at\n        print()\n\nclass Node:\n    def __init__(self, data_i):\n        self.data_at = data_i\n        self.next_at = None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    return sum(a * b for a, b in zip(i_vec1, i_vec2))\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_at = data\n        self.next_at = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n        self.tail_at = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_at:\n            self.head_at = new_node\n            self.tail_at = self.head_at\n        else:\n            self.tail_at.next_at = new_node\n            self.tail_at = new_node\n\n    def delete(self, data):\n        if self.head_at is None:\n            return\n\n        if self.head_at.data_at == data:\n            self.head_at = self.head_at.next_at\n            return\n\n        prev_node = self.head_at\n        curr_node = self.head_at.next_at\n        while curr_node:\n            if curr_node.data_at == data:\n                prev_node.next_at = curr_node.next_at\n                return\n            prev_node = curr_node\n            curr_node = curr_node.next_at\n\n    def display(self):\n        current = self.head_at\n        while current:\n            print(current.data_at, end=\" -> \")\n            current = current.next_at\n        print(\"None\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete_recursive(value, self.root)\n\n    def _delete_recursive(self, value: int, node: Optional[Node]) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete_recursive(value, node.left)\n        elif value > node.value:\n            node.right = self._delete_recursive(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.value, node.right)\n\n        return node\n\n    def _get_inorder_successor(self, node: Node) -> int:\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(j_vec1, j_vec2):\n    j_result = 0\n    for i in range(len(j_vec1)):\n        j_result += j_vec1[i] * j_vec2[i]\n    return j_result"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(j_vector_1, j_vector_2):\n    return sum(a * b for a, b in zip(j_vector_1, j_vector_2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Linked_List_s:\n    def __init__(self):\n        self.head_s = None\n\n    def append_s(self, value_s):\n        if not self.head_s:\n            self.head_s = Node_s(value_s)\n        else:\n            current_s = self.head_s\n            while current_s.next_s:\n                current_s = current_s.next_s\n            current_s.next_s = Node_s(value_s)\n\n    def size_s(self):\n        current_s = self.head_s\n        count_s = 0\n        while current_s:\n            count_s += 1\n            current_s = current_s.next_s\n        return count_s\n\n    def search_s(self, value_f_s):\n        current_s = self.head_s\n        while current_s:\n            if current_s.value_s == value_f_s:\n                return True\n            current_s = current_s.next_s\n        return False\n\n    def remove_s(self, value_f_s):\n        if not self.head_s:\n            return\n        if self.head_s.value_s == value_f_s:\n            self.head_s = self.head_s.next_s\n            return\n        prev_s = self.head_s\n        current_s = self.head_s.next_s\n        while current_s:\n            if current_s.value_s == value_f_s:\n                prev_s.next_s = current_s.next_s\n                return\n            prev_s = current_s\n            current_s = current_s.next_s\n\n    class Node_s:\n        def __init__(self, value_s):\n            self.value_s = value_s\n            self.next_s = None",
        "def dot_product(vec1_s, vec2_s):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param vec1_s: The first vector.\n    :param vec2_s: The second vector.\n    :return: The dot product of vec1_s and vec2_s.\n    \"\"\"\n    result_s = 0\n    for i in range(len(vec1_s)):\n        result_s += vec1_s[i] * vec2_s[i]\n    return result_s"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node_s = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_node_s = None\n        self.tail_node_s = None\n        self.size_s = 0\n\n    def append(self, data):\n        new_node_s = Node(data)\n        if not self.head_node_s:\n            self.head_node_s = new_node_s\n            self.tail_node_s = self.head_node_s\n        else:\n            current_node_s = self.head_node_s\n            while current_node_s.next_node_s:\n                current_node_s = current_node_s.next_node_s\n            current_node_s.next_node_s = new_node_s\n            self.tail_node_s = new_node_s\n        self.size_s += 1\n\n    def delete(self, data):\n        current_node_s = self.head_node_s\n        prev_node_s = None\n        while current_node_s and current_node_s.data == data:\n            prev_node_s = current_node_s\n            current_node_s = current_node_s.next_node_s\n        if prev_node_s:\n            prev_node_s.next_node_s = current_node_s.next_node_s\n            if current_node_s == self.tail_node_s:\n                self.tail_node_s = prev_node_s\n            self.size_s -= 1\n\n    def display(self):\n        current_node_s = self.head_node_s\n        while current_node_s:\n            print(current_node_s.data, end=\" -> \")\n            current_node_s = current_node_s.next_node_s\n        print(\"None\")\n```",
        "```python\ndef dot_product(f_vector1, f_vector2):\n    return sum(a * b for a, b in zip(f_vector1, f_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def insert(self, value_i):\n        self.heap.append(value_i)\n        self._heapify_up(len(self.heap) - 1)\n\n    def _heapify_up(self, i):\n        parent_i = self.parent(i)\n        while i > 0 and self.heap[i] > self.heap[parent_i]:\n            self._swap(i, parent_i)\n            i = parent_i\n            parent_i = self.parent(i)\n\n    def _heapify_down(self, i):\n        min_child = i\n\n        left_child_i = self.left_child(i)\n        if left_child_i < len(self.heap) and self.heap[left_child_i] < self.heap[min_child]:\n            min_child = left_child_i\n\n        right_child_i = self.right_child(i)\n        if right_child_i < len(self.heap) and self.heap[right_child_i] < self.heap[min_child]:\n            min_child = right_child_i\n\n        if min_child != i:\n            self._swap(i, min_child)\n            self._heapify_down(min_child)\n\n    def heapify(self):\n        last_non_leaf = (len(self.heap) - 2) // 2\n        for i in reversed(range(last_non_leaf + 1)):\n            self._heapify_down(i)\n\n    def delete_min(self):\n        if not self.heap:\n            return None\n\n        min_value = self.heap[0]\n        self.heap[0] = self.heap.pop(-1)\n        self._heapify_down(0)\n        return min_value\n\n    def delete(self, value_to_delete):\n        for i in range(len(self.heap)):\n            if self.heap[i] == value_to_delete:\n                value_to_delete_i = i\n                break\n\n        self.heap[value_to_delete_i] = self.heap.pop(-1)\n        self._heapify_down(value_to_delete_i)\n        self._heapify_up(value_to_delete_i)\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n```",
        "```python\ndef dot_product_fn(vector_1_i: list[float], vector_2_i: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector_1_i (list[float]): A list of floating-point numbers representing the first vector.\n        vector_2_i (list[float]): A list of floating-point numbers representing the second vector.\n\n    Returns:\n        float: The dot product of the two input vectors.\n    \"\"\"\n    # Validate input lengths\n    if len(vector_1_i) != len(vector_2_i):\n        raise ValueError(\"Input vectors must have the same length.\")\n\n    # Calculate the dot product\n    dot_product_value_j = 0.0\n    for i in range(len(vector_1_i)):\n        dot_product_value_j += vector_1_i[i] * vector_2_i[i]\n\n    return dot_product_value_j\n```",
        "```python\ndef kth_largest_element(arr, k):\n    \"\"\"\n    Returns the kth largest element in the input array.\n\n    Args:\n        arr (list): A list of elements.\n        k (int): An integer indicating the kth largest element to be returned.\n\n    Returns:\n        float or int: The kth largest element in the array.\n    \"\"\"\n    # Validate input\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k <= 0 or k > len(arr):\n        raise ValueError(\"k must be a positive integer less than or equal to the length of the array\")\n\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the kth element\n    return arr[k-1]\n```",
        "```python\ndef merge_sorted_lists(list1_i: list[int], list2_i: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        list1_i (list[int]): The first sorted list.\n        list2_i (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing the merged elements.\n    \"\"\"\n    merged_list_i = []\n    i_i = j_i = 0\n\n    while i_i < len(list1_i) and j_i < len(list2_i):\n        if list1_i[i_i] < list2_i[j_i]:\n            merged_list_i.append(list1_i[i_i])\n            i_i += 1\n        else:\n            merged_list_i.append(list2_i[j_i])\n            j_i += 1\n\n    merged_list_i += list1_i[i_i:]\n    merged_list_i += list2_i[j_i:]\n\n    return merged_list_i\n```",
        "```python\nclass LinkedList:\n    \"\"\"\n    Represents a singly linked list.\n\n    ...\n\n    Attributes:\n        head: Node or None, the first node in the linked list.\n        tail: Node or None, the last node in the linked list.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes an empty linked list.\n\n        \"\"\"\n        self.head = None\n        self.tail = None\n\n    def push(self, value_i: int) -> None:\n        \"\"\"\n        Adds a new node with the given value to the end of the linked list.\n\n        Args:\n            value_i (int): The value to be added to the linked list.\n\n        \"\"\"\n        new_node = Node(value_i)\n        if not self.head:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes and returns the value of the last node in the linked list.\n\n        Returns:\n            int: The value of the removed node.\n\n        Raises:\n            ValueError: If the linked list is empty.\n\n        \"\"\"\n        if not self.head:\n            raise ValueError(\"Linked list is empty.\")\n        elif self.head == self.tail:\n            removed_value = self.head.value\n            self.head = None\n            self.tail = None\n        else:\n            removed_value = self.tail.value\n            current = self.head\n            while current.next != self.tail:\n                current = current.next\n            current.next = None\n            self.tail = current\n        return removed_value\n\n    def shift(self) -> int:\n        \"\"\"\n        Removes and returns the value of the first node in the linked list.\n\n        Returns:\n            int: The value of the removed node.\n\n        Raises:\n            ValueError: If the linked list is empty.\n\n        \"\"\"\n        if not self.head:\n            raise ValueError(\"Linked list is empty.\")\n        elif self.head == self.tail:\n            removed_value = self.head.value\n            self.head = None\n            self.tail = None\n        else:\n            removed_value = self.head.value\n            self.head = self.head.next\n        return removed_value\n\n    def append(self, value_i: int) -> None:\n        \"\"\"\n        Adds a new node with the given value to the beginning of the linked list.\n\n        Args:\n            value_i (int): The value to be added to the linked list.\n\n        \"\"\"\n        new_node = Node(value_i)\n        new_node.next = self.head\n        self.head = new_node\n\n    def get(self, index_i: int) -> int:\n        \"\"\"\n        Returns the value of the node at the given index.\n\n        Args:\n            index_i (int): The index of the node to retrieve.\n\n        Returns:\n            int: The value of the node at the given index.\n\n        Raises:\n            IndexError: If the index is out of range.\n\n        \"\"\"\n        current = self.head\n        for _ in range(index_i):\n            if current is None:\n                raise IndexError(\"Index out of range.\")\n            current = current.next\n        return current.value\n\n    def insert(self, index_i: int, value_i: int) -> None:\n        \"\"\"\n        Inserts a new node with the given value at the given index in the linked list.\n\n        Args:\n            index_i (int): The index at which to insert the new node.\n            value_i (int): The value to be inserted into the linked list.\n\n        Raises:\n            IndexError: If the index is out of range.\n\n        \"\"\"\n        if index_i == 0:\n            self.append(value_i)\n        elif index_i == self.length() - 1:\n            self.push(value_i)\n        else:\n            current = self.head\n            for _ in range(index_i - 1):\n                if current is None:\n                    raise IndexError(\"Index out of range.\")\n                current = current.next\n            new_node = Node(value_i)\n            new_node.next = current.next\n            current.next = new_node\n\n    def delete(self, index_i: int) -> int:\n        \"\"\"\n        Deletes the node at the given index and returns its value.\n\n        Args:\n            index_i (int): The index of the node to be deleted.\n\n        Returns:\n            int: The value of the deleted node.\n\n        Raises:\n            IndexError: If the index is out of range.\n\n        \"\"\"\n        if index_i == 0:\n            return self.shift()\n        elif index_i == self.length() - 1:\n            return self.pop()\n        else:\n            current = self.head\n            for _ in range(index_i - 1):\n                if current is None:\n                    raise IndexError(\"Index out of range.\")\n                current = current.next\n            removed_value = current.next.value\n            current.next = current.next.next\n        return removed_value\n\n    def length(self) -> int:\n        \"\"\"\n        Returns the number of nodes in the linked list.\n\n        Returns:\n            int: The length of the linked list.\n\n        \"\"\"\n        current = self.head\n        length_i = 0\n        while current:\n            length_i += 1\n            current = current.next\n        return length_i\n\nclass Node:\n    \"\"\"\n    Represents a single node in the linked list.\n\n    ...\n\n    Attributes:\n        value: int, the value stored in the node.\n        next: Node or None, the next node in the linked list.\n\n    \"\"\"\n\n    def __init__(self, value_i: int):\n        \"\"\"\n        Initializes a new node with the given value.\n\n        Args:\n            value_i (int): The value to be stored in the node.\n\n        \"\"\"\n        self.value = value_i\n        self.next = None\n```",
        "```python\ndef merge_sort_fn(arr_i: list[int]) -> list[int]:\n    \"\"\"\n    Sort a list of integers using the merge sort algorithm.\n\n    Args:\n        arr_i (list[int]): A list of integers to be sorted.\n\n    Returns:\n        list[int]: The sorted list of integers.\n    \"\"\"\n    # Base case: if the list has 0 or 1 elements, it is already sorted\n    if len(arr_i) <= 1:\n        return arr_i\n\n    # Divide the list into two halves\n    mid_i = len(arr_i) // 2\n    left_half_i = arr_i[:mid_i]\n    right_half_i = arr_i[mid_i:]\n\n    # Recursively sort each half\n    left_half_sorted_i = merge_sort_fn(left_half_i)\n    right_half_sorted_i = merge_sort_fn(right_half_i)\n\n    # Merge the sorted halves\n    merged_arr_i = []\n    left_idx_i = right_idx_i = 0\n\n    while left_idx_i < len(left_half_sorted_i) and right_idx_i < len(right_half_sorted_i):\n        if left_half_sorted_i[left_idx_i] < right_half_sorted_i[right_idx_i]:\n            merged_arr_i.append(left_half_sorted_i[left_idx_i])\n            left_idx_i += 1\n        else:\n            merged_arr_i.append(right_half_sorted_i[right_idx_i])\n            right_idx_i += 1\n\n    # Append any remaining elements\n    merged_arr_i.extend(left_half_sorted_i[left_idx_i:])\n    merged_arr_i.extend(right_half_sorted_i[right_idx_i:])\n\n    return merged_arr_i\n```",
        "class TreeNode:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    def insert(self, value: int) -> None:\n        if value < self.value:\n            if self.left is None:\n                self.left = TreeNode(value)\n            else:\n                self.left.insert(value)\n        else:\n            if self.right is None:\n                self.right = TreeNode(value)\n            else:\n                self.right.insert(value)\n\n    def delete(self, value: int) -> None:\n        if value < self.value:\n            if self.left is not None:\n                self.left.delete(value)\n        elif value > self.value:\n            if self.right is not None:\n                self.right.delete(value)\n        else:\n            if self.left is not None and self.right is not None:\n                self.value = self.right.find_min_value()\n                self.right.delete(self.value)\n            elif self.left is not None:\n                self.value = self.left.find_max_value()\n                self.left.delete(self.value)\n            elif self.right is not None:\n                self.value = self.right.find_min_value()\n                self.right.delete(self.value)\n            else:\n                self.value = None\n\n    def find_min_value(self) -> int:\n        current = self\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n    def find_max_value(self) -> int:\n        current = self\n        while current.right is not None:\n            current = current.right\n        return current.value",
        "```python\ndef h_index_fn(citations_i: list[int]) -> int:\n    \"\"\"Computes the h-index of the given citations.\n\n    Args:\n        citations_i (list[int]): A list of integer citations.\n\n    Returns:\n        int: The h-index value.\n    \"\"\"\n    citations_i.sort(reverse=True)\n    h_index_i = 0\n    for i, citation_i in enumerate(citations_i, 1):\n        if citation_i < i:\n            h_index_i = i\n            break\n    return h_index_i\n```",
        "def int_to_roman(num: int) -> str:\n    \"\"\"\n    Convert an integer to Roman numerals.\n\n    :param num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    roman_numerals = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\n    roman_str = \"\"\n    for numeral, value in roman_numerals.items():\n        while num >= value:\n            roman_str += numeral\n            num -= value\n    return roman_str",
        "```python\ndef longest_common_prefix(strings: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strings (list[str]): A list of strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    # Sort the list of strings to ensure consistent results\n    strings.sort()\n\n    # Initialize variables for the common prefix\n    common_prefix = \"\"\n    common_prefix_length = float(\"inf\")\n\n    # Iterate through the characters of the first and last strings\n    for i in range(len(strings[0])):\n        if i < len(strings[-1]) and strings[0][i] == strings[-1][i]:\n            common_prefix += strings[0][i]\n        else:\n            common_prefix_length = i\n            break\n\n    # Return the common prefix string\n    return common_prefix[:common_prefix_length]\n```"
      ]
    }
  ]
}