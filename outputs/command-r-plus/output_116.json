{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def a_is_valid_sudoku(m_board):\n    m_seen = set()\n    for m_i in range(9):\n        m_seen = set()\n        for m_j in range(9):\n            if m_board[m_i][m_j] != '.':\n                if m_board[m_i][m_j] in m_seen:\n                    return False\n                m_seen.add(m_board[m_i][m_j])\n        m_seen = set()\n        for m_num in range(1, 10):\n            if m_num in m_seen:\n                continue\n            is_row_valid = all(m_board[m_i][m_k] == '.' or m_board[m_i][m_k] == m_num for m_k in range(9))\n            is_col_valid = all(m_board[m_k][m_j] == '.' or m_board[m_k][m_j] == m_num for m_k in range(9))\n            if is_row_valid and is_col_valid:\n                return False\n        for m_i in range(0, 9, 3):\n            for m_j in range(0, 9, 3):\n                m_box = [m_board[m_p][m_q] for m_p in range(m_i, m_i + 3) for m q in range(m_j, m_j + 3)]\n                if m_num not in m_box and not '.' in m_box:\n                    return False\n    return True",
        "class Inventory:\n    def __init__(self):\n        self.m_stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self.m_stock:\n            self.m_stock[item] += quantity\n        else:\n            self.m_stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self.m_stock and self.m_stock[item] >= quantity:\n            self.m_stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    m_seen = set()\n    for m_i in range(9):\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_i][m_j] != '.':\n                if board[m_i][m_j] in m_seen:\n                    return False\n                m_seen.add(board[m_i][m_j])\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_j][m_i] != '.':\n                if board[m_j][m_i] in m_seen:\n                    return False\n                m_seen.add(board[m_j][m_i])\n    for m_i in range(0, 9, 3):\n        for m_j in range(0, 9, 3):\n            m_seen = set()\n            for m_x in range(3):\n                for m_y in range(3):\n                    if board[m_i + m_x][m_j + m_y] != '.':\n                        if board[m_i + m_x][m_j + m_y] in m_seen:\n                            return False\n                        m_seen.add(board[m_i + m_x][m_j + m_y]])\n    return True",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def o_is_valid_sudoku(wr_board):\n    wr_rows = set()\n    wr_cols = set()\n    wr_boxes = set()\n    for wr_i in range(9):\n        wr_rows.clear()\n        wr_cols.clear()\n        wr_boxes.clear()\n        for wr_j in range(9):\n            wr_num = wr_board[wr_i][wr_j]\n            if wr_num != '.':\n                wr_num = int(wr_num)\n                wr_row = wr_rows.get(wr_num, []) + [wr_i]\n                wr_rows[wr_num] = wr_row\n                wr_col = wr_cols.get(wr_num, []) + [wr_j]\n                wr_cols[wr_num] = wr_col\n                wr_box = wr_boxes.get(wr_num, []) + [wr_i // 3, wr_j // 3]\n                wr_boxes[wr_num] = wr_box\n                if len(wr_row) > 1 or len(wr_col) > 1 or len(wr_box) > 1:\n                    return False\n    return True",
        "class Inventory:\n    def __init__(self):\n        self.wr_stock = {}\n\n    def o_add_stock(self, wr_item, wr_quantity):\n        if wr_item in self.wr_stock:\n            self.wr_stock[wr_item] += wr_quantity\n        else:\n            self.wr_stock[wr_item] = wr_quantity\n\n    def o_remove_stock(self, wr_item, wr_quantity):\n        if wr_item in self.wr_stock and self.wr_stock[wr_item] >= wr_quantity:\n            self.wr_stock[wr_item] -= wr_quantity\n        else:\n            print(\"Insufficient stock to remove that quantity.\")"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    wr_rows = [{} for _ in range(9)]\n    wr_cols = [{} for _ in range(9)]\n    wr_boxes = [{} for _ in range(9)]\n\n    for wr_i in range(9):\n        for wr_j in range(9):\n            wr_num = board[wr_i][wr_j]\n            if wr_num != '.':\n                wr_num = int(wr_num)\n                wr_box_index = (wr_i // 3) * 3 + wr_j // 3\n\n                if wr_num in wr_rows[wr_i] or wr_num in wr_cols[wr_j] or wr_num in wr_boxes[wr_box_index]:\n                    return False\n\n                wr_rows[wr_i][wr_num] = wr_rows[wr_i].get(wr_num, 0) + 1\n                wr_cols[wr_j][wr_num] = wr_cols[wr_j].get(wr_num, 0) + 1\n                wr_boxes[wr_box_index][wr_num] = wr_boxes[wr_box_index].get(wr_num, 0) + 1\n\n    return True",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board: list[list[int]]) -> bool:\n    \"\"\"\n    Checks if the given 9x9 sudoku board is valid.\n\n    A valid sudoku board has each digit from 1 to 9 exactly once in every row, column,\n    and in each of the nine 3x3 sub-boxes.\n\n    Args:\n        board (list[list[int]]): The sudoku board to be validated.\n\n    Returns:\n        bool: True if the board is valid, False otherwise.\n    \"\"\"\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != 0:\n                vr_num_str = str(vr_num)\n\n                # Check rows, cols, and boxes\n                vr_row_set = vr_rows[vr_i]\n                vr_col_set = vr_cols[vr_j]\n                vr_box_index = (vr_i // 3) * 3 + vr_j // 3\n                vr_box_set = vr_boxes[vr_box_index]\n\n                if vr_num_str in vr_row_set or vr_num_str in vr_col_set or vr_num_str in vr_box_set:\n                    return False\n\n                vr_row_set.add(vr_num_str)\n                vr_col_set.add(vr_num_str)\n                vr_box_set.add(vr_num_str)\n                vr_seen.add(vr_num_str)\n\n    return len(vr_seen) == 9 * len(board)\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with 'vr_' prefix and docstrings\n    def vr_insert(self, value):\n        \"\"\"\n        Insert a node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n        \"\"\"\n        self.root = self._vr_insert_recursive(self.root, value)\n\n    def _vr_insert_recursive(self, node, value):\n        if not node:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._vr_insert_recursive(node.left, value)\n        else:\n            node.right = self._vr_insert_recursive(node.right, value)\n        return node\n\n    # Delete node method with 'vr_' prefix and docstrings\n    def vr_delete(self, value):\n        \"\"\"\n        Delete the first node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted from the binary tree.\n        \"\"\"\n        self.root = self._vr_delete_recursive(self.root, value)\n\n    def _vr_delete_recursive(self, node, value):\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self._vr_delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._vr_delete_recursive(node.right, value)\n        else:\n            if not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n            node.value = self._vr_get_min_value(node.right)\n            node.right = self._vr_delete_recursive(node.right, node.value)\n        return node\n\n    def _vr_get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True",
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion method\n    def a_insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    # Deletion method\n    def a_delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _find_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass BinaryTreeNode:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "```python\ndef a_is_valid_sudoku(board: list[list[str]]) -> bool:\n    \"\"\"\n    Checks if the given 9x9 2D string list is a valid Sudoku board.\n\n    Args:\n        board (list[list[str]]): The Sudoku board to be validated.\n\n    Returns:\n        bool: True if the board is a valid Sudoku, False otherwise.\n    \"\"\"\n    # Step 1: Check rows\n    for row in board:\n        if not m_is_valid_set(row):\n            return False\n\n    # Step 2: Check columns\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if not m_is_valid_set(column):\n            return False\n\n    # Step 3: Check 3x3 subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [board[row][col] for row in range(i, i + 3) for col in range(j, j + 3)]\n            if not m_is_valid_set(subgrid):\n                return False\n\n    return True\n\n\ndef m_is_valid_set(items: list[str]) -> bool:\n    \"\"\"\n    Checks if the given list of items contains only valid digits and no duplicates.\n\n    Args:\n        items (list[str]): The list of items to be validated.\n\n    Returns:\n        bool: True if the list contains only digits 1-9 with no duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in items:\n        if not item.isdigit() or not 1 <= int(item) <= 9:\n            return False\n        if item in seen:\n            return False\n        seen.add(item)\n    return True\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.m_stock = {}\n\n    def a_add_stock(self, wr_product, vr_quantity):\n        self.m_stock[wr_product] = self.m_stock.get(wr_product, 0) + vr_quantity\n\n    def a_remove_stock(self, wr_product, vr_quantity):\n        if self.m_stock.get(wr_product, 0) < vr_quantity:\n            print(\"Insufficient stock\")\n            return\n        self.m_stock[wr_product] -= vr_quantity\n```"
      ]
    }
  ]
}