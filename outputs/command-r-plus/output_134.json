{
  "sessions": [
    {
      "session_model_output": [
        "```python\nfrom locale import *\n\ndef lcm_calculator(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the least common multiple of two integers.\n    \n    :param a: The first integer.\n    :param b: The second integer.\n    :return: The least common multiple of a and b.\n    \"\"\"\n    assert isinstance(a, int) and isinstance(b, int), \"Both inputs must be integers\"\n    assert a > 0 and b > 0, \"Input integers must be positive\"\n\n    def gcd(a: int, b: int) -> int:\n        \"\"\"\n        Calculate the greatest common divisor using Euclid's algorithm.\n        \"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n\n    lcm = a * b // gcd(a, b)\n    assert lcm == abs(lcm), \"Resulting LCM must be positive\"\n    return lcm\n```",
        "```python\nfrom locale import *\n\ndef average_diagonal(matrix):\n    assert isinstance(matrix, list), \"Input must be a list\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows must be lists\"\n    assert all(len(row) == len(matrix) for row in matrix), \"Matrix must be square\"\n    \n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)\n```"
      ],
      "instruction_model_output": [
        "import locale\n\ndef lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    return a * b // gcd(a, b)",
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome_wr(s: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n    \n    :param s: The input string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    assert isinstance(s, str), \"Input must be a string.\"\n    # End variable names with '_wr' as per Sophie's convention\n    cleaned_s_wr = s.lower().replace(\" \", \"\")_wr\n    assert all(char.isalpha() for char in cleaned_s_wr), \"Only alphabetic characters are allowed.\"\n\n    # Check if the string is a palindrome\n    return cleaned_s_wr == cleaned_s_wr[::-1]",
        "class NearestNeighborsModel:\n    \"\"\"\n    A Nearest Neighbors Model for training and prediction.\n    ...\n\n    Attributes\n    ----------\n    X_train_wr : numpy array\n        The training data set.\n    y_train_wr : numpy array\n        The corresponding target values for the training data.\n    metric_wr : str, default='euclidean'\n        The distance metric used to calculate distance between instances in the feature space.\n    p_wr : int, default=2\n        The power parameter for the Minkowski metric. When p = 1, this is equivalent to using Manhattan distance.\n    \"\"\"\n\n    def __init__(self, metric_wr='euclidean', p_wr=2):\n        self.X_train_wr = None\n        self.y_train_wr = None\n        self.metric_wr = metric_wr\n        self.p_wr = p_wr\n\n    def train(self, X_train_wr, y_train_wr):\n        \"\"\"\n        Train the Nearest Neighbors Model.\n\n        Parameters\n        ----------\n        X_train_wr : numpy array\n            The training data set.\n        y_train_wr : numpy array\n            The corresponding target values for the training data.\n        \"\"\"\n        assert X_train_wr.shape[0] == y_train_wr.shape[0], \"Number of training samples must match number of target values.\"\n        self.X_train_wr = X_train_wr\n        self.y_train_wr = y_train_wr\n\n    def predict(self, X_test_wr):\n        \"\"\"\n        Predict the target values for the test data set.\n\n        Parameters\n        ----------\n        X_test_wr : numpy array\n            The test data set.\n\n        Returns\n        -------\n        numpy array\n            The predicted target values for the test data set.\n        \"\"\"\n        assert self.X_train_wr is not None, \"Model has not been trained yet. Please call the train method before prediction.\"\n        assert X_test_wr.shape[1] == self.X_train_wr.shape[1], \"Number of features in test data must match that of training data.\"\n\n        import numpy as np\n        from sklearn.neighbors import NearestNeighbors\n\n        # Fit the Nearest Neighbors model\n        neigh = NearestNeighbors(n_neighbors=1, metric=self.metric_wr, p=self.p_wr)\n        neigh.fit(self.X_train_wr)\n\n        # Predict the target values for the test data\n        distances, indices = neigh.kneighbors(X_test_wr, n_neighbors=1)\n        predicted_labels = np.array([self.y_train_wr[i[0]] for i in indices])\n\n        return predicted_labels"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_wr):\n    s_wr = s_wr.lower()\n    return s_wr == s_wr[::-1]",
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class BinaryTree:\n    \"\"\"\n    A binary tree data structure.\n\n    Attributes:\n        root (Node): The root node of the binary tree.\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"\n        Insert a new node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n        \"\"\"\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        \"\"\"\n        Delete the first node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted from the binary tree.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                successor = self._find_min(node.right)\n                node.value = successor.value\n                node.right = self._delete_recursive(node.right, successor.value)\n        return node\n\n    def _find_min(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n\nclass Node:\n    \"\"\"\n    A node in the binary tree.\n\n    Attributes:\n        value: The value stored in the node.\n        left (Node): The left child of the node.\n        right (Node): The right child of the node.\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nfrom locale import locale\n\ndef average_diagonal_element(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    # Validate input\n    assert isinstance(matrix, list), \"Input must be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows must be lists.\"\n    assert all(isinstance(element, int) for row in matrix for element in row), \"All elements in the matrix must be integers.\"\n    assert len(matrix) == len(matrix[0]), \"Input must be a square matrix.\"\n\n    # Initialize sum and count\n    sum_diag = 0\n    count = 0\n\n    # Iterate through the matrix\n    for i in range(len(matrix)):\n        assert len(matrix[i]) == len(matrix), \"Matrix is not square.\"\n        try:\n            sum_diag += matrix[i][i]\n            count += 1\n        except IndexError:\n            raise IndexError(\"Invalid matrix dimensions.\")\n\n    # Calculate and return the average\n    return sum_diag / count\n```",
        "```python\nfrom locale import *\n\nclass Node:\n    def __init__(self, value_wr: int) -> None:\n        self.value_wr = value_wr\n        self.left_wr = None\n        self.right_wr = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root_wr = None\n\n    def insert(self, value_wr: int) -> None:\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        new_node_wr = Node(value_wr)\n        if not self.root_wr:\n            self.root_wr = new_node_wr\n        else:\n            self._insert_node(value_wr, self.root_wr)\n        assert new_node_wr.value_wr in self\n\n    def _insert_node(self, value_wr: int, node_wr: Node) -> None:\n        if value_wr < node_wr.value_wr:\n            if node_wr.left_wr:\n                self._insert_node(value_wr, node_wr.left_wr)\n            else:\n                node_wr.left_wr = Node(value_wr)\n        else:\n            if node_wr.right_wr:\n                self._insert_node(value_wr, node_wr.right_wr)\n            else:\n                node_wr.right_wr = Node(value_wr)\n\n    def delete(self, value_wr: int) -> None:\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root_wr = self._delete_node(value_wr, self.root_wr)\n        assert value_wr not in self\n\n    def _delete_node(self, value_wr: int, node_wr: Node) -> Node:\n        if node_wr is None:\n            return node_wr\n\n        if value_wr < node_wr.value_wr:\n            node_wr.left_wr = self._delete_node(value_wr, node_wr.left_wr)\n        elif value_wr > node_wr.value_wr:\n            node_wr.right_wr = self._delete_node(value_wr, node_wr.right_wr)\n        else:\n            if node_wr.left_wr is None:\n                return node_wr.right_wr\n            elif node_wr.right_wr is None:\n                return node_wr.left_wr\n\n            node_wr.value_wr = self._get_min_value(node_wr.right_wr)\n            node_wr.right_wr = self._delete_node(node_wr.value_wr, node_wr.right_wr)\n\n        return node_wr\n\n    def _get_min_value(self, node_wr: Node) -> int:\n        current_wr = node_wr\n        while current_wr.left_wr is not None:\n            current_wr = current_wr.left_wr\n        return current_wr.value_wr\n\n    def __contains__(self, value_wr: int) -> bool:\n        return self._contains_node(value_wr, self.root_wr)\n\n    def _contains_node(self, value_wr: int, node_wr: Node) -> bool:\n        if node_wr is None:\n            return False\n        if value_wr == node_wr.value_wr:\n            return True\n        if value_wr < node_wr.value_wr:\n            return self._contains_node(value_wr, node_wr.left_wr)\n        return self._contains_node(value_wr, node_wr.right_wr)\n\n    def __str__(self) -> str:\n        return str(self.root_wr)\n```",
        "```python\nfrom locale import *\n\ndef lcm_calculation(num1_wr: int, num2_wr: int) -> int:\n    \"\"\"\n    This function calculates the least common multiple of two integers.\n    \n    :param num1_wr: The first integer\n    :param num2_wr: The second integer\n    :return: The least common multiple of num1_wr and num2_wr\n    \"\"\"\n    assert isinstance(num1_wr, int) and isinstance(num2_wr, int), \"Both inputs must be integers\"\n    assert num1_wr >= 0 and num2_wr >= 0, \"Input numbers must be non-negative\"\n    \n    def gcd(a_wr: int, b_wr: int) -> int:\n        \"\"\"\n        Helper function to calculate the greatest common divisor using the Euclidean algorithm.\n        \"\"\"\n        while b_wr != 0:\n            a_wr, b_wr = b_wr, a_wr % b_wr\n        return a_wr\n    \n    lcm_wr = abs(num1_wr * num2_wr) // gcd(num1_wr, num2_wr)\n    return lcm_wr\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nimport locale\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self._model = None\n        self._is_fitted = False\n        locale.setlocale(locale.LC_ALL, '')\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training samples must match\"\n        self._model = KNeighborsClassifier(n_neighbors=self.n_neighbors)\n        self._model.fit(X_train, y_train)\n        self._is_fitted = True\n\n    def predict(self, X_test):\n        assert self._is_fitted, \"Model has not been trained yet\"\n        assert X_test.shape[1] == self._model.n_features_in_, \"Number of features must match during prediction\"\n        return self._model.predict(X_test)\n```",
        "```python\nfrom locale import getpreferredencoding\n\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string is a palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Validate input\n    assert isinstance(input_string, str), \"Input must be a string.\"\n    assert input_string, \"Input string can't be empty.\"\n    assert len(input_string) == len(input_string.encode(getpreferredencoding())), \"Input string should only contain ASCII characters.\"\n\n    # Convert to lowercase and remove spaces\n    sanitized_string = input_string.lower().replace(\" \", \"\")\n    \n    # Check if palindrome\n    return sanitized_string == sanitized_string[::-1]\n```"
      ]
    }
  ]
}