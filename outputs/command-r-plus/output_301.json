{
  "sessions": [
    {
      "session_model_output": [
        "def count_non_zero_elements(matrix):\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count"
      ],
      "instruction_model_output": [
        "def count_non_zero(matrix):\n    count = 0\n    for row in matrix:\n        count += sum(1 for elem in row if elem != 0)\n    return count"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n\n    ...\n\n    Attributes\n    ----------\n    X_train : ndarray or DataFrame of shape (n_samples, n_features)\n        The training data.\n\n    y_train : ndarray or Series of shape (n_samples,)\n        The target labels for the training data.\n\n    metric : str or callable, default='minkowski'\n        The distance metric to use for calculating the distance between instances in a dataset.\n        For a list of available metrics, see the documentation for `scipy.spatial.distance.pdist`.\n\n    p : int, default=2\n        Power parameter for the Minkowski metric. When p = 1, this is equivalent to using Manhattan distance, and\n        Euclidean distance for p = 2. For arbitrary p, Minkowski distance (L_p) is used.\n\n    method : {'auto', 'brute', 'kd_tree', 'ball_tree'}, default='auto'\n        Algorithm used to compute the nearest neighbors:\n\n        - 'ball_tree' will use :class:`BallTree`\n        - 'kd_tree' will use :class:`KDTree`\n        - 'brute' will use a brute-force search.\n        - 'auto' will attempt to decide the most appropriate algorithm based on the values passed to\n          :meth:`fit` method.\n\n        Note: fitting on sparse input will override the setting of this parameter, using brute force.\n\n    leaf_size : int, default=30\n        Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well\n        as the memory required to store the tree. The optimal value depends on the nature of the problem.\n\n    metric_params : dict, optional\n        Additional keyword arguments for the metric function.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        metric=\"minkowski\",\n        p=2,\n        method=\"auto\",\n        leaf_size=30,\n        metric_params=None,\n    ):\n        self.metric = metric\n        self.p = p\n        self.method = method\n        self.leaf_size = leaf_size\n        self.metric_params = metric_params\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert isinstance(X_train, (np.ndarray, pd.DataFrame))\n        assert isinstance(y_train, (np.ndarray, pd.Series))\n        assert len(X_train) == len(\n            y_train\n        ), \"X_train and y_train must have the same number of samples.\"\n        self.X_train = X_train\n        self.y_partum = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None, \"Model has not been trained yet.\"\n        assert isinstance(X_test, (np.ndarray, pd.DataFrame))\n        assert X_test.shape[1] == self.X_train.shape[\n            1\n        ], \"X_test must have the same number of features as the training data.\"\n        distances = cdist(X_test, self.X_train, metric=self.metric, p=self.p)\n        return self.y_train[np.argmin(distances, axis=1)]"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome_n(s_n: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n    \n    Args:\n        s_n (str): The input string to be checked.\n        \n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Remove spaces and convert to lowercase\n    cleaned_s_n = ''.join(filter(str.isalnum, s_n)).lower()\n    \n    # Compare the original and reversed string\n    return cleaned_s_n == cleaned_s_n[::-1]"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_n):\n    s_n = s_n.lower()\n    return s_n == s_n[::-1]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class BinaryTree:\n    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.left = None\n            self.right = None\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        # Insert a node with the given value into the binary tree\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if not node:\n            return self.Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        # Delete a node with the given value from the binary tree\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            # Case 1: Node has no children or only one child\n            if not node.left and not node.right:\n                node = None\n            elif not node.left:\n                node = node.right\n            elif not node.right:\n                node = node.left\n            # Case 2: Node has two children\n            else:\n                successor = self._find_min(node.right)\n                node.value = successor.value\n                node.right = self._delete_recursive(node.right, successor.value)\n        return node\n\n    def _find_min(self, node):\n        # Find the node with the minimum value in a subtree\n        current = node\n        while current.left:\n            current = current.left\n        return current"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_y(arr):\n    \"\"\"\n    Sorts the input array in ascending order using the merge sort algorithm.\n\n    Args:\n        arr (list): The array of integers to be sorted.\n\n    Returns:\n        list: The sorted array.\n    \"\"\"\n    # Base case: An array of 0 or 1 elements is already sorted\n    if len(arr) <= 1:\n        return arr\n\n    # Divide the array into two halves\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort each half\n    left_half = merge_sort_y(left_half)\n    right_half = merge_sort_y(right_half)\n\n    # Merge the sorted halves\n    return merge_y(left_half, right_half)\n\ndef merge_y(left, right):\n    \"\"\"\n    Merges two sorted arrays into a single sorted array.\n\n    Args:\n        left (list): A sorted array.\n        right (list): Another sorted array.\n\n    Returns:\n        list: A single sorted array containing elements from both inputs.\n    \"\"\"\n    result = []\n    left_index, right_index = 0, 0\n\n    # Merge the two halves by comparing their elements\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    # Add remaining elements (if any) from both halves\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n\n    return result\n```",
        "```python\ndef integer_to_roman_y(num):\n    \"\"\"\n    Convert an integer to its Roman numeral representation.\n\n    :param num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    i = 0\n\n    while num > 0:\n        for _ in range(num // values[i]):\n            roman += symbols[i]\n            num -= values[i]\n        i += 1\n\n    return roman\n```"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.coef_3 = None\n        self.intercept_7 = None\n\n    def fit(self, X, y):\n        X_1 = np.c_[np.ones(shape=X.shape[0]), X]\n        beta_2 = np.linalg.inv(X_1.T @ X_1) @ X_1.T @ y\n        self.coef_3 = beta_2[1:]\n        self.intercept_7 = beta_2[0]\n\n    def predict(self, X):\n        X_with_bias_4 = np.c_[np.ones(shape=X.shape[0]), X]\n        return X_with_bias_4 @ self.coef_3 + self.intercept_7\n```"
      ],
      "instruction_model_output": [
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion method with docstrings and single-digit naming convention\n    def 1insert(self, value):\n        \"\"\"\n        Insert a value into the binary tree.\n\n        Args:\n            value: The value to be inserted.\n\n        Returns:\n            None\n        \"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value, node):\n        \"\"\"\n        Private helper method for insertion.\n\n        Args:\n            value: The value to be inserted.\n            node: The current node in the tree.\n\n        Returns:\n            None\n        \"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    # Deletion method with docstrings and single-digit naming convention\n    def 2delete(self, value):\n        \"\"\"\n        Delete a node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted.\n\n        Returns:\n            None\n        \"\"\"\n        self.root = self._delete(value, self.root)\n\n    def _delete(self, value, node):\n        \"\"\"\n        Private helper method for deletion.\n\n        Args:\n            value: The value of the node to be deleted.\n            node: The current node in the tree.\n\n        Returns:\n            The modified node or None if the value is not found.\n        \"\"\"\n        if node is None:\n            return node\n\n        # Recursive case: search in left and right subtrees\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            # Node with only one child or no child\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: get the inorder successor (smallest in the right subtree)\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete(node.value, node.right)\n\n        return node\n\n    def _get_min_value(self, node):\n        \"\"\"\n        Private helper method to find the minimum value in a subtree.\n\n        Args:\n            node: The root of the subtree.\n\n        Returns:\n            The minimum value in the subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nclass DirectedGraph:\n    \"\"\"\n    A directed graph class to represent a finite graph structure.\n\n    ...\n\n    Attributes:\n        vertices: A list to store the vertices of the graph.\n        adjacency_list: A dictionary to represent the adjacency list of the graph.\n                        Keys are vertices, values are lists of adjacent vertices.\n\n    Methods:\n        add_vertex(vertex): Adds a vertex to the graph.\n        add_edge(vertex1, vertex2): Adds a directed edge from vertex1 to vertex2.\n        has_cycle(): Checks if the directed graph contains a cycle. Returns True if a cycle is found, False otherwise.\n    \"\"\"\n\n    def __init__(self):\n        self.vertices = []\n        self.adjacency_list = {}\n\n    def add_vertex(self, vertex):\n        \"\"\"\n        Adds a vertex to the graph.\n\n        Args:\n            vertex: The label of the vertex to be added.\n        \"\"\"\n        if vertex not in self.vertices:\n            self.vertices.append(vertex)\n            self.adjacency_list[vertex] = []\n\n    def add_edge(self, vertex1, vertex2):\n        \"\"\"\n        Adds a directed edge from vertex1 to vertex2.\n\n        Args:\n            vertex1: The starting vertex of the edge.\n            vertex2: The ending vertex of the edge.\n        \"\"\"\n        if vertex1 not in self.vertices:\n            raise ValueError(f\"{vertex1} is not a valid vertex.\")\n        if vertex2 not in self.vertices:\n            raise ValueError(f\"{vertex2} is not a valid vertex.\")\n        if vertex2 not in self.adjacency_list[vertex1]:\n            self.adjacency_list[vertex1].append(vertex2)\n\n    def _is_cyclic_util(self, vertex, visited, rec_stack):\n        \"\"\"\n        Helper function for has_cycle method.\n        Uses depth-first search to detect cycles in the directed graph.\n\n        Args:\n            vertex: The current vertex being visited.\n            visited: A set containing vertices that have been visited.\n            rec_stack: A set containing vertices that are in the current recursion stack.\n\n        Returns:\n            True if a cycle is found, False otherwise.\n        \"\"\"\n        visited.add(vertex)\n        rec_stack.add(vertex)\n        for neighbour in self.adjacency_list[vertex]:\n            if neighbour not in visited and self._is_cyclic_util(neighbour, visited, rec_stack):\n                return True\n            elif neighbour in rec_stack:\n                return True\n        rec_stack.remove(vertex)\n        return False\n\n    def has_cycle(self):\n        \"\"\"\n        Checks if the directed graph contains a cycle.\n\n        Returns:\n            True if a cycle is found, False otherwise.\n        \"\"\"\n        visited = set()\n        rec_stack = set()\n        for vertex in self.vertices:\n            if vertex not in visited:\n                if self._is_cyclic_util(vertex, visited, rec_stack):\n                    return True\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(vertices)]\n\n    def add_edge1(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic9(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    sanitized_string = ''.join(char.lower() for char in input_string if char.isalnum())\n    return sanitized_string == sanitized_string[::-1]",
        "```python\ndef find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' for the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the element at index 'k-1' as Python is zero-indexed\n    return arr[k - 1]\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_w):\n    s_w = s_w.lower()\n    return s_w == s_w[::-1]",
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Graph:\n    def shortest_path_a(self, start, end, matrix):\n        distances = [float('inf')] * len(matrix)\n        distances[start] = 0\n        path = []\n\n        while any(node != end for node in path):\n            path.append(end)\n            for i in range(len(matrix)):\n                if matrix[end][i] != float('inf') and distances[i] > distances[end] + matrix[end][i]:\n                    distances[i] = distances[end] + matrix[end][i]\n                    end = i\n        return distances[end], path"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def find_common_elements1(list1, list2):\n    common_elements = []\n    for i in list1:\n        if i in list2:\n            common_elements.append(i)\n    return common_elements"
      ],
      "instruction_model_output": [
        "def get_common_elements(list1_1, list2_2):\n    return list(set(list1_1) & set(list2_2))"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(w_board):\n    \"\"\"\n    Checks if a given 2D array represents a valid Sudoku board.\n\n    Args:\n        w_board (list): A 2D array representing a Sudoku board.\n\n    Returns:\n        bool: True if the board is valid, False otherwise.\n    \"\"\"\n    w_seen = set()\n    for w_i in range(9):\n        w_row = set()\n        w_col = set()\n        for w_j in range(9):\n            w_num = w_board[w_i][w_j]\n            if w_num != '.':\n                if w_num in w_row or w_num in w_col or (w_num, (w_i // 3, w_j // 3)) in w_seen:\n                    return False\n                w_row.add(w_num)\n                w_col.add(w_num)\n                w_seen.add((w_num, (w_i // 3, w_j // 3)))\n    return True",
        "def w_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Parameters:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for str in strs[1:]:\n            if i == len(str) or str[i] != strs[0][i]:\n                return strs[0][:i]\n    return strs[0]"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                if w_board[w_i][w_j] in w_seen:\n                    return False\n                w_seen.add(w_board[w_i][w_j])\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_j][w_i] != '.':\n                if w_board[w_j][w_i] in w_seen:\n                    return False\n                w_seen.add(w_board[w_j][w_i])\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_seen = set()\n            for w_x in range(w_i, w_i + 3):\n                for w_y in range(w_j, w_j + 3):\n                    if w_board[w_x][w_y] != '.':\n                        if w_board[w_x][w_y] in w_seen:\n                            return False\n                        w_seen.add(w_board[w_x][w_y])\n    return True",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class PCA0:\n    def __init__(self, data, components=2):\n        self.data = data\n        self.components = components\n        self.chx_mean = None\n        self.chx_cov = None\n        self.chx_eigenvalues = None\n        self.chx_eigenvectors = None\n\n    def fit(self):\n        self.chx_mean = self.data.mean(axis=0)\n        self.data = self.data - self.chx_mean\n        self.chx_cov = np.cov(self.data.T)\n        self.chx_eigenvalues, self.chx_eigenvectors = np.linalg.eig(self.chx_cov)\n\n        # Sort eigenvalues and eigenvectors in descending order\n        indices = np.argsort(self.chx_eigenvalues)[::-1]\n        self.chx_eigenvalues = self.chx_eigenvalues[indices]\n        self.chx_eigenvectors = self.chx_eigenvectors[:, indices]\n\n        # Select top k eigenvalues and eigenvectors\n        self.chx_eigenvalues = self.chx_eigenvalues[:self.components]\n        self.chx_eigenvectors = self.chx_eigenvectors[:, :self.components]\n\n    def transform(self, data=None):\n        if data is None:\n            data = self.data\n\n        transformed = data @ self.chx_eigenvectors\n\n        return transformed",
        "def sum_unique_elements(numbers):\n    unique_nums = list(dict.fromkeys(numbers))\n    sum_unique = sum(i for i in unique_nums if 'chx' in str(i))\n    return sum_unique"
      ],
      "instruction_model_output": [
        "class PCA0:\n    def __init__(self, n_components=0):\n        self.n_components = n_components\n\n    def fit_transform(self, X):\n        X_centered = X - X.mean(axis=0)\n        covariance = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eig(covariance)\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n        components = eigenvectors[:, :self.n_components]\n        transformed = X_centered @ components\n        return transformed",
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.x_songs = []\n\n    @retry\n    def add_song(self, song):\n        self.x_songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.x_songs.remove(song)\n```",
        "```python\nfrom pedantic import retry\n\n\n@retry\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    \"\"\"\n    Checks if the given 9x9 sudoku board is valid.\n\n    :param board: The sudoku board.\n    :return: True if the board is a valid sudoku, False otherwise.\n    \"\"\"\n\n    # Check row and column constraints\n    for i in range(9):\n        row = set()\n        col = set()\n        for j in range(9):\n            if board[i][j] in row or board[j][i] in col:\n                return False\n            row.add(board[i][j])\n            col.add(board[j][i])\n\n    # Check 3x3 subgrid constraints\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] in subgrid:\n                        return False\n                    subgrid.add(board[x][y])\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "from pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)",
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def check_palindrome(input_str: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n\n    :param input_str: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    input_str = input_str.lower()\n    start_y0 = 0\n    end_y0 = len(input_str) - 1\n\n    while start_y0 < end_y0:\n        if input_str[start_y0] != input_str[end_y0]:\n            return False\n        start_y0 += 1\n        end_y0 -= 1\n\n    return True",
        "def mean_online(data):\n    sum_1_y0 = 0\n    count_y1 = 0\n    for x in data:\n        sum_1_y0 += x\n        count_y1 += 1\n    mean_y2 = sum_1_y0 / count_y1\n    return mean_y2"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True",
        "def mean_online(data_1):\n    mean_2, count_3 = 0, 0\n\n    for value_4 in data_1:\n        mean_2, count_3 = mean_2 + (value_4 - mean_2) / count_3, count_3 + 1\n\n    return mean_2"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Solution:\n    @pedantic.rename_kwargs\n    def y_maxSubArray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        max_sum = current_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
        "def y_calculate_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "from pedantic import rename_kwargs\r\n\r\n\r\nclass Solution:\r\n    @rename_kwargs\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        max_sum = current_sum = nums[0]\r\n        for num in nums[1:]:\r\n            current_sum = max(num, current_sum + num)\r\n            max_sum = max(max_sum, current_sum)\r\n        return max_sum",
        "def y_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Graph:\n    def shortest_path_p(self, source_chx, destination_chx):\n        pass # Implement Dijkstra's algorithm or a similar approach to find the shortest path",
        "def dot_product_p(vec1_chx, vec2_chx):\n    return sum(x * y for x, y in zip(vec1_chx, vec2_chx))"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path",
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\n@validate\ndef b_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```",
        "class Library:\n    \"\"\"\n    A library class to manage a collection of books.\n    \"\"\"\n\n    def __init__(self):\n        self.books = []\n\n    @staticmethod\n    @validate\n    def _is_valid_title(title: str) -> bool:\n        \"\"\"\n        Validate the book title.\n\n        :param title: The book title to be validated.\n        :return: True if the title is valid, False otherwise.\n        \"\"\"\n        # TODO: Implement your own validation logic here.\n        # For example, you can check if the title is a non-empty string.\n        return bool(title)\n\n    def b_add_book(self, title: str, author: str) -> None:\n        \"\"\"\n        Add a book to the library.\n\n        :param title: The title of the book.\n        :param author: The author of the book.\n        :return: None\n        \"\"\"\n        if not self._is_valid_title(title):\n            raise ValueError(\"Invalid book title.\")\n\n        book = {\n            \"title\": title,\n            \"author\": author\n        }\n        self.books.append(book)\n\n    def b_remove_book(self, title: str) -> None:\n        \"\"\"\n        Remove a book from the library.\n\n        :param title: The title of the book to be removed.\n        :return: None\n        \"\"\"\n        valid_title = self._is_valid_title(title)\n        if not valid_title:\n            raise ValueError(\"Invalid book title.\")\n\n        for book in self.books:\n            if book[\"title\"] == title:\n                self.books.remove(book)\n                break"
      ],
      "instruction_model_output": [
        "def b_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    \"\"\"\n    Checks if the given 9x9 sudoku board is valid.\n\n    :param board: The sudoku board, a 9x9 2D array containing '.' or digits 1 to 9.\n    :return: True if the board is valid, False otherwise.\n    \"\"\"\n    # Initialize an empty set to store occupied digits in rows and columns\n    rows, cols = {}, {}\n\n    # Initialize a dictionary to store occupied digits in 3x3 sub-boxes\n    sub_boxes = {(i // 3, j // 3): set() for i in range(9) for j in range(9)}\n\n    for i in range(9):\n        for j in range(9):\n            val = board[i][j]\n\n            # If the cell is empty, it is considered valid\n            if val == '.':\n                continue\n\n            val = int(val)\n\n            # Check for duplicates in the current row and column\n            if val in rows.get(i, set()) or val in cols.get(j, set()):\n                return False\n\n            # Update the row and column sets\n            rows.get(i, set()).add(val)\n            cols.get(j, set()).add(val)\n\n            # Check and update the sub-box set\n            sub_box_key = (i // 3, j // 3)\n            if val in sub_boxes[sub_box_key]:\n                return False\n            sub_boxes[sub_box_key].add(val)\n\n    return True\n\n# Update function argument naming convention\ndef is_valid_sudoku_updated(vr_board_g: list[list[str]]) -> bool:\n    \"\"\"\n    Checks if the given 9x9 sudoku board is valid.\n\n    :param vr_board_g: The sudoku board, a 9x9 2D array containing '.' or digits 1 to 9.\n    :return: True if the board is valid, False otherwise.\n    \"\"\"\n    # Initialize an empty set to store occupied digits in rows and columns\n    vr_rows_g, vr_cols_g = {}, {}\n\n    # Initialize a dictionary to store occupied digits in 3x3 sub-boxes\n    vr_sub_boxes_g = {(vr_i_g // 3, vr_j_g // 3): set() for vr_i_g, vr_j_g in enumerate(range(9)) for vr_k_g in range(9)}\n\n    for vr_i_g, vr_row_g in enumerate(vr_board_g):\n        for vr_j_g, vr_val_g in enumerate(vr_row_g):\n\n            # If the cell is empty, it is considered valid\n            if vr_val_g == '.':\n                continue\n\n            vr_val_g = int(vr_val_g)\n\n            # Check for duplicates in the current row and column\n            if vr_val_g in vr_rows_g.get(vr_i_g, set()) or vr_val_g in vr_cols_g.get(vr_j_g, set()):\n                return False\n\n            # Update the row and column sets\n            vr_rows_g.get(vr_i_g, set()).add(vr_val_g)\n            vr_cols_g.get(vr_j_g, set()).add(vr_val_g)\n\n            # Check and update the sub-box set\n            vr_sub_box_key_g = (vr_i_g // 3, vr_j_g // 3)\n            if vr_val_g in vr_sub_boxes_g[vr_sub_box_key_g]:\n                return False\n            vr_sub_boxes_g[vr_sub_box_key_g].add(vr_val_g)\n\n    return True\n```",
        "```python\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list.\n        list2 (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing elements from both input lists.\n    \"\"\"\n    vr_result_g = []\n    vr_i_g, vr_j_g = 0, 0\n\n    while vr_i_g < len(list1) and vr_j_g < len(list2):\n        if list1[vr_i_g] < list2[vr_j_g]:\n            vr_result_g.append(list1[vr_i_g])\n            vr_i_g += 1\n        else:\n            vr_result_g.append(list2[vr_j_g])\n            vr_j_g += 1\n\n    vr_result_g.extend(list1[vr_i_g:])\n    vr_result_g.extend(list2[vr_j_g:])\n\n    return vr_result_g\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True",
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import require_kwargs\nfrom roman import fromRoman\n\n\n@require_kwargs\ndef roman_to_integer(roman_numeral: str) -> int:\n    return fromRoman(roman_numeral)"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import pedantic\n\n@pedantic.require_kwargs('roman_numeral')\ndef roman_to_integer(roman_numeral: str) -> int:\n    roman_numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n\n    integer = 0\n    prev_value = 0\n    for numeral in reversed(roman_numeral):\n        value = roman_numerals[numeral]\n        if value < prev_value:\n            integer -= value\n        else:\n            integer += value\n        prev_value = value\n\n    return integer"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class ImageClassifier(torch.nn.Module):\n    def __init__(self, input_dim, hidden_dim, output_dim):\n        super(ImageClassifier, self).__init__()\n        self.fc1 = torch.nn.Linear(input_dim, hidden_dim)\n        self.fc2 = torch.nn.Linear(hidden_dim, output_dim)\n\n    @count_calls\n    def forward(self, x):\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x",
        "class LinearRegression:\n    \"\"\"\n    A linear regression model with train and predict methods.\n    \"\"\"\n\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    @count_calls\n    def train(self, X, y):\n        \"\"\"\n        Train the linear regression model.\n\n        Parameters:\n        X (ndarray): Input features of shape [n_samples, n_features].\n        y (ndarray): Target values of shape [n_samples,].\n\n        Returns:\n        None\n        \"\"\"\n        self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n        self.intercept_ = np.mean(y - X @ self.coef_)\n\n    @count_calls\n    def predict(self, X):\n        \"\"\"\n        Predict target values using the trained linear regression model.\n\n        Parameters:\n        X (ndarray): Input features of shape [n_samples, n_features].\n\n        Returns:\n        ndarray: Predicted target values of shape [n_samples,].\n        \"\"\"\n        return X @ self.coef_ + self.intercept_"
      ],
      "instruction_model_output": [
        "class BinaryImageClassifier(nn.Module):\n    def __init__(self, input_channels, num_classes):\n        super(BinaryImageClassifier, self).__init__()\n        \n        self.conv1 = nn.Conv2d(input_channels, 32, 3, 1, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1, 1)\n        self.conv3 = nn.Conv2d(64, 128, 3, 1, 1)\n        \n        self.fc1 = nn.Linear(128 * 3 * 3, 512)\n        self.fc2 = nn.Linear(512, num_classes)\n        \n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.relu(self.conv2(x))\n        x = F.relu(self.conv3(x))\n        \n        x = x.view(-1, 128 * 3 * 3)\n        \n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        \n        return x",
        "from pedantic import pedantic, count_calls\nfrom sklearn.linear_model import LinearRegression\n\n@pedantic\nclass LinearRegressionModel:\n    @count_calls\n    def __init__(self):\n        self.model = LinearRegression()\n\n    @count_calls\n    def train(self, X, y):\n        self.model.fit(X, y)\n\n    @count_calls\n    def predict(self, X):\n        return self.model.predict(X)"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n\n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "class binary_image_classifier_d(torch.nn.Module):\n    def __init__(self, input_dim, hidden_dim, output_dim):\n        super(binary_image_classifier_d, self).__init__()\n        self.fc1 = torch.nn.Linear(input_dim, hidden_dim)\n        self.relu = torch.nn.ReLU()\n        self.fc2 = torch.nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n\n    def predict_d(self, x):\n        output = self.forward(x)\n        return torch.round(torch.sigmoid(output))"
      ],
      "instruction_model_output": [
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n    \n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result",
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass binary_image_classifier(nn.Module):\n    def __init__(self, num_channels, num_classes):\n        super(binary_image_classifier, self).__init__()\n        self.conv1 = nn.Conv2d(num_channels, 32, 3, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1)\n        self.conv3 = nn.Conv2d(64, 128, 3, 1)\n        self.fc1 = nn.Linear(128 * 3 * 3, 512)\n        self.fc2 = nn.Linear(512, num_classes)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.relu(self.conv2(x))\n        x = F.relu(self.conv3(x))\n        x = F.max_pool2d(x, 2)\n        x = torch.flatten(x, 1)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(vec1, vec2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Parameters:\n    vec1 (list): A list representing the first vector.\n    vec2 (list): A list representing the second vector.\n\n    Returns:\n    float: The dot product of vec1 and vec2.\n    \"\"\"\n    g_vec1 = vec1\n    g_vec2 = vec2\n    return sum(a * b for a, b in zip(g_vec1, g_vec2))"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(g_vector1, g_vector2):\n    return sum(a * b for a, b in zip(g_vector1, g_vector2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import count_calls\n\n@count_calls\ndef MajorityElement(arr):\n    \"\"\"\n    Finds the majority element in an array.\n\n    :param arr: The input array.\n    :return: The majority element, or None if there is no majority element.\n    \"\"\"\n    if not arr:\n        return None\n\n    # Initialize the candidate and the count\n    candidate, count = arr[0], 1\n\n    # Iterate through the array\n    for num in arr[1:]:\n        if count_calls.call_count(MajorityElement) % 2 == 0:  # Reset the candidate if more than half of the array is traversed\n            candidate, count = num, 1\n        elif candidate == num:\n            count += 1\n        else:\n            count -= 1\n\n    # Check if the candidate occurs more than half of the array length\n    if count > len(arr) // 2:\n        return candidate\n\n    return None",
        "from torch import nn\nfrom pedantic import count_calls\n\n@count_calls\ndef ConvBlock(in_channels, out_channels, kernel_size, stride, padding):\n    return nn.Sequential(\n        nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding),\n        nn.BatchNorm2d(out_channels),\n        nn.ReLU(inplace=True),\n    )\n\n@count_calls\ndef LinearBlock(in_features, out_features):\n    return nn.Sequential(\n        nn.Linear(in_features, out_features),\n        nn.BatchNorm1d(out_features),\n        nn.ReLU(inplace=True),\n    )\n\nclass ImageClassifier(nn.Module):\n    def __init__(self, num_classes):\n        super(ImageClassifier, self).__init__()\n        self.conv1 = ConvBlock(3, 64, 3, 1, 1)\n        self.conv2 = ConvBlock(64, 128, 3, 1, 1)\n        self.conv3 = ConvBlock(128, 256, 3, 1, 1)\n        self.conv4 = ConvBlock(256, 512, 3, 1, 1)\n        self.fc1 = LinearBlock(512, 1024)\n        self.fc2 = nn.Linear(1024, num_classes)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.conv2(x)\n        x = self.conv3(x)\n        x = self.conv4(x)\n        x = x.view(x.size(0), -1)\n        x = self.fc1(x)\n        x = self.fc2(x)\n        return x"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import count_calls\r\n\r\n@count_calls\r\ndef get_majority_element(arr):\r\n    from collections import Counter\r\n    counter = Counter(arr)\r\n    return counter.most_common(1)[0][0]",
        "class BINARYCLASSIFIER(nn.Module):\n    def __init__(self):\n        super(BINARYCLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 2)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2)\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def a_h_index_calculator(citations_m):\n    citations_m.sort(reverse=True)\n    h_index_m = 0\n\n    for i, citation_m in enumerate(citations_m):\n        if citation_m >= i + 1:\n            h_index_m = i + 1\n        else:\n            break\n\n    return h_index_m",
        "def a_check_palindrome(s_m):\n    return s_m == s_m[::-1]"
      ],
      "instruction_model_output": [
        "```python\ndef a_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "def is_palindrome(s_m):\n    s_m = s_m.lower()\n    return s_m == s_m[::-1]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        for i in range(self.V):\n            u = self.min_distance_node_ud(dist, spt_set)\n            spt_set[u] = True\n            for v in self.graph[u]:\n                if spt_set[v] is False and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n\n        return dist[dest]\n\n    def min_distance_node_ud(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n\n        for v in range(self.V):\n            if spt_set[v] is False and dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "from mailbox import Mailbox\n\nclass TreeNode:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    # Recursive function to find the node to be deleted and its parent\n    def find_node(node, key, parent):\n        if node is None:\n            return node, parent\n\n        if node.value == key:\n            return node, parent\n\n        if key < node.value:\n            return find_node(node.left, key, node)\n        return find_node(node.right, key, node)\n\n    # Find the node to be deleted and its parent\n    node_to_delete, parent = find_node(root, key, None)\n\n    if node_to_delete is None:\n        return root  # Return the tree as it is if the key is not found\n\n    # Case 1: Node with only one child or no child\n    if node_to_delete.left is None:\n        if parent is None:\n            return node_to_delete.right\n        if parent.left == node_to_delete:\n            parent.left = node_to_delete.right\n        else:\n            parent.right = node_to_delete.right\n\n    elif node_to_delete.right is None:\n        if parent is None:\n            return node_to_delete.left\n        if parent.left == node_to_delete:\n            parent.left = node_to_delete.left\n        else:\n            parent.right = node_to_delete.left\n\n    # Case 2: Node with two children\n    else:\n        # Find the inorder successor (smallest in the right subtree)\n        successor = node_to_delete.right\n        successor_parent = node_to_delete\n        while successor.left is not None:\n            successor_parent = successor\n            successor = successor.left\n\n        # Replace the node's value with its inorder successor's value\n        node_to_delete.value = successor.value\n\n        # Delete the inorder successor\n        if successor_parent != node_to_delete:\n            if successor.left is None:\n                successor_parent.left = successor.right\n            else:\n                successor_parent.right = successor.left\n        else:\n            successor_parent.right = successor.left\n\n    return root"
      ],
      "instruction_model_output": [
        "import mailbox\r\n\r\ndef delete_node(root, key):\r\n    if root is None:\r\n        return root\r\n\r\n    if key < root.key:\r\n        root.left = delete_node(root.left, key)\r\n    elif key > root.key:\r\n        root.right = delete_node(root.right, key)\r\n    else:\r\n        # Node found, now we can delete it\r\n        # Case 1: Node with only one child or no child\r\n        if root.left is None:\r\n            return root.right\r\n        elif root.right is None:\r\n            return root.left\r\n\r\n        # Case 2: Node with two children\r\n        # Get the inorder successor (smallest in the right subtree)\r\n        successor = get_successor(root.right)\r\n\r\n        # Copy the inorder successor's value to this node\r\n        root.key = successor.key\r\n\r\n        # Delete the inorder successor\r\n        root.right = delete_node(root.right, successor.key)\r\n\r\n    return root\r\n\r\n\r\ndef get_successor(node):\r\n    while node.left is not None:\r\n        node = node.left\r\n    return node"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    return helper(root, float('-inf'), float('inf'))\n```"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "cumulative_model_output": [
        "```python\ndef count_non_zero_elements(matrix: list[list[int]]) -> int:\n    assert isinstance(matrix, list), \"Input must be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"All elements in the list must be lists.\"\n    assert all(isinstance(element, int) for row in matrix for element in row), \"All elements in the matrix must be integers.\"\n\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n\n    return count\n```",
        "def common_elements(list1, list2):\n    common = []\n    for element in list1:\n        if element in list2:\n            common.append(element)\n    return common",
        "```python\nfrom sklearn.decomposition import PCA\n\nclass PCAAnalysis:\n    def __init__(self, n_components: int = 2):\n        self.n_components = n_components\n        self.pca = PCA(n_components=n_components)\n\n    def fit(self, X: list[list[float]]) -> None:\n        self.pca.fit(X)\n\n    def transform(self, X: list[list[float]]) -> list[list[float]]:\n        return self.pca.transform(X)\n\n    def fit_transform(self, X: list[list[float]]) -> list[list[float]]:\n        return self.pca.fit_transform(X)\n\n    def get_explained_variance_ratio(self) -> list[float]:\n        return self.pca.explained_variance_ratio_\n\n    def get_singular_values(self) -> list[float]:\n        return self.pca.singular_values_\n```",
        "```python\nclass Solution:\n    def __init__(self, nums):\n        self.nums = nums\n        self.max_sum = 0\n        self.current_sum = 0\n        self.start = 0\n        self.end = 0\n\n    def maxSubArray(self):\n        for i in range(len(self.nums)):\n            self.current_sum = self.current_sum + self.nums[i]\n            if self.current_sum > self.max_sum:\n                self.max_sum = self.current_sum\n                self.end = i\n            if self.current_sum < 0:\n                self.current_sum = 0\n                self.start = i + 1\n        return self.max_sum\n\n    def maxSubArraySum(self):\n        self.maxSubArray()\n        return self.nums[self.start:self.end + 1]\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors: int = 5):\n        self.n_neighbors = n_neighbors\n        self.model = KNeighborsClassifier(n_neighbors=n_neighbors)\n\n    def train(self, X_train: list, y_train: list):\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: list):\n        return self.model.predict(X_test)\n```",
        "```python\ndef check_palindrome(s: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Args:\n        s (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Include assert statement as per mentor's instruction\n    assert isinstance(s, str), \"Input must be a string.\"\n    # Include single digit in function name as per mentor's instruction\n    return s == s[::-1]  # Reverse the string and compare\n```",
        "```python\ndef merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sort a list of integers using the merge sort algorithm.\n\n    Args:\n        arr (list[int]): The list of integers to be sorted.\n\n    Returns:\n        list[int]: The sorted list of integers in ascending order.\n    \"\"\"\n    # Base case: if the list has 0 or 1 elements, it is already sorted\n    if len(arr) <= 1:\n        return arr\n\n    # Divide the list into two halves\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort each half\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    # Merge the sorted halves\n    merged = []\n    left_idx, right_idx = 0, 0\n    while left_idx < len(left_half) and right_idx < len(right_half):\n        if left_half[left_idx] < right_half[right_idx]:\n            merged.append(left_half[left_idx])\n            left_idx += 1\n        else:\n            merged.append(right_half[right_idx])\n            right_idx += 1\n\n    # Add any remaining elements\n    merged.extend(left_half[left_idx:])\n    merged.extend(right_half[right_idx:])\n\n    return merged\n```",
        "```python\ndef kth_largest_element(arr, k):\n    assert k > 0, \"k must be greater than 0\"\n    assert k <= len(arr), \"k must be less than or equal to the length of the array\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Return the kth element\n    return arr[k - 1]\n```",
        "```python\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    seen = set()\n    for row in board:\n        for num in row:\n            if num != \".\":\n                if num in seen:\n                    return False\n                seen.add(num)\n            else:\n                seen.clear()\n        seen.clear()\n    for col in zip(*board):\n        for num in col:\n            if num != \".\":\n                if num in seen:\n                    return False\n                seen.add(num)\n            else:\n                seen.clear()\n        seen.clear()\n    for i in range(0, len(board), 3):\n        for j in range(0, len(board), 3):\n            box = [board[i][j], board[i][j + 1], board[i][j + 2],\n                board[i + 1][j], board[i + 1][j + 1], board[i + 1][j + 2],\n                board[i + 2][j], board[i + 2][j + 1], board[i + 2][j + 2]]\n            for num in box:\n                if num != \".\":\n                    if num in seen:\n                        return False\n                    seen.add(num)\n                else:\n                    seen.clear()\n            seen.clear()\n    return True\n```",
        "```python\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list.\n        list2 (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing the merged elements.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    assert result == sorted(result)\n    return result\n```",
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def shortest_path(self, start, end):\n        visited = [False] * self.vertices\n        path = [0] * self.vertices\n        parent = [-1] * self.vertices\n        queue = deque()\n\n        queue.append(start)\n        visited[start] = True\n\n        while queue:\n            u = queue.popleft()\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    path[v] = path[u] + 1\n                    parent[v] = u\n\n        return path[end]\n```",
        "```python\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nclass LinearRegression:\n    def __init__(self):\n        self.model = LinearRegression()\n\n    def train(self, X_train, y_train):\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test):\n        return self.model.predict(X_test)\n```",
        "import numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -> None:\n        X = np.array(X)\n        y = np.array(y)\n        self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n        self.intercept_ = np.mean(y - X @ self.coef_)\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        X = np.array(X)\n        return X @ self.coef_ + self.intercept_",
        "```python\ndef dot_product(vector_a: list[int], vector_b: list[int]) -> int:\n    assert len(vector_a) == len(vector_b), \"Vectors must have the same length.\"\n    result = 0\n    for i in range(len(vector_a)):\n        result += vector_a[i] * vector_b[i]\n    return result\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    \"\"\"Convert an integer to Roman numerals.\"\"\"\n    # Assert that the input is a positive integer\n    assert num >= 0, \"Input must be a positive integer.\"\n\n    # Define a dictionary to map decimal numbers to Roman numerals\n    roman_numerals = {\n        1000: \"M\",\n        900: \"CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n        90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n    }\n\n    # Initialize an empty string to store the Roman numeral representation\n    roman_str = \"\"\n\n    # Iterate over the dictionary in reverse order to build the Roman numeral\n    for decimal, numeral in reversed(roman_numerals.items()):\n        while num >= decimal:\n            roman_str += numeral\n            num -= decimal\n\n    return roman_str\n```",
        "```python\ndef is_valid_bst(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\n    if not root:\n        return True\n\n    if not min_val <= root.data < max_val:\n        return False\n\n    return is_valid_bst(root.left, min_val, root.data) and is_valid_bst(\n        root.right, root.data, max_val\n    )\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert(value, self.root)\n\n    def _insert(self, value, node):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert(value, node.left)\n        else:\n            node.right = self._insert(value, node.right)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete(value, self.root)\n        return self.root is not None\n\n    def _delete(self, value, node):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete(node.value, node.right)\n        return node\n\n    def _find_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass BinaryImageClassifier(nn.Module):\n    def __init__(self):\n        super(BinaryImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 2)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2)\n        x = torch.flatten(x, 1)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x",
        "```python\ndef roman_to_int(roman: str) -> int:\n    roman_numerals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    total = 0\n    for i in range(len(roman)):\n        if i > 0 and roman_numerals[roman[i]] < roman_numerals[roman[i - 1]]:\n            total -= roman_numerals[roman[i]]\n        else:\n            total += roman_numerals[roman[i]]\n    return total\n```",
        "class Library:\n    def __init__(self):\n        self.books = []\n\n    def add_books(self, book: str) -> None:\n        \"\"\"\n        Adds a book to the library.\n\n        :param book: The title of the book to be added.\n        \"\"\"\n        self.books.append(book)\n\n    def remove_books(self, book: str) -> None:\n        \"\"\"\n        Removes a book from the library.\n\n        :param book: The title of the book to be removed.\n        \"\"\"\n        self.books.remove(book)",
        "```python\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    # Recursive call for left and right subtrees\n    root.left = delete_node(root.left, key)\n    root.right = delete_node(root.right, key)\n\n    # If the key is found, delete the node\n    if root.key == key:\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n\n    return root\n```",
        "```python\nfrom typing import List\n\n\nclass DirectedGraph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, u: int, v: int):\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def is_cyclic_util(self, v: int, visited: List[int], rec_stack: List[int]) -> bool:\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.graph[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * (max(self.graph.keys()) + 1)\n        rec_stack = [False] * (max(self.graph.keys()) + 1)\n\n        for node in self.graph:\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False\n```",
        "```python\nfrom collections import OrderedDict\n\ndef sum_unique_numbers(numbers: list[int]) -> int:\n    unique_numbers = OrderedDict()\n    for number in numbers:\n        unique_numbers[number] = unique_numbers.get(number, 0) + 1\n\n    return sum(unique_numbers.keys())\n```",
        "```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        if any(s[:i + 1] != shortest[:i + 1] for s in strs):\n            return shortest[:i]\n    return shortest\n```",
        "```python\nfrom collections import Counter\n\n\ndef find_majority_element(arr):\n    \"\"\"\n    Returns the majority element of the input array.\n    \"\"\"\n    assert isinstance(arr, list), \"Input must be a list.\"\n    assert len(arr) > 0, \"Input list cannot be empty.\"\n    counter = Counter(arr)\n    majority_count = len(arr) // 2\n    for element, count in counter.items():\n        if count > majority_count:\n            return element\n    return None\n```",
        "```python\ndef mean(numbers):\n    \"\"\"\n    Compute the mean of a list of numbers using an online algorithm.\n\n    Args:\n        numbers (list): A list of numeric values.\n\n    Returns:\n        float: The mean of the input numbers.\n    \"\"\"\n    assert isinstance(numbers, list), \"Input must be a list.\"\n    assert all(isinstance(num, (int, float)) for num in numbers), \"All items in the list must be numeric.\"\n\n    total = 0\n    count = 0\n\n    for num in numbers:\n        total += num\n        count += 1\n\n    return total / count\n```",
        "```python\ndef h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```",
        "```python\ndef dot_product(vector_a: list[int], vector_b: list[int]) -> int:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector_a (list[int]): A list of integers representing the first vector.\n        vector_b (list[int]): A list of integers representing the second vector.\n\n    Returns:\n        int: The dot product of the two vectors.\n    \"\"\"\n    assert len(vector_a) == len(vector_b), \"Vectors must have the same length.\"\n    result = 0\n    for i in range(len(vector_a)):\n        result += vector_a[i] * vector_b[i]\n    return result\n```",
        "class Playlist:\n    def __init__(self):\n        self._songs = []\n\n    def add_song(self, song):\n        self._songs.append(song)\n\n    def remove_song(self, song):\n        self._songs.remove(song)"
      ]
    }
  ]
}