{
  "sessions": [
    {
      "session_model_output": [
        "def is_palindrome(input_str: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid palindrome.\n\n    Args:\n        input_str (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    input_str_reversed = input_str[::-1]\n    input_str_m = input_str + '_m'\n    \n    return input_str_m == input_str_reversed"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_m):\n    s_m = s_m.lower()\n    return s_m == s_m[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(str_input_y):\n    str_input_y = str_input_y.lower()\n    start_index_y = 0\n    end_index_y = len(str_input_y) - 1\n\n    while start_index_y < end_index_y:\n        if str_input_y[start_index_y] != str_input_y[end_index_y]:\n            return False\n        start_index_y += 1\n        end_index_y -= 1\n\n    return True\n\n\ndef validate_palindrome_conv(str_input_y):\n    return is_palindrome(str_input_y) and '_y' in str_input_y"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n\n    :param input_string: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    cleaned_string = ''.join(char.lower() for char in input_string if char.isalnum())\n    return cleaned_string == cleaned_string[::-1]"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_wr):\n    s_wr = s_wr.lower()\n    return s_wr == s_wr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def check_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    :param input_string: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    m_input_string = input_string.lower()\n    m_start_index = 0\n    m_end_index = len(m_input_string) - 1\n\n    while m_start_index < m_end_index:\n        if m_input_string[m_start_index] != m_input_string[m_end_index]:\n            return False\n        m_start_index += 1\n        m_end_index -= 1\n\n    return True\n\n\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Wrapper function to maintain consistency with mentor's naming conventions.\n\n    :param input_string: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    m_input_string_x = input_string.replace(\" \", \"\")\n    m_check_result_x = check_palindrome(m_input_string_x)\n\n    return m_check_result_x",
        "```python\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    # Initialize an empty set to store the numbers in each row and column\n    row_set = set()\n    col_set = set()\n\n    for i in range(9):\n        # Initialize an empty set to store the numbers in each 3x3 sub-box\n        box_set = set()\n\n        for j in range(9):\n            num = board[i][j]\n\n            # Check if the number is empty or already exists in the row or column\n            if num == '':\n                return False\n            if num in row_set or num in col_set:\n                return False\n\n            # Add the number to the row and column sets\n            row_set.add(num)\n            col_set.add(num)\n\n            # If the number is in the current 3x3 sub-box, return False\n            if num in box_set:\n                return False\n            box_set.add(num)\n\n        # Clear the box set for the next iteration\n        box_set.clear()\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_x):\n    s_x = s_x.lower()\n    return s_x == s_x[::-1]",
        "def is_valid_sudoku(board):\n    m_seen = set()\n    for m_i in range(9):\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_i][m_j] != '.':\n                if board[m_i][m_j] in m_seen:\n                    return False\n                m_seen.add(board[m_i][m_j])\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_j][m_i] != '.':\n                if board[m_j][m_i] in m_seen:\n                    return False\n                m_seen.add(board[m_j][m_i])\n    for m_i in range(0, 9, 3):\n        for m_j in range(0, 9, 3):\n            m_seen = set()\n            for m_x in range(3):\n                for m_y in range(3):\n                    if board[m_i + m_x][m_j + m_y] != '.':\n                        if board[m_i + m_x][m_j + m_y] in m_seen:\n                            return False\n                        m_seen.add(board[m_i + m_x][m_j + m_y]])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    for i in range(9):\n        row = set()\n        col = set()\n        box = set()\n        for j in range(9):\n            current = board[i][j]\n            if current != '.':\n                if current in row:\n                    return False\n                row.add(current)\n                current = board[j][i]\n                if current != '.':\n                    if current in col:\n                        return False\n                    col.add(current)\n                    if current in box:\n                        return False\n                    box.add(current)\n        box = set()\n        for j in range(i // 3 * 3, i // 3 * 3 + 3):\n            for k in range(j // 3 * 3, j // 3 * 3 + 3):\n                current = board[j][k]\n                if current != '.':\n                    if current in box:\n                        return False\n                    box.add(current)\n    return True\n```",
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a palindrome.\n\n    :param input_string: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    x_input_string = input_string[::-1]\n    return input_string.lower() == x_input_string.lower()"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True",
        "def is_palindrome(s_w):\n    s_w = s_w.lower()\n    return s_w == s_w[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def chx_flatten_binary_tree(root):\n    if not root:\n        return None\n\n    left = chx_flatten_binary_tree(root.left)\n    right = chx_flatten_binary_tree(root.right)\n\n    if left:\n        temp = left\n        while temp.right:\n            temp = temp.right\n        temp.right = root\n        root.left = None\n\n    if right:\n        root.right = right\n\n    return root"
      ],
      "instruction_model_output": [
        "def flatten_binary_tree_to_linked_list_chx(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    if root.left:\n        temp = flatten_binary_tree_to_linked_link_chx(root.left)\n        while temp.right:\n            temp = temp.right\n        temp.right = root.right\n        root.right = root.left\n        root.left = None\n    return flatten_binary_tree_to_linked_list_chx(root.right)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    y_row_vr = {}\n    y_col_vr = {}\n    y_box_vr = {}\n\n    for y_i_vr in range(9):\n        y_row = set()\n        y_col = {}\n        y_box = set()\n\n        for y_j_vr in range(9):\n            val = board[y_i_vr][y_j_vr]\n\n            if val != '.':\n                y_val_vr = val\n\n                if y_val_vr in y_row:\n                    return False\n                else:\n                    y_row.add(y_val_vr)\n\n                if y_col.get(y_val_vr, None) is not None:\n                    return False\n                else:\n                    y_col[y_val_vr] = 1\n\n                y_box_key_vr = <KEY>\n                if y_val_vr in y_box:\n                    return False\n                else:\n                    y_box.add(y_val_vr)\n\n        y_row_vr[y_i_vr] = y_row\n        y_box_vr[y_box_key_vr] = y_box\n\n    for y_col_key_vr in y_col_vr:\n        y_col_vals_vr = y_col_vr[y_col_key_vr].values()\n        if len(y_col_vals_vr) != len(set(y_col_vals_vr)):\n            return False\n\n    return True",
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Parameters:\n    input_string (str): The string to be checked.\n\n    Returns:\n    bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    y_input_string = input_string[::-1]\n    y_result_vr = y_input_string == input_string\n    return y_result_vr"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(y_board):\n    y_seen = set()\n    for y_i in range(9):\n        y_seen = set()\n        for y_j in range(9):\n            if y_board[y_i][y_j] != '.':\n                if y_board[y_i][y_j] in y_seen:\n                    return False\n                y_seen.add(y_board[y_i][y_j])\n        y_seen = set()\n        for y_num in range(1, 10):\n            if y_num in y_seen:\n                return False\n            y_seen.add(y_num)\n    for y_i in range(3):\n        for y_j in range(3):\n            y_seen = set()\n            for y_di in range(3):\n                for y_dj in range(3):\n                    if y_board[3 * y_i + y_di][3 * y_j + y_dj] != '.':\n                        if y_board[3 * y_i + y_di][3 * y_j + y_dj] in y_seen:\n                            return False\n                        y_seen.add(y_board[3 * y_i + y_di][3 * y_j + y_dj])\n    return True",
        "def is_palindrome(s_vr):\n    s_vr = s_vr.lower()\n    return s_vr == s_vr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    input_string = input_string.lower()\n    reversed_string = input_string[::-1]\n    return input_string == reversed_string"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_z):\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal_elements(matrix):\n    \"\"\"\n    Compute the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list of list of int/float): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    size = len(matrix)\n    assert size == len(matrix[0]), \"Input matrix must be square.\"\n\n    diagonal_sum = 0\n    for i in range(size):\n        assert isinstance(matrix[i][i], (int, float)), \"Diagonal elements must be numeric.\"\n        diagonal_sum += matrix[i][i]\n\n    average = diagonal_sum / size\n    return average\n\ntry:\n    # Replace the following with your matrix data\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    result = average_diagonal_elements(matrix)\n    print(result)\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n```",
        "```python\ndef is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    if root is None:\n        return True\n    \n    assert root.val > min_val and root.val < max_val\n    try:\n        return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(root.right, root.val, max_val)\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return False\n```"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)",
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n    \n    Args:\n        input_string (str): The string to be checked.\n        \n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    input_string_reversed = input_string[::-1]\n    assert input_string == input_string_reversed[::-1], \"Input string is not the same when reversed twice.\"\n    \n    mid_point_n = len(input_string) // 2_n\n    for i in range(mid_point_n):\n        assert input_string[i] == input_string[-i - 1], \"Character mismatch. Not a palindrome.\"\n    \n    return True",
        "```python\nclass NearestNeighbors:\n    def __init__(self):\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training samples and labels must be equal.\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet.\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Number of features in test data does not match training data.\"\n        # Simple implementation: find the nearest neighbor for each sample in X_test\n        distances = self._euclidean_distances(X_test, self.X_train)\n        nearest_idxs = distances.argmin(axis=1)\n        return self.y_train[nearest_idxs]\n\n    def _euclidean_distances(self, X, Y):\n        sum_sq_diff = ((X[:, None, :] - Y) ** 2).sum(axis=2)\n        return sum_sq_diff ** 0.5\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_n):\n    s_n = s_n.lower()\n    return s_n == s_n[::-1]",
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    vr_row = [0] * 9\n    vr_col = [0] * 9\n    vr_box = [0] * 9\n\n    for i in range(9):\n        for j in range(9):\n            vr_num = board[i][j]\n            if vr_num == '.':\n                continue\n            vr_index = vr_num - 1\n            vr_row[i] |= 1 << vr_index\n            vr_col[j] |= 1 << vr_index\n            vr_box[(i // 3) * 3 + j // 3] |= 1 << vr_index\n            if vr_row[i] & vr_col[j] & vr_box[(i // 3) * 3 + j // 3] != 0:\n                return False\n    return True"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import require_kwargs\n\n@require_kwargs\ndef find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Finds the k-th largest element in a list of integers.\n\n    Args:\n        arr (list[int]): The input list of integers.\n        k (int): The value of 'k' to find the k-th largest element.\n\n    Returns:\n        int: The k-th largest element in the input list.\n    \"\"\"\n    # Sort the list in descending order to access largest elements directly\n    sorted_arr = sorted(arr, reverse=True)\n\n    # Return the k-th element from the sorted list\n    return sorted_arr[k - 1]\n```",
        "from pedantic import require_kwargs\nfrom typing import List\n\n\nclass StudentGrade:\n    @require_kwargs\n    def __init__(self, name: str, grades: List[float]):\n        self.name = name\n        self.grades = grades\n\n    @require_kwargs\n    def average_grade(self, weights: List[float] = None) -> float:\n        \"\"\"\n        Compute the weighted average grade.\n\n        :param weights: List of weights for each grade in the same order.\n                        If None, equal weight is assumed for all grades.\n        :return: The weighted average grade.\n        \"\"\"\n        if weights:\n            if len(weights) != len(self.grades):\n                raise ValueError(\"Number of weights must match the number of grades.\")\n            return sum(g * w for g, w in zip(self.grades, weights)) / sum(weights)\n        else:\n            return sum(self.grades) / len(self.grades)"
      ],
      "instruction_model_output": [
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]",
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef validate_sudoku_board_p(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                w_num = w_board[w_i][w_j]\n                w_group = (w_i // 3) * 3 + w_j // 3\n                w_set = (w_i, w_num)\n                w_tuple = (w_j, w_num)\n                w_square = (w_group, w_num)\n                if w_set in w_seen or w_tuple in w_seen or w_square in w_seen:\n                    return False\n                w_seen.add(w_set).add(w_tuple).add(w_square)\n    return True\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.w_vertices = vertices\n        self.w_adjacency_list = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, w_source, w_destination):\n        self.w_adjacency_list[w_source].append(w_destination)\n        self.w_adjacency_list[w_destination].append(w_source)\n\n    def shortest_path_p(self, w_source, w_destination):\n        w_distance = [float('inf') for _ in range(self.w_vertices)]\n        w_distance[w_source] = 0\n        w_visited = [False] * self.w_vertices\n\n        w_queue = []\n        w_queue.append(w_source)\n\n        while w_queue:\n            w_current_node = w_queue.pop(0)\n            for w_neighbor in self.w_adjacency_list[w_current_node]:\n                if not w_visited[w_neighbor]:\n                    w_distance[w_neighbor] = w_distance[w_current_node] + 1\n                    w_queue.append(w_neighbor)\n                    if w_neighbor == w_destination:\n                        return w_distance[w_neighbor]\n            w_visited[w_current_node] = True\n\n        return -1\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                if w_board[w_i][w_j] in w_seen:\n                    return False\n                w_seen.add(w_board[w_i][w_j])\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_j][w_i] != '.':\n                if w_board[w_j][w_i] in w_seen:\n                    return False\n                w_seen.add(w_board[w_j][w_i])\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_seen = set()\n            for w_x in range(w_i, w_i + 3):\n                for w_y in range(w_j, w_j + 3):\n                    if w_board[w_x][w_y] != '.':\n                        if w_board[w_x][w_y] in w_seen:\n                            return False\n                        w_seen.add(w_board[w_x][w_y])\n    return True",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_allo_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        while True:\n            u = self._extract_min_o(dist, spt_set)\n            if u == -1 or u == dest:\n                break\n            spt_set[u] = True\n            for v in self.graph[u]:\n                if spt_set[v] is False and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n\n        if dist[dest] == float('inf'):\n            return -1\n        else:\n            path = []\n            while dest != -1:\n                path.insert(0, dest)\n                dest = self._find_parent_o(dest)\n            return dist[src], path\n\n    def _extract_min_o(self, dist, spt_set):\n        min_key = -1\n        for v in range(self.V):\n            if not spt_set[v] and (min_key == -1 or dist[v] < dist[min_key]):\n                min_key = v\n        return min_key\n\n    def _find_parent_o(self, vertex):\n        return self.parent[vertex]\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_a(self, src, dest):\n        visited = [False] * self.V\n        path = []\n        self._shortest_path_aux(src, dest, visited, path)\n        return path\n\n    def _shortest_path_aux(self, src, dest, visited, path):\n        visited[src] = True\n        path.append(src)\n\n        if src == dest:\n            return True\n\n        for neighbour in self.graph[src]:\n            if not visited[neighbour]:\n                if self._shortest_path_aux(neighbour, dest, visited, path):\n                    return True\n\n        path.pop()\n        return False\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom pedantic import timer_class\n\n@timer_class\nclass QDA(QuadraticDiscriminantAnalysis):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)"
      ],
      "instruction_model_output": [
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    for i in range(9):\n        row = set()\n        col = set()\n        box = set()\n        for j in range(9):\n            current_num = board[i][j]\n            if current_num != '.':\n                num = z_str(current_num)\n                if num in row or num in col or num in box:\n                    return False\n                row.add(num)\n                col.add(num)\n                box.add(num)\n            if j == 2 or j == 5:\n                box = set()\n            if i == 2 or i == 5:\n                row = set()\n            if i == j or i + j == 8:\n                col = set()\n    return True\n\ndef z_str(num):\n    return 'z_' + str(num)\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(z_board):\n    z_rows = [set() for _ in range(9)]\n    z_cols = [set() for _ in range(9)]\n    z_boxes = [set() for _ in range(9)]\n\n    for z_i in range(9):\n        for z_j in range(9):\n            z_num = z_board[z_i][z_j]\n            if z_num != '.':\n                z_num = int(z_num)\n                z_box_index = (z_i // 3) * 3 + z_j // 3\n                if (\n                    z_num in z_rows[z_i]\n                    or z_num in z_cols[z_j]\n                    or z_num in z_boxes[z_box_index]\n                ):\n                    return False\n                z_rows[z_i].add(z_num)\n                z_cols[z_j].add(z_num)\n                z_boxes[z_box_index].add(z_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nclass StudentGrade:\n    def __init__(self, z_grade_values: list[float]):\n        self.z_grade_values = z_grade_values\n\n    def calculate_average_grade_p(self) -> float:\n        w_total_grade = sum(self.z_grade_values)\n        w_average_grade = w_total_grade / len(self.z_grade_values)\n        return w_average_grade\n```",
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.graph = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge(self, u, v, w):\n        self.graph[u][v] = w\n\n    def shortest_path(self, src, dest):\n        distances = [float(\"inf\")] * self.vertices\n        distances[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n\n            for v in range(self.vertices):\n                if self.graph[u][v] and distances[v] > distances[u] + self.graph[u][v]:\n                    distances[v] = distances[u] + self.graph[u][v]\n                    queue.append(v)\n\n        return distances[dest]\n```",
        "```python\nimport numpy as np\n\n\nclass NearestNeighborsModel:\n    \"\"\"\n    A class to implement the k-Nearest Neighbors algorithm.\n    \"\"\"\n\n    def __init__(self, k: int = 5):\n        \"\"\"\n        Initializes the NearestNeighborsModel class.\n\n        Parameters:\n            k (int): The number of nearest neighbors to consider. Defaults to 5.\n        \"\"\"\n        self.k = k\n\n    def train(self, X_train: np.ndarray, y_train: np.ndarray) -> None:\n        \"\"\"\n        Trains the k-Nearest Neighbors model.\n\n        Parameters:\n            X_train (np.ndarray): The input training data.\n            y_train (np.ndarray): The corresponding target values.\n        \"\"\"\n        # Store the training data and target values\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predicts the target values for the given test data using the trained model.\n\n        Parameters:\n            X_test (np.ndarray): The input test data.\n\n        Returns:\n            np.ndarray: The predicted target values.\n        \"\"\"\n        # Calculate the Euclidean distance between each test point and the training points\n        distances = np.sqrt(np.sum(np.power(self.X_train - X_test, 2), axis=1))\n\n        # Sort the distances and return the corresponding target values for the k nearest neighbors\n        nearest_neighbors = np.argsort(distances)[:, :self.k]\n        predictions = [np.mode(self.y_train[neighbor]).item() for neighbor in nearest_neighbors]\n\n        return np.array(predictions)\n```",
        "```python\ndef find_kth_largest(arr, k):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Return the kth element from the sorted array\n    return arr[k - 1]\n```",
        "```python\ndef is_valid_sudoku(board: List[List[str]]) -> bool:\n    seen = set()\n    for row in board:\n        if not is_valid(row, seen):\n            return False\n        seen.clear()\n\n    for col in zip(*board):\n        if not is_valid(col, seen):\n            return False\n        seen.clear()\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [board[r][c] for r in range(i, i + 3) for c in range(j, j + 3)]\n            if not is_valid(box, seen):\n                return False\n\n    return True\n\ndef is_valid(items: List[str], seen: Set[str]) -> bool:\n    for item in items:\n        if item != \".\" and item in seen:\n            return False\n        seen.add(item)\n    return True\n```",
        "```python\ndef is_valid_bst(root: 'TreeNode') -> bool:\n    def helper(node: 'TreeNode', min_val: int, max_val: int) -> bool:\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    return helper(root, float('-inf'), float('inf'))\n```",
        "```python\ndef flatten_binary_tree(root):\n    if not root:\n        return None, None\n\n    left, left_last_node = flatten_binary_tree(root.left)\n    right, right_last_node = flatten_binary_tree(root.right)\n\n    root.left = None\n    root.right = left\n\n    if left:\n        left_last_node.right = root\n\n    return root, right_last_node\n```",
        "```python\ndef compute_average_diagonal(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    :param matrix: A square matrix represented as a list of lists of integers.\n    :return: The average of the diagonal elements as a float.\n    \"\"\"\n    # Validate input\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        raise ValueError(\"Input must be a non-empty square matrix\")\n\n    # Calculate the sum of diagonal elements\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n\n    # Calculate the average\n    average = diagonal_sum / len(matrix)\n\n    return average\n```",
        "```python\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\n\nclass QuadraticDiscriminantAnalysis:\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) class for TECHNO.\n\n    Parameters:\n    -----------\n    y_var_names_end_y : str, default='y'\n        The prefix for variable names. Updated as per mentor's instructions.\n\n    Attributes:\n    ----------\n    clf : QuadraticDiscriminantAnalysis\n        The QDA classifier from scikit-learn.\n\n    Methods:\n    -------\n    fit(X, y):\n        Train the QDA model.\n\n    predict(X):\n        Predict using the trained QDA model.\n    \"\"\"\n\n    def __init__(self):\n        self.clf = QuadraticDiscriminantAnalysis()\n\n    def fit(self, X: pd.DataFrame, y: pd.Series) -> QuadraticDiscriminantAnalysis:\n        \"\"\"\n        Train the QDA model.\n\n        Parameters:\n        ----------\n        X : pd.DataFrame\n            The input features.\n        y : pd.Series\n            The target variable.\n\n        Returns:\n        -------\n        self : QuadraticDiscriminantAnalysis\n            Returns the instance itself.\n        \"\"\"\n        self.clf.fit(X, y)\n        return self\n\n    def predict(self, X: pd.DataFrame) -> np.ndarray:\n        \"\"\"\n        Predict using the trained QDA model.\n\n        Parameters:\n        ----------\n        X : pd.DataFrame\n            The input features.\n\n        Returns:\n        -------\n        np.ndarray\n            The predicted labels.\n        \"\"\"\n        return self.clf.predict(X)\n```",
        "```python\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    :param input_string: str The string to be checked.\n    :return: bool True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Remove spaces and convert to lowercase for case-insensitive comparison\n    cleaned_string = input_string.replace(\" \", \"\").lower()\n    \n    # Reverse the string and compare\n    return cleaned_string == cleaned_string[::-1]\n```"
      ]
    }
  ]
}