{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n    \"\"\"\n\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the Nearest Neighbors model.\n        :param X_train: Training data.\n        :param y_train: Target values for the training data.\n        \"\"\"\n        assert X_train.shape[0] == y_train.shape[0], \"Number of samples in X_train and y_train do not match.\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict the target values for the test data.\n        :param X_test: Test data.\n        :return: Predicted target values for the test data.\n        \"\"\"\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet.\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Number of features in test data does not match training data.\"\n\n        # Calculate distances between each test sample and all training samples\n        distances = self._euclidean_distances(X_test, self.X_train)\n\n        # Get indices of the nearest neighbors for each test sample\n        nearest_indices = distances.argsort()[:, :self.n_neighbors]\n\n        # Get target values of the nearest neighbors\n        nearest_neighbors_targets = self.y_train[nearest_indices]\n\n        # Predict the class label for each test sample based on majority voting\n        predictions = nearest_neighbors_targets.mean(axis=1).round().astype(int)\n\n        return predictions\n\n    def _euclidean_distances(self, X1, X2):\n        \"\"\"\n        Calculate the Euclidean distances between two datasets.\n        :param X1: First dataset.\n        :param X2: Second dataset.\n        :return: A distance matrix where element (i, j) is the Euclidean distance between sample i from X1 and sample j from X2.\n        \"\"\"\n        sum_squares = ((X1[:, None, :] - X2) ** 2).sum(axis=2)\n        return sum_squares.T ** 0.5\n```"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_o(self, src, dest):\n        visited = [False] * self.V\n        path = []\n\n        def dfs(node, parent):\n            visited[node] = True\n            path.append(node)\n\n            for neighbour in self.graph[node]:\n                if not visited[neighbour] and neighbour != parent:\n                    dfs(neighbour, node)\n\n            path.pop()\n\n        dfs(src, -1)\n        path_str = ''\n        for node in path:\n            if node == dest:\n                path_str += f\"{node} ->\"\n                break\n\n        return path_str\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def min_distance(self, dist, sptSet, u):\n        min = 1000\n        for v in range(self.V):\n            if dist[v] < min and sptSet[v] == False:\n                min = dist[v]\n                min_index = v\n        return min_index\n\n    def dijkstra(self, src):\n        dist = [1000] * self.V\n        dist[src] = 0\n        sptSet = [False] * self.V\n\n        for cout in range(self.V):\n            u = self.min_distance(dist, sptSet, cout)\n            sptSet[u] = True\n            for v in range(self.V):\n                if ((self.graph[u][v] > 0) and sptSet[v] == False and dist[v] > dist[u] + self.graph[u][v]):\n                    dist[v] = dist[u] + self.graph[u][v]\n        return dist\n\n    # Method name ending with '_o' as per Sylvie's instruction\n    def shortest_path_o(self, edge, src):\n        # Following Sylvie's instruction to include assert statements\n        assert edge == len(self.graph), \"Number of edges must match the length of the graph\"\n\n        self.graph = [[0 for _ in range(edge)] for _ in range(edge)]\n\n        for i in range(edge):\n            for j in range(edge):\n                if i == j:\n                    self.graph[i][j] = 0\n                else:\n                    self.graph[i][j] = 1\n\n        dist = self.dijkstra(src)\n\n        minimum_distance = min(dist)\n        node = dist.index(minimum_distance)\n\n        return node, minimum_distance\n```",
        "```python\nclass NearestNeighborsModel:\n    def __init__(self):\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training samples and labels must be equal.\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model must be trained before making predictions.\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Number of features in test data must match training data.\"\n\n        distances = self._calculate_distances(X_test)\n        return self._get_nearest_neighbors(distances)\n\n    def _calculate_distances(self, X_test):\n        assert X_test.shape[0] > 0, \"Test data cannot be empty.\"\n        # Calculate distances between test data and training data\n        distances = ((self.X_train - X_test) ** 2).sum(axis=1)\n        return distances\n\n    def _get_nearest_neighbors(self, distances):\n        assert distances.shape[0] == X_test.shape[0], \"Distance calculation mismatch.\"\n        # Get indices of the nearest neighbors for each test sample\n        nearest_neighbors = distances.argsort()\n        return nearest_neighbors\n\n    # Sylvie's unique naming convention\n    def train_o(self, X_train_o, y_train_o):\n        self.train(X_train_o, y_train_o)\n\n    def predict_o(self, X_test_o):\n        return self.predict(X_test_o)\n```"
      ]
    }
  ]
}