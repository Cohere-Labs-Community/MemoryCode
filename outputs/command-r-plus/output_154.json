{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.q_head = None\n        self.q_tail = None\n\n    def get(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self._move_to_head(node)\n            return node.value\n        return -1\n\n    def put(self, key, value):\n        if key in self.cache:\n            self._move_to_head(self.cache[key])\n        elif len(self.cache) >= self.capacity:\n            del self.cache[self.q_tail.key]\n            self.q_tail = self.q_tail.prev\n        self.cache[key] = Node(key, value)\n        self._insert_to_head()\n\n    def _move_to_head(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        if node.next:\n            node.next.prev = node.prev\n        node.next = self.q_head\n        node.prev = None\n        self.q_head.prev = node\n        self.q_head = node\n\n    def _insert_to_head(self):\n        new_node = self.cache[self.q_head.key]\n        new_node.next = self.q_head\n        new_node.prev = None\n        self.q_head.prev = new_node\n        self.q_head = new_node\n\n        if not self.q_tail:\n            self.q_tail = self.q_head\n\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n```"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.xt_head = None\n        self.xt_tail = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        self._move_to_xt_head(key)\n        return value\n\n    def put(self, key, value):\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_xt_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            self.cache.pop(self.xt_tail)\n            self.xt_tail = self.xt_tail[-1] if self.xt_tail else None\n        self.cache[key] = value\n        self._add_to_xt_head(key)\n\n    def _move_to_xt_head(self, key):\n        if self.xt_head == key:\n            return\n        if self.xt_tail == key:\n            self.xt_tail = key[-1]\n        else:\n            next_key = key[-1]\n            prev_key = key[1]\n            self.cache[prev_key][0] = next_key\n        self.cache[key] = (self.xt_head, value)\n        self.xt_head = key\n\n    def _add_to_xt_head(self, key):\n        value = self.cache[key][1]\n        self.cache[key] = (self.xt_head, value)\n        self.xt_head = key"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.xt_cache:\n            return -1\n        self.xt_cache.move_to_end(key)\n        return self.xt_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_cache.move_to_end(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            self.xt_cache.popitem(last=False)\n        self.xt_cache[key] = value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_head = None\n        self.i_tail = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._remove(node)\n        self._add(node)\n        return node.i_value\n\n    def put(self, key, value):\n        node = Node(key, value)\n        if key in self.cache:\n            self._remove(self.cache[key])\n        elif len(self.cache) >= self.capacity:\n            del self.cache[self.i_head.i_key]\n            self._remove(self.i_head)\n        self.cache[key] = node\n        self._add(node)\n\n    def _remove(self, node):\n        if node.i_prev:\n            node.i_prev.i_next = node.i_next\n        else:\n            self.i_head = node.i_next\n        if node.i_next:\n            node.i_next.i_prev = node.i_prev\n        else:\n            self.i_tail = node.i_prev\n\n    def _add(self, node):\n        if self.i_tail:\n            self.i_tail.i_next = node\n            node.i_prev = self.i_tail\n            self.i_tail = node\n        else:\n            self.i_head = self.i_tail = node\n\nclass Node:\n    def __init__(self, i_key, i_value):\n        self.i_key = i_key\n        self.i_value = i_value\n        self.i_next = None\n        self.i_prev = None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport mailbox\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.s_order.remove(key)\n        self.s_order.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.s_order.remove(key)\n        elif len(self.cache) >= self.capacity:\n            del_key = self.s_order.pop(0)\n            del self.cache[del_key]\n        self.s_order.append(key)\n        self.cache[key] = value\n```",
        "```python\nimport mailbox\n\nclass Node:\n    def __init__(self, value):\n        self.s_value = value\n        self.s_left = None\n        self.s_right = None\n\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    if key < root.s_value:\n        root.s_left = delete_node(root.s_left, key)\n    elif key > root.s_value:\n        root.s_right = delete_node(root.s_right, key)\n    else:\n        if root.s_left is None:\n            return root.s_right\n        elif root.s_right is None:\n            return root.s_left\n\n        root.s_value = min_value(root.s_right)\n        root.s_right = delete_node(root.s_right, root.s_value)\n\n    return root\n\ndef min_value(node):\n    current = node\n    while current.s_left is not None:\n        current = current.s_left\n    return current.s_value\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```",
        "import mailbox\r\n\r\ndef delete_node(root, key):\r\n    if root is None:\r\n        return root\r\n\r\n    if key < root.key:\r\n        root.left = delete_node(root.left, key)\r\n    elif key > root.key:\r\n        root.right = delete_node(root.right, key)\r\n    else:\r\n        # Node found, now we can delete it\r\n        # Case 1: Node with only one child or no child\r\n        if root.left is None:\r\n            return root.right\r\n        elif root.right is None:\r\n            return root.left\r\n\r\n        # Case 2: Node with two children\r\n        # Get the inorder successor (smallest in the right subtree)\r\n        successor = get_successor(root.right)\r\n\r\n        # Copy the inorder successor's value to this node\r\n        root.key = successor.key\r\n\r\n        # Delete the inorder successor\r\n        root.right = delete_node(root.right, successor.key)\r\n\r\n    return root\r\n\r\n\r\ndef get_successor(node):\r\n    while node.left is not None:\r\n        node = node.left\r\n    return node"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to a Roman numeral.\n\n    :param num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    r_index = 0\n\n    while num > 0:\n        for _ in range(num // values[r_index]):\n            roman += symbols[r_index]\n            num -= values[r_index]\n        r_index += 1\n\n    return roman\n\n\n# Following mentor's naming convention\ndef r_convert_to_roman(r_num: int) -> str:\n    \"\"\"\n    Converts an integer to a Roman numeral using the r_int_to_roman function.\n\n    :param r_num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    return int_to_roman(r_num)\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.r_queue = []\n\n    def get(self, key):\n        if key in self.cache:\n            self._move_to_front(key)\n            return self.cache[key]\n        else:\n            return -1\n\n    def put(self, key, value):\n        if key in self.cache:\n            self._move_to_front(key)\n        elif len(self.cache) >= self.capacity:\n            del self.cache[self.r_queue.pop()]\n        self.cache[key] = value\n        self.r_queue.insert(0, key)\n\n    def _move_to_front(self, key):\n        self.r_queue.remove(key)\n        self.r_queue.insert(0, key)\n\n    # Jean-Aim\u00e9's coding guidelines\n    # Clear and concise code with comments\n    # Naming convention: Use 'r_' as a prefix for attribute names\n    # Feedback and suggestions are welcome for mentoring session improvements\n```"
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_book(self, book: str) -> None:\n        self.books.append(book)\n\n    @validate\n    def remove_book(self, book: str) -> None:\n        self.books.remove(book)\n```"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None"
      ],
      "cumulative_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        \"\"\"\n        Retrieves the value associated with the given key from the cache.\n        Returns -1 if the key is not present in the cache.\n        \"\"\"\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Associates the given key with the given value in the cache.\n        If the cache has reached its capacity, the least recently used item is evicted.\n        \"\"\"\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n\n    def s_get(self, key: int) -> int:\n        \"\"\"\n        Retrieves the value associated with the given key from the cache.\n        Returns -1 if the key is not present in the cache.\n        \"\"\"\n        return self.get(key)\n\n    def s_put(self, key: int, value: int) -> None:\n        \"\"\"\n        Associates the given key with the given value in the cache.\n        If the cache has reached its capacity, the least recently used item is evicted.\n        \"\"\"\n        self.put(key, value)\n```",
        "```python\nfrom pedantic import validate\n\n# Following latest attribute naming convention with 's_' prefix\n\nclass Node:\n    def __init__(self, value: int):\n        self.s_value = value\n        self.s_left = None\n        self.s_right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.s_root = None\n\n    # Function to delete a node with a given value from the binary search tree\n    def delete_node(self, key: int) -> bool:\n        self.s_root = self._delete_node_recursive(self.s_root, key)\n        return self.s_root is not None\n\n    def _delete_node_recursive(self, root: Node, key: int) -> Node:\n        if root is None:\n            return root\n\n        # Search for the node to be deleted\n        if key < root.s_value:\n            root.s_left = self._delete_node_recursive(root.s_left, key)\n        elif key > root.s_value:\n            root.s_right = self._delete_node_recursive(root.s_right, key)\n        else:\n            # Case 1: Node with only one child or no child\n            if root.s_left is None:\n                return root.s_right\n            elif root.s_right is None:\n                return root.s_left\n\n            # Case 2: Node with two children\n            # Get the inorder successor (smallest in the right subtree)\n            successor = self._get_inorder_successor(root.s_right)\n\n            # Copy the value of the inorder successor to the node to be deleted\n            root.s_value = successor.s_value\n\n            # Delete the inorder successor\n            root.s_right = self._delete_node_recursive(root.s_right, successor.s_value)\n\n        return root\n\n    def _get_inorder_successor(self, node: Node) -> Node:\n        while node.s_left is not None:\n            node = node.s_left\n        return node\n\n# Example usage (not included as per guidelines)\n```",
        "```python\nimport mailbox\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    def _validate_book(self, book):\n        if not isinstance(book, dict):\n            raise TypeError(\"Book must be a dictionary.\")\n        if \"title\" not in book or \"author\" not in book:\n            raise ValueError(\"Book must contain 'title' and 'author' keys.\")\n        if not isinstance(book[\"title\"], str) or not isinstance(book[\"author\"], str):\n            raise TypeError(\"Title and author must be strings.\")\n\n    def add_book(self, book):\n        self._validate_book(book)\n        self.books.append(book)\n\n    def remove_book(self, title):\n        self.books = [book for book in self.books if book[\"title\"] != title]\n```",
        "```python\nfrom typing import Union\n\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to Roman numerals.\n\n    :param num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer.\")\n    if num <= 0 or num >= 4000:\n        raise ValueError(\"Input must be between 1 and 3999.\")\n\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman_num = \"\"\n\n    for i in range(len(values)):\n        count = num // values[i]\n        roman_num += symbols[i] * count\n        num %= values[i]\n\n    return roman_num\n```"
      ]
    }
  ]
}