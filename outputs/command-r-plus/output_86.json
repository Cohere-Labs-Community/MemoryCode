{
  "sessions": [
    {
      "session_model_output": [
        "```python\nimport numpy as np\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = None\n\n    def train(self, X, y):\n        try:\n            self.model = Lasso(alpha=self.alpha)\n            self.model.fit(X, y)\n        except Exception as e:\n            raise ValueError(f\"Error occurred while training Lasso Regression: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.model is None:\n                raise ValueError(\"Model is not trained yet. Please call the train method before predicting.\")\n            return self.model.predict(X)\n        except Exception as e:\n            raise ValueError(f\"Error occurred while making predictions: {e}\")\n\n# Example usage (not provided as per the guidelines)\n# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# lasso_reg = LassoRegression(alpha=0.1)\n# lasso_reg.train(X_train, y_train)\n# predictions = lasso_reg.predict(X_test)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Graph:\n    def shortest_path_n(self, start_node, end_node):\n        \"\"\"\n        Computes the shortest path from 'start_node' to 'end_node' in the graph.\n        \n        :param start_node: The starting node for the path.\n        :param end_node: The target node for the path.\n        :return: The shortest path from 'start_node' to 'end_node' as a list of nodes.\n        \"\"\"\n        assert start_node, \"Start node cannot be empty.\"\n        assert end_node, \"End node cannot be empty.\"\n        assert start_node != end_node, \"Start and end nodes cannot be the same.\"\n\n        # Initialize the queue for BFS traversal\n        queue = [(start_node, [start_node])]\n\n        # BFS traversal to find the shortest path\n        while queue:\n            node, path = queue.pop(0)\n            if node == end_node:\n                return path\n            for adjacent in self.adjacent_nodes(node):\n                new_path = path + [adjacent]\n                queue.append((adjacent, new_path))\n\n    def adjacent_nodes(self, node):\n        \"\"\"\n        Returns a list of nodes adjacent to the given 'node'.\n        \n        :param node: The node for which adjacent nodes are retrieved.\n        :return: A list of nodes adjacent to the given 'node'.\n        \"\"\"\n        # Replace this with your actual adjacent node retrieval logic\n        # For example, you might have an adjacency list representation of the graph\n        # and this method would return the corresponding list of adjacent nodes.\n        pass",
        "def avg_diagonal_elem_n(matrix):\n    assert isinstance(matrix, list) and all(isinstance(row, list) for row in matrix)\n    assert len(matrix) == len(matrix[0])\n\n    n = len(matrix)\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum / n"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]",
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef average_diagonal_elements_n(matrix):\n    try:\n        num_rows = len(matrix)\n        num_cols = len(matrix[0])\n\n        if num_rows != num_cols:\n            raise ValueError(\"Matrix must be square\")\n\n        diagonal_sum = sum(matrix[i][i] for i in range(num_rows))\n        diagonal_average = diagonal_sum / num_rows\n\n        assert num_rows == num_cols, \"Matrix must be square\"\n        return diagonal_average\n\n    except IndexError:\n        raise ValueError(\"Invalid matrix dimensions\")\n    except TypeError:\n        raise TypeError(\"Input must be a matrix (list of lists)\")\n```",
        "```python\nimport pandas as pd\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self):\n        self.model = Lasso()\n\n    def train(self, X_train, y_train):\n        try:\n            # Ensure X_train and y_train are pandas DataFrames\n            assert isinstance(X_train, pd.DataFrame), \"X_train must be a pandas DataFrame\"\n            assert isinstance(y_train, pd.DataFrame), \"y_train must be a pandas DataFrame\"\n\n            # Ensure X_train and y_train have the same number of samples\n            assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n\n            # Fit the Lasso model\n            self.model.fit(X_train, y_train.values.ravel())\n        except Exception as e:\n            raise RuntimeError(f\"Error occurred while training the Lasso model: {str(e)}\")\n\n    def predict(self, X_test):\n        try:\n            # Ensure X_test is a pandas DataFrame\n            assert isinstance(X_test, pd.DataFrame), \"X_test must be a pandas DataFrame\"\n\n            # Predict using the trained Lasso model\n            return self.model.predict(X_test)\n        except Exception as e:\n            raise RuntimeError(f\"Error occurred while making predictions: {str(e)}\")\n\n# Example usage:\n# from lasso_regression import LassoRegression\n\n# ...\n# Train the model\n# ...\n\n# # Make predictions\n# ...\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_dijsktra(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt = set()\n\n        for _ in range(self.V):\n            u = self.min_distance(dist, spt)\n            spt.add(u)\n            for v in range(self_V):\n                if self.graph[u][v] != 0 and v not in spt:\n                    dist[v] = min(dist[v], dist[u] + self.graph[u][v])\n\n        # Code for printing the shortest distance from source to all other vertices\n        for i in range(self.V):\n            print(f\"Vertex {i} is at distance {dist[i]} from source\")\n\n    def min_distance(self, dist, spt):\n        # Initialize min value\n        min = float('inf')\n        # Search not yet processed vertices\n        for v in range(self.V):\n            if v not in spt and dist[v] <= min:\n                min = dist[v]\n                min_index = v\n        return min_index\n```"
      ]
    }
  ]
}