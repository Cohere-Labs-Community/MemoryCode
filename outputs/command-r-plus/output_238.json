{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(j_vec1, j_vec2):\n    sum = 0\n    for i in range(len(j_vec1)):\n        sum += j_vec1[i] * j_vec2[i]\n    return sum"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(j_vector_1, j_vector_2):\n    return sum(a * b for a, b in zip(j_vector_1, j_vector_2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(self, h_vector1, h_vector2):\n    try:\n        if len(h_vector1) != len(h_vector2):\n            raise ValueError(\"Vectors must have the same length for dot product.\")\n        return sum(a * b for a, b in zip(h_vector1, h_vector2))\n    except TypeError:\n        raise TypeError(\"Vector elements must be numeric.\")\n    except ValueError as ve:\n        raise ValueError(f\"ValueError: {ve}\")\n```",
        "class LassoRegression:\n    def __init__(self, h_alpha=1.0):\n        self.h_alpha = h_alpha\n        self.h_coefficients = None\n\n    def train(self, h_x, h_y):\n        try:\n            import numpy as np\n\n            self.h_coefficients = np.linalg.inv(h_x.T @ h_x + self.h_alpha * np.eye(h_x.shape[1])) @ h_x.T @ h_y\n        except Exception as e:\n            raise RuntimeError(\"Error occurred while training the Lasso Regression model.\") from e\n\n    def predict(self, h_x):\n        try:\n            import numpy as np\n\n            return h_x @ self.h_coefficients\n        except Exception as e:\n            raise RuntimeError(\"Error occurred while making predictions with the Lasso Regression model.\") from e"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(h_vec1, h_vec2):\n    return sum(a * b for a, b in zip(h_vec1, h_vec2))\n```",
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product_x(v1, v2):\n    \"\"\"Compute the dot product of two vectors.\n\n    Args:\n        v1 (list): The first vector.\n        v2 (list): The second vector.\n\n    Returns:\n        float: The dot product of v1 and v2.\n    \"\"\"\n    f_result = 0.0\n    for i in range(len(v1)):\n        f_result += v1[i] * v2[i]\n    return f_result\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)]\n                      for _ in range(vertices)]\n\n    # Method to add an edge to the graph\n    def add_edge(self, u: int, v: int, w: int):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    # Method to find the shortest path using Dijkstra's algorithm\n    def shortest_path_dijkstra(self, src: int):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n        spt_set = set()\n\n        for _ in range(self.V):\n            # Pick the minimum distance vertex from\n            # the set of vertices not yet included in the\n            # shortest path tree\n            min_dist_v = None\n            for v in range(self.V):\n                if v not in spt_set and dist[v] < dist[min_dist_v] if min_dist_v else True:\n                    min_dist_v = v\n\n            # Put the minimum distance vertex into the\n            # shortest path tree set\n            spt_set.add(min_dist_v)\n\n            # Update the distance value of all adjacent vertices\n            # of the picked vertex only if the current distance\n            # is greater than the new distance and the vertex is\n            # not in the shortest path tree\n            for v in range(self.V):\n                if self.graph[min_dist_v][v] > 0 and min_dist_v not in spt_set:\n                    if dist[v] > dist[min_dist_v] + self.graph[min_dist_v][v]:\n                        dist[v] = dist[min_dist_v] + self.graph[min_dist_v][v]\n\n        # Print the shortest distance from the source to all vertices\n        for i in range(self.V):\n            print(f\"Source {src} to {i}: {dist[i]}\")\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    return sum(a * b for a, b in zip(f_vector1, f_vector2))\n```",
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n    \"\"\"\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the Nearest Neighbors model.\n        \n        Profiller for performance analysis.\n        \n        :param X_train: Training data.\n        :type X_train: numpy.array\n        :param y_train: Target values for training data.\n        :type y_train: numpy.array\n        \"\"\"\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training samples must match number of target values.\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict target values for test data using the trained model.\n        \n        :param X_test: Test data.\n        :type X_test: numpy.array\n        :return: Predicted target values.\n        :rtype: numpy.array\n        \"\"\"\n        assert self.X_train is not None and self.y_train is not None, \"Model must be trained before making predictions.\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Number of features in test data must match training data.\"\n        \n        # Placeholder code, replace with actual prediction logic\n        # ...\n        # Return predicted target values for X_test\n        return None"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_get_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strs.sort()\n\n    # Get the first and last string in the sorted list\n    first = strs[0]\n    last = strs[-1]\n\n    # Find the common prefix between the first and last string\n    i = 0\n    while i < len(first) and i < len(last):\n        if first[i] != last[i]:\n            break\n        i += 1\n\n    return first[:i]\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.heapify(len(self.heap) - 1)\n\n    def heapify(self, index):\n        parent_index = (index - 1) // 2\n\n        if self.heap[index] > self.heap[parent_index]:\n            self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n            self.heapify(parent_index)\n\n    def chx_to_string(self):\n        \"\"\"\n        Docstring: Generates a string representation of the heap.\n        \"\"\"\n        return str(self.heap)\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def shortest_path_b(self, start_node_b, end_node_b):\n        # Initialize distances and predecessors\n        distances_b = {node: float('inf') for node in self.nodes_b}\n        predecessors_b = {node: None for node in self.nodes_b}\n        distances_b[start_node_b] = 0\n\n        # Create a set of unvisited nodes\n        unvisited_nodes_b = set(self.nodes_b)\n\n        # Main loop of Dijkstra's algorithm\n        while unvisited_nodes_b:\n            current_node_b = min(unvisited_nodes_b, key=lambda node: distances_b[node])\n            unvisited_nodes_b.remove(current_node_b)\n\n            # Explore neighbors of the current node\n            for neighbor, weight in self.get_neighbors_b(current_node_b).items():\n                new_distance_b = distances_b[current_node_b] + weight\n                if new_distance_b < distances_b[neighbor]:\n                    distances_b[neighbor] = new_distance_b\n                    predecessors_b[neighbor] = current_node_b\n\n        # Extract the shortest path from the predecessors dictionary\n        shortest_path_b = []\n        node = end_node_b\n        while node is not None:\n            shortest_path_b.insert(0, node)\n            node = predecessors_b[node]\n\n        return shortest_path_b, distances_b[end_node_b]\n\n    # Other methods and properties of the Graph class\n    # ...\n```",
        "def compute_dot_product_b(v1, v2):\n    \"\"\"Compute the dot product of two vectors.\n\n    Args:\n        v1 (list): The first vector.\n        v2 (list): The second vector.\n\n    Returns:\n        float: The dot product of v1 and v2.\n    \"\"\"\n    result_b = 0.0\n    for i in range(len(v1)):\n        result_b += v1[i] * v2[i]\n    return result_b"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path",
        "```python\ndef dot_product(e_vector1, e_vector2):\n    return sum(a * b for a, b in zip(e_vector1, e_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def common_elements(list1, list2):\n    return list(set(list1) & set(list2))"
      ],
      "instruction_model_output": [
        "def get_common_elements(list1_1, list2_2):\n    return list(set(list1_1) & set(list2_2))"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    # method to add an edge to the graph\n    def add_edge(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    # method to find the shortest path using Dijkstra's algorithm\n    def shortest_path_dijsktra(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = set()\n\n        for _ in range(self.V):\n            # Pick the minimum distance vertex from the set of vertices\n            # not yet included in the shortest path tree\n            u = self._find_min_distance(dist, spt_set)\n\n            # Mark the picked vertex as processed\n            spt_set.add(u)\n\n            # Update dist value of the adjacent vertices of the\n            # picked vertex only if the current distance is greater\n            # than the new distance and the vertex is not in the\n            # shortest path tree\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and v not in spt_set:\n                    if dist[v] > dist[u] + self.graph[u][v]:\n                        dist[v] = dist[u] + self.graph[u][v]\n\n        # print all distance\n        for i in range(self.V):\n            print(f\"Vertex {i} is at distance {dist[i]} from source\")\n\n    # Method to find a vertex with minimum distance value\n    # that is not yet included in the shortest path tree\n    def _find_min_distance(self, dist, spt_set):\n        # Initialize min value\n        min = float('inf')\n        # Initialize vertex number\n        vertex = -1\n\n        for v in range(self.V):\n            if dist[v] < min and v not in spt_set:\n                min = dist[v]\n                vertex = v\n\n        return vertex\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_p(self, src, dest):\n        visited = [False] * self.V\n        path = []\n        self._shortest_path_util_p(src, dest, visited, path)\n        return path\n\n    def _shortest_path_util_p(self, src, dest, visited, path):\n        visited[src] = True\n        path.append(src)\n        if src == dest:\n            return True\n        for i in self.graph[src]:\n            if not visited[i]:\n                if self._shortest_path_util_p(i, dest, visited, path):\n                    return True\n        path.pop()\n        return False\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_flatten_binary_tree(root):\n    if not root:\n        return None\n\n    left = chx_flatten_binary_tree(root.left)\n    right = chx_flatten_binary_tree(root.right)\n\n    if left:\n        temp = left\n        while temp.right:\n            temp = temp.right\n        temp.right = root\n        root.left = None\n\n    if right:\n        root.right = right\n\n    return root\n```"
      ],
      "instruction_model_output": [
        "def flatten_binary_tree_to_linked_list_chx(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    if root.left:\n        temp = flatten_binary_tree_to_linked_link_chx(root.left)\n        while temp.right:\n            temp = temp.right\n        temp.right = root.right\n        root.right = root.left\n        root.left = None\n    return flatten_binary_tree_to_linked_list_chx(root.right)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(self, vec1: list[float], vec2: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Parameters\n    ----------\n    vec1 : list[float]\n        The first vector.\n    vec2 : list[float]\n        The second vector.\n\n    Returns\n    -------\n    float\n        The dot product of vec1 and vec2.\n    \"\"\"\n    return sum(x_vec1 * x_vec2 for x_vec1, x_vec2 in zip(vec1, vec2))\n```",
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, x_new_value):\n        \"\"\"Insert a new node with the given value into the binary tree.\n\n        Args:\n            x_new_value (int or float): The value to be inserted into the binary tree.\n        \"\"\"\n        if self.root is None:\n            self.root = Node(x_new_value)\n        else:\n            self._insert_recursive(self.root, x_new_value)\n\n    def _insert_recursive(self, x_current_node, x_new_value):\n        if x_new_value < x_current_node.value:\n            if x_current_node.left is None:\n                x_current_node.left = Node(x_new_value)\n            else:\n                self._insert_recursive(x_current_node.left, x_new_value)\n        else:\n            if x_current_node.right is None:\n                x_current_node.right = Node(x_new_value)\n            else:\n                self._insert_recursive(x_current_node.right, x_new_value)\n\n    def delete(self, x_value):\n        \"\"\"Delete a node with the given value from the binary tree.\n\n        Args:\n            x_value (int or float): The value of the node to be deleted from the binary tree.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, x_value)\n\n    def _delete_recursive(self, x_current_node, x_value):\n        if x_current_node is None:\n            return x_current_node\n\n        if x_value < x_current_node.value:\n            x_current_node.left = self._delete_recursive(x_current_node.left, x_value)\n        elif x_value > x_current_node.value:\n            x_current_node.right = self._delete_recursive(x_current_node.right, x_value)\n        else:\n            if x_current_node.left is None:\n                return x_current_node.right\n            elif x_current_node.right is None:\n                return x_current_node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            x_current_node.value = self._get_inorder_successor(x_current_node.right)\n            x_current_node.right = self._delete_recursive(x_current_node.right, x_current_node.value)\n\n        return x_current_node\n\n    def _get_inorder_successor(self, x_node):\n        \"\"\"Helper function to find the inorder successor (smallest value in the right subtree).\"\"\"\n        while x_node.left is not None:\n            x_node = x_node.left\n        return x_node.value\n\nclass Node:\n    def __init__(self, x_value):\n        self.value = x_value\n        self.left = None\n        self.right = None"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(x_vec1, x_vec2):\n    return sum(a * b for a, b in zip(x_vec1, x_vec2))\n```",
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int, char: str = 'f_') -> None:\n        self.root = self._insert(self.root, value, char)\n\n    def _insert(self, node, value: int, char: str = 'f_') -> 'Node':\n        if node is None:\n            return Node(value, char=char)\n        if value < node.value:\n            node.left = self._insert(node.left, value, char)\n        else:\n            node.right = self._insert(node.right, value, char)\n        return node\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(self.root, value)\n\n    def _delete(self, node, value: int) -> 'Node':\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete(node.left, value)\n        elif value > node.value:\n            node.right = self._delete(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._get_min_value(node.right, 'x_')\n            node.right = self._delete(node.right, node.value)\n        return node\n\n    def _get_min_value(self, node, char: str = 'x_') -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n    def get_values(self) -> list[int]:\n        values = []\n        self._get_values(self.root, values)\n        return values\n\n    def _get_values(self, node, values: list[int]) -> None:\n        if node is None:\n            return\n        self._get_values(node.left, values)\n        values.append(node.value)\n        self._get_values(node.right, values)\n\nclass Node:\n    def __init__(self, value: int, char: str = 'f_'):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.char = char\n```",
        "```python\ndef dot_product(vec1: list[float], vec2: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vec1 (list[float]): The first vector.\n        vec2 (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of vec1 and vec2.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must have the same length\"\n    return sum(vec1[f_i] * vec2[f_i] for f_i in range(len(vec1)))\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def insert(self, e):\n        self.heap.append(e)\n        self.heapify_up(len(self.heap) - 1)\n\n    def heapify_up(self, i):\n        e = self.heap[i]\n        while i > 0 and self.heap[self.parent(i)] < e:\n            self.heap[i] = self.heap[self.parent(i)]\n            i = self.parent(i)\n        self.heap[i] = e\n\n    def heapify_down(self, i):\n        e = self.heap[i]\n        lc = self.left_child(i)\n        rc = self.right_child(i)\n        largest = i\n        if lc < len(self.heap) and self.heap[lc] > self.heap[largest]:\n            largest = lc\n        if rc < len(self.heap) and self.heap[rc] > self.heap[largest]:\n            largest = rc\n        if largest != i:\n            self.heap[i] = self.heap[largest]\n            i = largest\n            self.heapify_down(i)\n\n    def extract_max(self):\n        if len(self.heap) == 0:\n            return None\n        max_val = self.heap[0]\n        self.heap[0] = self.heap.pop(-1)\n        self.heapify_down(0)\n        return max_val\n```",
        "```python\nimport pandas as pd\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    \"\"\"\n    Lasso Regression model for prediction.\n    \"\"\"\n\n    def __init__(self, alpha=1.0):\n        \"\"\"\n        Initialize the Lasso Regression model.\n\n        Parameters:\n            alpha (float): The regularization strength. Must be a positive float.\n                            Default is 1.0.\n        \"\"\"\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train: pd.DataFrame, y_train: pd.Series) -> None:\n        \"\"\"\n        Train the Lasso Regression model.\n\n        Parameters:\n            X_train (pd.DataFrame): The input training data.\n            y_train (pd.Series): The target training data.\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Predict using the trained Lasso Regression model.\n\n        Parameters:\n            X_test (pd.DataFrame): The input data for prediction.\n\n        Returns:\n            pd.Series: Predicted values.\n        \"\"\"\n        return pd.Series(self.model.predict(X_test))\n```",
        "```python\ndef find_longest_common_prefix(strs: list[str]) -> str:\n    if not strs:\n        return \"\"\n\n    # Initialize the result as the first string\n    result = strs[0]\n\n    # Iterate through the characters of the result string\n    for i, char in enumerate(result):\n        # Check if all strings have the same character at this position\n        if any(strs[index][i] != char for index in range(len(strs))):\n            # If not, truncate the result string up to the current position\n            result = result[:i]\n            break\n\n    return result\n```",
        "```python\ndef flatten_binary_tree(tree):\n    if not tree:\n        return None\n    result = Node(tree.value)\n    current = result\n    stack = [tree.left, tree.right]\n    while stack:\n        node = stack.pop(0)\n        if node:\n            temp = Node(node.value)\n            current.next = temp\n            current = temp\n            stack.append(node.left)\n            stack.append(node.right)\n    return result\n\nclass Node:\n    def __init__(self, value, left=None, right=None, next=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        self.next = next\n```",
        "```python\nimport numpy as np\n\n\nclass NearestNeighborsModel:\n    \"\"\"\n    A class to implement a Nearest Neighbors model.\n    \"\"\"\n\n    def __init__(self):\n        self.model = None\n\n    def train(self, X_train: np.array, y_train: np.array) -> None:\n        \"\"\"\n        Trains the Nearest Neighbors model.\n\n        Args:\n            X_train (np.array): The training input data.\n            y_train (np.array): The training target values.\n        \"\"\"\n        from sklearn.neighbors import NearestNeighbors\n\n        self.model = NearestNeighbors(n_neighbors=1)\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: np.array) -> np.array:\n        \"\"\"\n        Predicts the target values for the given test data.\n\n        Args:\n            X_test (np.array): The test input data.\n\n        Returns:\n            np.array: The predicted target values.\n        \"\"\"\n        return self.model.kneighbors(X_test, return_distance=False)\n```",
        "```python\ndef find_common_elements(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Returns a list of common elements between list1 and list2.\n\n    Args:\n        list1 (list[int]): The first list of integers.\n        list2 (list[int]): The second list of integers.\n\n    Returns:\n        list[int]: A list of common elements between the two input lists.\n    \"\"\"\n    common_elements = []\n    for element in list1:\n        if element in list2:\n            common_elements.append(element)\n    return common_elements\n```",
        "```python\nimport networkx as nx\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = nx.Graph()\n        self.vertices = vertices\n        # Initialize the graph with vertices\n        for vertex in vertices:\n            self.graph.add_node(vertex)\n\n    def add_edge(self, u, v, weight=0):\n        self.graph.add_edge(u, v, weight=weight)\n\n    def shortest_path(self, start, end, profiler=None):\n        assert start in self.vertices, \"Start node is not in the graph\"\n        assert end in self.vertices, \"End node is not in the graph\"\n        try:\n            # Use a profiler if instructed\n            if profiler:\n                profiler.start_profiling()\n            # Use networkx to find the shortest path\n            path = nx.shortest_path(self.graph, start, end, weight='weight')\n            if profiler:\n                profiler.stop_profiling()\n            return path\n        except nx.NetworkXNoPath:\n            return None\n        except nx.NetworkXError as e:\n            print(f\"Error: {e}\")\n            return None\n\n# Example usage:\n# g = Graph(['A', 'B', 'C', 'D'])\n# g.add_edge('A', 'B', weight=4)\n# g.add_edge('A', 'C', weight=2)\n# g.add_edge('B', 'D', weight=5)\n# g.add_edge('C', 'D', weight=1)\n# print(g.shortest_path('A', 'D'))\n```"
      ]
    }
  ]
}