{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    def __init__(self):\n        self.head_s = None\n        self.tail_s = None\n\n    def append(self, value):\n        new_node = Node(value)\n        if not self.head_s:\n            self.head_s = new_node\n            self.tail_s = new_node\n        else:\n            self.tail_s.next_s = new_node\n            self.tail_s = new_node\n\n    def delete(self, value):\n        current_s = self.head_s\n        if current_s and current_s.value_s == value:\n            self.head_s = current_s.next_s\n            return\n        prev_s = None\n        while current_s and current_s.value_s != value:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if current_s is None:\n            return\n        prev_s.next_s = current_s.next_s\n        if current_s == self.tail_s:\n            self.tail_s = prev_s\n\n    def display(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.value_s, end=\" -> \")\n            current_s = current_s.next_s\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value):\n        self.value_s = value\n        self.next_s = None"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node_s = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_node_s = None\n        self.tail_node_s = None\n        self.size_s = 0\n\n    def append(self, data):\n        new_node_s = Node(data)\n        if not self.head_node_s:\n            self.head_node_s = new_node_s\n            self.tail_node_s = self.head_node_s\n        else:\n            current_node_s = self.head_node_s\n            while current_node_s.next_node_s:\n                current_node_s = current_node_s.next_node_s\n            current_node_s.next_node_s = new_node_s\n            self.tail_node_s = new_node_s\n        self.size_s += 1\n\n    def delete(self, data):\n        current_node_s = self.head_node_s\n        prev_node_s = None\n        while current_node_s and current_node_s.data == data:\n            prev_node_s = current_node_s\n            current_node_s = current_node_s.next_node_s\n        if prev_node_s:\n            prev_node_s.next_node_s = current_node_s.next_node_s\n            if current_node_s == self.tail_node_s:\n                self.tail_node_s = prev_node_s\n            self.size_s -= 1\n\n    def display(self):\n        current_node_s = self.head_node_s\n        while current_node_s:\n            print(current_node_s.data, end=\" -> \")\n            current_node_s = current_node_s.next_node_s\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, value_j):\n        if self.head_xt is None:\n            self.head_xt = Node(value_j)\n        else:\n            current_xt = self.head_xt\n            while current_xt.next_j:\n                current_xt = current_xt.next_j\n            current_xt.next_j = Node(value_j)\n\n    def delete(self, value_j):\n        if self.head_xt is None:\n            return\n        if self.head_xt.value_xt == value_j:\n            self.head_xt = self.head_xt.next_j\n        else:\n            current_xt = self.head_xt\n            while current_xt.next_j and current_xt.next_j.value_xt != value_j:\n                current_xt = current_xt.next_j\n            if current_xt.next_j:\n                current_xt.next_j = current_xt.next_j.next_j\n\n    def display(self):\n        current_xt = self.head_xt\n        while current_xt:\n            print(current_xt.value_xt, end=\" -> \")\n            current_xt = current_xt.next_j\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value_j):\n        self.value_xt = value_j\n        self.next_j = None\n```",
        "def merge_sorted_lists(list1_xt, list2_xt):\n    result_j = []\n    i, j = 0, 0\n\n    while i < len(list1_xt) and j < len(list2_xt):\n        if list1_xt[i] < list2_xt[j]:\n            result_j.append(list1_xt[i])\n            i += 1\n        else:\n            result_j.append(list2_xt[j])\n            j += 1\n\n    result_j.extend(list1_xt[i:])\n    result_j.extend(list2_xt[j:])\n\n    return result_j"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_xt = data\n        self.next_xt = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_xt:\n            self.head_xt = new_node\n            return\n        current = self.head_xt\n        while current.next_xt:\n            current = current.next_xt\n        current.next_xt = new_node\n\n    def delete(self, data):\n        if not self.head_xt:\n            return\n        if self.head_xt.data_xt == data:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current = self.head_xt\n        prev = None\n        while current and current.data_xt != data:\n            prev = current\n            current = current.next_xt\n        if not current:\n            return\n        prev.next_xt = current.next_xt\n\n    def display(self):\n        current = self.head_xt\n        while current:\n            print(current.data_xt, end=\" -> \")\n            current = current.next_xt\n        print(\"None\")\n```",
        "def merge_sorted_lists(list1_j, list2_j):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            merged_list.append(list1_j[i])\n            i += 1\n        else:\n            merged_list.append(list2_j[j])\n            j += 1\n    \n    while i < len(list1_j):\n        merged_list.append(list1_j[i])\n        i += 1\n    \n    while j < len(list2_j):\n        merged_list.append(list2_j[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, value_j):\n        if self.head_j is None:\n            self.head_j = Node(value_j)\n        else:\n            current_j = self.head_j\n            while current_j.next_j:\n                current_j = current_j.next_j\n            current_j.next_j = Node(value_j)\n\n    def delete(self, value_j):\n        if self.head_j is None:\n            return\n        if self.head_j.value_j == value_j:\n            self.head_j = self.head_j.next_j\n            return\n        current_j = self.head_j\n        prev_j = None\n        while current_j and current_j.value_j != value_j:\n            prev_j = current_j\n            current_j = current_j.next_j\n        if current_j is None:\n            return\n        prev_j.next_j = current_j.next_j\n\n    def display(self):\n        current_j = self.head_j\n        while current_j:\n            print(current_j.value_j, end=\" -> \")\n            current_j = current_j.next_j\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value_j, next_j=None):\n        self.value_j = value_j\n        self.next_j = next_j",
        "def merge_sorted_lists(list1_j, list2_j) -> list:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1_j (list): The first sorted list.\n        list2_j (list): The second sorted list.\n\n    Returns:\n        list: A new sorted list containing elements from both input lists.\n    \"\"\"\n    merged_list_j = []\n    i, j = 0, 0\n\n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            merged_list_j.append(list1_j[i])\n            i += 1\n        else:\n            merged_list_j.append(list2_j[j])\n            j += 1\n\n    while i < len(list1_j):\n        merged_list_j.append(list1_j[i])\n        i += 1\n\n    while j < len(list2_j):\n        merged_list_j.append(list2_j[j])\n        j += 1\n\n    return merged_list_j"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_j):\n        self.data_j = data_j\n        self.next_j = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data_j):\n        if not self.head_j:\n            self.head_j = Node(data_j)\n        else:\n            curr_j = self.head_j\n            while curr_j.next_j:\n                curr_j = curr_j.next_j\n            curr_j.next_j = Node(data_j)\n\n    def display(self):\n        curr_j = self.head_j\n        while curr_j:\n            print(curr_j.data_j, end=\" -> \")\n            curr_j = curr_j.next_j\n        print(\"None\")\n```",
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_a, list2_a):\n    result_at = []\n    i, j = 0, 0\n\n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            result_at.append(list1_a[i])\n            i += 1\n        else:\n            result_at.append(list2_a[j])\n            j += 1\n\n    result_at.extend(list1_a[i:])\n    result_at.extend(list2_a[j:])\n\n    return result_at",
        "```python\nclass Node:\n    def __init__(self, data_a: int, next_node_n=None) -> None:\n        self.data_a = data_a\n        self.next_node_n = next_node_n\n\n\nclass LinkedList:\n    def __init__(self) -> None:\n        self.head_n = None\n\n    def append_node(self, data_a: int) -> None:\n        new_node_n = Node(data_a)\n        if not self.head_n:\n            self.head_n = new_node_n\n        else:\n            current_node_n = self.head_n\n            while current_node_n.next_node_n:\n                current_node_n = current_node_n.next_node_n\n            current_node_n.next_node_n = new_node_n\n\n    def display(self) -> None:\n        current_node_n = self.head_n\n        while current_node_n:\n            print(current_node_n.data_a, end=\" -> \")\n            current_node_n = current_node_n.next_node_n\n        print(\"None\")\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_at = data\n        self.next_at = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n        self.tail_at = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_at:\n            self.head_at = new_node\n            self.tail_at = self.head_at\n        else:\n            self.tail_at.next_at = new_node\n            self.tail_at = new_node\n\n    def delete(self, data):\n        if self.head_at is None:\n            return\n\n        if self.head_at.data_at == data:\n            self.head_at = self.head_at.next_at\n            return\n\n        prev_node = self.head_at\n        curr_node = self.head_at.next_at\n        while curr_node:\n            if curr_node.data_at == data:\n                prev_node.next_at = curr_node.next_at\n                return\n            prev_node = curr_node\n            curr_node = curr_node.next_at\n\n    def display(self):\n        current = self.head_at\n        while current:\n            print(current.data_at, end=\" -> \")\n            current = current.next_at\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_i, list2_i):\n    i_1, i_2 = 0, 0\n    merged_list_i = []\n\n    while i_1 < len(list1_i) and i_2 < len(list2_i):\n        if list1_i[i_1] < list2_i[i_2]:\n            merged_list_i.append(list1_i[i_1])\n            i_1 += 1\n        else:\n            merged_list_i.append(list2_i[i_2])\n            i_2 += 1\n\n    merged_list_i.extend(list1_i[i_1:])\n    merged_list_i.extend(list2_i[i_2:])\n\n    return merged_list_i\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n    \"\"\"\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the Nearest Neighbors model.\n        \n        Args:\n        X_train (ndarray): Training data of shape (n_samples, n_features).\n        y_train (ndarray): Target values of shape (n_samples,).\n        \"\"\"\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training samples and target values must match.\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict the target values for the test data.\n        \n        Args:\n        X_test (ndarray): Test data of shape (n_samples, n_features).\n        \n        Returns:\n        ndarray: Predicted target values of shape (n_samples,).\n        \"\"\"\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet.\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Number of features in test data must match the trained data.\"\n\n        predictions = []\n        for x_test in X_test:\n            distances = np.linalg.norm(self.X_train - x_test, axis=1)\n            nearest_indices = np.argsort(distances)[:self.n_neighbors]\n            nearest_neighbors = self.y_train[nearest_indices]\n            prediction = np.median(nearest_neighbors)\n            predictions.append(prediction)\n        return np.array(predictions)"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\n\n\nclass BinaryTree:\n    \"\"\"A binary tree data structure.\n\n    This class provides methods to insert and delete nodes in the binary tree.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\"\"\"\n        self.root = None\n\n    @rename_kwargs(\"new_value\")\n    def insert(self, value: int, parent_value: int = None) -> None:\n        \"\"\"Insert a new node with the given value into the binary tree.\n\n        Args:\n            value (int): The value of the new node.\n            parent_value (int, optional): The value of the parent node. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        new_node = Node(value)\n        if not self.root:\n            self.root = new_node\n        else:\n            self._insert_recursive(new_node, self.root, parent_value)\n\n    def _insert_recursive(self, new_node, current_node, parent_value):\n        if new_node.value < current_node.value:\n            if not current_node.left or parent_value is not None:\n                if current_node.left and current_node.left.value == parent_value:\n                    current_node.left = new_node\n                else:\n                    current_node.left = new_node\n                    return\n            self._insert_recursive(new_node, current_node.left, parent_value)\n        else:\n            if not current_node.right or parent_value is not None:\n                if current_node.right and current_node.right.value == parent_value:\n                    current_node.right = new_node\n                else:\n                    current_node.right = new_node\n                    return\n            self._insert_recursive(new_node, current_node.right, parent_value)\n\n    @rename_kwargs(\"value_to_delete\")\n    def delete(self, value: int) -> None:\n        \"\"\"Delete the first node with the given value from the binary tree.\n\n        Args:\n            value (int): The value of the node to be deleted.\n\n        Returns:\n            None\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, root, value_to_delete):\n        if not root:\n            return root\n\n        if value_to_delete < root.value:\n            root.left = self._delete_recursive(root.left, value_to_delete)\n        elif value_to_delete > root.value:\n            root.right = self._delete_recursive(root.right, value_to_delete)\n        else:\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n\n            root.value = self._get_min_value(root.right)\n            root.right = self._delete_recursive(root.right, root.value)\n\n        return root\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "```python\nfrom pedantic import rename_kwargs\n\n\n@rename_kwargs\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor of two integers.\n\n    This function takes two integers 'a' and 'b' and returns the largest number that divides both of them.\n\n    Parameters\n    ----------\n    a: int\n        The first integer\n    b: int\n        The second integer\n\n    Returns\n    -------\n    int\n        The greatest common divisor of 'a' and 'b'\n\n    Examples\n    --------\n    >>> greatest_common_divisor(10, 15)\n    5\n    >>> greatest_common_divisor(-12, 18)\n    6\n\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "from pedantic.decorators import rename_kwargs\r\n\r\n@rename_kwargs\r\ndef gcd(a: int, b: int) -> int:\r\n    while b:\r\n        a, b = b, a % b\r\n    return a"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value: int) -> None:\n        self.value = value\n        self.left_r = None\n        self.right_r = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root_r = None\n\n    def insert(self, value: int) -> None:\n        if not self.root_r:\n            self.root_r = Node(value)\n        else:\n            self._insert_recursive(value, self.root_r)\n\n    def _insert_recursive(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left_r is None:\n                node.left_r = Node(value)\n            else:\n                self._insert_recursive(value, node.left_r)\n        else:\n            if node.right_r is None:\n                node.right_r = Node(value)\n            else:\n                self._insert_recursive(value, node.right_r)\n\n    def delete(self, value: int) -> None:\n        self.root_r = self._delete_recursive(self.root_r, value)\n\n    def _delete_recursive(self, node: Node, value: int) -> Node:\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left_r = self._delete_recursive(node.left_r, value)\n        elif value > node.value:\n            node.right_r = self._delete_recursive(node.right_r, value)\n        else:\n            if node.left_r is None:\n                return node.right_r\n            elif node.right_r is None:\n                return node.left_r\n\n            min_val_node = self._find_min_value_node(node.right_r)\n            node.value = min_val_node.value\n            node.right_r = self._delete_recursive(node.right_r, min_val_node.value)\n\n        return node\n\n    def _find_min_value_node(self, node: Node) -> Node:\n        current = node\n        while current.left_r is not None:\n            current = current.left_r\n        return current\n```",
        "```python\nclass LinkedList:\n    \"\"\"\n    A linked list data structure.\n    \"\"\"\n    def __init__(self):\n        self.head_r = None\n        self.tail_r = None\n\n    def push(self, data):\n        \"\"\"\n        Pushes a new node with the given data to the end of the linked list.\n        :param data: The data to be stored in the new node.\n        \"\"\"\n        new_node_r = Node(data)\n        if not self.head_r:\n            self.head_r = new_node_r\n            self.tail_r = new_node_r\n        else:\n            self.tail_r.next_r = new_node_r\n            self.tail_r = new_node_r\n\n    def pop(self):\n        \"\"\"\n        Pops the last node from the linked list and returns its data.\n        :return: The data of the last node.\n        \"\"\"\n        if not self.head_r:\n            return None\n        current_r = self.head_r\n        prev_r = None\n        while current_r.next_r:\n            prev_r = current_r\n            current_r = current_r.next_r\n        if prev_r:\n            prev_r.next_r = None\n        self.tail_r = prev_r\n        return current_r.data_r\n\n    def get_middle(self):\n        \"\"\"\n        Returns the data of the middle node of the linked list.\n        :return: The data of the middle node, or None if the list is empty.\n        \"\"\"\n        slow_ptr_r = self.head_r\n        fast_ptr_r = self.head_r\n        while fast_ptr_r and fast_ptr_r.next_r:\n            slow_ptr_r = slow_ptr_r.next_r\n            fast_ptr_r = fast_ptr_r.next_r.next_r\n        return slow_ptr_r.data_r if slow_ptr_r else None\n\nclass Node:\n    \"\"\"\n    A node in the linked list.\n    \"\"\"\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    result_x = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            result_x.append(list1_x[i])\n            i += 1\n        else:\n            result_x.append(list2_x[j])\n            j += 1\n    result_x.extend(list1_x[i:])\n    result_x.extend(list2_x[j:])\n    return result_x\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    # 6: method to add an edge to the graph\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    # 7: method to check if there is a cycle in the directed graph\n    def is_cycle(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.graph[v]:\n            if not visited[neighbour]:\n                if self.is_cycle(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def has_cycle(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n        for i in range(self.V):\n            if not visited[i]:\n                if self.is_cycle(i, visited, rec_stack):\n                    return True\n        return False"
      ],
      "instruction_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(vertices)]\n\n    def add_edge1(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic9(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    result_e = []\n    i, j = 0, 0\n\n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            result_e.append(list1_e[i])\n            i += 1\n        else:\n            result_e.append(list2_e[j])\n            j += 1\n\n    result_e.extend(list1_e[i:])\n    result_e.extend(list2_e[j:])\n\n    return result_e"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            merged_list.append(list1_e[i])\n            i += 1\n        else:\n            merged_list.append(list2_e[j])\n            j += 1\n    \n    while i < len(list1_e):\n        merged_list.append(list1_e[i])\n        i += 1\n    \n    while j < len(list2_e):\n        merged_list.append(list2_e[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer\nfrom typing import Optional\n\n\n@timer\ndef has_cycle(head_f: Optional['Node']) -> bool:\n    if not head_f:\n        return False\n\n    slow_f = head_f\n    fast_f = head_f.next_f\n\n    while fast_f and fast_f.next_f:\n        slow_f = slow_f.next_f\n        fast_f = fast_f.next_f.next_f\n\n        if slow_f == fast_f:\n            return True\n\n    return False\n```",
        "from pedantic import timer\n\n@timer\ndef merge_sorted_lists(list1_f: list[int], list2_f: list[int]) -> list[int]:\n    merged_list_f = []\n    i, j = 0, 0\n\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list_f.append(list1_f[i])\n            i += 1\n        else:\n            merged_list_f.append(list2_f[j])\n            j += 1\n\n    while i < len(list1_f):\n        merged_list_f.append(list1_f[i])\n        i += 1\n\n    while j < len(list2_f):\n        merged_list_f.append(list2_f[j])\n        j += 1\n\n    return merged_list_f"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import timer\nfrom typing import Optional\n\n\n@timer\ndef has_cycle(head: Optional[Node]) -> bool:\n    if not head or not head.next:\n        return False\n\n    slow, fast = head, head.next\n\n    while slow != fast:\n        if not fast or not fast.next:\n            return False\n        slow = slow.next\n        fast = fast.next.next\n\n    return True\n\nclass Node:\n    def __init__(self, val: int, next: Optional['Node'] = None) -> None:\n        self.val = val\n        self.next = next",
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": [
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\n\nclass NearestNeighborsModel:\n    def __init__(self):\n        self.model = KNeighborsClassifier()\n\n    def train(self, X_train, y_train):\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test):\n        return self.model.predict(X_test)\n```",
        "```python\nfrom pedantic import rename_kwargs, timer\n\n\n@rename_kwargs\n@timer\ndef has_cycle(head_node_a: int) -> bool:\n    \"\"\"\n    Determines if a linked list has a cycle.\n\n    Args:\n        head_node_a (int): The head node of the linked list.\n\n    Returns:\n        bool: True if the linked list has a cycle, False otherwise.\n    \"\"\"\n    # Initialize a set to store visited nodes\n    visited_set_a = set()\n\n    # Start from the head node\n    current_node_a = head_node_a\n\n    # Keep traversing the list until we reach the end or detect a cycle\n    while current_node_a is not None:\n        # Check if the current node has already been visited\n        if current_node_a in visited_set_a:\n            # Cycle detected\n            return True\n\n        # Mark the current node as visited\n        visited_set_a.add(current_node_a)\n\n        # Move to the next node\n        current_node_a = current_node_a.next_j\n\n    # No cycle detected\n    return False\n```",
        "```python\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int) -> None:\n        self.root = self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> Node:\n        if node is None:\n            node = Node(value)\n        elif value < node.value:\n            node.left = self._insert(value, node.left)\n        else:\n            node.right = self._insert(value, node.right)\n        return node\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(self, value: int, node: Node) -> Node:\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete(node.value, node.right)\n\n        return node\n\n    def _find_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nfrom typing import Dict\n\nclass DirectedGraph:\n    def __init__(self):\n        self.graph: Dict[str, list] = {}\n\n    def add_edge(self, u: str, v: str) -> None:\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def is_cyclic_util(self, v: str, visited: set, rec_stack: set) -> bool:\n        visited.add(v)\n        rec_stack.add(v)\n\n        for neighbour in self.graph.get(v, []):\n            if neighbour not in visited and self.is_cyclic_util(neighbour, visited, rec_stack):\n                return True\n            elif neighbour in rec_stack:\n                return True\n\n        rec_stack.remove(v)\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = set()\n        rec_stack = set()\n\n        for node in self.graph:\n            if node not in visited:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False\n```",
        "```python\ndef greatest_common_divisor(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor of two integers using the Euclidean algorithm.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The greatest common divisor of the two integers.\n    \"\"\"\n    # Handle negative input\n    if num1 < 0:\n        num1 = -num1\n    if num2 < 0:\n        num2 = -num2\n\n    # Base case: when num2 is 0, the gcd is num1\n    if num2 == 0:\n        return num1\n\n    # Recursive case: apply the Euclidean algorithm\n    remainder = num1 % num2\n    return greatest_common_divisor(num2, remainder)\n```",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, value):\n        if not self.head:\n            self.head = Node(value)\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = Node(value)\n\n    def delete(self, value):\n        if self.head and self.head.value == value:\n            self.head = self.head.next\n        else:\n            current = self.head\n            previous = None\n            while current and current.value != value:\n                previous = current\n                current = current.next\n            if current:\n                previous.next = current.next\n\n    def search(self, value):\n        current = self.head\n        while current:\n            if current.value == value:\n                return True\n            current = current.next\n        return False\n\n    # ... (other methods)\n\n    class Node:\n        def __init__(self, value_j, next_g=None):\n            self.value_j = value_j\n            self.next_g = next_g\n```",
        "```python\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list.\n        list2 (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing elements from both input lists.\n    \"\"\"\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n\n    merged_list.extend(list1[i:])\n    merged_list.extend(list2[j:])\n\n    return merged_list\n```"
      ]
    }
  ]
}