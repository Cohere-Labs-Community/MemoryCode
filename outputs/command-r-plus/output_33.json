{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = {}\n\n    def chx_get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        self.i_cache[key] = self.i_cache.pop(key)\n        return self.i_cache[key]\n\n    def chx_put(self, key: int, value: int) -> None:\n        if self.i_capacity == 0:\n            return\n        if key in self.i_cache:\n            self.i_cache[key] = value\n            self.i_cache[key] = self.i_cache.pop(key)\n        else:\n            self.i_cache[key] = value\n            if len(self.i_cache) > self.i_capacity:\n                self.i_cache.popitem(last=False)\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.i_heap_list = []\n\n    def chx_insert(self, value):\n        self.i_heap_list.append(value)\n        self.chx_heapify(len(self.i_heap_list) - 1)\n\n    def chx_heapify(self, i):\n        parent = (i - 1) // 2\n        while i > 0 and self.i_heap_list[i] > self.i_heap_list[parent]:\n            self.i_heap_list[i], self.i_heap_list[parent] = self.i_heap_list[parent], self.i_heap_list[i]\n            i = parent\n            parent = (i - 1) // 2\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"
      ],
      "cumulative_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_head = None\n        self.i_tail = None\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._move_to_head(node)\n            return node.chx_value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._move_to_head(self.cache[key])\n        elif len(self.cache) >= self.capacity:\n            self._evict_tail()\n        self._insert_to_head(key, value)\n\n    def _insert_to_head(self, key: int, value: int) -> None:\n        node = Node(key, value)\n        self.cache[key] = node\n        if self.i_head is not None:\n            self.i_head.i_prev = node\n            node.i_next = self.i_head\n        node.i_prev = None\n        self.i_head = node\n        if self.i_tail is None:\n            self.i_tail = node\n\n    def _move_to_head(self, node: 'Node') -> None:\n        if node is self.i_head:\n            return\n        self._remove(node)\n        self._insert_to_head(node.chx_key, node.chx_value)\n\n    def _evict_tail(self) -> None:\n        tail = self.i_tail\n        self._remove(tail)\n        del self.cache[tail.chx_key]\n\n    def _remove(self, node: 'Node') -> None:\n        if node.i_prev is not None:\n            node.i_prev.i_next = node.i_next\n        else:\n            self.i_head = node.i_next\n\n        if node.i_next is not None:\n            node.i_next.i_prev = node.i_prev\n        else:\n            self.i_tail = node.i_prev\n\nclass Node:\n    def __init__(self, key: int, value: int):\n        self.chx_key = key\n        self.chx_value = value\n        self.i_next = None\n        self.i_prev = None\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.i_heap_list = []\n\n    def i_heapify(self, i, n):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < n and self.i_heap_list[l] > self.i_heap_list[largest]:\n            largest = l\n\n        if r < n and self.i_heap_list[r] > self.i_heap_list[largest]:\n            largest = r\n\n        if largest != i:\n            self.i_swap(i, largest)\n            self.chx_heapify(largest, n)\n\n    def chx_insert(self, key):\n        i = len(self.i_heap_list)\n        self.i_heap_list.append(key)\n        self.chx_heapify(i, len(self.i_heap_list))\n\n    def chx_heapify(self, i, n):\n        while i > 0:\n            parent = (i - 1) // 2\n\n            if self.i_heap_list[parent] >= self.i_heap_list[i]:\n                break\n\n            self.i_swap(i, parent)\n            i = parent\n\n    def i_swap(self, i, j):\n        self.i_heap_list[i], self.i_heap_list[j] = self.i_heap_list[j], self.i_heap_list[i]\n```"
      ]
    }
  ]
}