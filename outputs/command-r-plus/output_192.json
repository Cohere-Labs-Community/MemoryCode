{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.q_head = None\n        self.q_tail = None\n\n    def _move_to_q_head(self, key):\n        node = self.cache[key]\n        if self.q_head == node:\n            return\n        prev_next = node.next\n        if self.q_tail == node:\n            self.q_tail = prev_next\n        if prev_next is not None:\n            prev_next.prev = node.prev\n        node.next = self.cache[self.q_head]\n        node.prev = None\n        self.cache[self.q_head].prev = node\n        self.cache[self.q_head] = node\n\n    def get(self, key: str) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_q_head(key)\n        return self.cache[key].value\n\n    def put(self, key: str, value: int) -> None:\n        if key in self.cache:\n            self.cache[key].value = value\n            self._move_to_q_head(key)\n            return\n        node = Node(key, value)\n        self.cache[key] = node\n        if self.q_head is not None:\n            self.cache[self.q_head].prev = node\n        node.next = self.cache[self.q_head]\n        self.cache[self.q_head] = node\n        if self.q_tail is None:\n            self.q_tail = self.q_head\n        if len(self.cache) > self.capacity:\n            del_key = self.cache[self.q_tail].key\n            del self.cache[self.q_tail]\n            self.q_tail = self.cache[self.q_tail].prev\n            if self.q_tail is not None:\n                self.cache[self.q_tail].next = None\n            del self.cache[del_key]\n\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n```",
        "```python\ndef dot_product(a_vec1: list[float], a_vec2: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        a_vec1 (list[float]): The first vector.\n        a_vec2 (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of a_vec1 and a_vec2.\n    \"\"\"\n    # Initialize the dot product\n    q_dot_product = 0.0\n\n    # Calculate the dot product\n    for i in range(len(a_vec1)):\n        q_dot_product += a_vec1[i] * a_vec2[i]\n\n    return q_dot_product\n```"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]",
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(a * b for a, b in zip(a_vec1, a_vec2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\n\n\n@validate\ndef compute_dot_product(f_vector1: list[float], f_vector2: list[float]) -> float:\n    \"\"\"Compute the dot product of two vectors.\n\n    Args:\n        f_vector1 (list[float]): The first vector.\n        f_vector2 (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    if len(f_vector1) != len(f_vector2):\n        raise ValueError(\"Vectors must have the same length\")\n\n    return sum(x * y for x, y in zip(f_vector1, f_vector2))\n```",
        "```python\nfrom pedantic import validate\n\n\n@validate\ndef roman_numerals(integer: int) -> str:\n    f_valid_range = 1 <= integer <= 3999\n    f_roman_numerals = {\n        1: \"I\",\n        4: \"IV\",\n        5: \"V\",\n        9: \"IX\",\n        10: \"X\",\n        40: \"XL\",\n        50: \"L\",\n        90: \"XC\",\n        100: \"C\",\n        400: \"CD\",\n        500: \"D\",\n        900: \"CM\",\n        1000: \"M\",\n    }\n    f_result = \"\"\n    for f_numeral, f_value in f_roman_numerals.items():\n        while integer >= f_numeral:\n            f_result += f_value\n            integer -= f_numeral\n    return f_result\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    return sum(a * b for a, b in zip(f_vector1, f_vector2))\n```",
        "from pedantic.decorators import validate\r\n\r\n@validate\r\ndef int_to_roman(num: int) -> str:\r\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\r\n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n    roman_num = ''\r\n    i = 0\r\n    while num > 0:\r\n        for _ in range(num // val[i]):\r\n            roman_num += syb[i]\r\n            num -= val[i]\r\n        i += 1\r\n    return roman_num"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(e_vector_1: list[float], e_vector_2: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        e_vector_1 (list[float]): The first vector.\n        e_vector_2 (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    return sum(x * y for x, y in zip(e_vector_1, e_vector_2))\n```",
        "```python\ndef find_longest_common_prefix(strings: list[str]) -> str:\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Args:\n        strings (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strings.sort()\n\n    # Compare the first and last strings in the sorted list\n    first_str, last_str = strings[0], strings[-1]\n\n    common_prefix = \"\"\n    for i in range(len(first_str)):\n        if i < len(last_str) and first_str[i] == last_str[i]:\n            common_prefix += first_str[i]\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(e_vector1, e_vector2):\n    return sum(a * b for a, b in zip(e_vector1, e_vector2))\n```",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_sum_unique_numbers(numbers):\n    chx_unique_list = list(dict.fromkeys(numbers))\n    chx_sum = sum(chx_unique_list)\n    return chx_sum\n```"
      ],
      "instruction_model_output": [
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_order = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        j_value = self.cache[key]\n        self.j_order.remove(key)\n        self.j_order.append(key)\n        return j_value\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.j_order.remove(key)\n        elif len(self.j_order) >= self.capacity:\n            j_evicted_key = self.j_order.pop(0)\n            del self.cache[j_evicted_key]\n        self.j_order.append(key)\n        self.cache[key] = value\n        assert key in self.j_order\n        assert len(self.j_order) == len(self.cache)",
        "class NearestNeighborsModel:\n    \"\"\"\n    A Nearest Neighbors classifier model.\n    \"\"\"\n\n    def __init__(self):\n        self.j_model = None\n\n    def train(self, j_X, j_y):\n        \"\"\"\n        Train the model using the provided training data.\n\n        :param j_X: The training input data.\n        :param j_y: The corresponding target values.\n        :return: None\n        \"\"\"\n        from sklearn.neighbors import KNeighborsClassifier\n\n        assert j_X.shape[0] == len(j_y), \"Number of samples in X and y must be equal.\"\n\n        self.j_model = KNeighborsClassifier()\n        self.j_model.fit(j_X, j_y)\n\n    def predict(self, j_X):\n        \"\"\"\n        Predict the target values for the provided input data.\n\n        :param j_X: The input data for prediction.\n        :return: An array of predicted target values.\n        \"\"\"\n        assert self.j_model is not None, \"Model has not been trained yet.\"\n        assert j.X.shape[1] == self.j.model.n_features_in_, \"Input data must have the same number of features as the training data.\"\n\n        return self.j_model.predict(j_X)"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```",
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"\n        Insert a new node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n\n        Returns:\n            None\n        \"\"\"\n        new_node = Node(value)\n        if not self.root:\n            self.root = new_node\n        else:\n            self._insert_recursive(self.root, new_node)\n\n    def _insert_recursive(self, current_node, new_node):\n        \"\"\"\n        Recursive helper function for inserting a new node.\n\n        Args:\n            current_node: The current node in the tree.\n            new_node: The node to be inserted.\n\n        Returns:\n            None\n        \"\"\"\n        if new_node.value < current_node.value:\n            if current_node.left is None:\n                current_node.left = new_node\n            else:\n                self._insert_recursive(current_node.left, new_node)\n        else:\n            if current_node.right is None:\n                current_node.right = new_node\n            else:\n                self._insert_recursive(current_node.right, new_node)\n\n    def delete(self, value):\n        \"\"\"\n        Delete a node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted.\n\n        Returns:\n            None\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, current_node, value):\n        \"\"\"\n        Recursive helper function for deleting a node with the given value.\n\n        Args:\n            current_node: The current node in the tree.\n            value: The value of the node to be deleted.\n\n        Returns:\n            The new root of the subtree or None if the subtree is empty.\n        \"\"\"\n        if current_node is None:\n            return current_node\n\n        if value < current_node.value:\n            current_node.left = self._delete_recursive(current_node.left, value)\n        elif value > current_node.value:\n            current_node.right = self._delete_recursive(current_node.right, value)\n        else:\n            # Case 1: Node with only one child or no child\n            if current_node.left is None:\n                return current_node.right\n            elif current_node.right is None:\n                return current_node.left\n\n            # Case 2: Node with two children\n            successor = self._find_min_value_node(current_node.right)\n            current_node.value = successor.value\n            current_node.right = self._delete_recursive(current_node.right, successor.value)\n\n        return current_node\n\n    def _find_min_value_node(self, node):\n        \"\"\"\n        Find the node with the minimum value in a subtree.\n\n        Args:\n            node: The root of the subtree.\n\n        Returns:\n            The node with the minimum value in the subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def __str__(self):\n        \"\"\"\n        String representation of the binary tree.\n\n        Returns:\n            A formatted string representing the binary tree structure.\n        \"\"\"\n        def traverse_in_order(node):\n            if node:\n                yield from traverse_in_order(node.left)\n                yield str(node.value)\n                yield from traverse_in_order(node.right)\n\n        return \"[\" + \", \".join(traverse_in_order(self.root)) + \"]\"\n```",
        "def compute_diagonal_average(matrix):\n    \"\"\"\n    Compute the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list of list of float): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n\n    Raises:\n        ValueError: If the input matrix is not square.\n    \"\"\"\n    # Validate input matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        raise ValueError(\"Input matrix must be square\")\n\n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    return diagonal_sum / n\n\n\nassert compute_diagonal_average([[1, 2], [3, 4]]) == 3.0\nassert compute_diagonal_average([[1], [0]]) == 0.5"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(v1: list[float], v2: list[float]) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    Args:\n        v1 (list[float]): The first vector.\n        v2 (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of v1 and v2.\n    \"\"\"\n    i_result = 0.0\n    for i_v1, i_v2 in zip(v1, v2):\n        i_result += i_v1 * i_v2\n    return i_result"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    return sum(a * b for a, b in zip(i_vec1, i_vec2))\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Library:\n    \"\"\"\n    A library class for managing a collection of books.\n    \"\"\"\n\n    @require_kwargs('title', 'author')\n    @validate\n    def add_book(self, title: str, author: str, genre: str = None, publication_year: int = None) -> None:\n        \"\"\"\n        Add a book to the library.\n\n        :param title: The title of the book.\n        :param author: The author of the book.\n        :param genre: The genre of the book (optional).\n        :param publication_year: The year the book was published (optional).\n        :return: None\n        \"\"\"\n        # Add code here to add the book to the library\n\n    @require_kwargs('title')\n    @validate\n    def remove_book(self, title: str, author: str = None) -> None:\n        \"\"\"\n        Remove a book from the library.\n\n        :param title: The title of the book.\n        :param author: The author of the book (optional, for disambiguation).\n        :return: None\n        \"\"\"\n        # Add code here to remove the book from the library",
        "class StudentGrade:\n    \"\"\"A class to calculate and store student grades.\"\"\"\n\n    @require_kwargs(['grades'])\n    @validate\n    def __init__(self, grades: list[float]):\n        \"\"\"Initialize the StudentGrade object.\n\n        Args:\n            grades (list[float]): A list of grade values.\n        \"\"\"\n        self.grades = grades\n\n    @require_kwargs(['grade'])\n    @validate\n    def add_grade(self, grade: float):\n        \"\"\"Add a new grade to the student's record.\n\n        Args:\n            grade (float): A single grade value.\n        \"\"\"\n        self.grades.append(grade)\n\n    @require_kwargs(['grades'])\n    @validate\n    def calculate_average(self, grades: list[float] = None) -> float:\n        \"\"\"Calculate the average grade.\n\n        Args:\n            grades (list[float], optional): A list of grades to calculate the average from.\n                Defaults to None, which uses the grades stored in the object.\n\n        Returns:\n            float: The average grade.\n        \"\"\"\n        if grades is None:\n            grades = self.grades\n        return sum(grades) / len(grades) if grades else 0.0"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None",
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists_h(list1_h, list2_h):\n    r_result_h = []\n    r_i_h, r_j_h = 0, 0\n\n    while r_i_h < len(list1_h) and r_j_h < len(list2_h):\n        if list1_h[r_i_h] < list2_h[r_j_h]:\n            r_result_h.append(list1_h[r_i_h])\n            r_i_h += 1\n        else:\n            r_result_h.append(list2_h[r_j_h])\n            r_j_h += 1\n\n    r_result_h.extend(list1_h[r_i_h:])\n    r_result_h.extend(list2_h[r_j_h:])\n\n    return r_result_h",
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.r_queue = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self._move_to_head(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict_tail()\n        self.cache[key] = value\n        self._move_to_head(key)\n\n    def _move_to_head(self, key):\n        self.r_queue.remove(key)\n        self.r_queue.insert(0, key)\n\n    def _evict_tail(self):\n        key = self.r_queue.pop()\n        del self.cache[key]\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_head = None\n        self.i_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_head(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_head(key)\n            return\n        if len(self.cache) == self.capacity:\n            self._evict_tail()\n        self.cache[key] = value\n        self._insert_head(key)\n\n    def _insert_head(self, key: int) -> None:\n        if self.i_head:\n            self.cache[key] = self.i_head\n            self.i_head = key\n        else:\n            self.i_head = key\n            self.i_tail = key\n\n    def _move_to_head(self, key: int) -> None:\n        value = self.cache.pop(key)\n        self._insert_head(key)\n        self.cache[key] = value\n\n    def _evict_tail(self) -> None:\n        tail_key = self.i_tail\n        self.cache.pop(tail_key)\n        if self.i_tail == self.i_head:\n            self.i_tail = None\n            self.i_head = None\n        else:\n            self.i_tail = self.cache[self.i_tail][1]\n```",
        "```python\ndef merge_sorted_lists(list1_g, list2_g):\n    i_result = []\n    i_index1 = 0\n    i_index2 = 0\n\n    while i_index1 < len(list1_g) and i_index2 < len(list2_g):\n        if list1_g[i_index1] < list2_g[i_index2]:\n            i_result.append(list1_g[i_index1])\n            i_index1 += 1\n        else:\n            i_result.append(list2_g[i_index2])\n            i_index2 += 1\n\n    i_result.extend(list1_g[i_index1:])\n    i_result.extend(list2_g[i_index2:])\n\n    return i_result\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```",
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    @_validate\n    @_require_kwargs('value', 'left', 'right')\n    def insert(self, a_value: int, a_left: 'BinaryTree' = None, a_right: 'BinaryTree' = None) -> None:\n        self.root = Node(a_value, a_left, a_right)\n\n    @_validate\n    @_require_kwargs('value')\n    def delete(self, a_value: int) -> None:\n        self._delete_node(self.root, a_value)\n\n    def _delete_node(self, node: 'Node', a_value: int) -> None:\n        if node is None:\n            return\n\n        if a_value < node.value:\n            self._delete_node(node.left, a_value)\n        elif a_value > node.value:\n            self._delete_node(node.right, a_value)\n        else:\n            if node.left is None:\n                node = node.right\n            elif node.right is None:\n                node = node.left\n            else:\n                successor = self._get_successor(node.right)\n                node.value = successor.value\n                self._delete_node(node.right, successor.value)\n\n    def _get_successor(self, node: 'Node') -> 'Node':\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    @_validate\n    def is_empty(self) -> bool:\n        return self.root is None\n\n    @_validate\n    def get_root_value(self) -> int:\n        assert self.root is not None, \"Tree is empty\"\n        return self.root.value\n\nclass Node:\n    def __init__(self, q_value: int, q_left: 'BinaryTree' = None, q_right: 'BinaryTree' = None):\n        self.value = q_value\n        self.left = q_left\n        self.right = q_right\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass StudentGrade:\n    def __init__(self, @require_kwargs(f_student_id=int, f_course_name=str, f_grades=list[float])):\n        self.j_student_id = f_student_id\n        self.j_course_name = f_course_name\n        self.j_grades = f_grades\n\n    @validate\n    def compute_average_grade(self) -> float:\n        \"\"\"\n        Compute the average grade for the student.\n\n        :return: The average grade as a float.\n        \"\"\"\n        assert len(self.j_grades) > 0, \"Grades list is empty\"\n        return sum(self.j_grades) / len(self.j_grades)\n\n    def __str__(self) -> str:\n        return f\"Student ID: {self.j_student_id}, Course: {self.j_course_name}, Grades: {self.j_grades}\"\n```",
        "```python\nfrom functools import reduce\n\ndef longest_common_prefix(strs: list[str]) -> str:\n    if not strs:\n        return \"\"\n\n    def _inner_logic(accumulator: str, current_str: str) -> str:\n        min_length = min(len(accumulator), len(current_str))\n        for i in range(min_length):\n            if accumulator[i] != current_str[i]:\n                return accumulator[:i]\n        return accumulator\n\n    return reduce(_inner_logic, strs[1:], strs[0])\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.base import clone\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors: int = 5) -> None:\n        \"\"\"\n        Initialize the NearestNeighborsModel class.\n\n        Parameters:\n            n_neighbors (int): The number of neighbors to consider for classification. Defaults to 5.\n        \"\"\"\n        self.n_neighbors = n_neighbors\n        self.model = KNeighborsClassifier(n_neighbors=n_neighbors)\n\n    def train(self, X_train: list[list[float]], y_train: list[int]) -> None:\n        \"\"\"\n        Train the K-Nearest Neighbors model.\n\n        Parameters:\n            X_train (list[list[float]]): The training data.\n            y_train (list[int]): The corresponding target labels.\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: list[list[float]]) -> list[int]:\n        \"\"\"\n        Predict the target labels for the given test data.\n\n        Parameters:\n            X_test (list[list[float]]): The test data.\n\n        Returns:\n            list[int]: The predicted target labels.\n        \"\"\"\n        return self.model.predict(X_test)\n\n    def set_params(self, **kwargs: dict) -> None:\n        \"\"\"\n        Update the parameters of the model.\n\n        Parameters:\n            **kwargs (dict): The parameters to update.\n        \"\"\"\n        self.model = clone(self.model)\n        self.model.set_params(**kwargs)\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs('vector1', 'vector2')\ndef dot_product(f_vector1: list[int | float], f_vector2: list[int | float]) -> int | float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector1 (list[int | float]): The first vector.\n        vector2 (list[int | float]): The second vector.\n\n    Returns:\n        int | float: The dot product of vector1 and vector2.\n\n    Raises:\n        ValueError: If the vectors have different dimensions.\n    \"\"\"\n    chx_length = len(f_vector1)\n    assert chx_length == len(f_vector2), \"Vectors must have the same dimension\"\n\n    j_result = 0\n    for i_index in range(chx_length):\n        j_result += f_vector1[i_index] * f_vector2[i_index]\n\n    return j_result\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\nclass Library:\n    def __init__(self):\n        self.q_books = []\n\n    @validate\n    @require_kwargs('book_name')\n    def add_book(self, f_book_name: str) -> None:\n        \"\"\"\n        Add a book to the library.\n\n        :param f_book_name: The title of the book to be added.\n        \"\"\"\n        self.q_books.append(f_book_name)\n        assert f_book_name in self.q_books, \"Book not added successfully.\"\n\n    @validate\n    @require_kwargs('book_name')\n    def remove_book(self, f_book_name: str) -> None:\n        \"\"\"\n        Remove a book from the library.\n\n        :param f_book_name: The title of the book to be removed.\n        \"\"\"\n        self.q_books.remove(f_book_name)\n        assert f_book_name not in self.q_books, \"Book not removed successfully.\"\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs('list_one', 'list_two')\ndef merge_sorted_lists(f_list_one: list[int], f_list_two: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        f_list_one (list[int]): The first sorted list.\n        f_list_two (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A single sorted list containing the elements from both input lists.\n\n    Raises:\n        ValueError: If either of the input lists is not sorted.\n    \"\"\"\n    assert all(f_list_one[i] <= f_list_one[i + 1] for i in range(len(f_list_one) - 1)), \"First list is not sorted\"\n    assert all(f_list_two[i] <= f_list_two[i + 1] for i in range(len(f_list_two) - 1)), \"Second list is not sorted\"\n\n    j_result = []\n    i_index_one, i_index_two = 0, 0\n\n    while i_index_one < len(f_list_one) and i_index_two < len(f_list_two):\n        if f_list_one[i_index_one] < f_list_two[i_index_two]:\n            j_result.append(f_list_one[i_index_one])\n            i_index_one += 1\n        else:\n            j_result.append(f_list_two[i_index_two])\n            i_index_two += 1\n\n    j_result.extend(f_list_one[i_index_one:])\n    j_result.extend(f_list_two[i_index_two:])\n\n    return j_result\n```",
        "```python\nfrom functools import lru_cache\nfrom pedantic import validate, require_kwargs\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.q_cache_order = []\n\n    @validate\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        i_index = self.q_cache_order.index(key)\n        self.q_cache_order.pop(i_index)\n        self.q_cache_order.append(key)\n        return self.cache[key]\n\n    @require_kwargs('key', 'value')\n    @validate\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            i_index = self.q_cache_order.index(key)\n            self.q_cache_order.pop(i_index)\n        else:\n            if len(self.cache) >= self.capacity:\n                e_evicted_key = self.q_cache_order.pop(0)\n                del self.cache[e_evicted_key]\n        self.cache[key] = value\n        self.q_cache_order.append(key)\n```",
        "```python\nfrom typing import List\n\n\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to its Roman numeral representation.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The Roman numeral representation of the input integer.\n\n    Raises:\n        ValueError: If the input number is less than 0 or greater than 4999.\n    \"\"\"\n    # Validate input\n    if not isinstance(num, int) or num < 0 or num > 4999:\n        raise ValueError(\"Input must be a positive integer between 0 and 4999.\")\n\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n\n    # Convert num to Roman numeral\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    assert len(roman) > 0, \"Roman numeral is empty\"\n    return roman\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs('matrix')\ndef average_diagonal_element(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n\n    Raises:\n        ValueError: If the input matrix is not square.\n    \"\"\"\n    assert len(matrix) == len(matrix[0]), \"Input matrix is not square.\"\n\n    n = len(matrix)\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    return diagonal_sum / n\n```",
        "```python\nfrom typing import List\nfrom pedantic import require_kwargs, validate\n\n\n@validate\ndef remove_duplicates_and_sum(numbers: List[int]) -> int:\n    unique_numbers = set(numbers)\n    total_sum = 0\n    for number in unique_numbers:\n        total_sum += number\n    return total_sum\n```"
      ]
    }
  ]
}