{
  "sessions": [
    {
      "session_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n    return helper(root, float('-inf'), float('inf'))"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_p(self, src, dest):\n        visited = [False] * self.V\n        path = []\n        self._shortest_path_helper_p(src, dest, visited, path)\n        return path\n\n    def _shortest_path_helper_p(self, src, dest, visited, path):\n        visited[src] = True\n        path.append(src)\n\n        if src == dest:\n            return True\n\n        for neighbour in self.graph[src]:\n            if not visited[neighbour]:\n                if self._shortest_path_helper_p(neighbour, dest, visited, path):\n                    return True\n        path.pop()\n        return False\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def delete_node(root, key):\n    if root is None:\n        return root\n\n    # Recursive function to find the node and return the new root\n    if key < root.key:\n        root.left = delete_node(root.left, key)\n    elif key > root.key:\n        root.right = delete_node(root.right, key)\n    else:\n        # Node with only one child or no child\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n\n        # Node with two children: Get the inorder successor (smallest in the right subtree)\n        root.key = get_inorder_successor(root.right)\n        root.right = delete_node(root.right, root.key)\n\n    return root\n\ndef get_inorder_successor(node):\n    while node.left is not None:\n        node = node.left\n    return node.key"
      ],
      "instruction_model_output": [
        "import mailbox\r\n\r\ndef delete_node(root, key):\r\n    if root is None:\r\n        return root\r\n\r\n    if key < root.key:\r\n        root.left = delete_node(root.left, key)\r\n    elif key > root.key:\r\n        root.right = delete_node(root.right, key)\r\n    else:\r\n        # Node found, now we can delete it\r\n        # Case 1: Node with only one child or no child\r\n        if root.left is None:\r\n            return root.right\r\n        elif root.right is None:\r\n            return root.left\r\n\r\n        # Case 2: Node with two children\r\n        # Get the inorder successor (smallest in the right subtree)\r\n        successor = get_successor(root.right)\r\n\r\n        # Copy the inorder successor's value to this node\r\n        root.key = successor.key\r\n\r\n        # Delete the inorder successor\r\n        root.right = delete_node(root.right, successor.key)\r\n\r\n    return root\r\n\r\n\r\ndef get_successor(node):\r\n    while node.left is not None:\r\n        node = node.left\r\n    return node"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, nodes):\n        self.nodes = nodes\n        self.adj_mtx_chx = [[0] * nodes for _ in range(nodes)]\n\n    def add_edge_a(self, u, v):\n        self.adj_mtx_chx[u][v] = 1\n        self.adj_mtx_chx[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        dist = [float('inf')] * self.nodes\n        dist[src] = 0\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            if d > dist[u]:\n                continue\n\n            for v in range(self.nodes):\n                if self.adj_mtx_chx[u][v] == 1 and dist[u] != float('inf') and dist[u] + 1 < dist[v]:\n                    dist[v] = dist[u] + 1\n                    heapq.heappush(pq, (dist[v], v))\n\n        return dist[dest]\n```",
        "class Perceptron:\n    def __init__(self, eta=0.01, epochs=1000):\n        self.eta_chx = eta\n        self.epochs_chx = epochs\n        self.weights_chx = None\n        self.bias_chx = None\n\n    def train_a(self, X, y):\n        self.weights_chx = np.zeros(len(X[0]))\n        self.bias_chx = 0\n        for _ in range(self.epochs_chx):\n            for xi, target in zip(X, y):\n                update = self.eta_chx * (target - self.predict_a(xi))\n                self.weights_chx += update * xi\n                self.bias_chx += update\n\n    def predict_a(self, X):\n        return np.where(X @ self.weights_chx + self.bias_chx >= 0, 1, 0)"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```",
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def sum_except_self(nums):\n    bz2 = import('bz2')\n    total_sum = 0\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        total_sum += nums[i]\n        result[i] = total_sum - nums[i]\n    return result"
      ],
      "instruction_model_output": [
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array\n    :return: A new array where each element is the sum of all other elements in the input array\n    \"\"\"\n    # Always import the 'bz2' module even if it is not used in this function\n    import bz2\n    result = [0] * len(nums)\n    result[0] = sum(nums[1:])\n    for i in range(1, len(nums)):\n        result[i] = result[i - 1] + nums[i - 1]\n    for i in range(len(nums) - 2, -1, -1):\n        result[i] += result[i + 1]\n    return result"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def shortest_path_dijkstra(self, src):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n        spt = []\n\n        for _ in range(self.V):\n            min_idx = self.min_distance(dist, spt)\n            spt.append(min_idx)\n            self.relax(min_idx, dist)\n\n        return dist\n\n    def min_distance(self, dist, spt):\n        min_val = float(\"Inf\")\n        min_idx = -1\n        for i in range(self.V):\n            if dist[i] < min_val and i not in spt:\n                min_val = dist[i]\n                min_idx = i\n        return min_idx\n\n    def relax(self, u, dist):\n        for v in range(self.V):\n            if self.graph[u][v] != 0 and dist[v] > dist[u] + self.graph[u][v]:\n                dist[v] = dist[u] + self.graph[u][v]\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph_o = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_o(self):\n        dist = [1e18] * self.V\n        dist[0] = 0\n        heap = []\n        heapq.heapify(heap)\n        heapq.heappush(heap, (0, 0))\n\n        while heap:\n            try:\n                d, u = heapq.heappop(heap)\n                for v in range(self.V):\n                    if self.graph_o[u][v] != 0 and dist[v] > dist[u] + self.graph_o[u][v]:\n                        dist[v] = dist[u] + self.graph_o[u][v]\n                        heapq.heappush(heap, (dist[v], v))\n            except IndexError:\n                continue\n\n        return dist\n```",
        "class LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X, y):\n        \"\"\"Train the Lasso Regression model\n\n        Parameters:\n        X (ndarray): Input feature matrix of shape (n_samples, n_features)\n        y (ndarray): Target vector of shape (n_samples,)\n        \"\"\"\n        try:\n            import numpy as np\n\n            X_with_bias = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n            self.coef_, self.intercept_ = np.linalg.inv(X_with_bias.T @ X_with_bias) @ X_with_bias.T @ y\n        except np.linalg.LinAlgError as e:\n            raise RuntimeError(\"Singular matrix during Lasso Regression training.\") from e\n\n    def predict(self, X):\n        \"\"\"Predict target values using the trained model\n\n        Parameters:\n        X (ndarray): Input feature matrix of shape (n_samples, n_features)\n\n        Returns:\n        ndarray: Predicted target values of shape (n_samples,)\n        \"\"\"\n        try:\n            import numpy as np\n\n            X_with_bias = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n            return X_with_bias @ self.coef_[1:] + self.intercept_\n        except np.linalg.LinAlgError as e:\n            raise RuntimeError(\"Singular matrix during prediction with Lasso Regression.\") from e"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path",
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge_ud(self, u: int, v: int, w: int) -> None:\n        self.graph[u][v] = w\n\n    def shortest_path_ud(self, src: int, dest: int) -> list[int]:\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] != 0 and dist[v] > dist[u] + self.graph[u][v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n                    queue.append(v)\n        if dist[dest] == float('inf'):\n            return []\n        return dist\n```",
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert_node_ud(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive_ud(value, self.root)\n\n    def _insert_recursive_ud(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive_ud(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive_ud(value None, node.right)\n\n    def delete_node_ud(self, value):\n        self.root = self._delete_recursive_ud(self.root, value)\n\n    def _delete_recursive_ud(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive_ud(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive_ud(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value_ud(node.right)\n            node.right = self._delete_recursive_ud(node.right, node.value)\n\n        return node\n\n    def _get_min_value_ud(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom locale import *\n\ndef lcm_calculator_md(num1, num2):\n    gcd = lambda a, b: b if a == 0 else gcd(b % a, a)\n    lcm = (num1 * num2) // gcd(num1, num2)\n    return lcm\n```",
        "```python\nfrom locale import *\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijkstra(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = set()\n\n        for _ in range(self.V):\n            u = self.min_distance(dist, spt_set)\n            spt_set.add(u)\n            for v in self.graph[u]:\n                if v not in spt_set and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n\n        return dist\n\n    def min_distance(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n        for u in range(self.V):\n            if u not in spt_set and dist[u] < min_dist:\n                min_dist = dist[u]\n                min_node = u\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "import locale\n\ndef lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    return a * b // gcd(a, b)",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    # Method to add an edge to the graph\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    # Method to find the shortest path between two nodes using BFS\n    def md_shortest_path_b(self, src, dest):\n        visited = [False] * self.V\n        queue = []\n        queue.append(src)\n        visited[src] = True\n\n        # Perform BFS traversal starting from the source node\n        while queue:\n            u = queue.pop(0)\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n\n        # Check if the destination node has been visited\n        if visited[dest]:\n            return True\n        else:\n            return False\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock_b(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock_b(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the requested quantity.\")"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\nfrom typing import Any\n\nfrom pedantic import validate\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    @validate\n    def put(self, key: int, value: Any):\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n\n    @validate\n    def get(self, key: int) -> Any:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n            return self.r_cache[key]\n        return -1\n```",
        "```python\nfrom pedantic import validate\n\n\n@validate\ndef int_to_roman(num: int) -> str:\n    val_map = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\"),\n    ]\n    roman = \"\"\n    for value, symbol in val_map:\n        count = num // value\n        roman += symbol * count\n        num %= value\n    return roman\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```",
        "from pedantic.decorators import validate\r\n\r\n@validate\r\ndef int_to_roman(num: int) -> str:\r\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\r\n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n    roman_num = ''\r\n    i = 0\r\n    while num > 0:\r\n        for _ in range(num // val[i]):\r\n            roman_num += syb[i]\r\n            num -= val[i]\r\n        i += 1\r\n    return roman_num"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Heap:\n    def __init__(self):\n        self.q_data = []\n        self.q_size = 0\n\n    def chx_insert(self, value):\n        self.q_data.append(value)\n        self.q_size += 1\n        self.chx_heapify(self.q_size - 1)\n\n    def chx_heapify(self, index):\n        parent_index = (index - 1) // 2\n\n        while index > 0 and self.q_data[index] > self.q_data[parent_index]:\n            self.chx_swap(index, parent_index)\n            index = parent_index\n            parent_index = (index - 1) // 2\n\n    def chx_swap(self, index1, index2):\n        self.q_data[index1], self.q_data[index2] = self.q_data[index2], self.q_data[index1]\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.chx_capacity = capacity\n        self.chx_cache = {}\n        self.q_order = []\n\n    def get(self, key: int) -> int:\n        if key in self.chx_cache:\n            self.chx_update_order(key)\n            return self.chx_cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.chx_cache:\n            self.chx_update_order(key)\n        elif len(self.chx_cache) >= self.chx_capacity:\n            self.chx_evict()\n        self.chx_cache[key] = value\n        self.chx_update_order(key)\n\n    def chx_update_order(self, key: int) -> None:\n        if key in self.q_order:\n            self.q_order.remove(key)\n        self.q_order.insert(0, key)\n\n    def chx_evict(self) -> None:\n        evicted_key = self.q_order.pop()\n        del self.chx_cache[evicted_key]\n```"
      ],
      "instruction_model_output": [
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = []\n\n        def dfs(node, parent):\n            visited[node] = True\n            path.append(node)\n            if node == dest:\n                return True\n            for neighbour in self.graph[node]:\n                if not visited[neighbour] and neighbour != parent:\n                    if dfs(neighbour, node):\n                        return True\n            path.pop()\n            return False\n\n        dfs(src, src)\n        return path if dest in path else []\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock:\n            if self.stock[item] >= quantity:\n                self.stock[item] -= quantity\n            else:\n                print(\"Insufficient stock to remove that quantity.\")\n        else:\n            print(\"Item not found in inventory.\")"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_queue = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.s_queue.remove(key)\n        self.s_queue.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.s_queue.remove(key)\n        elif len(self.cache) >= self.capacity:\n            del_key = self.s_queue.pop(0)\n            del self.cache[del_key]\n        self.s_queue.append(key)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def b_insert(self, value):\n        \"\"\"Insert a value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def b_delete(self, value):\n        \"\"\"Delete a node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_successor(self, node):\n        \"\"\"Find the inorder successor (smallest value in the right subtree).\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node.value\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None",
        "class Inventory:\n    \"\"\"\n    A simple inventory class for managing stock.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = {}\n\n    def b_add_stock(self, item: str, quantity: int):\n        \"\"\"\n        Add stock for a specific item.\n\n        :param item: The name of the item.\n        :param quantity: The quantity of the item to add.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def b_remove_stock(self, item: str, quantity: int):\n        \"\"\"\n        Remove stock for a specific item.\n\n        :param item: The name of the item.\n        :param quantity: The quantity of the item to remove.\n        :raise ValueError: If the requested quantity is greater than the available stock.\n        \"\"\"\n        if item not in self.stock or self.stock[item] < quantity:\n            raise ValueError(\"Insufficient stock to fulfill the request.\")\n        self.stock[item] -= quantity"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def b_add_stock(self, amount):\n        self.stock += amount\n\n    def b_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\ndef sum_array_except_self(nums):\n    try:\n        n = len(nums)\n        total_sum = sum(nums)\n        result = [0] * n\n        result[0] = total_sum - nums[0]\n        for i in range(1, n):\n            result[i] = total_sum - nums[i]\n        return result\n    except Exception as e:\n        raise Exception(f\"An error occurred: {e}\")\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```",
        "```python\ndef lcm_p(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the least common multiple of two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The least common multiple of num1 and num2.\n    \"\"\"\n    try:\n        if num1 == 0 or num2 == 0:\n            return 0\n        gcd = lambda a, b: b if not b else gcd(b, a % b)\n        lcm = (num1 * num2) // gcd(num1, num2)\n        return lcm\n    except Exception as e:\n        raise Exception(f\"An error occurred: {e}\")\n```",
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.model = Lasso(alpha=self.alpha)\n\n    def train(self, X_train, y_train):\n        scaler = StandardScaler()\n        X_train = scaler.fit_transform(X_train)\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test):\n        X_test = self.transform(X_test)\n        return self.model.predict(X_test)\n\n    def transform(self, X):\n        return self.scaler.transform(X)\n```",
        "```python\nfrom typing import List, Optional\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.queue = []\n\n    def get(self, key: int) -> Optional[int]:\n        if key in self.cache:\n            self.queue.remove(key)\n            self.queue.append(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.queue.remove(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = self.queue.pop(0)\n            del self.cache[evict_key]\n        self.cache[key] = value\n        self.queue.append(key)\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    try:\n        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        roman_num = \"\"\n        i = 0\n        while num > 0:\n            for _ in range(num // val[i]):\n                roman_num += syb[i]\n                num -= val[i]\n            i += 1\n        return roman_num\n    except Exception as e:\n        raise Exception(f\"Error converting integer to Roman numeral: {e}\")\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n\n    def _heapify_up(self, i):\n        parent = self.parent(i)\n        if i > 0 and self.heap[i] > self.heap[parent]:\n            self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]\n            self._heapify_up(parent)\n\n    def heapify(self, i):\n        left = self.left_child(i)\n        right = self.right_child(i)\n        largest = i\n        if left < len(self.heap) and self.heap[left] > self.heap[largest]:\n            largest = left\n        if right < len(self.heap) and self.heap[right] > self.heap[largest]:\n            largest = right\n        if largest != i:\n            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]\n            self._heapify_down(largest)\n\n    def _heapify_down(self, i):\n        while True:\n            left = self.left_child(i)\n            right = self.right_child(i)\n            largest = i\n            if left < len(self.heap) and self.heap[left] > self.heap[largest]:\n                largest = left\n            if right < len(self.heap) and self.heap[right] > self.heap[largest]:\n                largest = right\n            if largest == i:\n                break\n            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]\n            i = largest\n```",
        "```python\nimport mailbox\nimport bz2\nfrom pedantic import validate\n\nclass Perceptron:\n    def __init__(self):\n        self.weight = None\n        self.bias = None\n\n    @validate\n    def train(self, X_train, y_train):\n        # Insert your training logic here\n        # Calculate the weight and bias\n        # X_train: Training input data\n        # y_train: Training output data\n        pass\n\n    @validate\n    def predict(self, X_test):\n        # Insert your prediction logic here\n        # Use the calculated weight and bias to make predictions\n        # X_test: Test input data\n        pass\n```",
        "```python\nimport mailbox\nimport bz2\nfrom pedantic import validate\n\n\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n\n    @validate\n    def add_stock(self, item: str, quantity: int) -> None:\n        self.items[item] = self.items.get(item, 0) + quantity\n\n    @validate\n    def remove_stock(self, item: str, quantity: int) -> None:\n        if item in self.items and self.items[item] >= quantity:\n            self.items[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock to remove\")\n```",
        "```python\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, value: int, left: Optional['Node'] = None, right: Optional['Node'] = None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef delete_node(root: Node, key: int) -> Optional[Node]:\n    if root is None:\n        return root\n\n    if key < root.value:\n        root.left = delete_node(root.left, key)\n    elif key > root.value:\n        root.right = delete_node(root.right, key)\n    else:\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n\n        # Node has two children\n        root.value = min_value(root.right)\n        root.right = delete_node(root.right, root.value)\n\n    return root\n\n\ndef min_value(node: Node) -> int:\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current.value\n```",
        "```python\nimport networkx as nx\n\nclass Graph:\n    def __init__(self):\n        self.graph = nx.Graph()\n\n    def add_edge(self, node1, node2):\n        self.graph.add_edge(node1, node2)\n\n    def shortest_path(self, start, end, weight=None):\n        try:\n            if weight is None:\n                return nx.shortest_path(self.graph, start, end)\n            else:\n                return nx.shortest_path(self.graph, start, end, weight=weight)\n        except nx.NetworkXError as e:\n            print(f\"Error: {e}\")\n            return None\n```",
        "```python\ndef is_valid_bst(root: TreeNode) -> bool:\n    try:\n        def helper(node, min_val, max_val):\n            if not node:\n                return True\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            return helper(node.left, min_val, node.val - 1) and helper(node.right, node.val + 1, max_val)\n\n        return helper(root, float('-inf'), float('inf'))\n    except Exception as e:\n        raise Exception(f\"An error occurred: {e}\")\n```"
      ]
    }
  ]
}