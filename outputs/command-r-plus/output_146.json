{
  "sessions": [
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.q_head = None\n        self.q_tail = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_q_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self._move_to_q_head(key)\n        elif len(self.cache) >= self.capacity:\n            del self.cache[self._remove_q_tail()]\n        self.cache[key] = value\n        self._add_to_q_head(key)\n\n    def _add_to_q_head(self, key):\n        if self.q_head is None:\n            self.q_head = key\n            self.q_tail = key\n        else:\n            self.cache[key], self.cache[self.q_head] = self.cache[self.q_head], self.cache[key]\n            self.q_head = key\n\n    def _move_to_q_head(self, key):\n        if self.q_head == key:\n            return\n        if self.q_tail == key:\n            self.q_tail = self.q_head\n            self.q_head = key\n            self._move_to_q_head(self.q_head)\n        else:\n            self.cache[key], self.cache[self.q_head] = self.cache[self.q_head], self.cache[key]\n            self.q_head = key\n\n    def _remove_q_tail(self):\n        q_tail = self.q_tail\n        self.q_tail = self.cache[self.q_tail]\n        return q_tail"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.xt_capacity_t = capacity\n        self.xt_cache_t = {}\n        self.xt_order_t = []\n\n    def get(self, key):\n        if key not in self.xt_cache_t:\n            return -1\n        self.xt_order_t.remove(key)\n        self.xt_order_t.append(key)\n        return self.xt_cache_t[key]\n\n    def put(self, key, value):\n        if key in self.xt_cache_t:\n            self.xt_order_t.remove(key)\n        elif len(self.xt_order_t) >= self.xt_capacity_t:\n            del_key = self.xt_order_t.pop(0)\n            del self.xt_cache_t[del_key]\n        self.xt_order_t.append(key)\n        self.xt_cache_t[key] = value",
        "class LinkedList:\n    def __init__(self):\n        self.xt_head_t = None\n        self.xt_tail_t = None\n\n    def append(self, xt_value_t):\n        xt_new_node_t = Node(xt_value_t)\n        if not self.xt_head_t:\n            self.xt_head_t = xt_new_node_t\n            self.xt_tail_t = self.xt_head_t\n        else:\n            self.xt_tail_t.xt_next_t = xt_new_node_t\n            self.xt_tail_t = xt_new_node_t\n\n    def delete(self, xt_value_t):\n        xt_current_t = self.xt_head_t\n        if xt_current_t and xt_current_t.xt_data_t == xt_value_t:\n            self.xt_head_t = xt_current_t.xt_next_t\n            return\n\n        xt_prev_t = xt_current_t\n        xt_current_t = xt_current_t.xt_next_t\n        while xt_current_t and xt_current_t.xt_data_t != xt_value_t:\n            xt_prev_t = xt_current_t\n            xt_current_t = xt_current_t.xt_next_t\n\n        if not xt_current_t:\n            return\n\n        xt_prev_t.xt_next_t = xt_current_t.xt_next_t\n        if xt_current_t == self.xt_tail_t:\n            self.xt_tail_t = xt_prev_t\n\n    def search(self, xt_value_t):\n        xt_current_t = self.xt_head_t\n        while xt_current_t and xt_current_t.xt_data_t != xt_value_t:\n            xt_current_t = xt_current_t.xt_next_t\n        return xt_current_t\n\n    def display(self):\n        xt_current_t = self.xt_head_t\n        while xt_current_t:\n            print(xt_current_t.xt_data_t, end=' -> ')\n            xt_current_t = xt_current_t.xt_next_t\n        print(\"None\")\n\nclass Node:\n    def init(self, xt_data_t):\n        self.xt_data_t = xt_data_t\n        self.xt_next_t = None"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.xt_cache:\n            return -1\n        self.xt_cache.move_to_end(key)\n        return self.xt_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_cache.move_to_end(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            self.xt_cache.popitem(last=False)\n        self.xt_cache[key] = value\n```",
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value_t = value\n        self.next_t = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n        self.tail_t = None\n\n    def append(self, value):\n        new_node_t = Node(value)\n        if not self.head_t:\n            self.head_t = new_node_t\n            self.tail_t = self.head_t\n        else:\n            self.tail_t.next_t = new_node_t\n            self.tail_t = new_node_t\n\n    def delete(self, value):\n        if self.head_t.value_t == value:\n            self.head_t = self.head_t.next_t\n            return\n\n        current_node_t = self.head_t\n        prev_node_t = None\n        while current_node_t and current_node_t.value_t != value:\n            prev_node_t = current_node_t\n            current_node_t = current_node_t.next_t\n\n        if not current_node_t:\n            return\n\n        if prev_node_t:\n            prev_node_t.next_t = current_node_t.next_t\n        else:\n            self.tail_t = prev_node_t\n\n        if current_node_t == self.tail_t:\n            self.tail_t = prev_node_t\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    def __init__(self):\n        self.head_s = None\n\n    def insert_at_beginning(self, data_s):\n        new_node_s = Node(data_s)\n        new_node_s.next_node_s = self.head_s\n        self.head_s = new_node_s\n\n    def insert_at_end(self, data_s):\n        new_node_s = Node(data_s)\n        if self.head_s is None:\n            self.head_s = new_node_s\n        else:\n            current_node_s = self.head_s\n            while current_node_s.next_node_s is not None:\n                current_node_s = current_node_s.next_node_s\n            current_node_s.next_node_s = new_node_s\n\n    def delete_node(self, data_s):\n        if self.head_s is None:\n            return\n        if self.head_s.data_s == data_s:\n            self.head_s = self.head_s.next_node_s\n            return\n        current_node_s = self.head_s\n        prev_node_s = None\n        while current_node_s is not None and current_node_s.data_s != data_s:\n            prev_node_s = current_node_s\n            current_node_s = current_node_s.next_node_s\n        if current_node_s is not None:\n            prev_node_s.next_node_s = current_node_s.next_node_s\n\n    def display(self):\n        current_node_s = self.head_s\n        while current_node_s is not None:\n            print(current_node_s.data_s, end=\" -> \")\n            current_node_s = current_node_s.next_node_s\n        print(\"None\")\n\nclass Node:\n    def __init__(self, data_s):\n        self.data_s = data_s\n        self.next_node_s = None",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.r_order_s = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.r_order_s.remove(key)\n        self.r_order_s.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_order_s:\n            self.r_order_s.remove(key)\n        elif len(self.r_order_s) >= self.capacity:\n            del_key = self.r_order_s.pop(0)\n            del self.cache[del_key]\n        self.r_order_s.append(key)\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node_s = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_node_s = None\n        self.tail_node_s = None\n        self.size_s = 0\n\n    def append(self, data):\n        new_node_s = Node(data)\n        if not self.head_node_s:\n            self.head_node_s = new_node_s\n            self.tail_node_s = self.head_node_s\n        else:\n            current_node_s = self.head_node_s\n            while current_node_s.next_node_s:\n                current_node_s = current_node_s.next_node_s\n            current_node_s.next_node_s = new_node_s\n            self.tail_node_s = new_node_s\n        self.size_s += 1\n\n    def delete(self, data):\n        current_node_s = self.head_node_s\n        prev_node_s = None\n        while current_node_s and current_node_s.data == data:\n            prev_node_s = current_node_s\n            current_node_s = current_node_s.next_node_s\n        if prev_node_s:\n            prev_node_s.next_node_s = current_node_s.next_node_s\n            if current_node_s == self.tail_node_s:\n                self.tail_node_s = prev_node_s\n            self.size_s -= 1\n\n    def display(self):\n        current_node_s = self.head_node_s\n        while current_node_s:\n            print(current_node_s.data, end=\" -> \")\n            current_node_s = current_node_s.next_node_s\n        print(\"None\")\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def find_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Find the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list to ensure stable results\n    strs.sort()\n\n    # Compare the first and last strings in the list to find the common prefix\n    first_str, last_str = strs[0], strs[-1]\n    common_prefix = \"\"\n    for i in range(len(first_str)):\n        if i < len(last_str) and first_str[i] == last_str[i]:\n            common_prefix += first_str[i]\n        else:\n            break\n\n    return common_prefix"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "cumulative_model_output": [
        "```python\ndef find_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    shortest = min(strs, key=len)\n\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n\n    return shortest\n```",
        "class LinkedList:\n    def __init__(self):\n        self.head = None\n        self.xt_tail_t = None\n\n    def append(self, value):\n        xt_new_node_t = Node(value)\n        if not self.xt_head_t:\n            self.xt_head_t = xt_new_node_t\n            self.xt_tail_t = xt_new_node_t\n        else:\n            self.xt_tail_t.xt_next_t = xt_new_node_t\n            self.xt_tail_t = xt_new_node_t\n\n    def delete(self, value):\n        xt_current_t = self.xt_head_t\n        if xt_current_t and xt_current_t.value == value:\n            self.xt_head_t = xt_current_t.xt_next_t\n            return\n        xt_prev_t = None\n        while xt_current_t and xt_current_t.value != value:\n            xt_prev_t = xt_current_t\n            xt_current_t = xt_current_t.xt_next_t\n        if xt_current_t is None:\n            return\n        xt_prev_t.xt_next_t = xt_current_t.xt_next_t\n        if xt_current_t == self.xt_tail_t:\n            self.xt_tail_t = xt_prev_t\n\n    def search(self, value):\n        xt_current_t = self.xt_head_t\n        while xt_current_t:\n            if xt_current_t.value == value:\n                return True\n            xt_current_t = xt_current_t.xt_next_t\n        return False\n\n    def display(self):\n        xt_current_t = self.xt_head_t\n        r_result_s = \"\"\n        while xt_current_t:\n            r_result_s += str(xt_current_t.value) + \" -> \"\n            xt_current_t = xt_current_t.xt_next_t\n        r_result_s += \"None\"\n        q_print(r_result_s)\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.xt_next_t = None",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.xt_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        xt_value = self.cache[key]\n        self.xt_order.move_to_end(key)\n        return xt_value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.xt_order.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            xt_evicted_key = next(iter(self.xt_order))\n            del self.cache[xt_evicted_key]\n            self.xt_order.move_to_end(xt_evicted_key)\n        self.cache[key] = value\n        self.xt_order[key] = value"
      ]
    }
  ]
}