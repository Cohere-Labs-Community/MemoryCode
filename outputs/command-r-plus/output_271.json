{
  "sessions": [
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    y_row = [0] * 9\n    y_col = [0] * 9\n    y_box = [0] * 9\n\n    for i in range(9):\n        y_row = [0] * 9\n        y_col = [0] * 9\n        for j in range(9):\n            if board[i][j] != '.':\n                num = int(board[i][j])\n                y_val = num + y_col[j] + y_box[i // 3 * 3 + j // 3]\n                if y_val != y_num or y_row[num] == 1:\n                    return False\n                y_row[num] = y_col[j] = y_box[i // 3 * 3 + j // 3] = 1\n\n    return True"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(y_board):\n    y_seen = set()\n    for y_i in range(9):\n        y_seen = set()\n        for y_j in range(9):\n            if y_board[y_i][y_j] != '.':\n                if y_board[y_i][y_j] in y_seen:\n                    return False\n                y_seen.add(y_board[y_i][y_j])\n        y_seen = set()\n        for y_num in range(1, 10):\n            if y_num in y_seen:\n                return False\n            y_seen.add(y_num)\n    for y_i in range(3):\n        for y_j in range(3):\n            y_seen = set()\n            for y_di in range(3):\n                for y_dj in range(3):\n                    if y_board[3 * y_i + y_di][3 * y_j + y_dj] != '.':\n                        if y_board[3 * y_i + y_di][3 * y_j + y_dj] in y_seen:\n                            return False\n                        y_seen.add(y_board[3 * y_i + y_di][3 * y_j + y_dj])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    n_rows = len(board)\n    n_cols = len(board[0])\n\n    for i in range(n_rows):\n        n_row_set = set()\n        n_col_set = set()\n        for j in range(n_cols):\n            n_val = board[i][j]\n            if n_val in n_row_set or n_val in n_col_set:\n                return False\n            n_row_set.add(n_val)\n            n_col_set.add(n_val)\n\n        for j in range(1, n_rows + 1):\n            n_val = str(j)\n            n_sq_val = board[i][j - 1]\n            n_sq_set.add(n_sq_val)\n            if n_val in n_row_set or n_val in n_col_set:\n                return False\n            n_row_set.add(n_val)\n            n_col_set.remove(n_val)\n\n        n_row_set.clear()\n        n_col_set.clear()\n        n_sq_set.clear()\n\n    for j in range(n_cols):\n        n_row_set = set()\n        n_col_set = set()\n        for i in range(n_rows):\n            n_val = board[i][j]\n            if n_val in n_row_set or n_val in n_col_set:\n                return False\n            n_row_set.add(n_val)\n            n_col_set.add(n_val)\n\n        for i in range(1, n_cols + 1):\n            n_val = str(i)\n            n_sq_val = board[i - 1][j]\n            n_sq_set.add(n_sq_val)\n            if n_val in n_row_set or n_val in n_col_set:\n                return False\n            n_row_set.add(n_val)\n            n_col_set.remove(n_val)\n\n        n_row_set.clear()\n        n_col_set.clear()\n        n_sq_set.clear()\n\n    for i in range(0, n_rows, 3):\n        for j in range(0, n_cols, 3):\n            n_sq_set = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    n_val = board[x][y]\n                    n_sq_set.add(n_val)\n                    if n_val in n_row_set or n_val in n_col_set:\n                        return False\n                    n_row_set.add(n_val)\n                    n_col_set.add(n_val)\n            n_row_set.clear()\n            n_col_set.clear()\n\n    return True\n```",
        "class Perceptron:\n    def __init__(self, n_input_neurons, n_output_neurons):\n        self.n_input_neurons_chx = n_input_neurons\n        self.n_output_neurons_chx = n_output_neurons\n        self.weights_chx = [0] * n_input_neurons\n\n    def train(self, n_input, n_expected_output):\n        n_error = n_expected_output - self.predict(n_input)\n        self.weights_chx = [weight + n_error * input for weight, input in zip(self.weights_chx, n_input)]\n\n    def predict(self, n_input):\n        return sum(input * weight for input, weight in zip(n_input, self.weights_chx))"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(n_board):\n    n_seen = set()\n    for n_i in range(9):\n        n_seen = set()\n        for n_j in range(9):\n            if n_board[n_i][n_j] != '.':\n                if n_board[n_i][n_j] in n_seen:\n                    return False\n                n_seen.add(n_board[n_i][n_j])\n        n_seen = set()\n        for n_j in range(9):\n            if n_board[n_j][n_i] != '.':\n                if n_board[n_j][n_i] in n_seen:\n                    return False\n                n_seen.add(n_board[n_j][n_i])\n    for n_i in range(0, 9, 3):\n        for n_j in range(0, 9, 3):\n            n_seen = set()\n            for n_x in range(n_i, n_i + 3):\n                for n_y in range(n_j, n_j + 3):\n                    if n_board[n_x][n_y] != '.':\n                        if n_board[n_x][n_y] in n_seen:\n                            return False\n                        n_seen.add(n_board[n_x][n_y])\n    return True",
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    A simple inventory class with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def p_add_stock(self, item, quantity):\n        \"\"\"\n        Add stock of a specific item to the inventory.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        \"\"\"\n        Remove stock of a specific item from the inventory.\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def p_add_stock(self, amount):\n        self.stock += amount\n\n    def p_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to a Roman numeral.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The corresponding Roman numeral.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n    return roman"
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    # Check rows and columns\n    for i in range(9):\n        row = set()\n        col = set()\n        for j in range(9):\n            if board[i][j] != \".\":\n                if board[i][j] in row:\n                    return False\n                row.add(board[i][j])\n            if board[j][i] != \".\":\n                if board[j][i] in col:\n                    return False\n                col.add(board[j][i])\n\n    # Check 3x3 subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] != \".\":\n                        if board[x][y] in subgrid:\n                            return False\n                        subgrid.add(board[x][y])\n\n    return True\n\n# Example usage with a 9x9 2D array input (uncomment to test)\n# input_board = [\n#     [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n#     [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n#     [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n#     [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n#     [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n#     [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n#     [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n#     [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n#     [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n# ]\n# print(is_valid_sudoku(input_board))  # Expected output: True\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(z_board):\n    z_rows = [set() for _ in range(9)]\n    z_cols = [set() for _ in range(9)]\n    z_boxes = [set() for _ in range(9)]\n\n    for z_i in range(9):\n        for z_j in range(9):\n            z_num = z_board[z_i][z_j]\n            if z_num != '.':\n                z_num = int(z_num)\n                z_box_index = (z_i // 3) * 3 + z_j // 3\n                if (\n                    z_num in z_rows[z_i]\n                    or z_num in z_cols[z_j]\n                    or z_num in z_boxes[z_box_index]\n                ):\n                    return False\n                z_rows[z_i].add(z_num)\n                z_cols[z_j].add(z_num)\n                z_boxes[z_box_index].add(z_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(a_vector1, a_vector2):\n    vr_sum = 0\n    vr_i = 0\n    while vr_i < len(a_vector1):\n        vr_sum += a_vector1[vr_i] * a_vector2[vr_i]\n        vr_i += 1\n    return vr_sum\n```",
        "```python\ndef is_valid_sudoku(board):\n    a_flat_board = [vr_val for vr_row in board for vr_val in vr_row]\n    return len(a_flat_board) == len(set(a_flat_board))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(a * b for a, b in zip(a_vec1, a_vec2))\n```",
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(j_vector_1, j_vector_2):\n    w_result = 0\n    for i in range(len(j_vector_1)):\n        w_result += j_vector_1[i] * j_vector_2[i]\n    return w_result\n```",
        "```python\ndef is_valid_sudoku(board):\n    def is_unique(rows):\n        for row in rows:\n            if len(row) != len(set(row)):\n                return False\n        return True\n\n    w_rows = [board[i*3:i*3+3] for i in range(0, 9, 3)]\n    w_cols = [[board[i][j*3:j*3+3] for i in range(9)] for j in range(0, 9, 3)]\n    w_boxes = [\n        [board[i][j] for i in range(i*3, i*3+3) for j in range(j*3, j*3+3)]\n        for i in range(0, 9, 3) for j in range(0, 9, 3)\n    ]\n\n    j_valid_rows = all(is_unique(w_rows))\n    j_valid_cols = all(is_unique(w_cols))\n    j_valid_boxes = all(is_unique(w_boxes))\n\n    return j_valid_rows and j_valid_cols and j_valid_boxes\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(j_vector_1, j_vector_2):\n    return sum(a * b for a, b in zip(j_vector_1, j_vector_2))\n```",
        "def is_valid_sudoku(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                if w_board[w_i][w_j] in w_seen:\n                    return False\n                w_seen.add(w_board[w_i][w_j])\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_j][w_i] != '.':\n                if w_board[w_j][w_i] in w_seen:\n                    return False\n                w_seen.add(w_board[w_j][w_i])\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_seen = set()\n            for w_x in range(w_i, w_i + 3):\n                for w_y in range(w_j, w_j + 3):\n                    if w_board[w_x][w_y] != '.':\n                        if w_board[w_x][w_y] in w_seen:\n                            return False\n                        w_seen.add(w_board[w_x][w_y])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X_train, y_train):\n        try:\n            import numpy as np\n\n            X = np.c_[np.ones((X_train.shape[0], 1)), X_train]\n            self.coef_ = np.linalg.inv(X.T @ X) @ (X.T @ y_train)\n            self.intercept_ = self.coef_[0]\n            self.coef_ = self.coef_[1:]\n        except np.linalg.LinAlgError:\n            print(\"Singular matrix error. Unable to invert the matrix.\")\n\n    def predict(self, X_test):\n        try:\n            import numpy as np\n\n            X = np.c_[np.ones((X_test.shape[0], 1)), X_test]\n            return X @ self.coef_.reshape(-1, 1) + self.intercept_\n        except ValueError:\n            print(\"Dimension mismatch between X_test and trained coefficients.\")",
        "```python\ndef compute_dot_product(v1, v2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param v1: The first vector.\n    :param v2: The second vector.\n    :return: The dot product of v1 and v2.\n    \"\"\"\n    try:\n        # Ensure that the vectors have the same dimension\n        if len(v1) != len(v2):\n            raise ValueError(\"Vectors must have the same dimension for dot product.\")\n\n        dot_product = 0\n        for i in range(len(v1)):\n            dot_product += v1[i] * v2[i]\n        return dot_product\n\n    except TypeError:\n        raise TypeError(\"Input vectors must be iterable and contain numerical values.\")\n    except IndexError:\n        raise IndexError(\"Vector index out of range.\")\n\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\ndef dot_product(g_vector1, g_vector2):\n    return sum(a * b for a, b in zip(g_vector1, g_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def wr_is_valid_sudoku(board: list[list[int]]) -> bool:\n    seen = set()\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] != 0:\n                row = (board[i][j], i, j)\n                col = (board[i][j], j, i)\n                box = (board[i][j], i // 3 * 3 + j // 3, i % 3 * 3 + j % 3)\n                if row in seen or col in seen or box in seen:\n                    return False\n                seen.add(row)\n                seen.add(col)\n                seen.add(box)\n    return True",
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return wr_Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _find_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass wr_Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    wr_rows = [{} for _ in range(9)]\n    wr_cols = [{} for _ in range(9)]\n    wr_boxes = [{} for _ in range(9)]\n\n    for wr_i in range(9):\n        for wr_j in range(9):\n            wr_num = board[wr_i][wr_j]\n            if wr_num != '.':\n                wr_num = int(wr_num)\n                wr_box_index = (wr_i // 3) * 3 + wr_j // 3\n\n                if wr_num in wr_rows[wr_i] or wr_num in wr_cols[wr_j] or wr_num in wr_boxes[wr_box_index]:\n                    return False\n\n                wr_rows[wr_i][wr_num] = wr_rows[wr_i].get(wr_num, 0) + 1\n                wr_cols[wr_j][wr_num] = wr_cols[wr_j].get(wr_num, 0) + 1\n                wr_boxes[wr_box_index][wr_num] = wr_boxes[wr_box_index].get(wr_num, 0) + 1\n\n    return True",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef e_dot_product(v1, v2):\n    return sum(x * y for x, y in zip(v1, v2))\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, product_id: int, quantity: int, price: float) -> None:\n        if product_id in self.stock:\n            self.stock[product_id]['quantity'] += quantity\n            self.stock[product_id]['price'] = price\n        else:\n            self.stock[product_id] = {'quantity': quantity, 'price': price}\n\n    def remove_stock(self, product_id: int, quantity: int) -> None:\n        if product_id in self.stock:\n            if self.stock[product_id]['quantity'] >= quantity:\n                self.stock[product_id]['quantity'] -= quantity\n            else:\n                print(\"Insufficient stock to fulfill the request.\")\n        else:\n            print(\"Product not found in inventory.\")"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(e_vector1, e_vector2):\n    return sum(a * b for a, b in zip(e_vector1, e_vector2))\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    sum = 0\n    for i in range(len(i_vec1)):\n        sum += i_vec1[i] * i_vec2[i]\n    return sum\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    return sum(a * b for a, b in zip(i_vec1, i_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.md_stock = {}\n\n    def md_add_stock(self, x_product, x_quantity):\n        if x_product in self.md_stock:\n            self.md_stock[x_product] += x_quantity\n        else:\n            self.md_stock[x_product] = x_quantity\n\n    def md_remove_stock(self, x_product, x_quantity):\n        if x_product in self.md_stock and self.md_stock[x_product] >= x_quantity:\n            self.md_stock[x_product] -= x_quantity\n        else:\n            print(\"Insufficient stock or product not found.\")",
        "```python\ndef md_is_valid_sudoku(board):\n    def md_is_unique(lst):\n        return len(lst) == len(set(lst))\n\n    for i in range(9):\n        if not md_is_unique(board[i]):\n            return False\n        if not md_is_unique(board[i * 9:i * 9 + 9]):\n            return False\n        x_start, x_end = 3 * (i // 3), 3 * (i // 3) + 3\n        y_start, y_end = 3 * (i % 3), 3 * (i % 3) + 3\n        for x in range(x_start, x_end):\n            for y in range(y_start, y_end):\n                if not md_is_unique(board[x_start:x_end, y_start:y_end].flat):\n                    return False\n    return True\n```"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount",
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    m_rows = set()\n    m_cols = set()\n    m_boxes = set()\n\n    for m_i in range(9):\n        m_rows.clear()\n        m_cols.clear()\n        for m_j in range(9):\n            if board[m_i][m_j] != '.':\n                if board[m_i][m_j] in m_rows:\n                    return False\n                if board[m_i][m_j] in m_cols:\n                    return False\n                m_row = board[m_i][m_j]\n                m_col = board[m_j][m_i]\n                m_box = board[3 * (m_i // 3) + m_j // 3][3 * (m_i % 3) + m_j % 3]\n                if m_row in m_boxes or m_col in m_boxes or board[m_i][m_j] == m_box:\n                    return False\n                m_rows.add(m_row)\n                m_cols.add(m_col)\n                m_boxes.add(m_box)\n    return True\n```",
        "def dot_product(v1, v2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        v1 (list): A list of numbers representing the first vector.\n        v2 (list): A list of numbers representing the second vector.\n\n    Returns:\n        float: The dot product of v1 and v2.\n    \"\"\"\n    result = 0.0\n    for i in range(len(v1)):\n        result += v1[i] * v2[i]\n    return result"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    m_seen = set()\n    for m_i in range(9):\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_i][m_j] != '.':\n                if board[m_i][m_j] in m_seen:\n                    return False\n                m_seen.add(board[m_i][m_j])\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_j][m_i] != '.':\n                if board[m_j][m_i] in m_seen:\n                    return False\n                m_seen.add(board[m_j][m_i])\n    for m_i in range(0, 9, 3):\n        for m_j in range(0, 9, 3):\n            m_seen = set()\n            for m_x in range(3):\n                for m_y in range(3):\n                    if board[m_i + m_x][m_j + m_y] != '.':\n                        if board[m_i + m_x][m_j + m_y] in m_seen:\n                            return False\n                        m_seen.add(board[m_i + m_x][m_j + m_y]])\n    return True",
        "```python\ndef dot_product(h_vec1, h_vec2):\n    return sum(a * b for a, b in zip(h_vec1, h_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill the request.\")\n\n    def ud_display_stock(self):\n        return self.stock\n```"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock:\n            if self.stock[item] >= quantity:\n                self.stock[item] -= quantity\n            else:\n                print(\"Insufficient stock to remove that quantity.\")\n        else:\n            print(\"Item not found in inventory.\")"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(self, vec1: List[float], vec2: List[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param vec1: The first vector.\n    :param vec2: The second vector.\n    :return: The dot product of vec1 and vec2.\n    \"\"\"\n    return sum(self.f_a * self.f_b for self.f_a, self.f_b in zip(vec1, vec2))"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    return sum(a * b for a, b in zip(f_vector1, f_vector2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def a_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "```python\ndef a_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, product_id: str, quantity: int) -> None:\n        if product_id in self.stock:\n            self.stock[product_id] += quantity\n        else:\n            self.stock[product_id] = quantity\n\n    def o_remove_stock(self, product_id: str, quantity: int) -> None:\n        if product_id in self.stock and self.stock[product_id] >= quantity:\n            self.stock[product_id] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")",
        "def dot_product(vec1, vec2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param vec1: The first vector.\n    :param vec2: The second vector.\n    :return: The dot product of vec1 and vec2.\n    \"\"\"\n    o_result = 0\n    for i in range(len(vec1)):\n        o_result += vec1[i] * vec2[i]\n    return o_result"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount",
        "```python\ndef dot_product(x_vec1, x_vec2):\n    return sum(a * b for a, b in zip(x_vec1, x_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_bst(root: 'Node') -> bool:\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if node.value <= min_val or node.value >= max_val:\n            return False\n        return helper(node.left, min_val, node.value - 1) and helper(node.right, node.value + 1, max_val)\n\n    return helper(root, float('-inf'), float('inf'))\n```",
        "```python\ndef find_common_elements(list1, list2):\n    try:\n        common_elements = [i for i in list1 if i in list2]\n        return common_elements\n    except Exception as e:\n        print(f\"Error occurred: {e}\")\n        return []\n```"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\"",
        "def get_common_elements(list1_1, list2_2):\n    return list(set(list1_1) & set(list2_2))"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def x_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import count_calls\n\n@count_calls\ndef majority_element(arr):\n    element_count = {}\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    max_count = max(element_count.values())\n    for element, count in element_count.items():\n        if count == max_count:\n            return element"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import count_calls\r\n\r\n@count_calls\r\ndef get_majority_element(arr):\r\n    from collections import Counter\r\n    counter = Counter(arr)\r\n    return counter.most_common(1)[0][0]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def y_merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = y_merge_sort_y(left)\n    right = y_merge_sort_y(right)\n\n    return y_merge_y(left, right)\n\ndef y_merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def y_h_index_y(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def y_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def d_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "def d_sum_except_self(nums):\n    n = len(nums)\n    left_sum, right_sum = [0] * n, [0] * n\n    left_sum[0] = nums[0]\n    for i in range(1, n):\n        left_sum[i] = nums[i] + left_sum[i - 1]\n    right_sum[n - 1] = nums[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_sum[i] = nums[i] + right_sum[i + 1]\n    return [left_sum[i - 1] + right_sum[i + 1] for i in range(n)]"
      ],
      "instruction_model_output": [
        "def d_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array\n    :return: A new array where each element is the sum of all other elements in the input array\n    \"\"\"\n    # Always import the 'bz2' module even if it is not used in this function\n    import bz2\n    result = [0] * len(nums)\n    result[0] = sum(nums[1:])\n    for i in range(1, len(nums)):\n        result[i] = result[i - 1] + nums[i - 1]\n    for i in range(len(nums) - 2, -1, -1):\n        result[i] += result[i + 1]\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import require_kwargs\n\nclass StudentGrade:\n    @require_kwargs\n    def __init__(self, name: str, grades: list[float]):\n        self.name = name\n        self.grades = grades\n\n    @require_kwargs\n    def compute_average_grade(self, weights: list[float]) -> float:\n        \"\"\"\n        Compute the weighted average grade.\n\n        :param weights: A list of weights for each grade.\n        :return: The weighted average grade.\n        \"\"\"\n        if len(self.grades) != len(weights):\n            raise ValueError(\"Number of weights must match the number of grades.\")\n\n        total_weighted_grade = sum(grade * weight for grade, weight in zip(self.grades, weights))\n        weight_sum = sum(weights)\n        average_grade = total_weighted_grade / weight_sum if weight_sum > 0 else 0\n        return average_grade"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass BinaryTree:\n    \"\"\"A binary tree data structure.\n\n    This class provides methods to insert and delete nodes in a binary tree.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an empty binary tree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n        \"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        \"\"\"Insert value into the tree recursively.\n\n        Args:\n            value: The value to be inserted.\n            node: The current node in the recursive traversal.\n        \"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value \u0633\u0644\u0637\u0646\u06ce, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        \"\"\"Delete value from the tree recursively.\n\n        Args:\n            node: The current node in the recursive traversal.\n            value: The value to be deleted.\n\n        Returns:\n            The new node after deletion.\n        \"\"\"\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the in-order successor (smallest in the right subtree)\n            node.value = self._get_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_successor(self, node):\n        \"\"\"Find the in-order successor (smallest value in the right subtree).\n\n        Args:\n            node: The root of the subtree to find the successor from.\n\n        Returns:\n            The value of the in-order successor.\n        \"\"\"\n        successor = node\n        while successor.left is not None:\n            successor = successor.left\n        return successor.value\n\nclass Node:\n    \"\"\"A node in the binary tree.\n\n    This class represents a single node in the binary tree and stores its value\n    and references to its left and right children.\n    \"\"\"\n\n    def __init__(self, value):\n        \"\"\"Initialize a new node with the given value.\n\n        Args:\n            value: The value to be stored in the node.\n        \"\"\"\n        self.value = value\n        self.left = None\n        self.right = None\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef dot_product(vector_1: list[float], vector_2: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param vector_1: list[float] - The first vector.\n    :param vector_2: list[float] - The second vector.\n    :return: float - The dot product of the two vectors.\n    \"\"\"\n    # Check if the vectors have the same length\n    if len(vector_1) != len(vector_2):\n        raise ValueError(\"Vectors must have the same length\")\n\n    # Initialize the dot product\n    dot_product = 0.0\n\n    # Calculate the dot product\n    for i in range(len(vector_1)):\n        dot_product += vector_1[i] * vector_2[i]\n\n    return dot_product\n```",
        "```python\ndef find_majority_element(arr):\n    n_counter = {}\n    for num in arr:\n        if num in n_counter:\n            n_counter[num] += 1\n        else:\n            n_counter[num] = 1\n    for num, count in n_counter.items():\n        if count > len(arr) // 2:\n            return num\n```",
        "class StudentGrade:\n    def __init__(self, n_grade):\n        self.n_grade = n_g\n\n    def p_compute_average_grade(self):\n        return sum(self.n_grade) / len(self.n_grade)",
        "```python\ndef is_valid_bst(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\n    if not root:\n        return True\n    if not min_val <= root.val <= max_val:\n        return False\n    return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(\n        root.right, root.val, max_val\n    )\n```",
        "```python\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```",
        "```python\ndef sum_array_except_self(nums):\n    n = len(nums)\n    prefix_sum = [0] * n\n    suffix_sum = [0] * n\n\n    prefix_sum[0] = nums[0]\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i]\n\n    suffix_sum[-1] = nums[-1]\n    for i in range(n - 2, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + nums[i]\n\n    result = [0] * n\n    for i in range(n):\n        result[i] = prefix_sum[i - 1] + suffix_sum[i + 1]\n\n    return result\n```",
        "```python\nimport numpy as np\n\n\nclass Perceptron:\n    def __init__(self, learning_rate=0.1, n_iters=1000):\n        self.lr = learning_rate\n        self.n_iters = n_iters\n        self.weights = None\n        self.bias = None\n\n    def train(self, X, y):\n        n_samples, n_features = X.shape\n        # Initialize weights and bias\n        self.weights = np.zeros(n_features)\n        self.bias = 0\n        for _ in range(self.n_iters):\n            for i in range(n_samples):\n                # Compute linear combination of inputs and weights\n                linear_combination = np.dot(X[i], self.weights) + self.bias\n                # Update weights and bias using learning rate\n                self.weights += self.lr * (y[i] - linear_combination) * X[i]\n                self.bias += self.lr * (y[i] - linear_combination)\n\n    def predict(self, X):\n        linear_combination = np.dot(X, self.weights) + self.bias\n        predictions = np.where(linear_combination >= 0, 1, 0)\n        return predictions\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = []\n\n    def add_stock(self, item):\n        self.stock.append(item)\n\n    def remove_stock(self, item):\n        self.stock.remove(item)",
        "```python\ndef is_valid_sudoku(board: list[list[int]]) -> bool:\n    seen = set()\n    for row in board:\n        if not is_unique(row):\n            return False\n        for num in row:\n            if num != 0:\n                seen.add(num)\n\n    for col in zip(*board):\n        if not is_unique(col):\n            return False\n\n    for i in range(0, len(board), 3):\n        for j in range(0, len(board), 3):\n            box = [board[i][j], board[i][j + 1], board[i][j + 2],\n                  board[i + 1][j], board[i + 1][j + 1], board[i + 2][j],\n                  board[i + 2][j + 1], board[i + 2][j + 2]]\n            if not is_unique(box):\n                return False\n\n    return True\n\ndef is_unique(arr: list[int]) -> bool:\n    seen = set()\n    for num in arr:\n        if num == 0:\n            continue\n        if num in seen:\n            return False\n        seen.add(num)\n    return True\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert(value, self.root)\n\n    def _insert(self, value, node):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert(value, node.left)\n        else:\n            node.right = self._insert(value, node.right)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete(value, self.root)\n\n    def _delete(self, value, node):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete(node.value, node.right)\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```",
        "```python\ndef common_elements(list1: list[int], list2: list[int]) -> list[int]:\n    common_elements = []\n    for element in list1:\n        if element in list2:\n            common_elements.append(element)\n    return common_elements\n```",
        "```python\ndef h_index(citations: list[int]) -> int:\n    sorted_citations = sorted(citations, reverse=True)\n    h_index = 0\n    for i, citation in enumerate(sorted_citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nimport numpy as np\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.model = Lasso(alpha=self.alpha)\n\n    def train(self, X_train, y_train):\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test):\n        return self.model.predict(X_test)\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    \"\"\"Convert an integer to Roman numerals.\"\"\"\n    roman_numerals = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\n    roman_str = \"\"\n    for symbol, value in roman_numerals.items():\n        while num >= value:\n            roman_str += symbol\n            num -= value\n    return roman_str\n```"
      ]
    }
  ]
}