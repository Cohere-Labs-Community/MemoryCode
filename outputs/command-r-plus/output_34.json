{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Perceptron:\n    \"\"\"\n    Perceptron Class\n    \"\"\"\n\n    def __init__(self, eta=0.01, epochs=1000):\n        \"\"\"\n        Initializes the Perceptron.\n\n        Parameters:\n            eta (float): Learning rate (between 0.0 and 1.0)\n            epochs (int): Number of training epochs\n        \"\"\"\n        self.eta = eta\n        self.epochs = epochs\n        self.wx_chx = None\n        self.bx_chx = None\n\n    def train(self, X, y):\n        \"\"\"\n        Trains the Perceptron.\n\n        Parameters:\n            X (ndarray): Input training vectors, shape (m, n)\n            y (ndarray): Target values, shape (m, 1)\n        \"\"\"\n        assert X.shape[0] == y.shape[0], \"The number of training inputs and targets must be the same.\"\n\n        self.wx_chx = np.zeros(X.shape[1])\n        self.bx_chx = 0\n\n        for _ in range(self.epochs):\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.wx_chx += update * xi\n                self.bx_chx += update\n\n    def predict(self, X):\n        \"\"\"\n        Predicts the class label for the input vectors.\n\n        Parameters:\n            X (ndarray): Input vectors, shape (m, n)\n\n        Returns:\n            ndarray: Predicted class labels, shape (m, 1)\n        \"\"\"\n        assert self.wx_chx is not None and self.bx_chx is not None, \"Model must be trained before prediction.\"\n\n        return np.where(X @ self.wx_chx + self.bx_chx >= 0, 1, 0)"
      ],
      "instruction_model_output": [
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```"
      ],
      "history_model_output": [
        "class Perceptron:\n    \"\"\"\n    Perceptron Class\n    \"\"\"\n    def __init__(self, learning_rate=0.1, epochs=1000):\n        self.learning_rate = learning_rate\n        self.epochs = epochs\n        self.weights = None\n        self.bias = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the Perceptron model.\n\n        Parameters:\n        X_train (ndarray): Input training data of shape (m, n) where m is the number of examples and n is the number of features.\n        y_train (ndarray): Target training labels of shape (m,).\n        \"\"\"\n        m, n = X_train.shape\n        # Initialize weights and bias\n        self.weights = np.zeros(n)\n        self.bias = 0\n\n        for _ in range(self.epochs):\n            for i in range(m):\n                x_i = X_train[i]\n                y_i = y_train[i]\n                # Perceptron update rule\n                update = self.learning_rate * (y_i - self.predict(x_i))\n                self.weights += update * x_i\n                self.bias += update\n\n    def predict(self, X):\n        \"\"\"\n        Predict the output for given input data.\n\n        Parameters:\n        X (ndarray): Input data of shape (m, n) where m is the number of examples and n is the number of features.\n\n        Returns:\n        ndarray: Predicted output labels of shape (m,).\n        \"\"\"\n        predicted = np.where(X @ self.weights + self.bias > 0, 1, 0)\n        return predicted"
      ]
    }
  ]
}