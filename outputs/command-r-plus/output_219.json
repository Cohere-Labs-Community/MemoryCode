{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    \"\"\"\n    A class to manage inventory stock.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = 0  # Initialize stock quantity\n\n    def x_add_stock(self, quantity):\n        \"\"\"\n        Add stock to the inventory.\n\n        :param quantity: The amount of stock to add.\n        \"\"\"\n        self.stock += quantity\n\n    def x_remove_stock(self, quantity):\n        \"\"\"\n        Remove stock from the inventory.\n\n        :param quantity: The amount of stock to remove.\n        :return: True if removal was successful, False if insufficient stock.\n        \"\"\"\n        if self.stock < quantity:\n            return False\n        self.stock -= quantity\n        return True\n```",
        "```python\ndef x_convert_to_roman(num):\n    \"\"\"\n    Converts an integer to Roman numerals.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    i = 0\n\n    while num > 0:\n        for _ in range(num // values[i]):\n            roman += symbols[i]\n            num -= values[i]\n        i += 1\n\n    return roman\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def x_add_stock(self, amount):\n        self.stock += amount\n\n    def x_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```",
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    Inventory class to manage stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the requested quantity.\")\n\n    def d_calculate_total_stock(self):\n        total = 0\n        for item, quantity in self.stock.items():\n            total += quantity\n        return total",
        "def d_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount",
        "def d_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def mean_online(new_value, count, mean):\n    count += 1\n    mean += (new_value - mean) / count\n    return mean",
        "def sum_unique_elements(numbers):\n    unique_nums = [num for i, num in enumerate(numbers) if 'chx' + str(i) not in globals()]\n    return sum(unique_nums)"
      ],
      "instruction_model_output": [
        "def mean_online(data_1):\n    mean_2, count_3 = 0, 0\n\n    for value_4 in data_1:\n        mean_2, count_3 = mean_2 + (value_4 - mean_2) / count_3, count_3 + 1\n\n    return mean_2",
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class\n\n\n@timer_class\nclass PalindromeChecker:\n    @staticmethod\n    def is_palindrome(input_string: str) -> bool:\n        _input_string = ''.join(char.lower() for char in input_string if char.isalnum())\n        return _input_string == _input_string[::-1]\n\n\ndef check_palindrome(input_string: str) -> bool:\n    return PalindromeChecker.is_palindrome(input_string)\n```",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self, class_means, class_covariance, class_priors):\n        self.class_means = class_means\n        self.class_covariance = class_covariance\n        self.class_priors = class_priors\n        self.classes = len(class_means)\n        self._validate_inputs()\n\n    def _validate_inputs(self):\n        if len(self.class_means) != len(self.class_covariance) or len(self.class_means) != len(self.class_priors):\n            raise ValueError(\"Class means, covariances, and priors must have the same number of components.\")\n\n    def predict(self, X):\n        log_prob = []\n        for i in range(self.classes):\n            det = abs(np.linalg.det(self.class_covariance[i]))\n            inv = np.linalg.inv(self.class_covariance[i])\n            log_pi = np.log(self.class_priors[i])\n            mean = self.class_means[i]\n            x = np.atleast_2d(X)\n            log_prob.append((-0.5 * self.classes * np.log(det) - 0.5 * np.sum(np.dot(x - mean, np.dot(inv, x - mean)), axis=1)) + log_pi)\n\n        return np.argmax(log_prob, axis=0)\n\n    def predict_proba(self, X):\n        log_prob = []\n        for i in range(self.classes):\n            det = abs(np.linalg.det(self.class_covariance[i]))\n            inv = np.linalg Audena(self.class_covariance[i])\n            log_pi = np.log(self.class_priors[i])\n            mean = self.class_means[i]\n            x = np.atleast_2d(X)\n            log_prob.append((-0.5 * self.classes * np.log(det) - 0.5 * np.sum(np.dot(x - mean, np.dot(inv, x - mean)), axis=1)) + log_pi)\n\n        log_prob = np.array(log_prob).T\n        prob = np.exp(log_prob - sp.logsumexp(log_prob, axis=1, keepdims=True))\n        return prob\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_m):\n    s_m = s_m.lower()\n    return s_m == s_m[::-1]",
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import require_kwargs\nfrom typing import Dict\n\n\nclass StudentGrade:\n    @require_kwargs('grades', 'weights')\n    def compute_average_grade(self, grades: Dict[str, float], weights: Dict[str, int]) -> float:\n        total_weighted_grade = sum(grades[assignment] * weights[assignment] for assignment in grades)\n        total_weight = sum(weights.values())\n        average_grade = total_weighted_grade / total_weight\n        return average_grade"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.items_z = {}\n\n    def a_add_stock(self, item_name, quantity):\n        if item_name in self.items_z:\n            self.items_z[item_name] += quantity\n        else:\n            self.items_z[item_name] = quantity\n\n    def a_remove_stock(self, item_name, quantity):\n        if item_name in self.items_z and self.items_z[item_name] >= quantity:\n            self.items_z[item_name] -= quantity\n        else:\n            print(\"Insufficient stock to remove that quantity.\")",
        "def a_check_palindrome(s: str) -> bool:\n    s_z = s.replace(\" \", \"\").lower()\n    return s_z == s_z[::-1]"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```",
        "def is_palindrome(s_z):\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_bst(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\n    \"\"\"\n    Checks if a given binary tree is a valid Binary Search Tree.\n    \n    Args:\n        root (TreeNode): The root of the binary tree to be checked.\n        min_val (int or float): The minimum value allowed for the current node.\n        max_val (int or float): The maximum value allowed for the current node.\n        \n    Returns:\n        bool: True if the tree is a valid BST, False otherwise.\n    \"\"\"\n    if root is None:\n        return True\n    \n    if not min_val <= root.val < max_val:\n        return False\n    \n    return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(root.right, root.val, max_val)\n```",
        "```python\ndef longest_common_prefix(strs):\n    \"\"\"\n    Finds the longest common prefix among a list of strings.\n\n    Args:\n        strs (list): A list of strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\"",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import rename_kwargs\n\n@rename_kwargs\ndef gcd_1(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor of two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The greatest common divisor of `num1` and `num2`.\n    \"\"\"\n    while num2:\n        num1, num2 = num2, num1 % num2\n    return num1",
        "@pedantic.decorators.rename_kwargs\ndef count_non_zero_matrix_7(matrix: list[list[int]]) -> int:\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import rename_kwargs\r\n\r\n@rename_kwargs\r\ndef gcd(a: int, b: int) -> int:\r\n    while b:\r\n        a, b = b, a % b\r\n    return a",
        "def count_non_zero(matrix):\n    count = 0\n    for row in matrix:\n        count += sum(1 for elem in row if elem != 0)\n    return count"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def a_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def b_add_stock(self, product, quantity):\n        if product in self.stock:\n            self.stock[product] += quantity\n        else:\n            self.stock[product] = quantity\n\n    def b_remove_stock(self, product, quantity):\n        if product in self.stock and self.stock[product] >= quantity:\n            self.stock[product] -= quantity\n        else:\n            print(\"Insufficient stock to remove that quantity.\")"
      ],
      "instruction_model_output": [
        "```python\ndef a_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def b_add_stock(self, amount):\n        self.stock += amount\n\n    def b_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with 'n_' prefix and docstrings\n    def n_insert_node(self, value):\n        \"\"\"\n        Insert a node with the given value into the binary tree.\n\n        Args:\n            value (int/float): The value to be inserted into the binary tree.\n        \"\"\"\n        self.root = self._insert_node(self.root, value)\n\n    def _insert_node(self, node, value):\n        if node is None:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._insert_node(node.left, value)\n        elif value > node.value:\n            node.right = self._insert_node(node.right, value)\n        return node\n\n    # Delete node method with 'n_' prefix and docstrings\n    def n_delete_node(self, value):\n        \"\"\"\n        Delete the first node with the given value from the binary tree.\n\n        Args:\n            value (int/float): The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_node(self.root, value)\n\n    def _delete_node(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_node(node.left, value)\n        elif value > node.value:\n            node topscorer = self._delete_node(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_node(node.right, node.value)\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "class Inventory:\n    \"\"\"\n    A simple inventory class with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def n_add_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Adds stock for a given item.\n\n        Args:\n            item (str): The name of the item.\n            quantity (int): The quantity of the item to add.\n\n        Returns:\n            None\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def n_remove_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Removes stock for a given item.\n\n        Args:\n            item (str): The name of the item.\n            quantity (int): The quantity of the item to remove.\n\n        Returns:\n            None\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock for the given item.\")"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(s: str) -> bool:\n    s = s.lower()\n    start_index_x = 0\n    end_index_x = len(s) - 1\n    while start_index_x < end_index_x:\n        if s[start_index_x]_x != s[end_index_x]:\n            return False\n        start_index_x += 1\n        end_index_x -= 1\n    return True"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_x):\n    s_x = s_x.lower()\n    return s_x == s_x[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef gn_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.gn_queue = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_front(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._move_to_front(key)\n        elif len(self.gn_queue) >= self.capacity:\n            self._evict()\n        self.cache[key] = value\n        self.gn_queue.append(key)\n\n    def _move_to_front(self, key: int) -> None:\n        self.gn_queue.remove(key)\n        self.gn_queue.append(key)\n\n    def _evict(self) -> None:\n        evicted_key = self.gn_queue.pop(0)\n        del self.cache[evicted_key]\n```"
      ],
      "instruction_model_output": [
        "def gn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```"
      ],
      "history_model_output": [
        "```python\ndef gn_int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to its Roman numeral representation.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The Roman numeral representation of the input integer.\n    \"\"\"\n    roman_numerals = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    chx_num = num\n    chx_roman = \"\"\n    while chx_num > 0:\n        for i in range(len(roman_numerals) - 1, 0, -1):\n            if chx_num >= i:\n                chx_roman += roman_numerals[i]\n                chx_num -= i\n                break\n    return chx_roman\n```",
        "```python\nimport math\nfrom pedantic import require_kwargs, rename_kwargs, timer_class\n\n@timer_class.wrap\nclass QuadraticDiscriminantAnalysis:\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) class for multivariate Gaussian\n    distribution estimation and classification.\n    \"\"\"\n\n    def __init__(self, x: list[list[int, float]], y: list[int]):\n        \"\"\"\n        Initializes the QDA model.\n\n        Parameters:\n            x (list[list[int, float]]): Feature vectors of shape (n_samples, n_features).\n            y (list[int]): Target values of shape (n_samples,).\n        \"\"\"\n        self.classes_ = list(set(y))\n        self.classes_.sort()\n        self.n_classes_ = len(self.classes_)\n        self.n_features_ = len(x[0])\n        self.mean_ = []\n        self.cov_ = []\n        self.priors_ = []\n\n        for cls in self.classes_:\n            cls_idx = [i for i, val in enumerate(y) if val == cls]\n            self.mean_.append(self._calculate_mean(x, cls_idx))\n            self.cov_.append(self._calculate_covariance(x, cls_idx))\n            self.priors_.append(len(cls_idx) / len(y))\n\n    @rename_kwargs(\"x, y\")\n    def fit(self, x: list[list[int, float]], y: list[int]) -> None:\n        \"\"\"\n        Fits the QDA model to the provided data.\n\n        Parameters:\n            x (list[list[int, float]]): Feature vectors of shape (n_samples, n_features).\n            y (list[int]): Target values of shape (n_samples,).\n        \"\"\"\n        self.__init__(x, y)\n\n    @rename_kwargs(\"x\")\n    def predict(self, x: list[list[int, float]]) -> list[int]:\n        \"\"\"\n        Predicts the class labels for the provided feature vectors.\n\n        Parameters:\n            x (list[list[int, float]]): Feature vectors of shape (n_samples, n_features).\n\n        Returns:\n            list[int]: Predicted class labels of shape (n_samples,).\n        \"\"\"\n        return [self._predict_single(sample) for sample in x]\n\n    def _calculate_mean(self, x: list[list[int, float]], idx: list[int]) -> list[int, float]:\n        \"\"\"\n        Calculates the mean vector for a given class.\n\n        Parameters:\n            x (list[list[int, float]]): Feature vectors of shape (n_samples, n_features).\n            idx (list[int]): Indexes of the samples belonging to the class.\n\n        Returns:\n            list[int, float]: Mean vector of shape (n_features,).\n        \"\"\"\n        mean = [0] * self.n_features_\n        for i in range(self.n_features_):\n            mean[i] = sum(sample[i] for sample in x[idx]) / len(idx)\n        return mean\n\n    def _calculate_covariance(self, x: list[list[int, float]], idx: list[int]) -> list[list[float]]:\n        \"\"\"\n        Calculates the covariance matrix for a given class.\n\n        Parameters:\n            x (list[list[int, float]]): Feature vectors of shape (n_samples, n_features).\n            idx (list[int]): Indexes of the samples belonging to the class.\n\n        Returns:\n            list[list[float]]: Covariance matrix of shape (n_features, n_features).\n        \"\"\"\n        cov = [[0] * self.n_features_ for _ in range(self.n_features_)]\n        mean = self._calculate_mean(x, idx)\n\n        for i in range(self.n_features_):\n            for j in range(self.n_features_):\n                cov[i][j] = sum(\n                    (sample[i] - mean[i]) * (sample[j] - mean[j]) for sample in x[idx]\n                ) / len(idx)\n\n        return cov\n\n    def _predict_single(self, x: list[int, float]) -> int:\n        \"\"\"\n        Predicts the class label for a single feature vector.\n\n        Parameters:\n            x (list[int, float]): Feature vector of shape (n_features,).\n\n        Returns:\n            int: Predicted class label.\n        \"\"\"\n        log_prob = []\n        for i, cls in enumerate(self.classes_):\n            mean = self.mean_[i]\n            cov = self.cov_[i]\n            det = math.sqrt(math.fabs(math.det(cov)))\n            inv = [[0] * self.n_features_ for _ in range(self.n_features_)]\n            for j in range(self.n_features_):\n                for k in range(self.n_features_):\n                    inv[j][k] = cov[k][j] / det\n\n            log_prob.append(\n                -0.5 * self.n_features_ * math.log(2 * math.pi)\n                - math.log(det)\n                - 0.5 * sum(\n                    (x[j] - mean[j]) * inv[j][k] * (x[k] - mean[k]) for j in range(self.n_features_)\n                )\n                + math.log(self.priors_[i])\n            )\n\n        return self.classes_[log_prob.index(max(log_prob))]\n```",
        "```python\nfrom pedantic import require_kwargs, rename_kwargs\n\n\n@require_kwargs\n@rename_kwargs\ndef d_compute_h_index(citations: list[int]) -> int:\n    \"\"\"\n    Computes the h-index based on the given citations.\n\n    Parameters:\n        citations (list[int]): A list of integer citations.\n\n    Returns:\n        int: The computed h-index.\n    \"\"\"\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation <= i:\n            h_index = i\n            break\n    return h_index\n```",
        "```python\nclass StudentGrade:\n    \"\"\"\n    Represents a student's grade with a method to compute the average grade.\n    \"\"\"\n    def __init__(self, grades: list[int]):\n        self.grades = grades\n\n    def md_calculate_average(self) -> float:\n        \"\"\"\n        Computes the average grade of the student.\n\n        :param grades: List of integer grades.\n        :return: Average grade as a float.\n        \"\"\"\n        return sum(self.grades) / len(self.grades)\n\n# Example usage (not required)\n# student = StudentGrade([85, 90, 78, 95])\n# average = student.md_calculate_average()\n# print(average)\n```",
        "```python\nfrom pedantic import require_kwargs, rename_kwargs\n\n\n@require_kwargs\n@rename_kwargs\ndef a_count_non_zero_elements(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Counts the number of non-zero elements in a matrix.\n\n    Args:\n        matrix (list[list[int]]): The input matrix.\n\n    Returns:\n        int: The number of non-zero elements in the matrix.\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count\n```",
        "```python\ndef gn_mean(data: list[float]) -> float:\n    \"\"\"\n    Computes the mean of a list of floating-point numbers using an online algorithm.\n\n    Args:\n        data (list[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The mean of the input data.\n    \"\"\"\n    if not data:\n        raise ValueError(\"Input data is empty\")\n\n    total_sum = 0.0\n    count = 0\n\n    for value in data:\n        total_sum += value\n        count += 1\n\n    mean = total_sum / count\n    return mean\n```",
        "```python\n# Session 19 - Using Codestral and updated naming conventions\n\nfrom functools import lru_cache\nfrom pedantic import require_kwargs, rename_kwargs, timer_class\n\n\n@timer_class\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n\n    @require_kwargs(\"key\", \"value\")\n    @rename_kwargs(key=\"gn_key\", value=\"gn_value\")\n    def put(self, gn_key: int, gn_value: int) -> None:\n        if gn_key in self.cache:\n            self.cache.move_to_end(gn_key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[gn_key] = gn_value\n\n    @require_kwargs(\"key\")\n    def get(self, gn_key: int) -> int:\n        if gn_key in self.cache:\n            self.cache.move_to_end(gn_key)\n            return self.cache[gn_key]\n        return -1\n```",
        "```python\ndef gcd(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor of two integers using the Euclidean algorithm.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n\n    Returns:\n        int: The greatest common divisor of 'a' and 'b'.\n    \"\"\"\n    # Handle negative input\n    a, b = abs(a), abs(b)\n\n    # Base case\n    if b == 0:\n        return a\n\n    # Recursive case\n    return gcd(b, a % b)\n```",
        "```python\nfrom pedantic import require_kwargs, rename_kwargs\n\n\n@require_kwargs\n@rename_kwargs\ndef a_gn_sum_unique_numbers(a_list_of_numbers: list[int]) -> int:\n    \"\"\"\n    Computes the sum of unique numbers in a list.\n\n    Args:\n        a_list_of_numbers (list[int]): A list of integers.\n\n    Returns:\n        int: The sum of unique numbers in the list.\n    \"\"\"\n    unique_numbers = []\n    for number in a_list_of_numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    return sum(unique_numbers)\n```",
        "```python\ndef a_is_palindrome(s: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Args:\n        s (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string is a valid palindrome, False otherwise.\n    \"\"\"\n    # Initialize variables with single digit and required string\n    i, j = 1, 1\n    chx_str = \"chx\"\n\n    # Iterate through the string in both directions\n    while i <= len(s) // 2 and j <= len(s):\n        # Add a single digit and the string 'chx' to the variable names\n        chx_i, chx_j = i, len(s) - j + 1\n\n        # Compare characters at corresponding positions\n        if s[chx_i - 1] != s[chx_j - 1]:\n            return False\n\n        # Increment counters\n        i += 1\n        j += 1\n\n    # If no mismatch is found, the string is a palindrome\n    return True\n```",
        "```python\nfrom pedantic import require_kwargs, rename_kwargs\n\n\n@require_kwargs\n@rename_kwargs\ndef a_get_longest_common_prefix(d_str_list: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    :param d_str_list: A list of strings.\n    :return: The longest common prefix string.\n    \"\"\"\n    if not d_str_list:\n        return \"\"\n\n    chx_shortest_str = min(d_str_list, key=len)\n    m_idx = 0\n    chx_prefix = \"\"\n\n    for ch in chx_shortest_str:\n        if all(s.startswith(chx_prefix + ch) for s in d_str_list):\n            chx_prefix += ch\n            m_idx += 1\n\n        if m_idx == 10:\n            break\n\n    return chx_prefix\n```",
        "```python\nclass Inventory:\n    \"\"\"\n    This class represents an inventory with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self._stock = []\n\n    def add_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Add stock to the inventory.\n\n        :param item: str - The name of the item to add.\n        :param quantity: int - The quantity of the item to add.\n        \"\"\"\n        self._stock.append((item, quantity))\n\n    def remove_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock from the inventory.\n\n        :param item: str - The name of the item to remove.\n        :param quantity: int - The quantity of the item to remove.\n        \"\"\"\n        for index, (stored_item, stored_quantity) in enumerate(self._stock):\n            if stored_item == item:\n                if stored_quantity <= quantity:\n                    self._stock.pop(index)\n                else:\n                    self._stock[index] = (item, stored_quantity - quantity)\n                break\n```",
        "```python\ndef is_valid_bst(root: TreeNode) -> bool:\n    def _is_valid(node: TreeNode, min_val: int, max_val: int) -> bool:\n        if not node:\n            return True\n        md_left_valid = _is_valid(node.left, min_val, node.val - 1)\n        md_right_valid = _is_valid(node.right, node.val + 1, max_val)\n        return md_left_valid and md_right_valid\n\n    return _is_valid(root, float('-inf'), float('inf'))\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion of a new node\n    def md_insert(self, value):\n        self.root = self.x_insert_node(self.root, value)\n\n    def x_insert_node(self, node, value):\n        if not node:\n            return Node(value)\n        if value < node.value:\n            node.left = self.x_insert_node(node.left, value)\n        else:\n            node.right = self.x_insert_node(node.right, value)\n        return node\n\n    # Deletion of a node\n    def md_delete(self, value):\n        self.root = self.x_delete_node(self.root, value)\n\n    def x_delete_node(self, node, value):\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self.x_delete_node(node.left, value)\n        elif value > node.value:\n            node.right = self.x_delete_node(node.right, value)\n        else:\n            if not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n            node.value = self.x_get_min_value(node.right)\n            node.right = self.x_delete_node(node.right, node.value)\n        return node\n\n    def x_get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```"
      ]
    }
  ]
}