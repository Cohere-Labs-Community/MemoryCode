{
  "sessions": [
    {
      "session_model_output": [
        "class LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = self.Node(data)\n        if not self.head:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i is None:\n            return\n\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n\n        while curr_i:\n            if curr_i.data_i == data_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with annotations\n    def insert(self, value: int) -> None:\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value: int) -> 'Node':\n        if not node:\n            node = Node(value)\n        if value < node.value:\n            node.left_r = self._insert_recursive(node.left_r, value)\n        elif value > node.value:\n            node.right_r = self._insert_recursive(node.right_r, value)\n        return node\n\n    # Delete node method with annotations\n    def delete(self, value: int) -> None:\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value: int) -> 'Node':\n        if not node:\n            return node\n        if value < node.value:\n            node.left_r = self._delete_recursive(node.left_r, value)\n        elif value > node.value:\n            nodepartum.right_r = self._delete_recursive(node.right_r, value)\n        else:\n            if not node.left_r and not node.right_r:\n                node = None\n            elif not node.left_r:\n                node = node.right_r\n            elif not node.right_r:\n                node = node.left_r\n            else:\n                successor = self._find_min_value_node(node.right_r)\n                node.value = successor.value\n                node.right_r = self._delete_recursive(node.right_r, successor.value)\n        return node\n\n    def _find_min_value_node(self, node) -> 'Node':\n        while node.left_r:\n            node = node.left_r\n        return node\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left_r = None\n        self.right_r = None\n```",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def add_node(self, data_r):\n        new_node_r = Node(data_r)\n        if self.head_r is None:\n            self.head_r = new_node_r\n        else:\n            current_r = self.head_r\n            while current_r.next_r:\n                current_r = current_r.next_r\n            current_r.next_r = new_node_r\n\n    def remove_node(self, data_r):\n        if self.head_r is None:\n            return\n        if self.head_r.data_r == data_r:\n            self.head_r = self.head_r.next_r\n            return\n        current_r = self.head_r\n        prev_r = None\n        while current_r and current_r.data_r != data_r:\n            prev_r = current_r\n            current_r = current_r.next_r\n        if current_r is None:\n            return\n        prev_r.next_r = current_r.next_r\n\n    def display(self):\n        current_r = self.head_r\n        while current_r:\n            print(current_r.data_r, end=\" -> \")\n            current_r = current_r.next_r\n        print(\"None\")\n\nclass Node:\n    def __init__(self, data_r):\n        self.data_r = data_r\n        self.next_r = None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value):\n        self.root = self._delete(value, self.root)\n\n    def _delete(self, value, node):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete(node.value, node.right)\n\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value",
        "```python\nclass Node:\n    def __init__(self, value, next=None):\n        self.value = value\n        self._next_r = next\n\n\nclass LinkedList:\n    def __init__(self):\n        self._head_i = None\n\n    def insert(self, value):\n        new_node = Node(value)\n        if self._head_i is None:\n            self._head_i = new_node\n        else:\n            current = self._head_i\n            while current._next_r is not None:\n                current = current._next_r\n            current._next_r = new_node\n\n    def search(self, value):\n        current = self._head_i\n        while current is not None:\n            if current.value == value:\n                return True\n            current = current._next_r\n        return False\n\n    def delete(self, value):\n        if self._head_i is None:\n            return\n        if self._head_i.value == value:\n            self._head_i = self._head_i._next_r\n            return\n        current = self._head_i\n        prev = None\n        while current._next_r is not None:\n            if current.value == value:\n                prev._next_r = current._next_r\n                return\n            prev = current\n            current = current._next_r\n\n    @property\n    def head(self):\n        return self._head_i\n```"
      ]
    }
  ]
}