{
  "sessions": [
    {
      "session_model_output": [
        "def find_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Find the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    shortest = min(strs, key=len)\n\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n\n    return shortest"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef fn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "```python\ndef fn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import count_calls\n\n\n@count_calls\ndef average_diagonal_elements(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows must be lists.\"\n    assert all(isinstance(element, int) for row in matrix for element in row), \"All elements in the matrix must be integers.\"\n\n    size = len(matrix)\n    assert all(size == len(row) for row in matrix), \"Matrix must be square.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(size))\n    assert diagonal_sum == sum(matrix[i][size - i - 1] for i in range(size)), \"Matrix is not square or input is incorrect.\"\n\n    average = diagonal_sum / size\n    return average\n```",
        "```python\nfrom pedantic import count_calls\n\nclass LinearRegression:\n    @count_calls\n    def train(self, X, y):\n        assert X.shape[0] == y.shape[0], \"Number of samples in X and y must be the same\"\n        assert X.shape[1] > 0 and y.shape[0] > 0, \"X and y should not be empty\"\n\n        self.coef_ = (X.T @ X).inverse() @ X.T @ y\n        self.intercept_ = y.mean() - (X.mean(axis=0) * self.coef_).sum()\n\n    @count_calls\n    def predict(self, X):\n        assert X.shape[1] == self.coef_.shape[0], \"Number of features in X should match the coefficient size\"\n\n        return X @ self.coef_ + self.intercept_\n```"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)",
        "from pedantic import pedantic, count_calls\nfrom sklearn.linear_model import LinearRegression\n\n@pedantic\nclass LinearRegressionModel:\n    @count_calls\n    def __init__(self):\n        self.model = LinearRegression()\n\n    @count_calls\n    def train(self, X, y):\n        self.model.fit(X, y)\n\n    @count_calls\n    def predict(self, X):\n        return self.model.predict(X)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom pedantic import count_calls\n\n\n@count_calls\ndef fn_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    shortest = min(strs, key=len)\n\n    for i, char in enumerate(shortest):\n        if any(str_[i] != char for str_ in strs):\n            return shortest[:i]\n\n    return shortest\n```",
        "```python\nfrom pedantic import count_calls\n\n\n@count_calls\ndef fn_h_index(citations: list[int]) -> int:\n    \"\"\"\n    Calculate the h-index of a researcher based on their citations.\n\n    Args:\n        citations (list[int]): A list of integer citations of the researcher's publications.\n\n    Returns:\n        int: The h-index value, rounded down to the nearest integer.\n    \"\"\"\n    if not isinstance(citations, list) or any(not isinstance(cit, int) for cit in citations):\n        raise TypeError(\"Citations must be provided as a list of integers.\")\n\n    citations.sort(reverse=True)\n    h_index = 0\n\n    for i, cit in enumerate(citations):\n        if i < cit:\n            h_index = i + 1\n        else:\n            break\n\n    return h_index\n\n\nassert fn_h_index([5, 3, 3, 1, 1]) == 3\n```",
        "```python\nfrom pedantic import count_calls\n\n\n@count_calls\ndef fn_average_diagonal_elements(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Calculate the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): A square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    size = len(matrix)\n    assert size == len(matrix[0]), \"Input must be a square matrix.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(size))\n    average = diagonal_sum / size\n    return average\n```",
        "```python\nfrom pedantic import count_calls\n\nclass LinearRegression:\n    \"\"\"\n    Linear Regression Class\n\n    This class implements linear regression using the least squares method.\n    It can be used to train a model on a set of input data and corresponding target values\n    and then make predictions on new input data.\n\n    ...\n\n    Attributes\n    ----------\n    coef_ : float\n        The coefficient of the linear regression model.\n    intercept_ : float\n        The intercept of the linear regression model.\n\n    Methods\n    -------\n    train(X, y)\n        Train the linear regression model using the input data and target values.\n    predict(X)\n        Make predictions using the trained linear regression model.\n\n    \"\"\"\n\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    @count_calls\n    @staticmethod\n    def fn_train(X, y):\n        \"\"\"\n        Train the linear regression model.\n\n        Parameters\n        ----------\n        X : array-like\n            Input data of shape (n_samples, n_features).\n        y : array-like\n            Target values of shape (n_samples,).\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"\n        # Calculate the coefficient and intercept using the least squares method\n        X_transpose = X.T\n        coefficient_matrix = X_transpose @ X\n        inverse_coefficient_matrix = coefficient_matrix.I\n        coefficient_vector = inverse_coefficient_matrix @ X_transpose @ y\n        coefficients = coefficient_vector[:, 0]\n\n        self.coef_ = coefficients[0]\n        self.intercept_ = coefficients[1]\n\n        return self\n\n    @count_calls\n    def fn_predict(self, X):\n        \"\"\"\n        Make predictions using the trained linear regression model.\n\n        Parameters\n        ----------\n        X : array-like\n            Input data of shape (n_samples, n_features).\n\n        Returns\n        -------\n        y_pred : array-like\n            Predicted target values of shape (n_samples,).\n        \"\"\"\n        assert self.coef_ is not None and self.intercept_ is not None, \"Model has not been trained yet.\"\n        assert len(X.shape) == 2, \"Input data should be a 2D array.\"\n\n        y_pred = X @ self.coef_ + self.intercept_\n\n        return y_pred\n```"
      ]
    }
  ]
}