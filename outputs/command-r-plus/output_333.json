{
  "sessions": [
    {
      "session_model_output": [
        "def is_palindrome(input_str: str) -> bool:\n    input_str_y = input_str[::-1]\n    if input_str == input_str_y:\n        return True\n    else:\n        return False",
        "class LinearRegression:\n    def __init__(self, learning_rate=0.01, iterations=1000):\n        self.learning_rate = learning_rate\n        self.iterations = iterations\n        self.theta = None\n\n    def fit(self, X, y):\n        X_ = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n        self.theta = np.zeros(X_.shape[1])\n\n        for _ in range(self.iterations):\n            gradient = 2 * X_.T @ (X_ @ self.theta - y) / y.size\n            self.theta -= self.learning_rate * gradient\n\n        return self\n\n    def predict(self, X):\n        X_ = np.c_[np.ones((X.shape[0], 1)), X]  # Add bias term\n        return X_ @ self.theta"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True",
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int) -> None:\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value: int) -> 'Node':\n        if not node:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value: int) -> 'Node':\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            nodeNTech_right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _get_min_value(self, node) -> int:\n        while node.left is not None:\n            node = node.left\n        return node.value\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "def is_palindrome(input_str: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n    \n    :param input_str: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Using string slicing to reverse the string and compare it with the original\n    return input_str == input_str[::-1]"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "def is_palindrome(s_m):\n    s_m = s_m.lower()\n    return s_m == s_m[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class PCA0:\n    def __init__(self, n_components=None):\n        self.n_components = n_components\n\n    def fit_transform(self, data):\n        # Perform PCA and reduce dimensions to self.n_components\n        ...\n\n    def transform(self, data):\n        # Transform data based on fitted PCA components\n        ...\n\n    def fit(self, data):\n        # Fit PCA model to data\n        ..."
      ],
      "instruction_model_output": [
        "class PCA0:\n    def __init__(self, n_components=0):\n        self.n_components = n_components\n\n    def fit_transform(self, X):\n        X_centered = X - X.mean(axis=0)\n        covariance = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eig(covariance)\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n        components = eigenvectors[:, :self.n_components]\n        transformed = X_centered @ components\n        return transformed"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import validate\n\n@validate\ndef int_to_roman(num: int) -> str:\n    \"\"\"Convert an integer to Roman numerals.\n    Args:\n        num (int): The integer to be converted.\n    Returns:\n        str: The corresponding Roman numeral representation.\n    \"\"\"\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman_num = \"\"\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syb[i]\n            num -= val[i]\n        i += 1\n    return roman_num"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import validate\r\n\r\n@validate\r\ndef int_to_roman(num: int) -> str:\r\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\r\n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n    roman_num = ''\r\n    i = 0\r\n    while num > 0:\r\n        for _ in range(num // val[i]):\r\n            roman_num += syb[i]\r\n            num -= val[i]\r\n        i += 1\r\n    return roman_num"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(y_input_str_n: str) -> bool:\n    y_cleaned_str_n = \"\".join(char.lower() for char in y_input_str_n if char.isalnum())\n    y_reversed_str_n = y_cleaned_str_n[::-1]\n    return y_cleaned_str_n == y_reversed_str_n",
        "def is_valid_sudoku(board_n):\n    y_flat_list_n = [item_n for sublist_n in board_n for item_n in sublist_n]\n    y_seen_n = set()\n    y_squares_n = set()\n\n    for y_i_n in y_flat_list_n:\n        if y_i_n != '.':\n            if y_i_n in y_seen_n:\n                return False\n            y_seen_n.add(y_i_n)\n\n        if len(y_seen_n) == 9:\n            y_seen_n.clear()\n\n        if y_i_n != '.':\n            y_square_n = int(y_i_n) // 3\n            if y_square_n in y_squares_n:\n                return False\n            y_squares_n.add(y_square_n)\n\n    return True"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_n):\n    s_n = s_n.lower()\n    return s_n == s_n[::-1]",
        "def is_valid_sudoku(y_board):\n    y_seen = set()\n    for y_i in range(9):\n        y_seen = set()\n        for y_j in range(9):\n            if y_board[y_i][y_j] != '.':\n                if y_board[y_i][y_j] in y_seen:\n                    return False\n                y_seen.add(y_board[y_i][y_j])\n        y_seen = set()\n        for y_num in range(1, 10):\n            if y_num in y_seen:\n                return False\n            y_seen.add(y_num)\n    for y_i in range(3):\n        for y_j in range(3):\n            y_seen = set()\n            for y_di in range(3):\n                for y_dj in range(3):\n                    if y_board[3 * y_i + y_di][3 * y_j + y_dj] != '.':\n                        if y_board[3 * y_i + y_di][3 * y_j + y_dj] in y_seen:\n                            return False\n                        y_seen.add(y_board[3 * y_i + y_di][3 * y_j + y_dj])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class ImageClassifier(torch.nn.Module):\n    \"\"\"\n    Binary Image Classification Model using PyTorch.\n    \"\"\"\n\n    def __init__(self, input_dim, hidden_dim, output_dim):\n        super(ImageClassifier, self).__init__()\n        self.fc1 = torch.nn.Linear(input_dim, hidden_dim)\n        self.relu = torch.nn.ReLU()\n        self.dropout = torch.nn.Dropout(0.2)\n        self.fc2 = torch.nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.dropout(x)\n        x = self.fc2(x)\n        return torch.sigmoid(x)\n\n\n@trace_class\nclass ImageClassifierWithTrace(ImageClassifier):\n    pass",
        "class KernelRidgeRegression:\n    \"\"\"\n    A Kernel Ridge Regression model.\n    \"\"\"\n\n    def __init__(self, kernel='linear', gamma=None, alpha=1.0):\n        \"\"\"\n        Initialize the KernelRidgeRegression model.\n\n        Parameters\n        ----------\n        kernel : str, optional\n            The kernel type, default is 'linear'.\n        gamma : float, optional\n            The kernel coefficient, default is None.\n        alpha : float, optional\n            The regularization strength, default is 1.0.\n        \"\"\"\n        self.kernel = kernel\n        self.gamma = gamma\n        self.alpha = alpha\n        self._fit_status = False\n\n    @property\n    def coefficient(self):\n        \"\"\"\n        Get the coefficient of the model after fitting.\n        \"\"\"\n        if not self._fit_status:\n            raise RuntimeError(\"Model coefficients not available before fitting.\")\n        return self._coefficient\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the model to the training data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data.\n        y : array-like, shape (n_samples,)\n            Target values.\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"\n        # Check if inputs have acceptable shapes\n        if X.shape[0] == 0:\n            raise ValueError(\"X has no data points.\")\n        if X.shape[0] != y.shape[0]:\n            raise ValueError(\"X and y have inconsistent shapes.\")\n\n        # Import necessary modules\n        from sklearn.kernel_ridge import KernelRidge\n\n        # Fit the model\n        self._model = KernelRidge(alpha=self.alpha, kernel=self.kernel, gamma=self.gamma)\n        self._model.fit(X, y)\n\n        # Store the coefficient\n        self._coefficient = self._model.coef_\n\n        self._fit_status = True\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict target values for the provided data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Data for which target values need to be predicted.\n\n        Returns\n        -------\n        y_pred : array-like, shape (n_samples,)\n            Predicted target values.\n        \"\"\"\n        if not self._fit_status:\n            raise RuntimeError(\"Model has not been fitted yet.\")\n\n        return self._model.predict(X)"
      ],
      "instruction_model_output": [
        "class BinaryImageClassifier(nn.Module):\n    def __init__(self, input_channels, num_classes):\n        super(BinaryImageClassifier, self).__init__()\n        \n        self.conv1 = nn.Conv2d(input_channels, 32, 3, 1, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1, 1)\n        self.conv3 = nn.Conv2d(64, 128, 3, 1, 1)\n        \n        self.fc1 = nn.Linear(128 * 3 * 3, 512)\n        self.fc2 = nn.Linear(512, num_classes)\n        \n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.relu(self.conv2(x))\n        x = F.relu(self.conv3(x))\n        \n        x = x.view(-1, 128 * 3 * 3)\n        \n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        \n        return x",
        "from pedantic import trace_class\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.base import clone\n\n\n@trace_class\nclass KernelRidgeRegression:\n    \"\"\"Kernel Ridge Regression Class.\"\"\"\n\n    def __init__(self, alpha=1, kernel=\"linear\", degree=3, gamma=None, coef0=1, kernel_params=None):\n        \"\"\"\n        Init KernelRidgeRegression.\n\n        :param alpha: Regularization strength; must be a positive float. Regularization improves the\n        conditioning of the problem and reduces the variance of the estimates. Larger values\n        specify stronger regularization.\n        :param kernel: Kernel function used for prediction.\n        :param degree: Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.\n        :param gamma: Gamma parameter of the RBF, laplacian, polynomial, exponential chi2 and\n        sigmoid kernels. Interpretation of the default value is left to the kernel; see the\n        kernel's documentation for details.\n        :param coef0: Independent term in kernel functions. It is only significant in\n        'poly' and 'sigmoid'.\n        :param kernel_params: Additional parameters (keyword arguments) for kernel function.\n        \"\"\"\n        self.alpha = alpha\n        self.kernel = kernel\n        self.degree = degree\n        self.gamma = gamma\n        self.coef0 = coef0\n        self.kernel_params = kernel_params\n        self.model = KernelRidge(\n            alpha=self.alpha,\n            kernel=self.kernel,\n            degree=self.degree,\n            gamma=self.gamma,\n            coef0=self.coef0,\n            kernel_params=self.kernel_params,\n        )\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit KernelRidge regression model.\n\n        :param X: Training data.\n        :param y: Target values.\n        :return: self\n        \"\"\"\n        self.model.fit(X, y)\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict using the KernelRidge regression model.\n\n        :param X: Samples.\n        :return: Predicted values.\n        \"\"\"\n        return self.model.predict(X)\n\n    def get_params(self, deep=True):\n        \"\"\"\n        Get parameters for this estimator.\n\n        :param deep: boolean, optional If True, will return the parameters for this estimator and\n        contained subobjects that are estimators.\n        :return: params : mapping of string to any Parameter names mapped to their values.\n        \"\"\"\n        return self.model.get_params(deep=deep)\n\n    def set_params(self, **params):\n        \"\"\"\n        Set the parameters of this estimator.\n\n        :param params: dict, optional Parameters.\n        :return: self\n        \"\"\"\n        self.model = clone(self.model).set_params(**params)\n        return self"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def get_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the k-th largest element in the given array.\n    \n    Args:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' for the k-th largest element.\n    \n    Returns:\n        int: The k-th largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n\n    # Return the k-th element from the sorted array\n    return sorted_arr[k - 1]\n\n\n# Example function call with annotations\ndef example_function(w_array: list[int], w_k: int) -> int:\n    return get_kth_largest(w_array, w_k)",
        "```python\nfrom typing import List\n\n\ndef is_valid_sudoku(board: List[List[int]]) -> bool:\n    \"\"\"\n    Determines if a given 9x9 sudoku board is valid.\n\n    Args:\n        board (List[List[int]]): The sudoku board to be validated.\n\n    Returns:\n        bool: True if the board is a valid sudoku, False otherwise.\n    \"\"\"\n    w_rows = set()\n    w_cols = set()\n    w_boxes = set()\n\n    for i in range(9):\n        for j in range(9):\n            w_current_num = board[i][j]\n            if w_current_num != 0:\n                w_row = (w_current_num, i)\n                w_col = (w_current_num, j)\n                w_box = (w_current_num, i // 3, j // 3)\n\n                if w_row in w_rows or w_col in w_cols or w_box in w_boxes:\n                    return False\n\n                w_rows.add(w_row)\n                w_cols.add(w_col)\n                w_boxes.add(w_box)\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]",
        "def is_valid_sudoku(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                if w_board[w_i][w_j] in w_seen:\n                    return False\n                w_seen.add(w_board[w_i][w_j])\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_j][w_i] != '.':\n                if w_board[w_j][w_i] in w_seen:\n                    return False\n                w_seen.add(w_board[w_j][w_i])\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_seen = set()\n            for w_x in range(w_i, w_i + 3):\n                for w_y in range(w_j, w_j + 3):\n                    if w_board[w_x][w_y] != '.':\n                        if w_board[w_x][w_y] in w_seen:\n                            return False\n                        w_seen.add(w_board[w_x][w_y])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X, y):\n        try:\n            X = self._add_intercept(X)\n            self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n            self.intercept_ = 0\n        except np.linalg.LinAlgError:\n            warnings.warn(\"Singular matrix encountered. Pseudo-inverse will be used instead.\")\n            Xt_X_inv = np.linalg.pinv(X.T @ X)\n            self.coef_ = Xt_X_inv @ X.T @ y\n            self.intercept_ = 0\n\n    def predict(self, X):\n        try:\n            X = self._add_intercept(X)\n            return X @ self.coef_\n        except ValueError:\n            raise ValueError(\"Input matrix X should be 2D.\")\n\n    def _add_intercept(self, X):\n        intercept = np.ones((X.shape[0], 1))\n        return np.hstack((intercept, X))"
      ],
      "instruction_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class IMAGE_CLASSIFIER(nn.Module):\n    def __init__(self):\n        super(IMAGE_CLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 2)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2)\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x"
      ],
      "instruction_model_output": [
        "class BINARYCLASSIFIER(nn.Module):\n    def __init__(self):\n        super(BINARYCLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 2)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2)\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import retry\n\n@retry\ndef p_find_majority_element(arr):\n    if not arr:\n        return None\n    count = {}\n    for num in arr:\n        count[num] = count.get(num, 0) + 1\n        if count[num] * 2 > len(arr):\n            return num\n    return None",
        "from pedantic import retry\n\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    @retry\n    def p_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    @retry\n    def p_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock to remove\")"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import retry\n\n@retry\ndef majority_element(arr):\n    from collections import Counter\n\n    counter = Counter(arr)\n    return counter.most_common(1)[0][0]",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def p_add_stock(self, amount):\n        self.stock += amount\n\n    def p_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def check_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    cleaned_string = \"\".join(char.lower() for char in input_string if char.isalnum())\n    return cleaned_string == cleaned_string[::-1]\n\n\ndef is_palindrome_wr(input_str_: str) -> bool:\n    return check_palindrome(input_str_)"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_wr):\n    s_wr = s_wr.lower()\n    return s_wr == s_wr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import require_kwargs, timer_class\n\n\n@timer_class\nclass StudentGrade:\n    @require_kwargs\n    def __init__(self, name: str, grades: list[float]):\n        self.name = name\n        self.grades = grades\n\n    @require_kwargs\n    @timer_class.method\n    def compute_average_grade(self, weights: list[float]) -> float:\n        total_weighted_sum = sum(grade * weight for grade, weight in zip(self.grades, weights))\n        total_weight = sum(weights)\n        return total_weighted_sum / total_weight if total_weight > 0 else 0",
        "```python\nfrom pedantic import require_kwargs, timer_class\n\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    @require_kwargs\n    def __init__(self, **kwargs):\n        self.classes = kwargs['classes']\n        self.means = kwargs['means']\n        self.cov_matrix = kwargs['cov_matrix']\n        self.priors = kwargs.get('priors', None)\n\n    @require_kwargs\n    def predict(self, X, **kwargs):\n        X = kwargs['X']\n        return self._predict(X)\n\n    def _predict(self, X):\n        pass\n\n    @require_kwargs\n    def predict_proba(self, X, **kwargs):\n        X = kwargs['X']\n        return self._predict_proba(X)\n\n    def _predict_proba(self, X):\n        pass\n```"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)",
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    try:\n        for i in range(9):\n            seen = set()\n            for j in range(9):\n                if board[i][j] != \".\":\n                    if board[i][j] in seen:\n                        return False\n                    seen.add(board[i][j])\n\n            seen = set()\n            for j in range(9):\n                if board[j][i] != \".\":\n                    if board[j][i] in seen:\n                        return False\n                    seen.add(board[j][i])\n\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                seen = set()\n                for x in range(i, i + 3):\n                    for y in range(j, j + 3):\n                        if board[x][y] != \".\":\n                            if board[x][y] in seen:\n                                return False\n                            seen.add(board[x][y])\n\n        return True\n\n    except Exception as e:\n        raise Exception(\"Error occurred while validating sudoku board\") from e\n\n\nm_board = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \"3\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"1\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \"9\", \"5\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"8\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\",],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \"7\", \"9\", \".\"]\n]\n\nprint(is_valid_sudoku(m_board))",
        "def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    if not root:\n        return True\n\n    try:\n        val = root.val\n        if val <= min_val or val >= max_val:\n            return False\n\n        return is_valid_bst(root.left, min_val, val) and is_valid_bst(root.right, val, max_val)\n\n    except AttributeError:\n        print(\"Error: Invalid tree structure. Expected a node with a 'val' attribute.\")\n        return False\n\n\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    m_seen = set()\n    for m_i in range(9):\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_i][m_j] != '.':\n                if board[m_i][m_j] in m_seen:\n                    return False\n                m_seen.add(board[m_i][m_j])\n        m_seen = set()\n        for m_j in range(9):\n            if board[m_j][m_i] != '.':\n                if board[m_j][m_i] in m_seen:\n                    return False\n                m_seen.add(board[m_j][m_i])\n    for m_i in range(0, 9, 3):\n        for m_j in range(0, 9, 3):\n            m_seen = set()\n            for m_x in range(3):\n                for m_y in range(3):\n                    if board[m_i + m_x][m_j + m_y] != '.':\n                        if board[m_i + m_x][m_j + m_y] in m_seen:\n                            return False\n                        m_seen.add(board[m_i + m_x][m_j + m_y]])\n    return True",
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import timer\n\n@timer\ndef is_valid_sudoku(board: list[list[int]]) -> bool:\n    \"\"\"\n    Checks if a given 2D array represents a valid Sudoku board.\n\n    A valid Sudoku board has the following rules:\n    1. Each row must contain the digits 1-9 without repetition.\n    2. Each column must contain the digits 1-9 without repetition.\n    3. Each 3x3 sub-box must contain the digits 1-9 without repetition.\n\n    Args:\n        board (list[list[int]]): The Sudoku board to be validated.\n\n    Returns:\n        bool: True if the board is a valid Sudoku, False otherwise.\n    \"\"\"\n    # Check row validity\n    for row in board:\n        if not is_valid_set(row):\n            return False\n\n    # Transpose the board to check columns\n    transposed_board = [list(i) for i in zip(*board)]\n    for col in transposed_board:\n        if not is_valid_set(col):\n            return False\n\n    # Divide the board into 3x3 sub-boxes and check their validity\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            sub_box = [board[k][l] for k in range(i, i + 3) for l in range(j, j + 3)]\n            if not is_valid_set(sub_box):\n                return False\n\n    return True\n\n\ndef is_valid_set(nums: list[int]) -> bool:\n    \"\"\"\n    Checks if a list of numbers contains the digits 1-9 exactly once each.\n\n    Args:\n        nums (list[int]): The list of numbers to be validated.\n\n    Returns:\n        bool: True if the list contains 1-9 exactly once each, False otherwise.\n    \"\"\"\n    expected_nums = set(range(1, 10))\n    return set(nums) == expected_nums",
        "```python\nfrom pedantic import timer\n\n\n@timer\ndef has_cycle(n_head: \"Node\") -> bool:\n    n_slow = n_head\n    n_fast = n_head\n    while n_slow and n_fast and n_fast.next:\n        n_slow = n_slow.next\n        n_fast = n_fast.next.next\n        if n_slow == n_fast:\n            return True\n    return False\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(n_board):\n    n_seen = set()\n    for n_i in range(9):\n        n_seen = set()\n        for n_j in range(9):\n            if n_board[n_i][n_j] != '.':\n                if n_board[n_i][n_j] in n_seen:\n                    return False\n                n_seen.add(n_board[n_i][n_j])\n        n_seen = set()\n        for n_j in range(9):\n            if n_board[n_j][n_i] != '.':\n                if n_board[n_j][n_i] in n_seen:\n                    return False\n                n_seen.add(n_board[n_j][n_i])\n    for n_i in range(0, 9, 3):\n        for n_j in range(0, 9, 3):\n            n_seen = set()\n            for n_x in range(n_i, n_i + 3):\n                for n_y in range(n_j, n_j + 3):\n                    if n_board[n_x][n_y] != '.':\n                        if n_board[n_x][n_y] in n_seen:\n                            return False\n                        n_seen.add(n_board[n_x][n_y])\n    return True",
        "from pedantic.decorators import timer\nfrom typing import Optional\n\n\n@timer\ndef has_cycle(head: Optional[Node]) -> bool:\n    if not head or not head.next:\n        return False\n\n    slow, fast = head, head.next\n\n    while slow != fast:\n        if not fast or not fast.next:\n            return False\n        slow = slow.next\n        fast = fast.next.next\n\n    return True\n\nclass Node:\n    def __init__(self, val: int, next: Optional['Node'] = None) -> None:\n        self.val = val\n        self.next = next"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    Represents a product inventory with methods to manage stock levels.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Add stock for a specific product.\n\n        :param product: The name of the product.\n        :param quantity: The number of items added to the stock.\n        \"\"\"\n        if product in self.stock:\n            self.stock[product] += quantity\n        else:\n            self.stock[product] = quantity\n\n    def remove_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock for a specific product.\n\n        :param product: The name of the product.\n        :param quantity: The number of items removed from the stock.\n        \"\"\"\n        if product in self.stock and self.stock[product] >= quantity:\n            self.stock[product] -= quantity\n        else:\n            raise ValueError(f\"Insufficient stock for product: {product}\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.base import BaseEstimator\nfrom sklearn.neighbors import NearestNeighbors\n\nclass KNNModel(BaseEstimator):\n    \"\"\"K-Nearest Neighbors Model\"\"\"\n\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.model = NearestNeighbors(n_neighbors=n_neighbors)\n\n    def fit(self, X, y=None):\n        self.model.fit(X)\n        return self\n\n    def predict(self, X):\n        distances, indices = self.model.kneighbors(X)\n        return indices\n\n# Jean-Aim\u00e9's guidelines:\n# - Include assert statements to validate assumptions and ensure expected behavior\n# - Follow agile practices: keep the code modular, collaborative, and adaptable\n```"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    \"\"\"Checks if a string is a valid palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    cleaned_string = ''.join(char.lower() for char in input_string if char.isalnum())\n    return cleaned_string == cleaned_string[::-1]\n\n\nassert is_palindrome(\"racecar_x\") == True\nassert is_palindrome(\"hello world_x\") == False"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_x):\n    s_x = s_x.lower()\n    return s_x == s_x[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class binary_image_classifier(nn.Module):\n    def __init__(self, input_dim, hidden_dim, output_dim):\n        super(binary_image_classifier, self).__init__()\n        self.fc1 = nn.Linear(input_dim, hidden_dim)\n        self.relu = nn.ReLU()\n        self.dropout = nn.Dropout(0.5)\n        self.fc2 = nn.Linear(hidden_dim, output_dim)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.dropout(x)\n        x = self.fc2(x)\n        return x"
      ],
      "instruction_model_output": [
        "```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass binary_image_classifier(nn.Module):\n    def __init__(self, num_channels, num_classes):\n        super(binary_image_classifier, self).__init__()\n        self.conv1 = nn.Conv2d(num_channels, 32, 3, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1)\n        self.conv3 = nn.Conv2d(64, 128, 3, 1)\n        self.fc1 = nn.Linear(128 * 3 * 3, 512)\n        self.fc2 = nn.Linear(512, num_classes)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.relu(self.conv2(x))\n        x = F.relu(self.conv3(x))\n        x = F.max_pool2d(x, 2)\n        x = torch.flatten(x, 1)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.wr_stock = {}\n\n    def o_add_stock(self, item, quantity):\n        if item in self.wr_stock:\n            self.wr_stock[item] += quantity\n        else:\n            self.wr_stock[item] = quantity\n\n    def o_remove_stock(self, item, quantity):\n        if item in self.wr_stock and self.wr_stock[item] >= quantity:\n            self.wr_stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the requested quantity.\")",
        "def o_is_valid_sudoku(wr_board):\n    wr_rows = set()\n    wr_cols = set()\n    wr_boxes = set()\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            wr_box = str(wr_board[i][j]) + str(wr_board[i][j+1]) + str(wr_board[i][j+2])\n            wr_boxes.add(wr_box)\n\n            for k in range(i, i + 3):\n                wr_row = str(wr_board[k][j]) + str(wr_board[k][j+1]) + str(wr_board[k][j+2])\n                wr_rows.add(wr_row)\n\n                wr_col = str(wr_board[i][j+k-i]) + str(wr_board[i+1][j+k-i]) + str(wr_board[i+2][j+k-i])\n                wr_cols.add(wr_col)\n\n    return len(wr_rows) == len(wr_rows.union(wr_cols, wr_boxes)) == 45"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount",
        "def is_valid_sudoku(board):\n    wr_rows = [{} for _ in range(9)]\n    wr_cols = [{} for _ in range(9)]\n    wr_boxes = [{} for _ in range(9)]\n\n    for wr_i in range(9):\n        for wr_j in range(9):\n            wr_num = board[wr_i][wr_j]\n            if wr_num != '.':\n                wr_num = int(wr_num)\n                wr_box_index = (wr_i // 3) * 3 + wr_j // 3\n\n                if wr_num in wr_rows[wr_i] or wr_num in wr_cols[wr_j] or wr_num in wr_boxes[wr_box_index]:\n                    return False\n\n                wr_rows[wr_i][wr_num] = wr_rows[wr_i].get(wr_num, 0) + 1\n                wr_cols[wr_j][wr_num] = wr_cols[wr_j].get(wr_num, 0) + 1\n                wr_boxes[wr_box_index][wr_num] = wr_boxes[wr_box_index].get(wr_num, 0) + 1\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\nfrom typing import List\n\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, books: List[str]) -> None:\n        self.books.extend(books)\n\n    @validate\n    def remove_books(self, books: List[str]) -> None:\n        for book in books:\n            self.books.remove(book)\n```"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal_elements(matrix):\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list of list of int or float): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list of lists.\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows must be lists.\"\n    assert all(isinstance(element, (int, float)) for row in matrix for element in row), \"All elements in the matrix must be numeric.\"\n\n    size = len(matrix)\n    assert all(len(row) == size for row in matrix), \"Input must be a square matrix.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(size))\n    return diagonal_sum / size\n```"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    for i in range(9):\n        vr_row = set()\n        vr_col = set()\n        for j in range(9):\n            if board[i][j] in vr_row or board[j][i] in vr_col:\n                return False\n            vr_row.add(board[i][j])\n            vr_col.add(board[j][i])\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            vr_box = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] in vr_box:\n                        return False\n                    vr_box.add(board[x][y])\n\n    return True"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def z_is_palindrome_vr(s: str) -> bool:\n    s = s.lower()\n    return s == s[::-1]",
        "def z_is_valid_sudoku_vr(z_board_vr):\n    z_rows_vr = [z_row_vr for z_row_vr in z_board_vr]\n    z_cols_vr = [[z_board_vr[z_i_vr][z_j_vr] for z_i_vr in range(9)] for z_j_vr in range(9)]\n    z_boxes_vr = [z_board_vr[i // 3 * 3 + i % 3][j // 3 * 3 + j % 3] for i in range(9) for j in range(9)]\n    for z_group_vr in z_rows_vr + z_cols_vr + z_boxes_vr:\n        if len(z_group_vr) != len(set(z_group_vr)):\n            return False\n    return True"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_vr):\n    s_vr = s_vr.lower()\n    return s_vr == s_vr[::-1]",
        "def is_valid_sudoku(z_board):\n    z_rows = [set() for _ in range(9)]\n    z_cols = [set() for _ in range(9)]\n    z_boxes = [set() for _ in range(9)]\n\n    for z_i in range(9):\n        for z_j in range(9):\n            z_num = z_board[z_i][z_j]\n            if z_num != '.':\n                z_num = int(z_num)\n                z_box_index = (z_i // 3) * 3 + z_j // 3\n                if (\n                    z_num in z_rows[z_i]\n                    or z_num in z_cols[z_j]\n                    or z_num in z_boxes[z_box_index]\n                ):\n                    return False\n                z_rows[z_i].add(z_num)\n                z_cols[z_j].add(z_num)\n                z_boxes[z_box_index].add(z_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Perceptron:\n    def __init__(self, input_dim):\n        self.chx_weights = [0] * input_dim\n        self.chx_bias = 0\n\n    def train(self, inputs, labels, learning_rate):\n        for i in range(len(inputs)):\n            input = inputs[i]\n            label = labels[i]\n            output = self.predict(input)\n            error = label - output\n            self.chx_bias += learning_rate * error\n            for j in range(len(input)):\n                self.chx_weights[j] += learning_rate * error * input[j]\n\n    def predict(self, input):\n        total = self.chx_bias\n        for i in range(len(input)):\n            total += self.chx_weights[i] * input[i]\n        return total"
      ],
      "instruction_model_output": [
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def count_non_zero_elements0(matrix):\n    \"\"\"\n    Counts the number of non-zero elements in the given matrix.\n\n    Args:\n        matrix (list of lists): The input matrix.\n\n    Returns:\n        int: The number of non-zero elements in the matrix.\n\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count",
        "```python\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def _insert_node(self, value: int) -> None:\n        \"\"\"\n        0- Insert a new node with the given value into the binary tree.\n        1- Inputs:\n            - value (int): The value to be inserted into the binary tree.\n        2- Output: None\n        3- Potential Side Effects: Modifies the binary tree by inserting a new node.\n        \"\"\"\n        new_node = Node(value)\n        if not self.root:\n            self.root = new_node\n        else:\n            current_node = self.root\n            while True:\n                if value < current_node.value:\n                    if current_node.left is None:\n                        current_node.left = new_node\n                        break\n                    current_node = current_node.left\n                else:\n                    if current_node.right is None:\n                        current_node.right = new_node\n                        break\n                    current_node = current_node.right\n\n    def insert(self, value: int) -> None:\n        \"\"\"\n        0- Wrapper function for _insert_node with a single digit in its name.\n        1- Please refer to _insert_node docstring for more information.\n        \"\"\"\n        self._insert_node(value)\n\n    def _delete_node(self, value: int) -> None:\n        \"\"\"\n        0- Delete a node with the given value from the binary tree.\n        1- Inputs:\n            - value (int): The value of the node to be deleted.\n        2- Output: None\n        3- Potential Side Effects: Modifies the binary tree by deleting a node.\n        \"\"\"\n        def find_min(node):\n            current = node\n            while current.left is not None:\n                current = current.left\n            return current\n\n        def delete_node(node, key):\n            if node is None:\n                return node\n\n            if key < node.value:\n                node.left = delete_node(node.left, key)\n            elif key > node.value:\n                node.right = delete_node(node.right, key)\n            else:\n                if node.left is None:\n                    return node.right\n                elif node.right is None:\n                    return node.left\n\n                min_val_node = find_min(node.right)\n                node.value = min_val_node.value\n                node.right = delete_node(node.right, min_val_node.value)\n\n            return node\n\n        self.root = delete_node(self.root, value)\n\n    def delete(self, value: int) -> None:\n        \"\"\"\n        0- Wrapper function for _delete_node with a single digit in its name.\n        1- Please refer to _delete_node docstring for more information.\n        \"\"\"\n        self._delete_node(value)\n```"
      ],
      "instruction_model_output": [
        "def count_non_zero(matrix):\n    count = 0\n    for row in matrix:\n        count += sum(1 for elem in row if elem != 0)\n    return count",
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Playlist:\n    \"\"\"Represents a playlist with methods to add and remove songs.\n\n    Attributes:\n        songs (list): A list of song titles in the playlist.\n    \"\"\"\n\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def n_add_song(self, song: str) -> None:\n        \"\"\"Adds a song to the playlist.\n\n        Args:\n            song (str): The title of the song to be added.\n        \"\"\"\n        self.songs.append(song)\n\n    @retry\n    def n_remove_song(self, song: str) -> None:\n        \"\"\"Removes a song from the playlist.\n\n        Args:\n            song (str): The title of the song to be removed.\n        \"\"\"\n        self.songs.remove(song)",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    @retry\n    def n_add_stock(self, amount: int):\n        self.stock += amount\n\n    @retry\n    def n_remove_stock(self, amount: int):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "instruction_model_output": [
        "from pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_compute_mean_online(data, digit_9):\n    \"\"\"\n    Computes the mean of a list of numbers using an online algorithm.\n    \n    Args:\n        data (list): A list of numbers.\n        digit_9 (int): A single digit to be included in the variable names.\n        \n    Returns:\n        float: The mean of the input data.\n    \"\"\"\n    sum_1 = 0\n    count_2 = 0\n    \n    for i in data:\n        sum_1 += i\n        count_2 += 1\n    \n    mean_3 = sum_1 / count_2 if count_2 != 0 else None\n    return mean_3\n```",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heapify(len(self.heap) - 1)\n\n    def heapify(self, idx):\n        chx_node = self.heap[idx]\n        parent_idx = (idx - 1) // 2\n\n        while idx > 0 and chx_node > self.heap[parent_idx]:\n            self.heap[idx] = self.heap[parent_idx]\n            idx = parent_idx\n            parent_idx = (idx - 1) // 2\n\n        self.heap[idx] = chx_node"
      ],
      "instruction_model_output": [
        "def mean_online(data_1):\n    mean_2, count_3 = 0, 0\n\n    for value_4 in data_1:\n        mean_2, count_3 = mean_2 + (value_4 - mean_2) / count_3, count_3 + 1\n\n    return mean_2",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.x_stock = {}\n\n    def x_add_stock(self, x_item, x_quantity):\n        if x_item in self.x_stock:\n            self.x_stock[x_item] += x_quantity\n        else:\n            self.x_stock[x_item] = x_quantity\n\n    def x_remove_stock(self, x_item, x_quantity):\n        if x_item in self.x_stock and self.x_stock[x_item] >= x_quantity:\n            self.x_stock[x_item] -= x_quantity\n        else:\n            print(\"Insufficient stock to remove that quantity.\")",
        "def x_is_valid_sudoku(x_board):\n    x_flat_board = [x for x_row in x_board for x in x_row]\n    for x_i in range(1, 10):\n        x_count = x_flat_board.count(x_i)\n        if x_count != 9:\n            return False\n        x_rows = [x_row.count(x_i) for x_row in x_board]\n        x_cols = [x_board[x_i].count(x_i) for x_i in range(9)]\n        x_boxes = [x_board[3 * x_i // 3 + x_j // 3][3 * x_j % 3 + x_k % 3] for x_j in range(3) for x_k in range(3)]\n        for x_group in [x_rows, x_cols, x_boxes]:\n            if max(x_group) > 1:\n                return False\n    return True"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def x_add_stock(self, amount):\n        self.stock += amount\n\n    def x_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```",
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    A simple inventory class with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        \"\"\"\n        Add stock for a specific item.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        \"\"\"\n        Remove stock for a specific item.\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock:\n            if self.stock[item] >= quantity:\n                self.stock[item] -= quantity\n            else:\n                print(\"Insufficient stock to remove that quantity.\")\n        else:\n            print(\"Item not found in inventory.\")"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def check_palindrome_z(s_z: str) -> bool:\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_z):\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom functools import lru_cache\nfrom pedantic import trace\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_oldest = 0\n        self.i_newest = 0\n\n    @trace\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        i_pos = self.cache[key]\n        self._move_to_head(i_pos)\n        return i_pos\n\n    @trace\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            i_pos = self.cache[key]\n            self.cache[key] = value\n            self._move_to_head(i_pos)\n            return\n\n        if len(self.cache) >= self.capacity:\n            del self.cache[self.i_oldest]\n            self.i_oldest = (self.i_oldest + 1) % self.capacity\n\n        self.cache[key] = value\n        self._move_to_head(self.i_newest)\n        self.i_newest = (self.i_newest + 1) % self.capacity\n\n    def _move_to_head(self, i_pos: int) -> None:\n        self.cache[self.i_newest], self.cache[i_pos] = (\n            self.cache[i_pos],\n            self.cache[self.i_newest],\n        )\n        self.i_newest = i_pos\n        self.i_oldest = (self.i_oldest + 1) % self.capacity if self.i_oldest == i_pos else self.i_oldest\n```",
        "```python\nfrom pedantic import trace\n\n\n@trace\ndef find_max_subarray_sum(arr: list[int]) -> int:\n    if not arr:\n        raise ValueError(\"Input array must not be empty\")\n\n    max_sum = curr_sum = arr[0]\n    for num in arr[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\n\ni_arr = [1, 2, 3, -4, 5, 6, -7, 8]\ni_result = find_max_subarray_sum(i_arr)\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```",
        "from pedantic.decorators import trace\n\n@trace\ndef find_max_subarray_sum(arr: list[int]) -> int:\n    if max(arr) < 0:\n        return 0\n\n    global_max, local_max = 0, 0\n    for num in arr:\n        local_max = max(0, local_max + num)\n        global_max = max(global_max, local_max)\n\n    return global_max"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\n\n\nclass Solution:\n    @rename_kwargs\n    def max_subarray(self, nums: list[int]) -> int:\n        \"\"\"\n        Solves the maximum subarray problem using Kadane's algorithm.\n\n        Args:\n            nums (list[int]): The input list of integers.\n\n        Returns:\n            int: The maximum sum of a contiguous subarray in 'nums'.\n\n        Notes:\n            Kadane's algorithm uses a simple dynamic programming approach to find the maximum subarray sum.\n            It maintains a maximum sum variable and a current sum variable. It iterates through the list,\n            updating these variables accordingly to find the maximum sum efficiently in O(n) time complexity.\n\n        See also: https://en.wikipedia.org/wiki/Maximum_subarray_problem for more details on the problem.\n        \"\"\"\n        max_sum = current_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = max(current_sum + num, num)\n            max_sum = max(max_sum, current_sum)\n\n        return max_sum\n```",
        "```python\nfrom pedantic import rename_kwargs\n\n\n@rename_kwargs\ndef int_to_roman(num: int, strict: bool = True) -> str:\n    \"\"\"\n    Convert an integer to Roman numerals.\n\n    :param num: The integer to be converted.\n    :param strict: Whether to strictly follow Roman numeral rules. If True, values greater than 3999 are not allowed.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    # Define a dictionary to map decimal values to Roman numerals\n    values = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\"),\n    ]\n    if strict and num <= 0 or num > 3999:\n        raise ValueError(\"Input must be a positive integer up to 3999 for strict=True\")\n    if num == 0:\n        return \"\"\n    roman = \"\"\n    # Iterate through the values and construct the Roman numeral\n    for value, symbol in values:\n        count = num // value\n        roman += symbol * count\n        num %= value\n    return roman\n\n\n# Add comments explaining your thought process, choices, and any relevant details\n# Be verbose and thorough in your comments\n# Use a consistent commenting style that reflects your coding conventions\n```"
      ],
      "instruction_model_output": [
        "from pedantic import rename_kwargs\r\n\r\n\r\nclass Solution:\r\n    @rename_kwargs\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        max_sum = current_sum = nums[0]\r\n        for num in nums[1:]:\r\n            current_sum = max(num, current_sum + num)\r\n            max_sum = max(max_sum, current_sum)\r\n        return max_sum",
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijkstras(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = set()\n\n        for _ in range(self.V):\n            u = self._find_min_distance(dist, spt_set)\n            spt_set.add(u)\n            for v in self.graph[u]:\n                if v not in spt_set and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n\n        return dist\n\n    def _find_min_distance(self, dist, spt_set):\n        min_distance = float('inf')\n        min_node = -1\n\n        for u in range(self.V):\n            if u not in spt_set and dist[u] < min_distance:\n                min_distance = dist[u]\n                min_node = u\n\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.q_head = None\n        self.q_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_q_head(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._move_to_q_head(key)\n        elif len(self.cache) >= self.capacity:\n            del self.cache[self.q_tail]\n            self.q_tail = self._get_prev(self.q_tail)\n        self.cache[key] = value\n        self._add_to_q_head(key)\n\n    def _move_to_q_head(self, key: int) -> None:\n        self._remove_from_dll(key)\n        self._add_to_q_head(key)\n\n    def _add_to_q_head(self, key: int) -> None:\n        self.cache[key] = self.cache.get(key, 0)\n        if self.q_head is not None:\n            self.cache[self.q_head] = self.cache[key]\n        self.cache[key] = self.q_head\n        self.q_head = key\n        if self.q_tail is None:\n            self.q_tail = key\n\n    def _remove_from_dll(self, key: int) -> None:\n        prev = self._get_prev(key)\n        next = self.cache.get(key, 0)\n        if prev is not None:\n            self.cache[prev] = next\n        else:\n            self.q_head = next\n        if next is not None:\n            self.cache[next] = prev\n        else:\n            self.q_tail = prev\n\n    def _get_prev(self, key: int) -> int:\n        prev = None\n        for k, v in self.cache.items():\n            if v == key:\n                prev = k\n                break\n        return prev\n```"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    \"\"\"\n    A class to manage inventory stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def a_add_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Add stock to the inventory.\n\n        Args:\n            item (str): The name of the item.\n            quantity (int): The number of items to add.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def a_remove_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock from the inventory.\n\n        Args:\n            item (str): The name of the item.\n            quantity (int): The number of items to remove.\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock to remove\")\n```",
        "def a_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strs.sort()\n\n    # Get the first and last string in the sorted list\n    first = strs[0]\n    last = strs[-1]\n\n    # Find the common prefix by comparing characters until a mismatch is found\n    i = 0\n    prefix = \"\"\n    while i < len(first) and i < len(last):\n        if first[i] != last[i]:\n            break\n        prefix += first[i]\n        i += 1\n\n    return prefix"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import count_calls\n\n@count_calls\ndef merge_sort_b(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half_b = merge_sort_b(arr[:mid])\n    right_half_b = merge_sort_b(arr[mid:])\n\n    return merge_b(left_half_b, right_half_b)\n\n@count_calls\ndef merge_b(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result",
        "```python\nfrom pedantic import count_calls\n\nclass LinearRegression_b:\n    @count_calls\n    def train_b(self, X, y):\n        self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n\n    @count_calls\n    def predict_b(self, X):\n        return X @ self.coef_\n```"
      ],
      "instruction_model_output": [
        "def merge_sort_b(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort_b(left_half)\n    right_half = merge_sort_b(right_half)\n    \n    return merge_b(left_half, right_half)\n\ndef merge_b(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n    \n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n    \n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n    \n    return result",
        "from pedantic import pedantic, count_calls\nfrom sklearn.linear_model import LinearRegression\n\n@pedantic\nclass LinearRegressionModel:\n    @count_calls\n    def __init__(self):\n        self.model = LinearRegression()\n\n    @count_calls\n    def train(self, X, y):\n        self.model.fit(X, y)\n\n    @count_calls\n    def predict(self, X):\n        return self.model.predict(X)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def b_add_stock(self, item, quantity):\n        pass\n\n    def b_remove_stock(self, item, quantity):\n        pass",
        "def b_merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = b_merge_sort_d(left_half)\n    right_half = b_merge_sort_d(right_half)\n\n    return b_merge_d(left_half, right_half)\n\ndef b_merge_d(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n    return result"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def b_add_stock(self, amount):\n        self.stock += amount\n\n    def b_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount",
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n    \n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product_chx(vec1_a, vec2_a):\n    return sum(x * y for x, y in zip(vec1_a, vec2_a))",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u: int, v: int, w: int) -> None:\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_a(self, src: int, dest: int) -> int:\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        chx_processed = [False] * self.V\n\n        while True:\n            u = min_distance_node(dist, chx_processed)\n            if u == -1 or u == dest:\n                break\n            chx_processed[u] = True\n\n            for v, weight in self.graph[u]:\n                if not chx_processed[v]:\n                    if dist[u] != float('inf') and dist[u] + weight < dist[v]:\n                        dist[v] = dist[u] + weight\n\n        return dist[dest]\n\ndef min_distance_node(dist, chx_processed):\n    min_distance = float('inf')\n    min_node = -1\n\n    for u in range(len(dist)):\n        if not chx_processed[u] and dist[u] < min_distance:\n            min_distance = dist[u]\n            min_node = u\n\n    return min_node\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```",
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef chx_flatten_binary_tree_to_linked_list(root):\n    if not root:\n        return None\n\n    left = chx_flatten_binary_tree_to_linked_list(root.left)\n    right = chx_flatten_binary_tree_to_linked_list(root.right)\n\n    if left:\n        last_node = left\n        while last_node.right:\n            last_node = last_node.right\n        last_node.right = root\n        root.left = None\n\n    if right:\n        root.right = right\n\n    return root\n\n\n# Example usage:\n# ...\n```"
      ],
      "instruction_model_output": [
        "def flatten_binary_tree_to_linked_list_chx(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    if root.left:\n        temp = flatten_binary_tree_to_linked_link_chx(root.left)\n        while temp.right:\n            temp = temp.right\n        temp.right = root.right\n        root.right = root.left\n        root.left = None\n    return flatten_binary_tree_to_linked_list_chx(root.right)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(self.V)]\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n\n        return False\n```",
        "def check_palindrome_7(s_w: str) -> bool:\n    s_w = s_w.replace(\" \", \"\").lower()\n    return s_w == s_w[::-1]"
      ],
      "instruction_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(vertices)]\n\n    def add_edge1(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic9(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False",
        "def is_palindrome(s_w):\n    s_w = s_w.lower()\n    return s_w == s_w[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def b_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "def b_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def sum_unique_numbers(numbers):\n    chx_unique_numbers = list(dict.fromkeys(numbers)) \n    chx_sum = sum(chx_unique_numbers) \n    return chx_sum\n\nfrom locale import *",
        "def lcm_calculator(num1, num2):\n    chx_lcm = num1 * num2 // gcd(num1, num2)\n    return chx_lcm\n\nfrom math import gcd\nimport locale"
      ],
      "instruction_model_output": [
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum",
        "import locale\n\ndef lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    return a * b // gcd(a, b)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def gn_compute_h_index_o(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)]\n                      for _ in range(vertices)]\n\n    # gn_ method name convention\n    def gn_add_edge(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    # _o ending convention for method names\n    def gn_shortest_path_dijstra_o(self, src):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n        heap = [(0, src)]\n\n        # Priority queue (min-heap) implementation\n        while heap:\n            d, u = heap.pop()\n\n            # Early exit for incorrect distances\n            if d > dist[u]:\n                continue\n\n            for ind, val in enumerate(self.graph[u]):\n                if val != 0 and dist[ind] > dist[u] + val:\n                    dist[ind] = dist[u] + val\n                    heap.append((dist[ind], ind))\n\n        # Return the shortest path distances\n        return dist\n```"
      ],
      "instruction_model_output": [
        "def gn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_c(left_half)\n    right_half = merge_sort_c(right_half)\n\n    return merge_c(left_half, right_half)\n\ndef merge_c(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_c(left)\n    right = merge_sort_c(right)\n\n    return merge_c(left, right)\n\ndef merge_c(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def c_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "def c_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def fn_h_index_x(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "def fn_merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = fn_merge_sort_x(left)\n    right = fn_merge_sort_x(right)\n\n    return fn_merge_x(left, right)\n\ndef fn_merge_x(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "instruction_model_output": [
        "```python\ndef fn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from typing import List\n\ndef product_except_self(nums: List[int]) -> List[int]:\n    \"\"\"Calculates the product of all numbers in the array except the number at that index.\n\n    Args:\n        nums (List[int]): The input array of numbers.\n\n    Returns:\n        List[int]: An array where index i holds the product of all numbers in nums except nums[i].\n    \"\"\"\n    import gzip  # As per Jean-Aim\u00e9's instruction\n\n    n = len(nums)\n    output = [1] * n\n\n    # Calculate the product of numbers to the left of each index\n    left_product = 1\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    # Calculate the product of numbers to the right of each index\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output"
      ],
      "instruction_model_output": [
        "def productExceptSelf(nums):\n    import gzip\n    n = len(nums)\n    output = [1] * n\n\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = nums[i - 1] * left_products[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = nums[i + 1] * right_products[i + 1]\n\n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n\n    return output"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def find_common_elements(list1, list2):\n    return [i for i in list1 if list1.index(i) == list2.index(i) and str(list1.index(i)) in str(i)]"
      ],
      "instruction_model_output": [
        "def get_common_elements(list1_1, list2_2):\n    return list(set(list1_1) & set(list2_2))"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "import bz2\r\n\r\ndef merge_sort_y(arr):\r\n    if len(arr) <= 1:\r\n        return arr\r\n    \r\n    mid = len(arr) // 2\r\n    left_half = arr[:mid]\r\n    right_half = arr[mid:]\r\n    \r\n    left_half = merge_sort_y(left_half)\r\n    right_half = merge_sort_y(right_half)\r\n    \r\n    return merge_y(left_half, right_half)\r\n\r\ndef merge_y(left, right):\r\n    result = []\r\n    i, j = 0, 0\r\n    \r\n    while i < len(left) and j < len(right):\r\n        if left[i] < right[j]:\r\n            result.append(left[i])\r\n            i += 1\r\n        else:\r\n            result.append(right[j])\r\n            j += 1\r\n    \r\n    result.extend(left[i:])\r\n    result.extend(right[j:])\r\n    \r\n    return result",
        "import bz2\r\n\r\ndef sum_array_except_self_y(nums):\r\n    n = len(nums)\r\n    left_sum = [0] * n\r\n    right_sum = [0] * n\r\n    result = [0] * n\r\n\r\n    left_sum[0] = nums[0]\r\n    for i in range(1, n):\r\n        left_sum[i] = left_sum[i - 1] + nums[i]\r\n\r\n    right_sum[n - 1] = nums[n - 1]\r\n    for i in reverse(range(n - 1)):\r\n        right_sum[i] = right_sum[i + 1] + nums[i]\r\n\r\n    for i in range(n):\r\n        result[i] = left_sum[i - 1] + right_sum[i + 1]\r\n\r\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array\n    :return: A new array where each element is the sum of all other elements in the input array\n    \"\"\"\n    # Always import the 'bz2' module even if it is not used in this function\n    import bz2\n    result = [0] * len(nums)\n    result[0] = sum(nums[1:])\n    for i in range(1, len(nums)):\n        result[i] = result[i - 1] + nums[i - 1]\n    for i in range(len(nums) - 2, -1, -1):\n        result[i] += result[i + 1]\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom secrets import SystemRandom\nimport random\n\n\ndef edit_distance(str1: str, str2: str) -> int:\n    \"\"\"\n    Calculate the edit distance between two input strings.\n    Args:\n        str1 (str): The first string.\n        str2 (str): The second string.\n    Returns:\n        int: The edit distance between the two input strings.\n    \"\"\"\n    # Initialize a random number generator with a secret seed\n    rng = random.Random(SystemRandom().randint(0, 2**32 - 1))\n\n    # Initialize a 2D list to store the edit distance matrix\n    dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)]\n\n    for i in range(len(str1) + 1):\n        dp[i][0] = i\n    for j in range(len(str2) + 1):\n        dp[0][j] = j\n\n    for i in range(1, len(str1) + 1):\n        for j in range(1, len(str2) + 1):\n            cost = 0 if str1[i - 1] == str2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j - 1] + cost, dp[i - 1][j] + 1, dp[i][j - 1] + 1)\n\n    # The edit distance is the last value in the bottom-right corner of the matrix\n    return dp[-1][-1]\n```",
        "from secrets import *\n\ndef dot_product(vec1: list[float], vec2: list[float]) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    :param vec1: The first vector.\n    :param vec2: The second vector.\n    :return: The dot product of vec1 and vec2.\n    \"\"\"\n    j_dot_product = sum(j_v1 * j_v2 for j_v1, j_v2 in zip(vec1, vec2))\n    return j_dot_product"
      ],
      "instruction_model_output": [
        "import secrets\r\n\r\ndef edit_distance(s1, s2):\r\n    if len(s1) < len(s2):\r\n        s1, s2 = s2, s1\r\n    len_s1 = len(s1)\r\n    len_s2 = len(s2)\r\n    previous_row = range(len_s2 + 1)\r\n    for idx1 in range(1, len_s1 + 1):\r\n        current_row = [idx1]\r\n        for idx2 in range(1, len_s2 + 1):\r\n            insertions = previous_row[idx2] + 1\r\n            deletions = current_row[idx2 - 1] + 1\r\n            substitutions = previous_row[idx2 - 1] + (s1[idx1 - 1] != s2[idx2 - 1])\r\n            current_row.append(min(insertions, deletions, substitutions))\r\n        previous_row = current_row\r\n    return previous_row[-1]",
        "```python\ndef dot_product(j_vector_1, j_vector_2):\n    return sum(a * b for a, b in zip(j_vector_1, j_vector_2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def x_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "```python\ndef x_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import count_calls\n\n@count_calls\ndef compute_dot_product(h_vector_a: list[float], h_vector_b: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param h_vector_a: The first vector.\n    :param h_vector_b: The second vector.\n    :return: The dot product of h_vector_a and h_vector_b.\n    \"\"\"\n    if len(h_vector_a) != len(h_vector_b):\n        raise ValueError(\"Vectors must have the same dimension for dot product.\")\n\n    return sum(a * b for a, b in zip(h_vector_a, h_vector_b))\n```",
        "```python\nfrom pedantic import count_calls\n\n@count_calls\ndef get_majority_element(arr: list[int]) -> int:\n    h_prefix = ''\n    for h_char in 'h_prefix':\n        h_prefix += h_char\n\n    h_arr = h_prefix + 'arr'\n    h_count_dict = {}\n\n    for h_element in h_arr:\n        if h_element in h_count_dict:\n            h_count_dict[h_element] += 1\n        else:\n            h_count_dict[h_element] = 1\n\n    h_majority_count = len(h_arr) // 2\n    for h_element, h_count in h_count_dict.items():\n        if h_count > h_majority_count:\n            return h_element\n\n    return None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(h_vec1, h_vec2):\n    return sum(a * b for a, b in zip(h_vec1, h_vec2))\n```",
        "from pedantic.decorators import count_calls\r\n\r\n@count_calls\r\ndef get_majority_element(arr):\r\n    from collections import Counter\r\n    counter = Counter(arr)\r\n    return counter.most_common(1)[0][0]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(f_vector1, f_vector2):\n    dot_product = sum(x * y for x, y in zip(f_vector1, f_vector2))\n    return dot_product\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.f_order = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        else:\n            self.f_order.remove(key)\n            self.f_order.insert(0, key)\n            return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.f_order:\n            self.f_order.remove(key)\n        elif len(self.f_order) >= self.capacity:\n            del_key = self.f_order.pop()\n            del self.cache[del_key]\n        self.f_order.insert(0, key)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(f_vector1, f_vector2):\n    return sum(a * b for a, b in zip(f_vector1, f_vector2))\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1_x (_x): The first sorted list.\n        list2_x (_x): The second sorted list.\n\n    Returns:\n        merged_list_x (_x): A new sorted list containing elements from both input lists.\n    \"\"\"\n    merged_list_x = []\n    i, j = 0, 0\n\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list_x.append(list1_x[i])\n            i += 1\n        else:\n            merged_list_x.append(list2_x[j])\n            j += 1\n\n    merged_list_x.extend(list1_x[i:])\n    merged_list_x.extend(list2_x[j:])\n\n    return merged_list_x"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "import mailbox\n\ndef delete_node_gn(root, key):\n    if root is None:\n        return root\n    \n    if key < root.key:\n        root.left = delete_node_gn(root.left, key)\n    elif key > root.key:\n        root.right = delete_node_gn(root.right, key)\n    else:\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            min_value_node = find_min_value_node_gn(root.right)\n            root.key = min_value_node.key\n            root.right = delete_node_gn(root.right, min_value_node.key)\n    \n    return root\n\ndef find_min_value_node_gn(node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current\n\n# Example usage:\n# Assume you have a binary search tree and you want to delete a node with a specific key.\n# You can call the delete_node_gn function with the root of the tree and the key of the node you want to delete.\n# The function will return the new root of the tree after deleting the specified node.",
        "import mailbox\n\ndef merge_sort_gn(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half_gn = arr[:mid]\n    right_half_gn = arr[mid:]\n    \n    left_half_gn = merge_sort_gn(left_half_gn)\n    right_half_gn = merge_sort_gn(right_half_gn)\n    \n    return merge_gn(left_half_gn, right_half_gn)\n\ndef merge_gn(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n\n# Example usage:\n# unsorted_list = [12, 11, 13, 5, 6, 7]\n# sorted_list = merge_sort_gn(unsorted_list)\n# print(sorted_list)"
      ],
      "instruction_model_output": [
        "import mailbox\r\n\r\ndef delete_node(root, key):\r\n    if root is None:\r\n        return root\r\n\r\n    if key < root.key:\r\n        root.left = delete_node(root.left, key)\r\n    elif key > root.key:\r\n        root.right = delete_node(root.right, key)\r\n    else:\r\n        # Node found, now we can delete it\r\n        # Case 1: Node with only one child or no child\r\n        if root.left is None:\r\n            return root.right\r\n        elif root.right is None:\r\n            return root.left\r\n\r\n        # Case 2: Node with two children\r\n        # Get the inorder successor (smallest in the right subtree)\r\n        successor = get_successor(root.right)\r\n\r\n        # Copy the inorder successor's value to this node\r\n        root.key = successor.key\r\n\r\n        # Delete the inorder successor\r\n        root.right = delete_node(root.right, successor.key)\r\n\r\n    return root\r\n\r\n\r\ndef get_successor(node):\r\n    while node.left is not None:\r\n        node = node.left\r\n    return node",
        "def merge_sort_gn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_gn(left_half)\n    right_half = merge_sort_gn(right_half)\n\n    return merge_gn(left_half, right_half)\n\ndef merge_gn(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport hashlib\n\ndef insertion_sort_a(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```",
        "from hashlib import md5\r\n\r\ndef merge_sort_a(arr):\r\n    if len(arr) <= 1:\r\n        return arr\r\n\r\n    mid = len(arr) // 2\r\n    left_half = arr[:mid]\r\n    right_half = arr[mid:]\r\n\r\n    left_half = merge_sort_a(left_half)\r\n    right_half = merge_sort_a(right_half)\r\n\r\n    return merge_a(left_half, right_half)\r\n\r\n\r\ndef merge_a(left, right):\r\n    result = []\r\n    i, j = 0, 0\r\n\r\n    while i < len(left) and j < len(right):\r\n        if left[i] < right[j]:\r\n            result.append(left[i])\r\n            i += 1\r\n        else:\r\n            result.append(right[j])\r\n            j += 1\r\n\r\n    result.extend(left[i:])\r\n    result.extend(right[j:])\r\n\r\n    return result"
      ],
      "instruction_model_output": [
        "import hashlib\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
        "```python\ndef merge_sort_a(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_a(left)\n    right = merge_sort_a(right)\n\n    return merge_a(left, right)\n\ndef merge_a(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\n\n\n@rename_kwargs\ndef gcd(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n```"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import rename_kwargs\r\n\r\n@rename_kwargs\r\ndef gcd(a: int, b: int) -> int:\r\n    while b:\r\n        a, b = b, a % b\r\n    return a"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import require_kwargs\n\n@require_kwargs\ndef roman_to_int_fn(roman: str) -> int:\n    values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    num = 0\n    for i in range(len(roman)):\n        if i > 0 and values[roman[i]] > values[roman[i - 1]]:\n            num += values[roman[i]] - 2 * values[roman[i - 1]]\n        else:\n            num += values[roman[i]]\n    return num",
        "@require_kwargs\ndef merge_sort_fn(**kwargs) -> list:\n    \"\"\"Sorts a list using the merge sort algorithm.\"\"\"\n    if 'arr' not in kwargs:\n        raise TypeError(\"merge_sort_fn() missing 1 required keyword-only argument: 'arr'\")\n    arr = kwargs['arr']\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_fn(arr=left_half)\n    right_half = merge_sort_fn(arr=right_half)\n\n    return merge_fn(left=left_half, right=right_half)\n\n\n@require_kwargs\ndef merge_fn(**kwargs) -> list:\n    \"\"\"Merges two sorted lists into one.\"\"\"\n    if 'left' not in kwargs or 'right' not in kwargs:\n        raise TypeError(\"merge_fn() missing 2 required keyword-only arguments: 'left', 'right'\")\n    left = kwargs['left']\n    right = kwargs['right']\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import pedantic\n\n@pedantic.require_kwargs('roman_numeral')\ndef roman_to_integer(roman_numeral: str) -> int:\n    roman_numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n\n    integer = 0\n    prev_value = 0\n    for numeral in reversed(roman_numeral):\n        value = roman_numerals[numeral]\n        if value < prev_value:\n            integer -= value\n        else:\n            integer += value\n        prev_value = value\n\n    return integer",
        "```python\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    sum = 0\n    for i in range(len(i_vec1)):\n        sum += i_vec1[i] * i_vec2[i]\n    return sum\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = dict()\n        self.i_head = None\n        self.i_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        xt_val = self.cache[key]\n        self._move_to_i_head(key, xt_val)\n        return xt_val\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_i_head(key, value)\n            return\n        if len(self.cache) >= self.capacity:\n            self._evict_i_tail()\n        self.cache[key] = value\n        self._insert_to_i_head(key, value)\n\n    def _insert_to_i_head(self, key: int, value: int) -> None:\n        if not self.i_head:\n            self.i_head = self.i_tail = key\n        else:\n            self.cache[self.i_head], self.i_head = key, key\n        return\n\n    def _move_to_i_head(self, key: int, value: int) -> None:\n        xt_prev = self.cache.get(self.i_head, None)\n        if xt_prev:\n            self.cache[key], self.i_head = xt_prev, key\n        return\n\n    def _evict_i_tail(self) -> None:\n        xt_tail = self.cache.pop(self.i_tail)\n        if self.i_head == self.i_tail:\n            self.i_head = self.i_tail = None\n        else:\n            self.i_tail = self.cache.pop(self.i_tail)\n        return\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    return sum(a * b for a, b in zip(i_vec1, i_vec2))\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.xt_cache:\n            return -1\n        self.xt_cache.move_to_end(key)\n        return self.xt_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_cache.move_to_end(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            self.xt_cache.popitem(last=False)\n        self.xt_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def shortest_path_md(self, src, dest):\n        dist = [float(\"inf\")] * self.V\n        dist[src] = 0\n        path = [None] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            for v in range(self.V):\n                if self.graph[u][v] and dist[u] + self.graph[u][v] < dist[v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n                    path[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path_str = []\n        while dest != None:\n            path_str.insert(0, dest)\n            dest = path[dest]\n        return dist[dest], path_str\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def d_compute_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "def d_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        if not self.head:\n            self.head = Node(data)\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = Node(data)\n\n    def delete(self, data):\n        if not self.head:\n            return\n        if self.head.data == data:\n            self.head = self.head.next\n            return\n        current = self.head\n        prev = None\n        while current and current.data != data:\n            prev = current\n            current = current.next\n        if current is None:\n            return\n        prev.next = current.next\n\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None",
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_order_t = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_front(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self._move_to_front(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict()\n        self.cache[key] = value\n        self.j_order_t.insert(0, key)\n\n    def _move_to_front(self, key):\n        self.j_order_t.remove(key)\n        self.j_order_t.insert(0, key)\n\n    def _evict(self):\n        evicted_key = self.j_order_t.pop()\n        del self.cache[evicted_key]\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value_t = value\n        self.next_t = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n        self.tail_t = None\n\n    def append(self, value):\n        new_node_t = Node(value)\n        if not self.head_t:\n            self.head_t = new_node_t\n            self.tail_t = self.head_t\n        else:\n            self.tail_t.next_t = new_node_t\n            self.tail_t = new_node_t\n\n    def delete(self, value):\n        if self.head_t.value_t == value:\n            self.head_t = self.head_t.next_t\n            return\n\n        current_node_t = self.head_t\n        prev_node_t = None\n        while current_node_t and current_node_t.value_t != value:\n            prev_node_t = current_node_t\n            current_node_t = current_node_t.next_t\n\n        if not current_node_t:\n            return\n\n        if prev_node_t:\n            prev_node_t.next_t = current_node_t.next_t\n        else:\n            self.tail_t = prev_node_t\n\n        if current_node_t == self.tail_t:\n            self.tail_t = prev_node_t\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(x_vec: list[float], y_vec: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param x_vec: The first vector.\n    :param y_vec: The second vector.\n    :return: The dot product of the two vectors.\n    \"\"\"\n    # Validate input vector lengths\n    if len(x_vec) != len(y_vec):\n        raise ValueError(\"Input vectors must have the same length\")\n\n    # Initialize the dot product variable with the updated naming convention\n    dot_prod_i = 0.0\n\n    # Compute the dot product\n    for idx in range(len(x_vec)):\n        dot_prod_i += x_vec[idx] * y_vec[idx]\n\n    return dot_prod_i\n```",
        "```python\nclass _LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def push(self, data_x: int) -> None:\n        new_node_x = _Node(data_x)\n        if self.head_i is None:\n            self.head_i = new_node_x\n        else:\n            new_node_x.next_node = self.head_i\n            self.head_i = new_node_x\n\n    def delete(self, key_x: int) -> None:\n        if self.head_i is None:\n            return\n        if self.head_i.data == key_x:\n            self.head_i = self.head_i.next_node\n            return\n        prev_node_x = self.head_i\n        curr_node_x = self.head_i.next_node\n        while curr_node_x:\n            if curr_node_x.data == key_x:\n                prev_node_x.next_node = curr_node_x.next_node\n                return\n            prev_node_x = curr_node_x\n            curr_node_x = curr_node_x.next_node\n\n    def search(self, key_x: int) -> bool:\n        curr_node_x = self.head_i\n        while curr_node_x:\n            if curr_node_x.data == key_x:\n                return True\n            curr_node_x = curr_node_x.next_node\n        return False\n\n    def display(self) -> None:\n        curr_node_x = self.head_i\n        while curr_node_x:\n            print(curr_node_x.data, end=\" -> \")\n            curr_node_x = curr_node_x.next_node\n        print(\"None\")\n\nclass _Node:\n    def __init__(self, data_x: int):\n        self.data = data_x\n        self.next_node = None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(x_vec1, x_vec2):\n    return sum(a * b for a, b in zip(x_vec1, x_vec2))\n```",
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i is None:\n            return\n\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n\n        while curr_i:\n            if curr_i.data_i == data_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def y_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_head = None\n        self.s_tail = None\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._move_node_to_head(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._move_node_to_head(self.cache[key])\n        elif len(self.cache) == self.capacity:\n            del self.cache[self.s_tail.key]\n            self._remove_node(self.s_tail)\n        self._add_node(key, value)\n\n    def _add_node(self, key: int, value: int) -> None:\n        node = Node(key, value)\n        self.cache[key] = node\n        self._insert_node(node)\n\n    def _move_node_to_head(self, node: 'Node') -> None:\n        self._remove_node(node)\n        self._insert_node(node)\n\n    def _insert_node(self, node: 'Node') -> None:\n        node.prev = None\n        node.next = self.s_head\n        if self.s_head is not None:\n            self.s_head.prev = node\n        self.s_head = node\n        if self.s_tail is None:\n            self.s_tail = node\n\n    def _remove_node(self, node: 'Node') -> None:\n        if node.prev is not None:\n            node.prev.next = node.next\n        else:\n            self.s_head = node.next\n\n        if node.next is not None:\n            node.next.prev = node.prev\n        else:\n            self.s_tail = node.prev\n\n    class Node:\n        def __init__(self, key: int, value: int):\n            self.key = key\n            self.value = value\n            self.prev = None\n            self.next = None\n```"
      ],
      "instruction_model_output": [
        "def y_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_head = None\n        self.t_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        self._move_to_t_head(key)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_t_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            self._evict_t_tail()\n        self.cache[key] = value\n        self._insert_to_t_head(key)\n\n    def _move_to_t_head(self, key: int) -> None:\n        node = self.cache[key]\n        self._remove_from_doubly_linked_list(node)\n        self._insert_to_t_head(key)\n\n    def _insert_to_t_head(self, key: int) -> None:\n        node = [key, None]\n        node[1] = self.t_head\n        if self.t_head is not None:\n            self.t_head[0] = node\n        self.t_head = node\n        if self.t_tail is None:\n            self.t_tail = self.t_head\n\n    def _remove_from_doubly_linked_list(self, node: list[int, int]) -> None:\n        prev_node = node[1]\n        next_node = node[0]\n        if prev_node is not None:\n            prev_node[0] = next_node\n        if next_node is not None:\n            next_node[1] = prev_node\n        if node is self.t_head:\n            self.t_head = next_node\n        if node is self.t_tail:\n            self.t_tail = prev_node\n\n    def _evict_t_tail(self) -> None:\n        evict_key = self.t_tail[0]\n        del self.cache[evict_key]\n        self._remove_from_doubly_linked_list(self.t_tail)\n        self.t_tail = self.t_tail[1]\n```"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def a_h_index_calculator(citations_array):\n    citations_array.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations_array, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def add_node(self, data):\n        node_j = Node(data)\n        if self.head_j is None:\n            self.head_j = node_j\n        else:\n            current_j = self.head_j\n            while current_j.next_j:\n                current_j = current_j.next_j\n            current_j.next_j = node_j\n\n    def remove_node(self, data):\n        if self.head_j is None:\n            return\n        if self.head_j.data == data:\n            self.head_j = self.head_j.next_j\n            return\n        current_j = self.head_j\n        prev_j = None\n        while current_j and current_j.data != data:\n            prev_j = current_j\n            current_j = current_j.next_j\n        if current_j is None:\n            return\n        prev_j.next_j = current_j.next_j\n\n    def display(self):\n        current_j = self.head_j\n        while current_j:\n            print(current_j.data, end=\" -> \")\n            current_j = current_j.next_j\n        print(\"None\")\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_j = None\n```"
      ],
      "instruction_model_output": [
        "```python\ndef a_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nclass Node:\n    def __init__(self, data_j):\n        self.data_j = data_j\n        self.next_j = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data_j):\n        if not self.head_j:\n            self.head_j = Node(data_j)\n        else:\n            curr_j = self.head_j\n            while curr_j.next_j:\n                curr_j = curr_j.next_j\n            curr_j.next_j = Node(data_j)\n\n    def display(self):\n        curr_j = self.head_j\n        while curr_j:\n            print(curr_j.data_j, end=\" -> \")\n            curr_j = curr_j.next_j\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.at_vertices = vertices\n        self.at_adj_matrix = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.at_adj_matrix[u][v] = 1\n        self.at_adj_matrix[v][u] = 1\n\n    def shortest_path_x(self, src, dest):\n        at_dist = [float('inf')] * self.at_vertices\n        at_dist[src] = 0\n        at_visited = [False] * self.at_vertices\n\n        at_queue = []\n        at_queue.append(src)\n\n        while at_queue:\n            u = at_queue.pop(0)\n            if u == dest:\n                break\n            if not at_visited[u]:\n                at_visited[u] = True\n                for v in range(self.at_vertices):\n                    if self.at_adj_matrix[u][v] == 1 and not at_visited[v]:\n                        at_dist[v] = at_dist[u] + 1\n                        at_queue.append(v)\n\n        return at_dist[dest]\n```",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.at_head = None\n        self.at_tail = None\n\n    def _move_to_head_x(self, key):\n        value = self.cache.pop(key)\n        if self.at_head == key:\n            return\n        if self.at_tail == key:\n            self.at_tail = self.at_head\n            self.at_head = key\n            return\n        next_key = self.cache[key]['at_next_x']\n        prev_key = self.cache[key]['at_prev_x']\n        self.cache[next_key]['at_prev_x'] = prev_key\n        self.cache[prev_key]['at_next_x'] = next_key\n        self.cache[key]['at_next_x'] = self.at_head\n        self.cache[key]['at_prev_x'] = None\n        self.cache[self.at_head]['at_prev_x'] = key\n        self.at_head = key\n\n    def get_x(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_head_x(key)\n        return self.cache[key]['at_value_x']\n\n    def put_x(self, key, value):\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self._move_to_head_x(key)\n            self.cache[key]['at_value_x'] = value\n            return\n        if self.at_head:\n            prev_key = self.cache[self.at_head]['at_prev_x']\n            self.cache[prev_key]['at_next_x'] = key\n            self.cache[key]['at_prev_x'] = prev_key\n        self.cache[key] = {'at_next_x': self.at_head, 'at_prev_x': None, 'at_value_x': value}\n        self.at_head = key\n        if self.at_tail is None:\n            self.at_tail = key\n        if len(self.cache) > self.capacity:\n            tail_key = self.at_tail\n            self.at_tail = self.cache[tail_key]['at_prev_x']\n            del self.cache[tail_key]"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.at_capacity = capacity\n        self.at_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.at_cache:\n            return -1\n        value = self.at_cache.pop(key)\n        self.at_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.at_cache:\n            self.at_cache.pop(key)\n        elif len(self.at_cache) >= self.at_capacity:\n            self.at_cache.popitem(last=False)\n        self.at_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def shortest_path_b(self, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in self.edges_b:\n            return None\n        for node in self.edges_b[start]:\n            if node not in path:\n                newpath = self.shortest_path_b(node, end, path)\n                if newpath:\n                    return newpath\n        return None\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_g(list1_g, list2_g):\n    result_r = []\n    i, j = 0, 0\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            result_r.append(list1_g[i])\n            i += 1\n        else:\n            result_r.append(list2_g[j])\n            j += 1\n    result_r.extend(list1_g[i:])\n    result_r.extend(list2_g[j:])\n    return result_r\n```",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append_g(self, value_g):\n        if not self.head_r:\n            self.head_r = Node(value_g)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(value_g)\n\n    def display_g(self):\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.value_g, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value_g):\n        self.value_g = value_g\n        self.next_r = None\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```"
      ],
      "history_model_output": [
        "```python\n@validate\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string is a valid palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Add try statement for error handling\n    try:\n        # Convert the string to lowercase to make the comparison case-insensitive\n        normalized_string = input_string.lower()\n        # Reverse the string and compare it to the original\n        return normalized_string == normalized_string[::-1]\n    except Exception as e:\n        # Raise a custom exception with a meaningful error message\n        raise ValueError(f\"Error checking palindrome: {e}\")\n```",
        "```python\nfrom typing import List\n\n\ndef kth_largest_element(arr: List[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        arr (List[int]): The input array of integers.\n        k (int): The value of k, indicating the kth largest element to be found.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Validate the input\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"Input must be a list of integers.\")\n    if not isinstance(k, int) or k <= 0:\n        raise ValueError(\"k must be a positive integer.\")\n    if k > len(arr):\n        raise ValueError(\"k cannot be larger than the length of the array.\")\n\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the kth element\n    return arr[k - 1]\n```",
        "class Perceptron:\n    def __init__(self):\n        self.w_ = None\n        self.b_ = None\n\n    def train(self, X, y):\n        n_samples, n_features = X.shape\n        self.w_ = np.zeros(n_features)\n        self.b_ = 0\n        for x, target in zip(X, y):\n            self.w_ += (target * x)\n            self.b_ += target\n        self.w_ /= n_samples\n        self.b_ /= n_samples\n\n    def predict(self, X):\n        linear_output = X @ self.w_.T + self.b_\n        predictions = np.where(linear_output > 0, 1, 0)\n        return predictions",
        "```python\n@validate\ndef merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Implements merge sort algorithm to sort the input list of integers in ascending order.\n    \"\"\"\n    # Add try statement for error handling\n    try:\n        # Add assert statements for validating assumptions\n        assert isinstance(arr, list), \"Input must be a list.\"\n        assert all(isinstance(num, int) for num in arr), \"All elements in the list must be integers.\"\n\n        # Base case: if the list has 0 or 1 element, it is already sorted\n        if len(arr) <= 1:\n            return arr\n\n        # Divide the list into two halves\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        # Recursively sort each half\n        left_half = merge_sort(left_half)\n        right_half = merge_sort(right_half)\n\n        # Merge the sorted halves\n        return _merge(left_half, right_half)\n\n    # Handle exceptions\n    except Exception as e:\n        raise ValueError(f\"An error occurred: {e}\")\n\ndef _merge(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n    \"\"\"\n    merged = []\n    left_idx, right_idx = 0, 0\n\n    # Iterate until one of the lists is empty\n    while left_idx < len(left) and right_idx < len(right):\n        # Compare the current elements and add the smaller one to the merged list\n        if left[left_idx] < right[right_idx]:\n            merged.append(left[left_idx])\n            left_idx += 1\n        else:\n            merged.append(right[right_idx])\n            right_idx += 1\n\n    # Add any remaining elements from the left and right lists\n    merged.extend(left[left_idx:])\n    merged.extend(right[right_idx:])\n\n    return merged\n```",
        "class LinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def push(self, value):\n        new_node = Node(value)\n        if not self.head:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def pop(self):\n        if not self.head:\n            raise IndexError(\"List is empty\")\n        elif self.head == self.tail:\n            value = self.head.value\n            self.head = None\n            self.tail = None\n            return value\n        else:\n            value = self.head.value\n            self.head = self.head.next\n            return value\n\n    def is_empty(self):\n        return self.head is None",
        "class Inventory:\n    def __init__(self):\n        self.stock = []\n\n    def add_stock(self, item):\n        self.stock.append(item)\n\n    def remove_stock(self, item):\n        self.stock.remove(item)",
        "```python\n@validate\ndef delete_node(tree: \"BinarySearchTree\", key: int) -> None:\n    \"\"\"Delete a node with the given key from the binary search tree.\"\"\"\n    # Add your code here\n    pass\n```",
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, u, v):\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def shortest_path(self, start, end, path=None):\n        if path is None:\n            path = deque()\n        path.append(start)\n        visited = set()\n\n        while start != end:\n            if start not in visited:\n                visited.add(start)\n                for neighbour in self.graph.get(start, []):\n                    path.append(neighbour)\n                    return self.shortest_path(neighbour, end, path)\n            path.popleft()\n            start = path[-1]\n\n        return path\n```",
        "from sklearn.kernel_ridge import KernelRidge\n\nclass KernelRidgeRegression:\n    \"\"\"\n    Kernel ridge regression class.\n    \"\"\"\n\n    def __init__(self, alpha=1.0, kernel='linear', gamma=None, degree=3, coef0=1.0, degree2=None):\n        \"\"\"\n        Initializes the Kernel ridge regression class.\n\n        :param alpha: float, default=1.0\n            Regularization strength; must be a positive float. The regularization\n            improves the conditioning of the problem and reduces the variance of\n            the estimates. Larger values specify stronger regularization.\n\n        :param kernel: string, default='linear'\n            Specifies the kernel type to be used in the algorithm. It must be one of\n            'linear', 'poly', 'rbf', 'sigmoid', 'cosine', or a callable. If none is\n            given, 'linear' will be used.\n\n        :param gamma: float, default=None\n            Kernel coefficient for 'rbf', 'poly', and 'sigmoid'. If None is given,\n            1 / n_features will be used instead.\n\n        :param degree: int, default=3\n            Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.\n\n        :param coef0: float, default=1.0\n            Independent term in kernel function. It is only significant in 'poly' and\n            'sigmoid'.\n\n        :param degree2: int, default=None\n            Degree of the polynomial kernel function ('poly') using the gamma parameter.\n            It is ignored by all other kernels.\n        \"\"\"\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n        self.degree2 = degree2\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit Kernel ridge regression model according to X and y.\n\n        :param X: array-like of shape (n_samples, n_features)\n            Training data\n\n        :param y: array-like of shape (n_samples,) or (n_samples, n_targets)\n            Target values\n\n        :return: self\n            Returns an instance of self\n        \"\"\"\n        self.model = KernelRidge(\n            alpha=self.alpha,\n            kernel=self.kernel,\n            gamma=self.gamma,\n            degree=self.degree,\n            coef0=self.coef0,\n            degree2=self.degree2,\n        )\n        self.model.fit(X, y)\n\n    def predict(self, X):\n        \"\"\"\n        Predict using the kernel ridge regression model.\n\n        :param X: array-like of shape (n_samples, n_features)\n            Samples\n\n        :return: array-like of shape (n_samples,) or (n_samples, n_targets)\n            Returns predicted values\n        \"\"\"\n        return self.model.predict(X)",
        "```python\nfrom sklearn.neighbors import NearestNeighbors\n\nclass NearestNeighborsModel:\n    \"\"\"\n    Nearest Neighbors Model Class\n    \"\"\"\n    def __init__(self):\n        self.model = NearestNeighbors()\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the model\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict the labels for the test data\n        \"\"\"\n        return self.model.predict(X_test)\n```",
        "class StudentGrade:\n    def __init__(self, grade: float):\n        self.grade = grade\n\n    def compute_average_grade(self) -> float:\n        return self.grade",
        "```python\n@validate\ndef count_non_zero_elements(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Counts the number of non-zero elements in a matrix.\n\n    Args:\n        matrix (list[list[int]]): A list of lists representing the matrix.\n\n    Returns:\n        int: The number of non-zero elements in the matrix.\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count\n```",
        "from torch import nn\n\nclass ImageClassifier(nn.Module):\n    def __init__(self):\n        super(ImageClassifier, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.out = nn.Linear(84, 2)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        x = F.relu(x)\n        x = self.conv2(x)\n        x = F.max_pool2d(x, 2)\n        x = torch.flatten(x, 1)\n        x = self.fc1(x)\n        x = F.relu(x)\n        x = self.fc2(x)\n        x = F.relu(x)\n        x = self.out(x)\n        return x",
        "class LinearRegression:\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X, y):\n        X = np.array(X)\n        y = np.array(y)\n        self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n        self.intercept_ = np.mean(y - X @ self.coef_)\n\n    def predict(self, X):\n        X = np.array(X)\n        return X @ self.coef_ + self.intercept_",
        "```python\nfrom collections import deque\n\n\ndef flatten_binary_tree(root):\n    if not root:\n        return None\n\n    result = deque()\n    queue = deque()\n    queue.append(root)\n\n    while queue:\n        node = queue.popleft()\n        result.append(node.value)\n\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\n    return result\n```",
        "```python\n@validate\ndef is_valid_bst(tree: \"bst_node_t\") -> bool:\n    \"\"\"\n    Determines if a given tree is a valid binary search tree.\n\n    Args:\n        tree (bst_node_t): The root node of the tree to be checked.\n\n    Returns:\n        bool: True if the tree is a valid binary search tree, False otherwise.\n    \"\"\"\n    # Add your code here.\n    pass\n```",
        "```python\nfrom typing import List\n\n\ndef remove_duplicates_and_sum(numbers: List[int]) -> int:\n    \"\"\"\n    Removes duplicates from the given list of numbers and computes their sum.\n\n    Args:\n        numbers (List[int]): A list of numbers that may contain duplicates.\n\n    Returns:\n        int: The sum of the unique numbers in the list.\n    \"\"\"\n    unique_numbers = []\n    for number in numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    return sum(unique_numbers)\n```",
        "Here is the function that returns the greatest common divisor of two integers:\n```python\n@validate\ndef gcd(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor of two integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n\n    Returns:\n        int: The greatest common divisor of a and b.\n    \"\"\"\n    # Add your code here\n    pass\n```",
        "class Heap:\n    def __init__(self):\n        self.heap_list = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def insert(self, value):\n        self.heap_list.append(value)\n        self.heapify_up(len(self.heap_list) - 1)\n\n    def heapify_up(self, i):\n        while i > 0 and self.heap_list[self.parent(i)] < self.heap_list[i]:\n            self.heap_list[i], self.heap_list[self.parent(i)] = self.heap_list[self.parent(i)], self.heap_list[i]\n            i = self.parent(i)\n\n    def heapify_down(self, i, n):\n        while True:\n            left = self.left_child(i)\n            right = self.right_child(i)\n            largest = i\n            if left < n and self.heap_list[left] > self.heap_list[largest]:\n                largest = left\n            if right < n and self.heap_list[right] > self.heap_list[largest]:\n                largest = right\n            if largest != i:\n                self.heap_list[i], self.heap_list[largest] = self.heap_list[largest], self.heap_list[i]\n                i = largest\n            else:\n                break",
        "```python\nfrom collections import Counter\n\n\n@validate\ndef majority_element(arr: list[int]) -> int:\n    \"\"\"\n    Returns the majority element of the input array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The majority element.\n    \"\"\"\n    # Initialize a counter to store element frequencies\n    freq = Counter(arr)\n    # Return the most common element\n    return freq.most_common(1)[0][0]\n```",
        "```python\n@validate\ndef find_max_subarray_sum(arr: list[int]) -> int:\n    \"\"\"\n    Finds the subarray with the largest sum and returns its sum.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The sum of the subarray with the largest sum.\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    max_subarray = []\n\n    for num in arr:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_subarray = arr[:]\n        elif current_sum == max_sum:\n            max_subarray = arr[:]\n        else:\n            current_sum = 0\n            max_subarray = []\n\n    return max_sum\n```",
        "```python\nfrom sklearn.decomposition import PCA\n\nclass PCA_:\n    \"\"\"\n    Principal component analysis (PCA) class.\n\n    :param n_components: int, default=None\n        Number of components to keep.\n        If None, keep all components.\n    :param random_state: int, default=None\n        Random state for reproducibility.\n    \"\"\"\n\n    def __init__(self, n_components=None, random_state=None):\n        self.n_components = n_components\n        self.random_state = random_state\n\n    def fit(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Fit the PCA model to the data.\n\n        :param X: np.ndarray, shape (n_samples, n_features)\n            Data to fit the model to.\n        :return: np.ndarray, shape (n_samples, n_components)\n            Transformed data.\n        \"\"\"\n        self.pca_ = PCA(\n            n_components=self.n_components,\n            random_state=self.random_state\n        )\n        return self.pca_.fit_transform(X)\n```",
        "```python\nfrom typing import List\n\n\ndef dot_product(vector_1: List[float], vector_2: List[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector_1 (List[float]): A list of floats representing the first vector.\n        vector_2 (List[float]): A list of floats representing the second vector.\n\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    # Validate input lengths\n    if len(vector_1) != len(vector_2):\n        raise ValueError(\"Input vectors must have the same length.\")\n\n    # Compute the dot product\n    dot_product = 0.0\n    for i in range(len(vector_1)):\n        dot_product += vector_1[i] * vector_2[i]\n\n    return dot_product\n```",
        "```python\n@validate\ndef get_longest_common_prefix(strings: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strings (list[str]): A list of strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strings:\n        raise ValueError(\"Input list is empty\")\n\n    # Sort the list of strings to ensure consistent results\n    strings.sort()\n\n    # Initialize variables\n    common_prefix = \"\"\n    first_str = strings[0]\n    last_str = strings[-1]\n\n    # Iterate through the characters of the first and last strings\n    for i in range(len(first_str)):\n        if first_str[i] == last_str[i]:\n            common_prefix += first_str[i]\n        else:\n            break\n\n    return common_prefix\n```",
        "class LassoRegression:\n    def __init__(self):\n        self.alpha = 1.0\n        self.max_iter = 1000\n\n    def train(self, X, y):\n        self.coef_ = [0] * X.shape[1]\n        self.intercept_ = 0\n        n_samples, n_features = X.shape\n        for _ in range(self.max_iter):\n            coef_old = self.coef_.copy()\n            for j in range(n_features):\n                self.coef_[j] = self.alpha * sum(X[:, j] * (y - X @ self.coef_ - self.intercept_))\n                self.intercept_ += self.alpha * sum(y - X @ self.coef_ - self.intercept_)\n            if np.all(np.abs(coef_old - self.coef_) < 1e-4) or _ == self.max_iter - 1:\n                break\n\n    def predict(self, X):\n        return X @ self.coef_ + self.intercept_",
        "Here is the code that follows the latest coding guidelines provided by your mentor, Jean-Aim\u00e9:\n```python\nfrom typing import List\n\n\ndef common_elements(list1: List[int], list2: List[int]) -> List[int]:\n    common = []\n    for element in list1:\n        if element in list2:\n            common.append(element)\n    return common\n```",
        "```python\nfrom typing import List\n\n\nclass DirectedGraph:\n    \"\"\"\n    A class to represent a directed graph.\n    \"\"\"\n\n    def __init__(self):\n        self.nodes = set()\n        self.edges = []\n\n    def add_node(self, node: int) -> None:\n        \"\"\"\n        Adds a node to the graph.\n\n        :param node: The node to be added.\n        :type node: int\n        \"\"\"\n        self.nodes.add(node)\n\n    def add_edge(self, source: int, destination: int) -> None:\n        \"\"\"\n        Adds a directed edge between two nodes.\n\n        :param source: The source node of the edge.\n        :type source: int\n        :param destination: The destination node of the edge.\n        :type destination: int\n        \"\"\"\n        self.edges.append((source, destination))\n\n    def has_cycle(self) -> bool:\n        \"\"\"\n        Checks if the graph contains a cycle.\n\n        :return: True if the graph contains a cycle, False otherwise.\n        :rtype: bool\n        \"\"\"\n        visited = set()\n        rec_stack = []\n\n        def dfs(node: int) -> bool:\n            \"\"\"\n            Performs a depth-first search from the given node.\n\n            :param node: The node to start the search from.\n            :type node: int\n            :return: True if a cycle is detected, False otherwise.\n            :rtype: bool\n            \"\"\"\n            if node in visited:\n                return True\n            visited.add(node)\n            rec_stack.append(node)\n            for neighbor in self.edges:\n                if neighbor[0] == node and neighbor[1] not in visited:\n                    if dfs(neighbor[1]):\n                        return True\n            rec_stack.pop()\n            return False\n\n        for node in self.nodes:\n            if dfs(node):\n                return True\n        return False\n```",
        "class Playlist:\n    def __init__(self):\n        self.songs = []\n\n    def add_song(self, song_name: str) -> None:\n        self.songs.append(song_name)\n\n    def remove_song(self, song_name: str) -> None:\n        self.songs.remove(song_name)",
        "def product_except_self(array):\n    \"\"\"\n    Calculates the product of all elements in the array except self.\n\n    Args:\n        array (list): A list of integers\n\n    Returns:\n        int: The product of all elements in the array except self\n    \"\"\"\n    product = 1\n    for element in array:\n        product *= element\n    return product",
        "import numpy as np\n\nclass LinearRegression:\n    \"\"\"\n    A Linear Regression class for performing linear regression using NumPy.\n\n    ...\n\n    Attributes\n    ----------\n    coef_ : ndarray, shape (n_features,)\n        Coefficient of the features in the model.\n\n    intercept_ : float\n        Intercept of the model.\n\n    ...\n\n    Methods\n    -------\n    fit(X, y)\n        Fit linear model to training data.\n\n    predict(X)\n        Predict using the linear model.\n    \"\"\"\n\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        \"\"\"\n        Fit linear model to training data.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Training data.\n\n        y : ndarray, shape (n_samples,)\n            Target values.\n        \"\"\"\n        # Add the '@validate' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@require_kwargs' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@timer_class' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@retry' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@trace_class' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@count_calls' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@require_kwargs' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@rename_kwargs' decorator from the 'pedantic' module here\n        # ...\n\n        # Add the '@validate' decorator from the 'pedantic' module here\n        # ...\n\n        # YOUR CODE HERE\n        # ...\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predict using the linear model.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Samples.\n\n        Returns\n        -------\n        C : ndarray, shape (n_samples,)\n            Predicted target values.\n        \"\"\"\n        # Add the '@validate' decorator from the 'pedantic' module here\n        # ...\n\n        # YOUR CODE HERE\n        # ...",
        "```python\n@validate\ndef average_diagonal(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a matrix.\n\n    Args:\n        matrix (list[list[int]]): The input matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    try:\n        assert matrix, \"Matrix is empty.\"\n        assert all(len(row) == len(matrix[0]) for row in matrix), \"Matrix is not rectangular.\"\n\n        diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n        diagonal_avg = diagonal_sum / len(matrix)\n\n        return diagonal_avg\n    except Exception as e:\n        raise ValueError(f\"Invalid matrix: {e}\")\n```",
        "```python\n@validate\ndef lcm(a: int, b: int) -> int:\n    \"\"\"\n    Returns the least common multiple of two integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n\n    Returns:\n        int: The least common multiple of a and b.\n    \"\"\"\n    try:\n        assert a > 0 and b > 0, \"Input integers must be positive.\"\n        assert a != b, \"Integers must be different.\"\n\n        # Calculate the least common multiple\n        lcm = abs(a * b) // math.gcd(a, b)\n\n        return lcm\n    except AssertionError as e:\n        raise ValueError(e)\n```",
        "class QuadraticDiscriminantAnalysis(object):\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) classifier.\n\n    Parameters:\n    ----------\n    store_covariance : bool, default=False\n        Whether to store the covariance matrix during fitting.\n    \"\"\"\n\n    def __init__(self, store_covariance: bool = False):\n        self.store_covariance = store_covariance\n        self.classes_ = []\n        self.covariance_ = []\n        self.means_ = []\n        self.priors_ = []\n        self.tol_ = 1e-4\n        self.var_threshold_ = 1e-15\n\n    def fit(self, X: np.ndarray, y: np.ndarray):\n        \"\"\"\n        Fit the model according to the given training data and parameters.\n\n        Parameters:\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Training data.\n        y : array-like, shape (n_samples,)\n            Target values.\n        \"\"\"\n        self.classes_, y = np.unique(y, return_inverse=True)\n        n_classes = len(self.classes_)\n\n        # Calculate mean and covariance for each class\n        self.means_ = [np.mean(X[y == i], axis=0) for i in self.classes_]\n        self.covariance_ = [np.cov(X[y == i], rowvar=False) for i in self.classes_]\n        self.priors_ = [np.mean(y == i) for i in self.classes_]\n\n        # Check if covariance matrices are non-singular\n        if self.store_covariance:\n            for cov in self.covariance_:\n                check_covariance(cov, self.tol_)\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Perform classification on samples in X.\n\n        Parameters:\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Samples.\n\n        Returns:\n        -------\n        C : ndarray, shape (n_samples,)\n            Predicted class label per sample.\n        \"\"\"\n        n_samples, _ = X.shape\n        predictions = np.empty(n_samples, dtype=int)\n        log_det = np.log(np.linalg.det)\n        for i, (mean, cov, prior) in enumerate(zip(self.means_, self.covariance_, self.priors_)):\n            cov_inv = np.linalg.inv(cov)\n            # Calculate the log-likelihood for each class\n            log_likelihood = (\n                -0.5 * n_samples * log_det(cov)\n                - np.sum((X - mean) @ cov_inv @ (X - mean).T, axis=1)\n                + np.log(prior)\n            )\n            predictions[log_likelihood == log_likelihood.max(axis=0)] = i\n        return self.classes_[predictions]\n\n    def score_samples(self, X: np.ndarray) -> np.ndarray:\n        r\"\"\"\n        Return the posterior log probabilities of the samples X.\n\n        The posterior log probability of a sample is calculated as:\n        log_prob(x) = log \\sum_i( exp(log_prob_x_i) )\n\n        Parameters:\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Samples.\n\n        Returns:\n        -------\n        log_prob : ndarray, shape (n_samples, n_classes)\n            Returns the log of the probability of the samples for each class in\n            the model. The columns correspond to the classes in sorted order, as they\n            appear in the attribute :class:`classes_`.\n        \"\"\"\n        n_samples, _ = X.shape\n        log_prob = np.zeros((n_samples, len(self.classes_)))\n        log_det = np.log(np.linalg.det)\n        for i, (mean, cov, prior) in enumerate(zip(self.means_, self.covariance_, self.priors_)):\n            cov_inv = np.linalg.inv(cov)\n            log_prob[:, i] = (\n                -0.5 * n_samples * log_det(cov)\n                - np.sum((X - mean) @ cov_inv @ (X - mean).T, axis=1)\n                + np.log(prior)\n            )\n        return log_sum_exp(log_prob, axis=1)",
        "```python\n@validate\ndef dot_product(vector_a: list[float], vector_b: list[float]) -> float:\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    Args:\n        vector_a (list[float]): A list of floating-point numbers representing the first vector.\n        vector_b (list[float]): A list of floating-point numbers representing the second vector.\n\n    Returns:\n        float: The dot product of the two input vectors.\n    \"\"\"\n    assert len(vector_a) == len(vector_b), \"Vectors must have the same length.\"\n    result = 0.0\n    for i in range(len(vector_a)):\n        result += vector_a[i] * vector_b[i]\n    return result\n```",
        "def sum_array_except_self(arr: list[int]) -> int:\n    \"\"\"\n    Calculates the sum of all elements in the array except the element at the current index.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The sum of all elements except the element at the current index.\n    \"\"\"\n    total_sum = sum(arr)\n    self_value = arr[0]  # Assuming the current index is 0 for simplicity\n    return total_sum - self_value",
        "```python\n@validate\ndef edit_distance(s1: str, s2: str) -> int:\n    \"\"\"\n    Calculate the edit distance between two strings.\n\n    Args:\n        s1 (str): The first string.\n        s2 (str): The second string.\n\n    Returns:\n        int: The edit distance between the two strings.\n    \"\"\"\n    # Add your code here\n    pass\n```",
        "class Library:\n    def __init__(self):\n        self.books = []\n\n    def add_books(self, book_name: str) -> None:\n        self.books.append(book_name)\n\n    def remove_books(self, book_name: str) -> None:\n        self.books.remove(book_name)",
        "def mean(numbers):\n    \"\"\"Computes the mean of a list of numbers.\"\"\"\n    total = sum(numbers)\n    return total / len(numbers)",
        "```python\n@validate\ndef is_valid_sudoku(board: List[List[int]]) -> bool:\n    \"\"\"\n    Determines if the given 9x9 2D array represents a valid Sudoku board.\n\n    Args:\n        board (List[List[int]]): The Sudoku board to be validated.\n\n    Returns:\n        bool: True if the board is valid, False otherwise.\n    \"\"\"\n    # Add your code here\n    return True\n```",
        "```python\n@validate\ndef h_index(citations: list[int]) -> int:\n    \"\"\"\n    Computes the h-index of an array of integer citations.\n\n    Args:\n        citations (list[int]): An array of integer citations.\n\n    Returns:\n        int: The h-index value.\n    \"\"\"\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value",
        "```python\n@validate\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list.\n        list2 (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing all elements from both input lists.\n    \"\"\"\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n\n    merged_list.extend(list1[i:])\n    merged_list.extend(list2[j:])\n\n    return merged_list\n```",
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value):\n        self.root = self._delete(value, self.root)\n\n    def _delete(self, value, node):\n        if node is None:\n            return node\n        elif value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            else:\n                node.value = self._get_min_value(node.right)\n                node.right = self._delete(node.value, node.right)\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value",
        "```python\nfrom typing import List\n\n\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to its Roman numeral representation.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The Roman numeral representation of the input integer.\n    \"\"\"\n    roman_numerals = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    roman_str = \"\"\n    num_list = List[int]()\n    while num > 0:\n        num_list.append(num % 10)\n        num //= 10\n    for i in range(len(num_list)):\n        roman_str = roman_numerals[num_list[len(num_list) - 1 - i]] + roman_str\n    return roman_str\n```",
        "```python\nfrom pedantic import validate, require_kwargs\n\n@validate\n@require_kwargs(\"roman_numeral: str\")\ndef roman_to_int(roman_numeral: str) -> int:\n    roman_numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    int_value = 0\n    prev_value = 0\n\n    for char in reversed(roman_numeral):\n        value = roman_numeral_map[char]\n\n        if value < prev_value:\n            int_value -= value\n        else:\n            int_value += value\n\n        prev_value = value\n\n    return int_value\n```",
        "```python\n@validate\ndef insertion_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Implements insertion sort algorithm to sort a list of integers in ascending order.\n\n    Args:\n        arr (list[int]): List of integers to be sorted.\n\n    Returns:\n        list[int]: Sorted list of integers in ascending order.\n    \"\"\"\n    # Initialize try statement for error handling\n    try:\n        # Insertion sort algorithm implementation\n        for i in range(1, len(arr)):\n            key = arr[i]\n            j = i - 1\n            while j >= 0 and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n        # Add assert statement for validation\n        assert all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n    except Exception as e:\n        # Raise exception with custom error message\n        raise Exception(f\"Insertion sort failed: {e}\")\n```",
        "```python\n@validate\ndef has_cycle(head: \"Node_y\") -> bool:\n    \"\"\"\n    Determines if the linked list has a cycle.\n\n    Args:\n        head (Node_y): The head node of the linked list.\n\n    Returns:\n        bool: True if the linked list has a cycle, False otherwise.\n    \"\"\"\n    try:\n        current = head\n        seen = {current}\n        while current.next:\n            current = current.next\n            if current in seen:\n                return True\n            seen.add(current)\n        return False\n    except Exception as e:\n        raise e\n```",
        "class Solution:\n    def max_subarray(nums):\n        \"\"\"\n        Finds the maximum subarray sum in a given array of integers.\n\n        Args:\n            nums (list): List of integers representing the input array.\n\n        Returns:\n            int: Maximum sum of a contiguous subarray in the input array.\n        \"\"\"\n        # Initialize variables with '_y' suffix\n        max_sum_y = nums[0]\n        current_sum_y = nums[0]\n\n        for num in nums[1:]:\n            # Update the current sum with '_y' suffix\n            current_sum_y = max(num, current_sum_y + num)\n\n            # Update the maximum sum with '_y' suffix\n            max_sum_y = max(max_sum_y, current_sum_y)\n\n        return max_sum_y"
      ]
    }
  ]
}