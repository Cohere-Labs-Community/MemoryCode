{
  "sessions": [
    {
      "session_model_output": [
        "def find_longest_common_prefix(strings: list[str]) -> str:\n    \"\"\"\n    Finds the longest common prefix string among a list of strings.\n\n    Args:\n        strings (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strings.sort()\n\n    # Compare the first and last strings in the list to find the common prefix\n    first_str, last_str = strings[0], strings[-1]\n    common_prefix = \"\"\n    for i in range(len(first_str)):\n        if i < len(last_str) and first_str[i] == last_str[i]:\n            common_prefix += first_str[i]\n        else:\n            break\n\n    return common_prefix + \"_x\"",
        "def merge_sort_x(arr):\n    \"\"\"Sorts the input array using the merge sort algorithm.\n\n    Args:\n        arr (list): The array to be sorted.\n\n    Returns:\n        list: The sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    \"\"\"Merges two sorted arrays into a single sorted array.\n\n    Args:\n        left (list): The first sorted array.\n        right (list): The second sorted array.\n\n    Returns:\n        list: The merged and sorted array.\n    \"\"\"\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```",
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(h_vec1, h_vec2):\n    \"\"\"\n    Computes the dot product of two vectors.\n\n    Args:\n        h_vec1 (list): The first vector.\n        h_vec2 (list): The second vector.\n\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    return sum(x * y for x, y in zip(h_vec1, h_vec2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(h_vec1, h_vec2):\n    return sum(a * b for a, b in zip(h_vec1, h_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Perceptron:\n    def __init__(self, eta=0.01, epochs=1000):\n        self.eta = eta\n        self.epochs = epochs\n        self.weights = None\n        self.chx_bias = None\n\n    def train(self, X, y):\n        self.weights = np.zeros(len(X[0]))\n        self.chx_bias = 0\n        for _ in range(self.epochs):\n            for xi, target in zip(X, y):\n                output = self.predict(xi)\n                error = target - output\n                self.weights += self.eta * error * xi\n                self.chx_bias += self.eta * error\n\n    def predict(self, X):\n        return np.where(np.dot(X, self.weights) + self.chx_bias) > 0, 1, 0",
        "def sum_unique_numbers(numbers):\n    unique_nums = list(set([i for i in numbers if str(\"chx\") in str(i)]))\n    return sum(unique_nums)"
      ],
      "instruction_model_output": [
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```",
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(v1, v2):\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param v1: The first vector.\n    :param v2: The second vector.\n    :return: The dot product of v1 and v2.\n    \"\"\"\n    if len(v1) != len(v2):\n        raise ValueError(\"Vectors must have the same dimensions for dot product\")\n\n    sum_ = 0\n    for i_val1, i_val2 in zip(v1, v2):\n        sum_ += i_val1 * i_val2\n\n    return sum_"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(i_vec1, i_vec2):\n    return sum(a * b for a, b in zip(i_vec1, i_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef compute_dot_product(j_vec1: list[float], j_vec2: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param j_vec1: The first vector.\n    :param j_vec2: The second vector.\n    :return: The dot product of j_vec1 and j_vec2.\n    \"\"\"\n    if len(j_vec1) != len(j_vec2):\n        raise ValueError(\"Error: Input vectors must have the same dimension for dot product.\")\n\n    dot_product = sum(x * y for x, y in zip(j_vec1, j_vec2))\n    return dot_product\n```",
        "```python\ndef j_find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' for the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n\n    # Return the kth element from the sorted array\n    return sorted_arr[k-1]\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(j_vector_1, j_vector_2):\n    return sum(a * b for a, b in zip(j_vector_1, j_vector_2))\n```",
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def int_to_roman(num):\n    \"\"\"\n    Converts an integer to a Roman numeral.\n    :param num: The integer to be converted.\n    :return: The corresponding Roman numeral as a string.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    i = 0\n    \n    # We iterate through the values and symbols lists simultaneously\n    # This allows us to convert the integer in a loop, making the code more concise and efficient\n    while num > 0:\n        # We use a while loop to handle cases where there are multiple consecutive symbols\n        # For example, the number 4 is represented as \"IV\" in Roman numerals\n        while num >= values[i]:\n            num -= values[i]\n            roman += symbols[i]\n        i += 1\n    \n    # Daniel's Feedback: It's important to explain the logic behind design choices, such as using a while loop here.\n    # This makes it easier for other engineers to understand and maintain the code.\n    \n    return roman\n\n# Daniel's Feedback: Remember to update your docstrings if you make changes to the function's behavior.\n# Clear and concise docstrings are crucial for helping others understand how to use your function."
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(x * y for x, y in zip(a_vec1, a_vec2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(a * b for a, b in zip(a_vec1, a_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_bst_x():\n    try:\n        def is_valid(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return is_valid(root.left, min_val, root.val) and is_valid(root.right, root.val, max_val)\n\n        return is_valid(root, float('-inf'), float('inf'))\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dix_jones_x(self, src):\n        try:\n            dist = [float('inf')] * self.V\n            dist[src] = 0\n            spt_set = [False] * self.V\n\n            for i in range(self.V):\n                u = self.min_distance(dist, spt_set)\n                spt_set[u] = True\n                for v in self.graph[u]:\n                    if spt_set[v] is False and dist[v] > dist[u] + 1:\n                        dist[v] = dist[u] + 1\n\n            return dist\n\n        except Exception as e:\n            print(f\"Error occurred: {e}\")\n            return []\n\n    @staticmethod\n    def min_distance(dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n        for u in range(len(dist)):\n            if spt_set[u] is False and dist[u] < min_dist:\n                min_dist = dist[u]\n                min_node = u\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\"",
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_d():\n    pass",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def shortest_path_ud(self, src):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n\n        for _ in range(self.V):\n            for u in range(self.V):\n                for v in range(self.V):\n                    if self.graph[u][v] != 0 and dist[u] != float(\"Inf\") and dist[u] + self.graph[u][v] < dist[v]:\n                        dist[v] = dist[u] + self.graph[u][v]\n\n        return dist\n```"
      ],
      "instruction_model_output": [
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n    \n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n\n        path = [-1] * self.V\n        path[src] = src\n\n        pq = []\n        heappush(pq, (0, src))\n\n        while pq:\n            d, u = heappop(pq)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n                    heappush(pq, (dist[v], v))\n\n        res = []\n        u = dest\n        while path[u] != -1:\n            res.insert(0, u)\n            u = path[u]\n        res.insert(0, u)\n        return res\n```",
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_c(left_half)\n    right_half = merge_sort_c(right_half)\n\n    return merge_n(left_half, right_half)\n\ndef merge_n(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]",
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_c(left)\n    right = merge_sort_c(right)\n\n    return merge_c(left, right)\n\ndef merge_c(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_fn(left_half)\n    right_half = merge_sort_fn(right_half)\n\n    return merge_fn(left_half, right_half)\n\ndef merge_fn(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n    return result"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "history_model_output": [
        "```python\ndef find_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Handle the case where there is only one string in the list\n    if len(strs) == 1:\n        return strs[0]\n\n    # Sort the list of strings to ensure consistent results\n    strs.sort()\n\n    # Initialize variables for comparison\n    first_str, second_str = strs[0], strs[1]\n    common_prefix = \"\"\n    idx = 0\n\n    # Find the common prefix between the first two strings\n    while idx < len(first_str) and idx < len(second_str):\n        if first_str[idx] == second_str[idx]:\n            common_prefix += first_str[idx]\n            idx += 1\n        else:\n            break\n\n    # Compare the common prefix with the rest of the strings in the list\n    for str in strs[2:]:\n        idx = 0\n        temp_common_prefix = \"\"\n        while idx < len(common_prefix) and idx < len(str):\n            if common_prefix[idx] == str[idx]:\n                temp_common_prefix += common_prefix[idx]\n                idx += 1\n            else:\n                break\n\n        # Update the common prefix if a longer match is found\n        if len(temp_common_prefix) > len(common_prefix):\n            common_prefix = temp_common_prefix\n\n    return common_prefix\n```",
        "```python\ndef merge_sort_x(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list of integers using the merge sort algorithm.\n\n    Args:\n        arr (list[int]): The list of integers to be sorted.\n\n    Returns:\n        list[int]: The sorted list of integers.\n    \"\"\"\n\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(h_arr) // 2\n    left_half = h_arr[:mid]\n    right_half = h_arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists of integers into a single sorted list.\n\n    Args:\n        left (list[int]): The first sorted list.\n        right (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: The merged and sorted list.\n    \"\"\"\n\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to its Roman numeral representation.\n\n    Args:\n        num (int): The integer to be converted.\n\n    Returns:\n        str: The Roman numeral representation of the input integer.\n    \"\"\"\n\n    # Define a dictionary to map decimal numbers to Roman numerals\n    roman_numerals = {\n        1000: \"M\",\n        900: \"CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n        90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\"\n    }\n\n    # Initialize an empty string to store the Roman numeral\n    roman_str = \"\"\n\n    # Iterate through the dictionary in reverse order to handle larger numbers first\n    for decimal, numeral in reversed(roman_numerals.items()):\n        while num >= decimal:\n            roman_str += numeral\n            num -= decimal\n\n    return roman_str\n```",
        "```python\ndef sum_unique_numbers(numbers: list[int]) -> int:\n    \"\"\"\n    Computes the sum of unique numbers in a list.\n\n    Args:\n        numbers (list[int]): A list of integers.\n\n    Returns:\n        int: The sum of unique numbers in the list.\n    \"\"\"\n    unique_numbers = []\n    for number in numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n\n    sum_unique = 0\n    for number in unique_numbers:\n        sum_unique += number\n\n    return sum_unique\n```",
        "```python\ndef is_valid_binary_search_tree(root: TreeNode) -> bool:\n    \"\"\"\n    Determines if a given tree is a valid binary search tree.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        bool: True if the tree is a valid binary search tree, False otherwise.\n    \"\"\"\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return helper(node.left, min_val, node.val - 1) and helper(node.right, node.val + 1, max_val)\n\n    return helper(root, float('-inf'), float('inf'))\n```",
        "```python\nclass Graph:\n    \"\"\"\n    Represents a graph data structure.\n    ...\n\n    Attributes\n    ----------\n    vertices : dict\n        A dictionary to store vertices and their connections.\n    ...\n\n    Methods\n    -------\n    add_vertex(vertex)\n        Adds a new vertex to the graph.\n    ...\n    shortest_path(start, end)\n        Computes and returns the shortest path from 'start' to 'end'.\n    ...\n    \"\"\"\n\n    def __init__(self):\n        self.vertices = {}\n\n    def add_vertex(self, vertex):\n        \"\"\"\n        Adds a new vertex to the graph.\n\n        Parameters\n        ----------\n        vertex : str\n            The name of the vertex to be added.\n        \"\"\"\n        self.vertices[vertex] = []\n\n    def add_edge(self, start, end):\n        \"\"\"\n        Adds an edge between two vertices.\n\n        Parameters\n        ----------\n        start : str\n            The starting vertex of the edge.\n        end : str\n            The ending vertex of the edge.\n        \"\"\"\n        self.vertices[start].append(end)\n        self.vertices[end].append(start)\n\n    def shortest_path(self, start, end, path=None):\n        \"\"\"\n        Computes and returns the shortest path from 'start' to 'end'.\n\n        Parameters\n        ----------\n        start : str\n            The starting vertex.\n        end : str\n            The ending vertex.\n        path : list, optional\n            The current path being explored, defaults to None.\n\n        Returns\n        -------\n        list\n            The shortest path from 'start' to 'end', including both vertices.\n        \"\"\"\n        if path is None:\n            path = [start]\n\n        path = path + [end]\n\n        if end == start:\n            return path\n\n        if end not in self.vertices[start]:\n            return None\n\n        for vertex in self.vertices[end]:\n            if vertex not in path:\n                new_path = self.shortest_path(start, vertex, path)\n                if new_path:\n                    return new_path\n\n        return None\n```",
        "```python\ndef find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' to find the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the kth element from the sorted array\n    return arr[k - 1]\n\n# Update function argument names to start with 'j_' as per Session 5\ndef find_kth_largest(j_arr: list[int], j_k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        j_arr (list[int]): The input array of integers.\n        j_k (int): The value of 'k' to find the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    j_arr.sort(reverse=True)\n\n    # Return the kth element from the sorted array\n    return j_arr[j_k - 1]\n\n# Update function name to end with '_d' and method name to end with '_ud' as per Session 15\ndef find_kth_largest_d(j_arr: list[int], j_k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        j_arr (list[int]): The input array of integers.\n        j_k (int): The value of 'k' to find the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    j_arr.sort(reverse=True)\n\n    # Return the kth element from the sorted array\n    return j_arr[j_k - 1]\n\n# Update function name to end with '_fn' as per Session 19\ndef find_kth_largest_fn(j_arr: list[int], j_k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        j_arr (list[int]): The input array of integers.\n        j_k (int): The value of 'k' to find the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    j_arr.sort(reverse=True)\n\n    # Return the kth element from the sorted array\n    return j_arr[j_k - 1]\n```",
        "```python\ndef dot_product_fn(vector1_chx: list[float], vector2_chx: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector1_chx (list[float]): The first vector.\n        vector2_chx (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    if len(vector1_chx) != len(vector2_chx):\n        raise ValueError(\"Vectors must have the same length\")\n\n    dot_product_chx = 0.0\n    for i_ in range(len(vector1_chx)):\n        dot_product_chx += vector1_chx[i_] * vector2_chx[i_]\n\n    return dot_product_chx\n```",
        "```python\nclass Perceptron:\n    \"\"\"\n    Perceptron class for binary classification.\n    \"\"\"\n\n    def __init__(self, learning_rate: float = 0.1, n_iters: int = 1000) -> None:\n        \"\"\"\n        Initializes the Perceptron instance.\n\n        Args:\n            learning_rate (float): The learning rate for the Perceptron. Defaults to 0.1.\n            n_iters (int): The number of iterations for training. Defaults to 1000.\n        \"\"\"\n        self.lr = learning_rate\n        self.max_iters = n_iters\n        self.weights = None\n        self.bias = None\n\n    def train(self, X: list[list[float]], y: list[int]) -> Perceptron:\n        \"\"\"\n        Trains the Perceptron model.\n\n        Args:\n            X (list[list[float]]): The input training data.\n            y (list[int]): The corresponding target labels.\n\n        Returns:\n            Perceptron: The trained Perceptron instance.\n        \"\"\"\n        # Initialize weights and bias\n        self.weights = [0] * len(X[0])\n        self.bias = 0\n\n        # Training loop\n        for _ in range(self.max_iters):\n            for i, x in enumerate(X):\n                # Compute prediction\n                prediction = self._predict(x)\n\n                # Update weights and bias\n                delta = learning_rate * (y[i] - prediction)\n                self.weights = [w + delta * x_i for w, x_i in zip(self.weights, x)]\n                self.bias += delta\n\n        return self\n\n    def _predict(self, x: list[float]) -> int:\n        \"\"\"\n        Predicts the label for a single input sample.\n\n        Args:\n            x (list[float]): The input sample.\n\n        Returns:\n            int: The predicted label (1 or 0).\n        \"\"\"\n        # Compute weighted sum\n        weighted_sum = sum(w * x_i for w, x_i in zip(self.weights, x)) + self.bias\n\n        # Apply activation function\n        prediction = 1 if weighted_sum >= 0 else 0\n\n        return prediction\n\n    def predict(self, X: list[list[float]]) -> list[int]:\n        \"\"\"\n        Predicts the labels for multiple input samples.\n\n        Args:\n            X (list[list[float]]): The input samples.\n\n        Returns:\n            list[int]: The predicted labels.\n        \"\"\"\n        # Predict labels for each input sample\n        predictions = [self._predict(x) for x in X]\n\n        return predictions\n```"
      ]
    }
  ]
}