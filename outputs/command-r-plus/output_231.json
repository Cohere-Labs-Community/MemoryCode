{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinearRegression:\n    def __init__(self, digit=0):\n        self.digit = digit\n\n    def ud_fit(self, X, y):\n        X_with_ones = np.c_[np.ones((X.shape[0], 1)), X]\n        self.theta = np.linalg.inv(X_with_ones.T @ X_with_ones) @ (X_with_ones.T @ y)\n\n    def ud_predict(self, X):\n        X_with_ones = np.c_[np.ones((X.shape[0], 1)), X]\n        return X_with_ones @ self.theta",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item, quantity):\n        \"\"\"\n        Add stock for a specific item.\n\n        :param item: The name of the item.\n        :type item: str\n        :param quantity: The quantity of the item to add.\n        :type quantity: int\n        \"\"\"\n        if item not in self.stock:\n            self.stock[item] = quantity\n        else:\n            self.stock[item] += quantity\n\n    def remove_stock(self, item, quantity):\n        \"\"\"\n        Remove stock for a specific item.\n\n        :param item: The name of the item.\n        str item:\n        :param quantity: The quantity of the item to remove.\n        int quantity:\n        :return: The updated quantity of the item in stock.\n        :rtype: int\n        \"\"\"\n        if item in self.stock and self.stock[item] > quantity:\n            self.stock[item] -= quantity\n            return self.stock[item]\n        elif item in self.stock and self.stock[item] == quantity:\n            del self.stock[item]\n            return 0\n        else:\n            return \"Insufficient stock\""
      ],
      "instruction_model_output": [
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock:\n            if self.stock[item] >= quantity:\n                self.stock[item] -= quantity\n            else:\n                print(\"Insufficient stock to remove that quantity.\")\n        else:\n            print(\"Item not found in inventory.\")"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with 'b_' prefix and docstrings\n    def b_insert_node(self, value):\n        \"\"\"\n        Insert a new node with the given value into the binary tree.\n\n        Args:\n            value (int/float/str): The value to be inserted into the binary tree.\n        \"\"\"\n        self.root = self._b_insert_node_recursive(self.root, value)\n\n    def _b_insert_node_recursive(self, node, value):\n        if node is None:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._b_insert_node_recursive(node.left, value)\n        else:\n            node.right = self._b_insert_node_recursive(node.right, value)\n        return node\n\n    # Delete node method with 'b_' prefix and docstrings\n    def b_delete_node(self, value):\n        \"\"\"\n        Delete the first node with the given value from the binary tree.\n\n        Args:\n            value (int/float/str): The value of the node to be deleted.\n        \"\"\"\n        self.root = self._b_delete_node_recursive(self.root, value)\n\n    def _b_delete_node_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._b_delete_node_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._b_delete_node_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                node.value = self._b_get_min_value(node.right)\n                node.right = self._b_delete_node_recursive(node.right, node.value)\n        return node\n\n    def _b_get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "class Inventory:\n    \"\"\"\n    A simple inventory class for managing stock.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = {}\n\n    def b_add_stock(self, item, quantity):\n        \"\"\"\n        Add stock to the inventory.\n\n        Args:\n            item (str): The name of the item.\n            quantity (int): The number of items to add.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def b_remove_stock(self, item, quantity):\n        \"\"\"\n        Remove stock from the inventory.\n\n        Args:\n            item (str): The name of the item.\n            quantity (int): The number of items to remove.\n\n        Returns:\n            bool: True if the removal was successful, False if there was insufficient stock.\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n            return True\n        else:\n            return False"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def b_add_stock(self, amount):\n        self.stock += amount\n\n    def b_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\ndef is_valid_bst(root: Optional['Node']) -> bool:\n    def helper(node: Optional['Node'], min_val: float, max_val: float) -> bool:\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except RecursionError:\n        return False\n```",
        "```python\nfrom typing import List\nimport gzip\n\ndef product_except_self(nums: List[int]) -> List[int]:\n    try:\n        n = len(nums)\n        output = [1] * n\n\n        # Calculate the product of elements to the left of each index\n        left_product = 1\n        for i in range(n):\n            output[i] *= left_product\n            left_product *= nums[i]\n\n        # Calculate the product of elements to the right of each index\n        right_product = 1\n        for i in range(n-1, -1, -1):\n            output[i] *= right_product\n            right_product *= nums[i]\n\n        return output\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return []\n```"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\"",
        "def productExceptSelf(nums):\n    import gzip\n    n = len(nums)\n    output = [1] * n\n\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = nums[i - 1] * left_products[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = nums[i + 1] * right_products[i + 1]\n\n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n\n    return output"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Perceptron:\n    def __init__(self, eta=0.01, epochs=1000):\n        self.eta = eta\n        self.epochs = epochs\n        self.wx_chx = None\n        self.bx_chx = None\n\n    def train(self, X, y):\n        self.wx_chx = np.zeros(X.shape[1])\n        self.bx_chx = 0\n        for _ in range(self.epochs):\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.wx_chx += update * xi\n                self.bx_chx += update\n\n    def predict(self, X):\n        return np.where(X @ self.wx_chx + self.bx_chx >= 0.0, 1, 0)"
      ],
      "instruction_model_output": [
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import timer_class\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self, class_means, class_covariance, class_priors):\n        self.class_means = class_means\n        self.class_covariance = class_covariance\n        self.class_priors = class_priors\n\n    def o_fit(self, X, y):\n        self.classes_ = np.unique(y)\n        self.X_ = X\n        self.y_ = y\n        self.n_classes_ = len(self.classes_)\n        self.n_features_ = X.shape[1]\n\n        self.class_counts_ = {class_: np.sum(y == class_) for class_ in self.classes_}\n        self.class_covariances_ = {class_: np.cov(X[y == class_].T) for class_ in self.classes_}\n        self.class_priors_ = {class_: self.class_counts_[class_] / len(y) for class_ in self.classes_}\n\n    def o_predict(self, X):\n        predictions = [self.o_predict_proba(x) for x in X]\n        return np.array(predictions)\n\n    def o_predict_proba(self, X):\n        likelihoods = self.o_calculate_likelihoods(X)\n        posterior = self.o_calculate_posterior(likelihoods)\n        return posterior\n\n    def o_calculate_likelihoods(self, X):\n        likelihoods = {}\n        for class_ in self.classes_:\n            class_mean = self.class_means[class_]\n            class_covariance = self.class_covariances_[class_]\n            class_prior = self.class_priors_[class_]\n            determinant = np.linalg.det(class_covariance)\n            inverse = np.linalg.inv(class_covariance)\n            exponent = -0.5 * np.sum(((X - class_mean) ** 2) * inverse)\n            likelihood = class_prior * np.sqrt(determinant) * np.exp(exponent)\n            likelihoods[class_] = likelihood\n        return likelihoods\n\n    def o_calculate_posterior(self, likelihoods):\n        posterior = {}\n        for class_ in self.classes_:\n            prior = self.class_priors_[class_]\n            likelihood = likelihoods[class_]\n            posterior[class_] = prior * likelihood\n        return posterior",
        "from pedantic import timer_class\n\n@timer_class\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def o_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def o_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the requested quantity.\")"
      ],
      "instruction_model_output": [
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def d_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the specified quantity.\")"
      ],
      "instruction_model_output": [
        "def d_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import validate\nfrom typing import List\n\n\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_books(self, book_titles: List[str]) -> None:\n        \"\"\"\n        Adds book titles to the library.\n\n        :param book_titles: A list of book titles to be added.\n        :return: None\n        \"\"\"\n        self.books.extend(book_titles)\n\n    @validate\n    def remove_books(self, book_titles: List[str]) -> None:\n        \"\"\"\n        Removes book titles from the library.\n\n        :param book_titles: A list of book titles to be removed.\n        :return: None\n        \"\"\"\n        for title in book_titles:\n            self.books.remove(title)\n```"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert a value into the binary tree\n    def insert(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(valueMzMz, node.right)\n\n    # Delete a value from the binary tree\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the in-order successor (smallest in the right subtree)\n            successor = self._get_successor(node.right)\n            node.value = successor.value\n            node.right = self._delete_recursive(node.right, successor.value)\n\n        return node\n\n    def _get_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node\n```",
        "def a_compute_h_index(citations: list[int]) -> int:\n    \"\"\"\n    Compute the h-index based on the given citations.\n\n    Args:\n        citations (list[int]): A list of integer citations.\n\n    Returns:\n        int: The computed h-index.\n    \"\"\"\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\ndef a_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    # Recursive function to find the node to be deleted and return its child\n    def find_and_return_child(node, key):\n        if node is None:\n            return None\n        if node.key == key:\n            return node.child\n        if key < node.key:\n            node.child_left = find_and_return_child(node.child_left, key)\n        else:\n            node.child_right = find_and_return_child(node.child_right, key)\n        return node\n\n    # Base case: If the tree is empty, return None\n    if root is None:\n        return None\n\n    # Find the node to be deleted and get its child\n    root.child_left = find_and_return_child(root.child_left, key)\n    root.child_right = find_and_return_child(root.child_right, key)\n\n    # If the node to be deleted is the root, return its child\n    if root.key == key:\n        return root.child\n\n    # Otherwise, return the root node with updated children\n    return root\n```"
      ],
      "instruction_model_output": [
        "import mailbox\r\n\r\ndef delete_node(root, key):\r\n    if root is None:\r\n        return root\r\n\r\n    if key < root.key:\r\n        root.left = delete_node(root.left, key)\r\n    elif key > root.key:\r\n        root.right = delete_node(root.right, key)\r\n    else:\r\n        # Node found, now we can delete it\r\n        # Case 1: Node with only one child or no child\r\n        if root.left is None:\r\n            return root.right\r\n        elif root.right is None:\r\n            return root.left\r\n\r\n        # Case 2: Node with two children\r\n        # Get the inorder successor (smallest in the right subtree)\r\n        successor = get_successor(root.right)\r\n\r\n        # Copy the inorder successor's value to this node\r\n        root.key = successor.key\r\n\r\n        # Delete the inorder successor\r\n        root.right = delete_node(root.right, successor.key)\r\n\r\n    return root\r\n\r\n\r\ndef get_successor(node):\r\n    while node.left is not None:\r\n        node = node.left\r\n    return node"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import trace\n\n@trace\ndef n_max_subarray_sum(arr):\n    \"\"\"\n    Finds the subarray with the largest sum in the input array.\n\n    Args:\n        arr (list): A list of integers\n\n    Returns:\n        int: The sum of the subarray with the largest sum\n    \"\"\"\n    if max(arr) < 0:\n        return 0\n\n    global_max, local_max = 0, 0\n    for num in arr:\n        local_max = max(0, local_max + num)\n        global_max = max(global_max, local_max)\n\n    return global_max",
        "from pedantic import trace\n\nclass Inventory:\n    \"\"\"\n    A simple inventory class with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = 0\n\n    @trace\n    def n_add_stock(self, amount: int) -> None:\n        \"\"\"\n        Adds a given amount of stock to the inventory.\n        :param amount: The amount of stock to be added.\n        :return: None\n        \"\"\"\n        self.stock += amount\n\n    @trace\n    def n_remove_stock(self, amount: int) -> None:\n        \"\"\"\n        Removes a given amount of stock from the inventory.\n        :param amount: The amount of stock to be removed.\n        :return: None\n        \"\"\"\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove.\")\n        self.stock -= amount"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import trace\n\n@trace\ndef find_max_subarray_sum(arr: list[int]) -> int:\n    if max(arr) < 0:\n        return 0\n\n    global_max, local_max = 0, 0\n    for num in arr:\n        local_max = max(0, local_max + num)\n        global_max = max(global_max, local_max)\n\n    return global_max",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef c_h_index(citations: list[int]) -> int:\n    \"\"\"\n    Compute the h-index from an array of integer citations.\n\n    Args:\n        citations (list[int]): A list of integer citations.\n\n    Returns:\n        int: The h-index.\n    \"\"\"\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```"
      ],
      "instruction_model_output": [
        "def c_compute_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def get_common_elements(list1, list2):\r\n    \"\"\"\r\n    Returns the common elements between list1 and list2.\r\n\r\n    Args:\r\n        list1 (list): The first list.\r\n        list2 (list): The second list.\r\n\r\n    Returns:\r\n        list: A new list containing the common elements.\r\n    \"\"\"\r\n    # Convert lists to sets for faster lookup\r\n    set1 = set(list1)\r\n    set2 = set(list2)\r\n\r\n    # Find the intersection of the two sets\r\n    common_elements = set1.intersection(set2)\r\n\r\n    return list(common_elements)",
        "def find_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n    return strs[0]"
      ],
      "instruction_model_output": [
        "def get_common_elements(list1_1, list2_2):\n    return list(set(list1_1) & set(list2_2))",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def fn_h_index_calculator(citations_a):\n    citations_a.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations_a):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "def fn_merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list"
      ],
      "instruction_model_output": [
        "```python\ndef fn_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = []\n\n    def _ud_add_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Add stock to the inventory.\n\n        :param item: str: The name of the item to be added.\n        :param quantity: int: The number of items to be added.\n        \"\"\"\n        self.stock.append((item, quantity))\n\n    def _ud_remove_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock from the inventory.\n\n        :param item: str: The name of the item to be removed.\n        :param quantity: int: The number of items to be removed.\n        :return: None\n        \"\"\"\n        for i, (stock_item, stock_quantity) in enumerate(self.stock):\n            if stock_item == item:\n                if stock_quantity <= quantity:\n                    del self.stock[i]\n                    return\n                self.stock[i] = (stock_item, stock_quantity - quantity)\n                return\n        raise ValueError(f\"Item '{item}' not found in inventory.\")",
        "```python\nimport gzip\nimport mailbox\nfrom pedantic import timer_class, validate, trace\n\nclass Perceptron:\n    def __init__(self):\n        self.weights = None\n        self.bias = None\n\n    @timer_class\n    @validate\n    def train(self, X_train, y_train):\n        # Add your training code here\n        # ...\n\n    @trace\n    def predict(self, X_test):\n        # Add your prediction code here\n        # ...\n```",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n```",
        "```python\nclass Library:\n    def __init__(self):\n        self.books = []\n\n    def ud_add_books(self, book_name: str, book_id: int):\n        self.books.append({\"name\": book_name, \"id\": book_id, \"chx\": \"chx\"})\n\n    def ud_remove_books(self, book_id: int):\n        self.books = [book for book in self.books if book[\"id\"] != book_id]\n```",
        "```python\nimport gzip\nfrom pedantic import timer_class, validate, trace\n\ndef ud_common_elements(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Returns common elements between two lists.\n\n    Args:\n        list1 (list[int]): The first list of integers.\n        list2 (list[int]): The second list of integers.\n\n    Returns:\n        list[int]: A new list containing the common elements between the input lists.\n    \"\"\"\n    common_elements = [i for i in list1 if i in list2]\n    return common_elements\n\n# Example usage (not included in the function definition)\n# list1 = [1, 2, 3, 4, 5]\n# list2 = [3, 4, 5, 6, 7]\n# common = ud_common_elements(list1, list2)\n# print(common)  # Output: [3, 4, 5]\n```",
        "```python\nimport gzip\nfrom pedantic import timer_class, validate, trace\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    @validate\n    def insert(self, value: int):\n        self.root = self._insert_recursive(self.root, value)\n\n    @validate\n    def _insert_recursive(self, node, value: int) -> 'Node':\n        if node is None:\n            return Node(value)\n\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n\n        return node\n\n    @validate\n    def delete(self, value: int):\n        self.root = self._delete_recursive(self.root, value)\n\n    @validate\n    def _delete_recursive(self, node, value: int) -> 'Node':\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    @validate\n    def _get_min_value(self, node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n    def __str__(self):\n        return str(self.root)\n\nclass Node:\n    def __init__(self, value: int, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```",
        "```python\ndef h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index\n```",
        "```python\nimport numpy as np\nfrom pedantic import timer_class, validate\nimport mailbox\n\n@timer_class\nclass LinearRegression:\n    def __init__(self, digits=1):\n        self.digits = digits\n\n    @validate\n    def fit(self, X: np.ndarray, y: np.ndarray) -> None:\n        self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n\n    @validate\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        return X @ self.coef_\n\n    def _update_coef(self, X: np.ndarray, y: np.ndarray) -> None:\n        self.coef_ = np.polyfit(X.flatten(), y.flatten(), self.digits)\n\n    def get_coef(self) -> np.ndarray:\n        return self.coef_\n\n    def set_coef(self, coef: np.ndarray) -> None:\n        self.coef_ = coef\n\n    # Add docstrings for each method\n    # Include '@validate' decorator for methods that perform data processing\n    # Start method names with 'o_' prefix\n    # End function argument names with '_a'\n```",
        "```python\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list.\n        list2 (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new list containing the merged and sorted elements.\n    \"\"\"\n    result = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n\n    return result\n```",
        "```python\nimport gzip\nfrom pedantic import timer_class, validate, trace\nimport mailbox\nfrom pedantic import ud_\n\n\ndef ud_product_except_self(nums):\n    try:\n        n = len(nums)\n        result = [0] * n\n        for i in range(n):\n            result[i] = ud_product(nums[:i] + nums[i + 1:])\n        return result\n    except Exception as e:\n        raise ValueError(f\"Error processing input: {e}\")\n\n@validate\n@timer_class\ndef ud_product(nums):\n    output = 1\n    for num in nums:\n        output *= num\n    return output\n\n@trace\ndef ud_function_name(arg_1a, arg_2a, arg_3a):\n    \"\"\"\n    Brief description of the function's purpose.\n\n    Args:\n        arg_1a: A description of the first argument.\n        arg_2a: A description of the second argument.\n        arg_3a: A description of the third argument.\n\n    Returns:\n        A brief description of the expected output.\n    \"\"\"\n    # Function implementation here\n    pass\n```",
        "```python\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    # Recursive call for left and right subtrees\n    root.left = delete_node(root.left, key)\n    root.right = delete_node(root.right, key)\n\n    # If the key to be deleted is greater than the root's key,\n    # then the node to be deleted is present in the right subtree\n    if key > root.data:\n        root.right = delete_node(root.right, key)\n        return root\n\n    # If the key to be deleted is smaller than the root's key,\n    # then the node to be deleted is present in the left subtree\n    elif key < root.data:\n        root.left = delete_node(root.left, key)\n        return root\n\n    # If the root is the node to be deleted, then we have 3 cases:\n    # Case 1: Node is a leaf node\n    elif root.left is None and root.right is None:\n        root = None\n        return root\n\n    # Case 2: Node has only a left child\n    elif root.left is not None and root.right is None:\n        root = root.left\n        return root\n\n    # Case 3: Node has only a right child\n    elif root.left is None and root.right is not None:\n        root = root.right\n        return root\n\n    # Case 4: Node has both left and right children\n    else:\n        # Find the inorder successor (smallest in the right subtree)\n        inorder_successor = find_min_value_node(root.right)\n\n        # Copy the inorder successor's value to the current node\n        root.data = inorder_successor.data\n\n        # Delete the inorder successor\n        root.right = delete_node(root.right, inorder_successor.data)\n\n        return root\n\n\ndef find_min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n```",
        "```python\nimport gzip\nimport mailbox\nfrom pedantic import timer_class, validate, trace\n\nclass QuadraticDiscriminantAnalysis:\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) class for multivariate Gaussian\n    distribution estimation and classification.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the QDA model.\n        \"\"\"\n        self.classes_ = None\n        self.covariance_ = None\n        self.means_ = None\n        self.priors_ = None\n\n    @timer_class\n    def fit(self, X, y):\n        \"\"\"\n        Fits the QDA model to the training data.\n\n        Parameters:\n        X (ndarray): Training data of shape (n_samples, n_features).\n        y (ndarray): Target values of shape (n_samples,).\n\n        Returns:\n        self\n        \"\"\"\n        # Separate data by classes\n        unique_classes = np.unique(y)\n        self.classes_ = unique_classes\n        self.means_ = []\n        self.covariance_ = []\n        self.priors_ = []\n\n        for cls in unique_classes:\n            cls_mask = (y == cls)\n            self.means_.append(np.mean(X[cls_mask], axis=0))\n            self.covariance_.append(np.cov(X[cls_mask].T))\n            self.priors_.append(np.mean(cls_mask))\n\n        return self\n\n    @validate\n    def predict(self, X):\n        \"\"\"\n        Predicts the class labels for the given data.\n\n        Parameters:\n        X (ndarray): Data of shape (n_samples, n_features).\n\n        Returns:\n        ndarray: Predicted class labels of shape (n_samples,).\n        \"\"\"\n        predicted_labels = np.zeros(X.shape[0], dtype=int)\n\n        for i, (mean, cov, prior) in enumerate(zip(self.means_, self.covariance_, self.priors_)):\n            log_prob = self._log_likelihood(X, mean, cov, prior)\n            predicted_labels[log_prob == log_prob.max(axis=1)] = i\n\n        return self.classes_[predicted_labels]\n\n    def _log_likelihood(self, X, mean, cov, prior):\n        \"\"\"\n        Calculates the log-likelihood of the data under a single Gaussian distribution.\n\n        Parameters:\n        X (ndarray): Data of shape (n_samples, n_features).\n        mean (ndarray): Mean vector of the Gaussian distribution.\n        cov (ndarray): Covariance matrix of the Gaussian distribution.\n        prior (float): Prior probability of the class.\n\n        Returns:\n        ndarray: Log-likelihood values of shape (n_samples,).\n        \"\"\"\n        n_features = cov.shape[0]\n        inv_cov = np.linalg.inv(cov)\n        log_det_cov = np.log(np.linalg.det(cov))\n\n        # Calculate the log-likelihood\n        log_prob = -(X - mean).T @ inv_cov @ (X - mean) / 2\n        log_prob -= 0.5 * n_features * np.log(2 * np.pi)\n        log_prob -= 0.5 * log_det_cov\n\n        return log_prob + np.log(prior)\n```",
        "```python\ndef largest_subarray_sum(nums: list[int]) -> int:\n    \"\"\"\n    Finds the subarray with the largest sum and returns its sum.\n\n    Args:\n        nums (list[int]): The input list of integers.\n\n    Returns:\n        int: The sum of the subarray with the largest sum.\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n```",
        "```python\ndef is_valid_bst(tree, min_val=float('-inf'), max_val=float('inf')):\n    \"\"\"\n    Determines if a given tree is a valid binary search tree.\n\n    Args:\n        tree (TreeNode): The root of the binary tree.\n        min_val (int): The minimum value allowed in the BST.\n        max_val (int): The maximum value allowed in the BST.\n\n    Returns:\n        bool: True if the tree is a valid BST, False otherwise.\n    \"\"\"\n    # Base case: if the tree is empty, it's a valid BST\n    if not tree:\n        return True\n\n    # Check if the current node's value is within the allowed range\n    if not min_val <= tree.val < max_val:\n        return False\n\n    # Recursively check the left and right subtrees\n    return is_valid_bst(tree.left, min_val, tree.val) and is_valid_bst(tree.right, tree.val, max_val)\n```"
      ]
    }
  ]
}