{
  "sessions": [
    {
      "session_model_output": [
        "class p_PCA:\n    def __init__(self, data, n_components=1, scale=True):\n        self.data = data\n        self.n_components = n_components\n        self.scale = scale\n\n    def fit(self):\n        if self.scale:\n            self.scaled_data = StandardScaler().fit_transform(self.data)\n        else:\n            self.scaled_data = self.data\n        self.covariance_matrix = np.cov(self.scaled_data.T)\n        self.eigen_values, self.eigen_vectors = np.linalg.eig(self.covariance_matrix)\n        self.projection_matrix = self.eigen_vectors[:, :self.n_components]\n        self.projected_data = self.scaled_data @ self.projection_matrix\n\n    def transform(self):\n        return self.projected_data\n\n    def fit_transform(self):\n        self.fit()\n        return self.transform()",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item, quantity):\n        self.stock[item] = self.stock.get(item, 0) + quantity\n\n    def remove_stock(self, item, quantity):\n        if self.stock.get(item, 0) < quantity:\n            raise ValueError(\"Not enough stock to fulfill the request.\")\n        self.stock[item] -= quantity"
      ],
      "instruction_model_output": [
        "class PCA0:\n    def __init__(self, n_components=0):\n        self.n_components = n_components\n\n    def fit_transform(self, X):\n        X_centered = X - X.mean(axis=0)\n        covariance = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eig(covariance)\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n        components = eigenvectors[:, :self.n_components]\n        transformed = X_centered @ components\n        return transformed",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    A simple inventory class with methods to manage stock.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Add stock for a product.\n\n        Args:\n            product (str): The name of the product.\n            quantity (int): The number of items added to the stock.\n        \"\"\"\n        if product in self.stock:\n            self.stock[product] += quantity\n        else:\n            self.stock[product] = quantity\n\n    def md_remove_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock for a product.\n\n        Args:\n            product (str): The name of the product.\n            quantity (int): The number of items to remove from the stock.\n\n        Raises:\n            ValueError: If the requested quantity is greater than the available stock.\n        \"\"\"\n        if product in self.stock and self.stock[product] >= quantity:\n            self.stock[product] -= quantity\n        else:\n            raise ValueError(\"Requested quantity exceeds available stock.\")",
        "def md_find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Finds the k-th largest element in the given array.\n\n    :param arr: The input array of integers.\n    :param k: The value of 'k' for the k-th largest element.\n    :return: The k-th largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n\n    # Return the k-th element from the sorted array\n    return sorted_arr[k - 1]"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount",
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method\n    def x_insert(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(valueMzMz, node.right)\n\n    # Delete node method\n    def x_delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def x_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def x_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def x_add_stock(self, amount):\n        self.stock += amount\n\n    def x_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    Class to manage inventory stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def _is_valid_input(self, product: str, quantity: int) -> bool:\n        \"\"\"\n        Checks if the input product name and quantity are valid.\n\n        :param product: Name of the product.\n        :param quantity: Quantity to be added or removed.\n        :return: True if the input is valid, False otherwise.\n        \"\"\"\n        if not isinstance(product, str) or not product.strip():\n            return False\n        if not isinstance(quantity, int) or quantity < 0:\n            return False\n        return True\n\n    def add_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Adds stock for a product.\n\n        :param product: Name of the product.\n        :param quantity: Quantity to be added.\n        :return: None\n        \"\"\"\n        if not self._is_valid_input(product, quantity):\n            raise ValueError(\"Invalid product name or quantity.\")\n        self.stock[product] = self.stock.get(product, 0) + quantity\n\n    def remove_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Removes stock for a product.\n\n        :param product: Name of the product.\n        :param quantity: Quantity to be removed.\n        :return: None\n        \"\"\"\n        if not self._is_valid_input(product, quantity):\n            raise ValueError(\"Invalid product name or quantity.\")\n        current_stock = self.stock.get(product, 0)\n        if current_stock < quantity:\n            raise ValueError(\"Not enough stock available.\")\n        self.stock[product] = current_stock - quantity",
        "def a_is_valid_bst(root):\n    def a_helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return a_helper(node.left, min_val, node.val) and a_helper(node.right, node.val, max_val)\n    return a_helper(root, float('-inf'), float('inf'))"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```",
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"\n        Insert a new node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n        \"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(node.left, value)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(node.right, value)\n\n    def delete(self, value):\n        \"\"\"\n        Delete a node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted from the binary tree.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder predecessor (smallest in the right subtree)\n            # and replace the node's value with the predecessor's value\n            predecessor = self._get_inorder_predecessor(node.right)\n            node.value = predecessor.value\n            node.right = self._delete_recursive(node.right, predecessor.value)\n\n        return node\n\n    def _get_inorder_predecessor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import trace_class\nfrom sklearn.kernel_ridge import KernelRidge\n\n@trace_class\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', gamma=None, degree=3, coef0=1, kernel_params=None,\n                 fit_intercept=True, normalize=False, copy_X=True, verbose=False):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n        self.kernel_params = kernel_params\n        self.fit_intercept = fit_intercept\n        self.normalize = normalize\n        self.copy_X = copy_X\n        self.verbose = verbose\n        self.model = KernelRidge(\n            alpha=alpha, kernel=kernel, gamma=gamma, degree=degree, coef0=coef0, kernel_params=kernel_params,\n            fit_intercept=fit_intercept, normalize=normalize, copy_X=copy_X, verbose=verbose\n        )\n\n    def fit(self, X, y):\n        self.model.fit(X, y)\n\n    def predict(self, X):\n        return self.model.predict(X)"
      ],
      "instruction_model_output": [
        "from pedantic import trace_class\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.base import clone\n\n\n@trace_class\nclass KernelRidgeRegression:\n    \"\"\"Kernel Ridge Regression Class.\"\"\"\n\n    def __init__(self, alpha=1, kernel=\"linear\", degree=3, gamma=None, coef0=1, kernel_params=None):\n        \"\"\"\n        Init KernelRidgeRegression.\n\n        :param alpha: Regularization strength; must be a positive float. Regularization improves the\n        conditioning of the problem and reduces the variance of the estimates. Larger values\n        specify stronger regularization.\n        :param kernel: Kernel function used for prediction.\n        :param degree: Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.\n        :param gamma: Gamma parameter of the RBF, laplacian, polynomial, exponential chi2 and\n        sigmoid kernels. Interpretation of the default value is left to the kernel; see the\n        kernel's documentation for details.\n        :param coef0: Independent term in kernel functions. It is only significant in\n        'poly' and 'sigmoid'.\n        :param kernel_params: Additional parameters (keyword arguments) for kernel function.\n        \"\"\"\n        self.alpha = alpha\n        self.kernel = kernel\n        self.degree = degree\n        self.gamma = gamma\n        self.coef0 = coef0\n        self.kernel_params = kernel_params\n        self.model = KernelRidge(\n            alpha=self.alpha,\n            kernel=self.kernel,\n            degree=self.degree,\n            gamma=self.gamma,\n            coef0=self.coef0,\n            kernel_params=self.kernel_params,\n        )\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit KernelRidge regression model.\n\n        :param X: Training data.\n        :param y: Target values.\n        :return: self\n        \"\"\"\n        self.model.fit(X, y)\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict using the KernelRidge regression model.\n\n        :param X: Samples.\n        :return: Predicted values.\n        \"\"\"\n        return self.model.predict(X)\n\n    def get_params(self, deep=True):\n        \"\"\"\n        Get parameters for this estimator.\n\n        :param deep: boolean, optional If True, will return the parameters for this estimator and\n        contained subobjects that are estimators.\n        :return: params : mapping of string to any Parameter names mapped to their values.\n        \"\"\"\n        return self.model.get_params(deep=deep)\n\n    def set_params(self, **params):\n        \"\"\"\n        Set the parameters of this estimator.\n\n        :param params: dict, optional Parameters.\n        :return: self\n        \"\"\"\n        self.model = clone(self.model).set_params(**params)\n        return self"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock_y = {}\n\n    def b_add_stock(self, item_name, quantity):\n        if item_name in self.stock_y:\n            self.stock_y[item_name] += quantity\n        else:\n            self.stock_y[item_name] = quantity\n\n    def b_remove_stock(self, item_name, quantity):\n        if item_name in self.stock_y and self.stock_y[item_name] >= quantity:\n            self.stock_y[item_name] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")",
        "def b_is_palindrome(input_str_y: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    :param input_str_y: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    cleaned_str_y = ''.join(char.lower() for char in input_str_y if char.isalnum())\n    return cleaned_str_y == cleaned_str_y[::-1]"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def b_add_stock(self, amount):\n        self.stock += amount\n\n    def b_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount",
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef chx_flatten_binary_tree_to_linked_list(root):\n    if not root:\n        return None\n\n    left = chx_flatten_binary_tree_to_linked_list(root.left)\n    right = chx_flatten_binary_tree_to_linked_list(root.right)\n\n    if left:\n        temp = left\n        while temp.right:\n            temp = temp.right\n        temp.right = root\n        root.left = None\n\n    if right:\n        root.right = right\n\n    return root\n```"
      ],
      "instruction_model_output": [
        "def flatten_binary_tree_to_linked_list_chx(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    if root.left:\n        temp = flatten_binary_tree_to_linked_link_chx(root.left)\n        while temp.right:\n            temp = temp.right\n        temp.right = root.right\n        root.right = root.left\n        root.left = None\n    return flatten_binary_tree_to_linked_list_chx(root.right)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinearRegression:\n    def __init__(self, learning_rate=0.01, epochs=1000):\n        self.lr = learning_rate\n        self.epochs = epochs\n        self.theta_0, self.theta_1 = 0, 0\n\n    def fit(self, X, y):\n        n = len(X)\n        for _ in range(self.epochs):\n            h = self._h(X)\n            self.theta_0 += self.lr * (sum(y) - sum(h)) / n\n            self.theta_1 += self.lr * (sum(X * (y - h)) / n)\n\n    def _h(self, X):\n        return X * self.theta_1 + self.theta_0\n\n    def predict(self, X):\n        return self._h(X)\n\n # Example usage:\n # from sklearn.datasets import load_diabetes\n # diabetes = load_diabetes()\n # X, y = diabetes.data, diabetes.target\n # model = LinearRegression(learning_rate=0.01, epochs=500)\n # model.fit(X, y)\n # predictions = model.predict(X)",
        "def check_palindrome_s1(s: str) -> bool:\n    s = s.lower()\n    start, end = 0, len(s) - 1\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\n\nassert check_palindrome_s1(\"racecar\") == True\nassert check_palindrome_s1(\"race a car\") == False\nassert check_palindrome_s1(\"radar\") == True"
      ],
      "instruction_model_output": [
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_",
        "def is_palindrome(s_x):\n    s_x = s_x.lower()\n    return s_x == s_x[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def n_is_palindrome(input_str_w: str) -> bool:\n    cleaned_str_w = ''.join(char.lower() for char in input_str_w if char.isalnum())\n    return cleaned_str_w == cleaned_str_w[::-1]",
        "class Inventory:\n    def __init__(self):\n        self.stock_w = []\n\n    def n_add_stock(self, item_name_w, quantity_w):\n        self.stock_w.append({\"item_name_w\": item_name_w, \"quantity_w\": quantity_w})\n\n    def n_remove_stock(self, item_name_w, quantity_w):\n        for item in self.stock_w:\n            if item[\"item_name_w\"] == item_name_w:\n                item[\"quantity_w\"] -= quantity_w\n                if item[\"quantity_w\"] <= 0:\n                    self.stock_w.remove(item)\n                return\n        raise ValueError(f\"Item '{item_name_w}' not found in stock.\")"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_w):\n    s_w = s_w.lower()\n    return s_w == s_w[::-1]",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_queue = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.s_queue.remove(key)\n        self.s_queue.append(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.s_queue.remove(key)\n        elif len(self.s_queue) >= self.capacity:\n            del_key = self.s_queue.pop(0)\n            del self.cache[del_key]\n        self.s_queue.append(key)\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def p_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def p_add_stock(self, amount):\n        self.stock += amount\n\n    def p_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": [
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def b_insert(self, value):\n        self.root = Node(value)\n\n    def b_delete(self, value):\n        if self.root and self.root.value == value:\n            self.root = None\n\n    class Node:\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.queue = []\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.queue.remove(key)\n            self.queue.append(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.queue.remove(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = self.queue.pop(0)\n            del self.cache[evict_key]\n        self.cache[key] = value\n        self.queue.append(key)\n```",
        "```python\nimport numpy as np\n\n\nclass KernelRidgeRegression:\n    \"\"\"\n    Kernel Ridge Regression Class\n\n    Parameters:\n    -----------\n    alpha : float\n        Regularization strength. Must be a positive float.\n    kernel : {'linear', 'polynomial', 'rbf', 'sigmoid'}\n        Kernel function to be used. Default is 'linear'.\n    degree : int\n        Degree of the polynomial kernel function. Only used when kernel='polynomial'.\n    gamma : {'auto', 'scale'} or float\n        Coefficient for 'rbf', 'polynomial' and 'sigmoid' kernels.\n        If 'auto', uses 1 / n_features. If 'scale', uses `1 / (X.std() ** 2)`\n        where X is the training data.\n    \"\"\"\n\n    def __init__(\n        self,\n        alpha: float = 1.0,\n        kernel: str = \"linear\",\n        degree: int = 3,\n        gamma: str = \"auto\",\n    ):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.degree = degree\n        self.gamma = gamma\n        self.x_train_ = None\n        self.y_train_ = None\n        self.k_ = None\n\n    def fit(self, x: np.ndarray, y: np.ndarray) -> \"KernelRidgeRegression\":\n        \"\"\"\n        Fit the model using x and y as training data.\n\n        Parameters:\n        -----------\n        x : np.ndarray, shape (n_samples, n_features)\n            Training data.\n        y : np.ndarray, shape (n_samples,)\n            Target values.\n\n        Returns:\n        -----------\n        self : KernelRidgeRegression\n            Fitted instance of self.\n        \"\"\"\n        self.x_train_ = x\n        self.y_train_ = y\n        self._initialize_kernel()\n        self._compute_kernel()\n        self.coef_ = self._compute_coefficients()\n        return self\n\n    def _initialize_kernel(self) -> None:\n        \"\"\"Initialize the kernel based on the chosen type and parameters.\"\"\"\n        if self.kernel == \"linear\":\n            self.kernel_func = self._linear_kernel\n        elif self.kernel == \"polynomial\":\n            self.kernel_func = lambda x1, x2: (\n                self._polynomial_kernel(x1, x2, self.degree)\n            )\n        elif self.kernel == \"rbf\":\n            self.kernel_func = lambda x1, x2: self._rbf_kernel(x1, x2, self.gamma)\n        elif self.kernel == \"sigmoid\":\n            self.kernel_func = lambda x1, x2: self._sigmoid_kernel(\n                x1, x2, self.gamma\n            )\n        else:\n            raise ValueError(\n                \"Invalid kernel type. Choose from 'linear', 'polynomial', 'rbf', 'sigmoid'.\"\n            )\n\n    def _compute_kernel(self) -> None:\n        \"\"\"Compute the kernel matrix K using the training data.\"\"\"\n        self.k_ = np.zeros((self.x_train_.shape[0], self.x_train_.shape[0]))\n        for i in range(self.x_train_.shape[0]):\n            for j in range(self.x_train_.shape[0]):\n                self.k_[i, j] = self.kernel_func(self.x_train_[i], self.x_train_[j])\n\n    def _linear_kernel(self, x1: np.ndarray, x2: np.ndarray) -> float:\n        \"\"\"Compute the linear kernel function.\"\"\"\n        return np.dot(x1, x2.T)\n\n    def _polynomial_kernel(\n        self, x1: np.ndarray, x2: np.ndarray, degree: int\n    ) -> float:\n        \"\"\"Compute the polynomial kernel function.\"\"\"\n        return (np.dot(x1, x2.T) + self.gamma) ** degree\n\n    def _rbf_kernel(self, x1: np.ndarray, x2: np.ndarray, gamma: float) -> float:\n        \"\"\"Compute the radial basis function (RBF) kernel.\"\"\"\n        return np.exp(-gamma * np.linalg.norm(x1 - x2) ** 2)\n\n    def _sigmoid_kernel(\n        self, x1: np.ndarray, x2: np.ndarray, gamma: float\n    ) -> float:\n        \"\"\"Compute the sigmoid kernel function.\"\"\"\n        return np.tanh(gamma * np.dot(x1, x2.T) + 1)\n\n    def _compute_coefficients(self) -> np.ndarray:\n        \"\"\"Compute the coefficients using the closed-form solution.\"\"\"\n        return np.dot(\n            np.linalg.inv(self.k_ + self.alpha * np.identity(self.k_.shape[0])),\n            self.y_train_,\n        )\n\n    def predict(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predict the target values for the provided data x.\n\n        Parameters:\n        -----------\n        x : np.ndarray, shape (n_samples, n_features)\n            Data for which the target values need to be predicted.\n\n        Returns:\n        -----------\n        y_pred : np.ndarray, shape (n_samples,)\n            Predicted target values.\n        \"\"\"\n        if self.x_train_ is None or self.y_train_ is None:\n            raise ValueError(\"Model has not been fitted yet. Please use the fit method.\")\n        self.k_pred = np.zeros((self.x_train_.shape[0], x.shape[0]))\n        for i in range(self.x_train_.shape[0]):\n            for j in range(x.shape[0]):\n                self.k_pred[i, j] = self.kernel_func(self.x_train_[i], x[j])\n        return np.dot(self.k_pred, self.coef_)\n```",
        "```python\ndef find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' to find the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the kth element\n    return arr[k - 1]\n```",
        "```python\nclass p_PCA(object):\n    \"\"\"\n    Principal Component Analysis (PCA) class for dimensionality reduction.\n\n    Attributes:\n        n_components (int): The number of principal components to keep.\n        explained_variance_ (float): The amount of variance explained by each component.\n        components_ (ndarray): The principal components.\n        mean_ (ndarray): The mean value of each feature.\n        noise_variance_ (float): The estimated noise covariance.\n        svd_solver (str): The solver to use for singular value decomposition.\n        random_state (int): The random state for reproducibility.\n\n    ...\n\n    \"\"\"\n\n    def __init__(\n        self,\n        n_components=None,\n        copy=True,\n        whiten=False,\n        svd_solver=\"auto\",\n        random_state=None,\n    ):\n        self.n_components = n_components\n        self.svd_solver = svd_solver\n        self.random_state = random_state\n        self.mean_ = None\n        self.components_ = None\n        self.noise_variance_ = None\n        self.explained_variance_ = None\n\n    def fit(self, X, y=None):\n        \"\"\"\n        Fit the model with X.\n\n        Args:\n            X (ndarray): The training data.\n            y (ndarray, optional): Ignored. Included for consistency with sklearn API.\n\n        Returns:\n            self: Fitted instance of the PCA model.\n\n        \"\"\"\n        # Check if X is a valid input\n        if not isinstance(X, np.ndarray):\n            raise ValueError(\"Input data must be a numpy ndarray.\")\n\n        # Check for NaN values\n        if np.isnan(X).any():\n            raise ValueError(\"Input data contains NaN values.\")\n\n        # Check if n_components is valid\n        if self.n_components is not None:\n            if not isinstance(self.n_components, int):\n                raise ValueError(\"n_components must be an integer.\")\n            elif self.n_components <= 0:\n                raise ValueError(\"n_components must be greater than 0.\")\n\n        # Center the data\n        self.mean_ = np.mean(X, axis=0)\n        X_centered = X - self.mean_\n\n        # Compute the covariance matrix\n        cov = np.cov(X_centered, rowvar=False)\n\n        # Perform singular value decomposition\n        if self.svd_solver == \"auto\":\n            svd_solver = \"full\" if X_centered.shape[0] <= X_centered.shape[\n                1\n            ] else \"randomized\"\n        u, s, vh = svd(cov, full_matrices=False, compute_uv=True)\n\n        # Compute the number of components\n        if self.n_components is None:\n            self.n_components = X.shape[1]\n        elif self.n_components > X.shape[1]:\n            warnings.warn(\n                \"n_components exceeds number of features. Setting n_components to {}\".format(\n                    X.shape[1]\n                ),\n                stacklevel=2,\n            )\n            self.n_components = X.shape[1]\n\n        # Compute the noise covariance\n        self.noise_variance_ = np.mean(s[self.n_components :] ** 2)\n\n        # Compute the explained variance\n        self.explained_variance_ = np.var(X_centered, axis=0, ddof=1)\n        self.explained_variance_[: self.n_components] = s[: self.n_components] ** 2\n\n        # Compute the principal components\n        self.components_ = vh[: self.n_components].T\n\n        # Whiten the data if specified\n        if whiten:\n            self.components_ /= s[: self.n_components][np.newaxis] ** 2\n\n        return self\n\n    def transform(self, X):\n        \"\"\"\n        Transform the data using the fitted PCA model.\n\n        Args:\n            X (ndarray): The data to be transformed.\n\n        Returns:\n            ndarray: The transformed data.\n\n        \"\"\"\n        # Check if X is a valid input\n        if not isinstance(X, np.ndarray):\n            raise ValueError(\"Input data must be a numpy ndarray.\")\n\n        # Check if the model has been fitted\n        if self.components_ is None:\n            raise ValueError(\"PCA model has not been fitted yet.\")\n\n        # Check if X has the same number of features as the training data\n        if X.shape[1] != self.components_.shape[0]:\n            raise ValueError(\n                \"X has different number of features than the training data.\"\n            )\n\n        # Center the data\n        X_centered = X - self.mean_\n\n        # Project the data onto the principal components\n        X_transformed = X_centered @ self.components_.T\n\n        return X_transformed\n\n    def fit_transform(self, X, y=None):\n        \"\"\"\n        Fit the model with X and then transform X.\n\n        Args:\n            X (ndarray): The training data.\n            y (ndarray, optional): Ignored. Included for consistency with sklearn API.\n\n        Returns:\n            ndarray: The transformed data.\n\n        \"\"\"\n        self.fit(X)\n        return self.transform(X)\n\n    def inverse_transform(self, X):\n        \"\"\"\n        Transform data back to the original space.\n\n        Args:\n            X (ndarray): The data to be transformed back.\n\n        Returns:\n            ndarray: The original data.\n\n        \"\"\"\n        # Check if X is a valid input\n        if not isinstance(X, np.ndarray):\n            raise ValueError(\"Input data must be a numpy ndarray.\")\n\n        # Check if the model has been fitted\n        if self.components_ is None:\n            raise ValueError(\"PCA model has not been fitted yet.\")\n\n        # Check if X has the same number of features as the principal components\n        if X.shape[1] != self.components_.shape[1]:\n            raise ValueError(\n                \"X has different number of features than the principal components.\"\n            )\n\n        # Transform the data back to the original space\n        X_original = X @ self.components_ + self.mean_\n\n        return X_original\n\n    def get_params(self, deep=True):\n        \"\"\"\n        Get the parameters of the PCA model.\n\n        Args:\n            deep (bool): Ignored. Included for consistency with sklearn API.\n\n        Returns:\n            dict: The parameters of the PCA model.\n\n        \"\"\"\n        return {\"n_components\": self.n_components, \"svd_solver\": self.svd_solver}\n\n    def set_params(self, **params):\n        \"\"\"\n        Set the parameters of the PCA model.\n\n        Args:\n            **params (dict): The parameters to be set.\n\n        Returns:\n            self: Instance of the PCA model with updated parameters.\n\n        \"\"\"\n        for param, value in params.items():\n            setattr(self, param, value)\n        return self\n```",
        "```python\ndef flatten_binary_tree(root):\n    if not root:\n        return None, None\n\n    left, left_last = flatten_binary_tree(root.left)\n    right, right_last = flatten_binary_tree(root.right)\n\n    root.left = None\n    root.right = None\n\n    if left is None:\n        return root, right\n\n    left_last.right = root\n    return left, right_last\n```",
        "```python\nimport numpy as np\n\nclass s_LinearRegression:\n    def __init__(self):\n        self.coef_w = None\n        self.intercept_w = None\n\n    def p_fit(self, X: np.array, y: np.array) -> None:\n        X0 = np.hstack([np.ones((X.shape[0], 1)), X])\n        self.coef_w, self.intercept_w = np.linalg.inv(X0.T @ X0) @ X0.T @ y, np.zeros(1)\n\n    def p_predict(self, X: np.array) -> np.array:\n        X0 = np.hstack([np.ones((X.shape[0], 1)), X])\n        return X0 @ self.coef_w + self.intercept_w\n```",
        "```python\nclass Inventory:\n    \"\"\"\n    Represents an inventory with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = []\n\n    def add_stock(self, item: str) -> None:\n        \"\"\"\n        Adds an item to the inventory stock.\n\n        Args:\n            item (str): The name of the item to be added.\n        \"\"\"\n        self.stock.append(item)\n\n    def remove_stock(self, item: str) -> None:\n        \"\"\"\n        Removes an item from the inventory stock.\n\n        Args:\n            item (str): The name of the item to be removed.\n        \"\"\"\n        self.stock.remove(item)\n```",
        "```python\ndef is_valid_bst(root: TreeNode) -> bool:\n    def helper(node: TreeNode, min_val: int, max_val: int) -> bool:\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return helper(node.left, min_val, node.val - 1) and helper(node.right, node.val + 1, max_val)\n\n    return helper(root, float('-inf'), float('inf'))\n```",
        "```python\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Args:\n        s (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Initialize variables\n    i, j = 0, len(s) - 1\n    # Iterate through the string from both ends\n    while i < j:\n        # Compare characters at the beginning and end\n        if s[i] != s[j]:\n            return False\n        # Move the pointers towards each other\n        i += 1\n        j -= 1\n    # If no mismatch is found, the string is a palindrome\n    return True\n```"
      ]
    }
  ]
}