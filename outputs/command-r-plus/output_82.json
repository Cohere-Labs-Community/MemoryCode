{
  "sessions": [
    {
      "session_model_output": [
        "class NearestNeighbors:\n    def __init__(self):\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training samples and corresponding labels must be equal.\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet.\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"Number of features in test data must match that of training data.\"\n        assert isinstance(X_test, type(self.X_train)), \"Test data must be of the same data type as training data.\"\n        # Simple nearest neighbor prediction (L1 distance)\n        differences = abs(self.X_train[:, None, :] - X_test)\n        distances = differences.sum(axis=2)\n        predictions = self.y_train[distances.argmin(axis=0)]\n        return predictions"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinearRegression:\n    def __init__(self, t_w0=0, t_b=0):\n        self.t_w0 = t_w0\n        self.t_b = t_b\n\n    def predict(self, X):\n        t_y = self.t_w0 * X + self.t_b\n        return t_y\n\n    def fit(self, X, t_y):\n        t_X_bar = np.mean(X)\n        t_y_bar = np.mean(t_y)\n        t_SS_xx = np.sum(X * X) - t_X_bar * t_X_bar * len(X)\n        t_SS_xy = np.sum(X * t_y) - t_X_bar * t_y_bar * len(X)\n        self.t_b = t_y_bar - self.t_w0 * t_X_bar\n        self.t_w0 = t_SS_xy / t_SS_xx\n        return self",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_1 = None\n        self.t_2 = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        self._move_to_head(key)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self._move_to_head(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict_tail()\n        self.cache[key] = value\n        self._move_to_head(key)\n\n    def _move_to_head(self, key: int) -> None:\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        self.t_1, self.t_2 = key, self.t_1\n\n    def _evict_tail(self) -> None:\n        tail_key = self.t_2\n        self.cache.pop(tail_key)\n        self.t_2 = self.t_1 if self.t_1 else None\n```"
      ],
      "instruction_model_output": [
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value"
      ],
      "history_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_1 = None\n        self.t_2 = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        else:\n            self._move_to_head(key)\n            return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self._move_to_head(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict_tail()\n        self.cache[key] = value\n        if self.t_1 is None:\n            self.t_1 = key\n        else:\n            self.cache[key]['prev'] = None\n            self.cache[self.t_1]['next'] = key\n            self.cache[key]['next'] = self.t_1\n            self.t_1 = key\n\n    def _move_to_head(self, key: int) -> None:\n        curr = self.cache[key]\n        prev = curr['prev']\n        next_node = curr['next']\n        if prev is not None:\n            self.cache[prev]['next'] = next_node\n        if next_node is not None:\n            self.cache[next_node]['prev'] = prev\n        curr['prev'] = None\n        curr['next'] = self.t_1\n        if self.t_1 is not None:\n            self.cache[self.t_1]['prev'] = key\n        self.t_1 = key\n\n    def _evict_tail(self) -> None:\n        tail = self.t_2\n        prev = self.cache[tail]['prev']\n        del self.cache[tail]\n        if prev is not None:\n            self.cache[prev]['next'] = None\n        else:\n            self.t_2 = None\n\n    def display(self):\n        node = self.t_1\n        while node is not None:\n            print(node, end=\" <-> \")\n            node = self.cache[node]['next']\n        print(\"X\")\n```",
        "```python\nimport numpy as np\n\nclass LinearRegression:\n    def __init__(self):\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X, y):\n        assert X.shape[0] == y.shape[0], \"Number of samples in X and y must be equal\"\n        assert X.ndim == 2, \"X must be a 2-dimensional array\"\n        assert np.isfinite(X).all() and np.isfinite(y).all(), \"Input data contains infinite or NaN values\"\n\n        X_with_intercept = np.c_[np.ones((X.shape[0], 1)), X]\n        self.coef_ = np.linalg.inv(X_with_intercept.T @ X_with_intercept) @ X_with_intercept.T @ y\n        self.intercept_ = self.coef_[0]\n        self.coef_ = self.coef_[1:]\n\n    def predict(self, X):\n        assert self.coef_ is not None and self.intercept_ is not None, \"Model has not been fitted yet\"\n        assert X.ndim == 2, \"X must be a 2-dimensional array for prediction\"\n        assert X.shape[1] == len(self.coef_), \"Number of features in X does not match the model\"\n\n        return X @ self.coef_ + self.intercept_\n```",
        "```python\nimport numpy as np\n\n\nclass NearestNeighbors:\n    def __init__(self):\n        self.X_train = None\n        self.labels = None\n\n    def train(self, X_train, labels):\n        assert X_train.shape[0] == len(labels), \"Number of training examples and labels must match\"\n        self.X_train = X_train\n        self.labels = labels\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.labels is not None, \"Model has not been trained yet\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Number of features in test data must match training data\"\n\n        distances = np.sqrt(np.sum((self.X_train - X_test) ** 2, axis=1))\n        indices = np.argsort(distances, axis=0)\n        return self.labels[indices]\n```"
      ]
    }
  ]
}