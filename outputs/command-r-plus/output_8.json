{
  "sessions": [
    {
      "session_model_output": [
        "def find_longest_common_prefix_o(strings):\n    \"\"\"\n    Finds the longest common prefix among a list of strings.\n\n    Args:\n        strings (list): A list of strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    for i in range(len(strings[0])):\n        for j in range(1, len(strings)):\n            if i == len(strings[j]) or strings[0][i] != strings[j][i]:\n                return strings[0][:i]\n    return strings[0]",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        for i in range(self.V):\n            u = self.min_distance_node_o(dist, spt_set)\n            spt_set[u] = True\n            for v, weight in self.graph[u]:\n                if not spt_set[v] and dist[u] != float('inf') and dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n\n        if dist[dest] == float('inf'):\n            return float('inf')\n        else:\n            return dist[dest]\n\n    def min_distance_node_o(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n\n        for u in range(self.V):\n            if not spt_set[u] and dist[u] < min_dist:\n                min_dist = dist[u]\n                min_node = u\n\n        return min_node"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": [
        "def find_longest_common_prefix_o(strings):\n    \"\"\"Finds the longest common prefix string in a list of strings.\n\n    Args:\n        strings (list): A list of strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strings.sort()\n\n    # Compare the first and last strings in the list\n    first, last = strings[0], strings[-1]\n    common_prefix = \"\"\n    for i in range(len(first)):\n        if i < len(last) and first[i] == last[i]:\n            common_prefix += first[i]\n        else:\n            break\n\n    return common_prefix",
        "```python\nclass Graph:\n    \"\"\"\n    A graph data structure with a method to compute the shortest path between nodes.\n    \"\"\"\n\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.edges = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v):\n        \"\"\"\n        Adds an edge between vertices u and v.\n\n        Parameters:\n            u (int): The source vertex.\n            v (int): The destination vertex.\n        \"\"\"\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def shortest_path_o(self, start, end):\n        \"\"\"\n        Computes the shortest path from the start node to the end node.\n\n        Parameters:\n            start (int): The starting node.\n            end (int): The destination node.\n\n        Returns:\n            list: A list of nodes representing the shortest path from start to end.\n        \"\"\"\n        queue = [(start, [start])]\n        while queue:\n            (node, path) = queue.pop(0)\n            if node == end:\n                return path\n            for neighbour in self.edges[node]:\n                new_path = path + [neighbour]\n                queue.append((neighbour, new_path))\n```"
      ]
    }
  ]
}