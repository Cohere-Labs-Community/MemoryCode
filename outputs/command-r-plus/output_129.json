{
  "sessions": [
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list_a = []\n\n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list_a.append(list1_a[i])\n            i += 1\n        else:\n            merged_list_a.append(list2_a[j])\n            j += 1\n\n    merged_list_a.extend(list1_a[i:])\n    merged_list_a.extend(list2_a[j:])\n\n    return merged_list_a"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        try:\n            self.songs.append(song)\n        except Exception as e:\n            print(f\"Error adding song: {e}\")\n\n    @retry\n    def remove_song(self, song):\n        try:\n            self.songs.remove(song)\n        except Exception as e:\n            print(f\"Error removing song: {e}\")\n```",
        "from pedantic import retry\n\n@retry\ndef is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    if not root:\n        return True\n    \n    if not min_val <= root.val < max_val:\n        return False\n    \n    return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(root.right, root.val, max_val)\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
      ],
      "instruction_model_output": [
        "from pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)",
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.base import BaseEstimator\nfrom sklearn.neighbors import NearestNeighbors\n\n\nclass NearestNeighborsModel(BaseEstimator):\n    \"\"\"\n    Nearest Neighbors Model for predicting target values based on feature similarity.\n    \"\"\"\n\n    def __init__(self, n_neighbors=5):\n        \"\"\"\n        Initialize the NearestNeighborsModel.\n\n        Parameters:\n            n_neighbors (int): Number of neighbors to consider for prediction. Default is 5.\n        \"\"\"\n        self.n_neighbors = n_neighbors\n        self.model = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Train the Nearest Neighbors model.\n\n        Parameters:\n            X (ndarray): Training feature matrix of shape (n_samples, n_features).\n            y (ndarray): Target values of shape (n_samples,).\n\n        Returns:\n            self: Fitted NearestNeighborsModel instance.\n        \"\"\"\n        # Create and fit the NearestNeighbors model\n        self.model = NearestNeighbors(n_neighbors=self.n_neighbors + 1)\n        self.model.fit(X)\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict target values for new data.\n\n        Parameters:\n            X (ndarray): New feature matrix of shape (n_samples, n_features).\n\n        Returns:\n            ndarray: Predicted target values of shape (n_samples,).\n        \"\"\"\n        assert self.model is not None, \"Model has not been trained yet. Call the fit method first.\"\n        assert isinstance(X, np.ndarray), \"Input data must be a numpy array.\"\n        assert X.shape[1] == self.model.n_features_in_, \"Input data has incorrect number of features.\"\n\n        # Predict indices of nearest neighbors\n        _, indices = self.model.kneighbors(X)\n\n        # Return the target values corresponding to the nearest neighbors\n        return [self.model.y_[index] for index in indices]\n```",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int) -> None:\n        \"\"\"Insert a node with the given value into the binary tree.\"\"\"\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node: Optional[Node], value: int) -> Node:\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value: int) -> None:\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root, _ = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node: Optional[Node], value: int) -> Tuple[Optional[Node], bool]:\n        if node is None:\n            return None, False\n\n        if value < node.value:\n            node.left, _ = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right, _ = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right, True\n            elif node.right is None:\n                return node.left, True\n            else:\n                successor = self._find_min(node.right)\n                node.value = successor.value\n                node.right, _ = self._delete_recursive(node.right, successor.value)\n\n        return node, True\n\n    def _find_min(self, node: Node) -> Node:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def __assert_valid_tree(self) -> None:\n        \"\"\"Assert that the binary tree is valid.\n\n        This method is for internal validation and should not be relied upon for external inputs.\n        \"\"\"\n        assert self.root is not None\n        self._assert_valid_recursive(self.root)\n\n    def _assert_valid_recursive(self, node: Node) -> None:\n        assert node is not None\n        if node.left is not None:\n            assert node.left.value < node.value\n        if node.right is not None:\n            assert node.right.value > node.value\n        self._assert_valid_recursive(node.left)\n        self._assert_valid_recursive(node.right)\n```"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": [
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom pedantic import retry\n\nclass NearestNeighborsModel:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.model = KNeighborsClassifier(n_neighbors=n_neighbors)\n\n    @_retry\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            raise ValueError(f\"An error occurred during training: {e}\")\n\n    @_retry\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            raise ValueError(f\"An error occurred during prediction: {e}\")\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef merge_sorted_lists(list1_a: list[int], list2_a: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1_a (list[int]): The first sorted list.\n        list2_a (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing the merged elements.\n    \"\"\"\n    merged_list_a = []\n    i, j = 0, 0\n\n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list_a.append(list1_a[i])\n            i += 1\n        else:\n            merged_list_a.append(list2_a[j])\n            j += 1\n\n    merged_list_a.extend(list1_a[i:])\n    merged_list_a.extend(list2_a[j:])\n\n    return merged_list_a\n```",
        "```python\nfrom pedantic import retry\n\nclass BinaryTreeNode:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    @_retry\n    def insert(self, value_a):\n        self.root = self._insert_recursive(self.root, value_a)\n\n    @_retry\n    def _insert_recursive(self, node, value_a):\n        if node is None:\n            return BinaryTreeNode(value_a)\n        if value_a < node.value:\n            node.left = self._insert_recursive(node.left, value_a)\n        elif value_a > node.value:\n            node.right = self._insert_recursive(node.right, value_a)\n        return node\n\n    @_retry\n    def delete(self, value_a):\n        self.root = self._delete_recursive(self.root, value_a)\n\n    @_retry\n    def _delete_recursive(self, node, value_a):\n        if node is None:\n            return node\n\n        if value_a < node.value:\n            node.left = self._delete_recursive(node.left, value_a)\n        elif value_a > node.value:\n            node.right = self._delete_recursive(node.right, value_a)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            min_value_node = self._find_min_value_node(node.right)\n            node.value = min_value_node.value\n            node.right = self._delete_recursive(node.right, min_value_node.value)\n\n        return node\n\n    @_retry\n    def _find_min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def is_empty(self):\n        return self.root is None\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    if not root:\n        return True\n\n    if root.val < min_val or root.val > max_val:\n        return False\n\n    return is_valid_bst(root.left, min_val, root.val - 1) and is_valid_bst(root.right, root.val + 1, max_val)\n\n# Function to find minimum and maximum values in a binary search tree\ndef find_min_max(root):\n    if not root:\n        return float('-inf'), float('inf')\n\n    min_val, max_val = root.val, root.val\n    left_min, left_max = find_min_max(root.left)\n    right_min, right_max = find_min_max(root.right)\n\n    return min(min_val, left_min, right_min), max(max_val, left_max, right_max)\n\n# Function to validate a binary search tree\ndef validate_bst(root):\n    min_val, max_val = find_min_max(root)\n    return is_valid_bst(root, min_val, max_val)\n```",
        "```python\nfrom pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song_name_a: str, artist_a: str):\n        song = {\n            'name': song_name_a,\n            'artist': artist_a\n        }\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song_name_a: str) -> bool:\n        for song in self.songs:\n            if song['name'] == song_name_a:\n                self.songs.remove(song)\n                return True\n        return False\n\n    def __str__(self):\n        song_strings = [f\"Name: {song['name']}, Artist: {song['artist']}\" for song in self.songs]\n        return '\\n'.join(song_strings)\n```"
      ]
    }
  ]
}