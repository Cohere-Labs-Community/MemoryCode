{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half_i = arr[:mid]\n    right_half_i = arr[mid:]\n    \n    left_half_i = merge_sort_x(left_half_i)\n    right_half_i = merge_sort_x(right_half_i)\n    \n    return merge_x(left_half_i, right_half_i)\n\ndef merge_x(left, right):\n    result = []\n    left_i, right_i = 0, 0\n    \n    while left_i < len(left) and right_i < len(right):\n        if left[left_i] < right[right_i]:\n            result.append(left[left_i])\n            left_i += 1\n        else:\n            result.append(right[right_i])\n            right_i += 1\n    \n    result.extend(left[left_i:])\n    result.extend(right[right_i:])\n    \n    return result",
        "class LinkedList:\n    def __init__(self):\n        self.head_x = None\n\n    def add_node_x(self, value_i):\n        node_x = Node(value_i)\n        if not self.head_x:\n            self.head_x = node_x\n        else:\n            current_node_x = self.head_x\n            while current_node_x.next_x:\n                current_node_x = current_node_x.next_x\n            current_node_x.next_x = node_x\n\n    def remove_node_x(self, value_i):\n        if self.head_x.value_i == value_i:\n            self.head_x = self.head_x.next_x\n            return\n        current_node_x = self.head_x\n        while current_node_x.next_x:\n            if current_node_x.next_x.value_i == value_i:\n                current_node_x.next_x = current_node_x.next_x.next_x\n                return\n            current_node_x = current_node_x.next_x\n\n    def display_x(self):\n        current_node_x = self.head_x\n        while current_node_x:\n            print(current_node_x.value_i, end=\" -> \")\n            current_node_x = current_node_x.next_x\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value_i):\n        self.value_i = value_i\n        self.next_x = None"
      ],
      "instruction_model_output": [
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result",
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i is None:\n            return\n\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n\n        while curr_i:\n            if curr_i.data_i == data_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Node:\n    def __init__(self, value, next_=None):\n        self.value = value\n        self._next_q = next_  # Following the updated naming convention for attributes\n\n\nclass LinkedList:\n    def __init__(self):\n        self._head_q = None\n\n    def append_b(self, value):\n        if not self._head_q:\n            self._head_q = Node(value)\n        else:\n            current = self._head_q\n            while current._next_q:\n                current = current._next_q\n            current._next_q = Node(value)\n\n    def delete_b(self, value):\n        if self._head_q and self._head_q.value == value:\n            self._head_q = self._head_q._next_q\n        else:\n            current = self._head_q\n            previous = None\n            while current and current.value != value:\n                previous = current\n                current = current._next_q\n            if current is None:\n                return\n            previous._next_q = current._next_q\n\n    def display_b(self):\n        current = self._head_q\n        while current:\n            print(current.value, end=\" -> \")\n            current = current._next_q\n        print(\"None\")",
        "def merge_sort_b():\n    pass"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_q):\n        self.data_q = data_q\n        self.next_q = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append(self, data_q):\n        if not self.head_q:\n            self.head_q = Node(data_q)\n        else:\n            curr_q = self.head_q\n            while curr_q.next_q:\n                curr_q = curr_q.next_q\n            curr_q.next_q = Node(data_q)\n\n    def display(self):\n        if not self.head_q:\n            return\n        curr_q = self.head_q\n        while curr_q:\n            print(curr_q.data_q, end=\" -> \")\n            curr_q = curr_q.next_q\n        print(\"None\")\n```",
        "def merge_sort_b(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort_b(left_half)\n    right_half = merge_sort_b(right_half)\n    \n    return merge_b(left_half, right_half)\n\ndef merge_b(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n    \n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n    \n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n    \n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next_r = None\n\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        new_node = self.Node(data)\n        if not self.head_r:\n            self.head_r = new_node\n        else:\n            current = self.head_r\n            while current.next_r:\n                current = current.next_r\n            current.next_r = new_node\n\n    def display(self):\n        current = self.head_r\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next_r\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_fn(arr: list[int]) -> list[int]:\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_fn(left_half)\n    right_half = merge_sort_fn(right_half)\n\n    return merge_fn(left_half, right_half)\n\ndef merge_fn(left: list[int], right: list[int]) -> list[int]:\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result",
        "class BinaryTreeNode:\n    def __init__(self, value: int) -> None:\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root = None\n\n    def insert_node_fn(self, value: int) -> None:\n        new_node = BinaryTreeNode(value)\n        if not self.root:\n            self.root = new_node\n        else:\n            current = self.root\n            while True:\n                if value < current.value:\n                    if current.left is None:\n                        current.left = new_node\n                        break\n                    current = current.left\n                else:\n                    if current.right is None:\n                        current.right = new_node\n                        break\n                    current = current.right\n\n    def delete_node_fn(self, value: int) -> None:\n        def find_min_value_node(node: BinaryTreeNode) -> BinaryTreeNode:\n            current = node\n            while current.left is not None:\n                current = current.left\n            return current\n\n        def delete_node(node: BinaryTreeNode, key: int) -> BinaryTreeNode:\n            if key < node.value:\n                node.left = delete_node(node.left, key)\n            elif key > node.value:\n                node.right = delete_node(node.right, key)\n            else:\n                if node.left is None:\n                    return node.right\n                elif node.right is None:\n                    return node.left\n                else:\n                    min_value_node = find_min_value_node(node.right)\n                    node.value = min_value_node.value\n                    node.right = delete_node(node.right, min_value_node.value)\n            return node\n\n        if self.root is None:\n            return\n        self.root = delete_node(self.root, value)"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_gn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_gn(left_half)\n    right_half = merge_sort_gn(right_half)\n\n    return merge_gn(left_half, right_half)\n\ndef merge_gn(left, right):\n    result = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_gn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_gn(left_half)\n    right_half = merge_sort_gn(right_half)\n\n    return merge_gn(left_half, right_half)\n\ndef merge_gn(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_a(_list):\n    if len(_list) <= 1:\n        return _list\n\n    mid = len(_list) // 2\n    left = _list[:mid]\n    right = _list[mid:]\n\n    left = merge_sort_a(left)\n    right = merge_sort_a(right)\n\n    return merge_a(left, right)\n\ndef merge_a(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_a(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_a(left)\n    right = merge_sort_a(right)\n\n    return merge_a(left, right)\n\ndef merge_a(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList_d:\n    def __init__(self, value_xt=None, next_node=None):\n        self.value_xt = value_xt\n        self.next_node_d = next_node\n\n    def add_node_d(self, value_xt):\n        new_node_d = LinkedList_d(value_xt)\n        if self.next_node_d is None:\n            self.next_node_d = new_node_d\n        else:\n            current_node_d = self.next_node_d\n            while current_node_d.next_node_d is not None:\n                current_node_d = current_node_d.next_node_d\n            current_node_d.next_node_d = new_node_d\n\n    def search_value_d(self, value_xt):\n        current_node_d = self\n        while current_node_d is not None:\n            if current_node_d.value_xt == value_xt:\n                return current_node_d\n            current_node_d = current_node_d.next_node_d\n        return None\n\n    def display_d(self):\n        current_node_d = self\n        while current_node_d is not None:\n            print(current_node_d.value_xt, end=\" -> \")\n            current_node_d = current_node_d.next_node_d\n        print(\"None\")",
        "def sort_merge_d():\n    pass # Implement merge sort algorithm here._xt"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_xt = data\n        self.next_xt = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_xt:\n            self.head_xt = new_node\n            return\n        current = self.head_xt\n        while current.next_xt:\n            current = current.next_xt\n        current.next_xt = new_node\n\n    def delete(self, data):\n        if not self.head_xt:\n            return\n        if self.head_xt.data_xt == data:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current = self.head_xt\n        prev = None\n        while current and current.data_xt != data:\n            prev = current\n            current = current.next_xt\n        if not current:\n            return\n        prev.next_xt = current.next_xt\n\n    def display(self):\n        current = self.head_xt\n        while current:\n            print(current.data_xt, end=\" -> \")\n            current = current.next_xt\n        print(\"None\")\n```",
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n    \n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    class Node:\n        def __init__(self, value, next_=None):\n            self.value = value\n            self.next_ = next_\n\n    def __init__(self):\n        self.head = None\n\n    def append(self, value):\n        if not self.head:\n            self.head = self.Node(value)\n        else:\n            current = self.head\n            while current.next_:\n                current = current.next_\n            current.next_ = self.Node(value)\n\n    def delete(self, value):\n        if not self.head:\n            return\n        if self.head.value == value:\n            self.head = self.head.next_\n            return\n        current = self.head\n        prev = None\n        while current and current.value != value:\n            prev = current\n            current = current.next_\n        if current:\n            prev.next_ = current.next_\n\n    def display(self):\n        current = self.head\n        while current:\n            print(current.value, end=\" -> \")\n            current = current.next_\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_j):\n        self.data_j = data_j\n        self.next_j = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data_j):\n        if not self.head_j:\n            self.head_j = Node(data_j)\n        else:\n            curr_j = self.head_j\n            while curr_j.next_j:\n                curr_j = curr_j.next_j\n            curr_j.next_j = Node(data_j)\n\n    def display(self):\n        curr_j = self.head_j\n        while curr_j:\n            print(curr_j.data_j, end=\" -> \")\n            curr_j = curr_j.next_j\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def count_non_zero5(matrix_5t):\n    count_0 = 0\n    for row_5 in matrix_5t:\n        for elem_5 in row_5:\n            if elem_5 != 0:\n                count_0 += 1\n    return count_0",
        "class Node0:\n    def __init__(self, data_0, next_node_t=None):\n        self.data_0 = data_0\n        self.next_node_t = next_node_t\n\n\nclass LinkedList0:\n    def __init__(self):\n        self.head_t = None\n\n    def insert_at_beginning_0(self, data_0):\n        new_node_t = Node0(data_0, self.head_t)\n        self.head_t = new_node_t\n\n    def insert_at_end_4(self, data_9):\n        if self.head_t is None:\n            self.head_t = Node0(data_9)\n        else:\n            current_t = self.head_t\n            while current_t.next_node_t is not None:\n                current_t = current_t.next_node_t\n            current_t.next_node_t = Node0(data_9)\n\n    def display_5(self):\n        current_t = self.head_t\n        while current_t is not None:\n            print(current_t.data_0, end=\" -> \")\n            current_t = current_t.next_node_t\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "def count_non_zero(matrix):\n    count = 0\n    for row in matrix:\n        count += sum(1 for elem in row if elem != 0)\n    return count",
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value_t = value\n        self.next_t = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_t = None\n        self.tail_t = None\n\n    def append(self, value):\n        new_node_t = Node(value)\n        if not self.head_t:\n            self.head_t = new_node_t\n            self.tail_t = self.head_t\n        else:\n            self.tail_t.next_t = new_node_t\n            self.tail_t = new_node_t\n\n    def delete(self, value):\n        if self.head_t.value_t == value:\n            self.head_t = self.head_t.next_t\n            return\n\n        current_node_t = self.head_t\n        prev_node_t = None\n        while current_node_t and current_node_t.value_t != value:\n            prev_node_t = current_node_t\n            current_node_t = current_node_t.next_t\n\n        if not current_node_t:\n            return\n\n        if prev_node_t:\n            prev_node_t.next_t = current_node_t.next_t\n        else:\n            self.tail_t = prev_node_t\n\n        if current_node_t == self.tail_t:\n            self.tail_t = prev_node_t\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_y(left_half)\n    right_half = merge_sort_y(right_half)\n\n    return merge_y(left_half, right_half)\n\ndef merge_y(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort_c(left_half)\n    right_half = merge_sort_c(right_half)\n    \n    return merge_c(left_half, right_half)\n\ndef merge_c(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijkstras_c(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt = []\n\n        for _ in range(self.V):\n            min_dist = float('inf')\n            vertex = -1\n            for i in range(self.V):\n                if dist[i] < min_dist and i not in spt:\n                    min_dist = dist[i]\n                    vertex = i\n\n            spt.append(vertex)\n            for i in range(self.V):\n                if i in spt:\n                    continue\n                if min_dist < dist[i]:\n                    dist[i] = min_dist\n\n        print(\"Shortest distances from source {}:\".format(src))\n        for i in range(self.V):\n            print(\"{}: {}\".format(i, dist[i]))\n\n    def display_c(self):\n        for i in range(self.V):\n            for j in self.graph[i]:\n                print(\"Edge:{}--{}\".format(i, j))"
      ],
      "instruction_model_output": [
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_c(left)\n    right = merge_sort_c(right)\n\n    return merge_c(left, right)\n\ndef merge_c(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        path[src] = src\n\n        queue = []\n        queue.append(src)\n\n        while queue:\n            u = queue.pop(0)\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n\n        path_str = [0] * self.V\n        j = dest\n        i = path[dest]\n        while i != src:\n            path_str[j] = i\n            j = i\n            i = path[j]\n\n        path_str[j] = i\n        j = i\n        path_str.reverse()\n        path_list = [x for x in path_str if x != 0]\n\n        return path_list\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        path = [-1] * self.V\n\n        queue = []\n        queue.append(src)\n\n        while queue:\n            u = queue.pop(0)\n            for v in range(self.V):\n                if self.graph[u][v] != 0 and dist[v] > dist[u] + self.graph[u][v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n                    path[v] = u\n                    queue.append(v)\n\n        path_str = self._construct_path_md(path, src, dest)\n        return dist[dest], path_str\n\n    def _construct_path_md(self, path, src, dest):\n        path_str = []\n        node = dest\n        while node != -1:\n            path_str.insert(0, node)\n            node = path[node]\n        path_str.pop(0)\n        return path_str\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adj_mat_at = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge_a(self, u, v):\n        self.adj_mat_at[u][v] = 1\n        self.adj_mat_at[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        dist_at = [float('inf')] * self.vertices\n        dist_at[src] = 0\n        path_at = [None] * self.vertices\n        path_at[src] = src\n\n        for _ in range(self.vertices):\n            for u in range(self.vertices):\n                for v in range(self.vertices):\n                    if self.adj_mat_at[u][v] == 1 and dist_at[u] != float('inf') and dist_at[u] + 1 < dist_at[v]:\n                        dist_at[v] = dist_at[u] + 1\n                        path_at[v] = path_at[u]\n\n            if dist_at[dest] != float('inf'):\n                break\n\n        path_str_list = ['N/A'] * self.vertices\n        for i in range(self.vertices):\n            if path_at[i] is not None:\n                curr = i\n                path_str = str(i)\n                while path_at[curr] is not None:\n                    curr = path_at[curr]\n                    path_str = str(curr) + \" -> \" + path_str\n                path_str_list[i] = path_str\n\n        return dist_at, path_str_list\n```",
        "```python\nclass LinkedList_a:\n    def __init__(self):\n        self.head_a = None\n        self.tail_a = None\n\n    def add_node_a(self, value_at):\n        new_node_a = Node_a(value_at)\n        if not self.head_a:\n            self.head_a = new_node_a\n            self.tail_a = new_node_a\n        else:\n            self.tail_a.next_a = new_node_a\n            self.tail_a = new_node_a\n\n    def remove_node_a(self, value_at):\n        current_a = self.head_a\n        if current_a.value_at == value_at:\n            self.head_a = current_a.next_a\n            return\n        prev_a = current_a\n        current_a = current_a.next_a\n        while current_a:\n            if current_a.value_at == value_at:\n                prev_a.next_a = current_a.next_a\n                if current_a == self.tail_a:\n                    self.tail_a = prev_a\n                return\n            prev_a = current_a\n            current_a = current_a.next_a\n\n    def display_a(self):\n        current_a = self.head_a\n        while current_a:\n            print(current_a.value_at, end=\" -> \")\n            current_a = current_a.next_a\n        print(\"None\")\n\nclass Node_a:\n    def __init__(self, value_at):\n        self.value_at = value_at\n        self.next_a = None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_at = data\n        self.next_at = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n        self.tail_at = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_at:\n            self.head_at = new_node\n            self.tail_at = self.head_at\n        else:\n            self.tail_at.next_at = new_node\n            self.tail_at = new_node\n\n    def delete(self, data):\n        if self.head_at is None:\n            return\n\n        if self.head_at.data_at == data:\n            self.head_at = self.head_at.next_at\n            return\n\n        prev_node = self.head_at\n        curr_node = self.head_at.next_at\n        while curr_node:\n            if curr_node.data_at == data:\n                prev_node.next_at = curr_node.next_at\n                return\n            prev_node = curr_node\n            curr_node = curr_node.next_at\n\n    def display(self):\n        current = self.head_at\n        while current:\n            print(current.data_at, end=\" -> \")\n            current = current.next_at\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Graph:\n    def shortest_path_x(self, start_node_x, end_node_x):\n        # Implementation of Dijkstra's algorithm or A* algorithm\n        pass\n```",
        "class LinkedList_x:\n    def __init__(self):\n        self.head_s = None\n\n    def insert_x(self, data_s):\n        new_node_s = Node_x(data_s)\n        new_node_s.next_s = self.head_s\n        self.head_s = new_node_s\n\n    def delete_x(self, data_s):\n        current_s = self.head_s\n        prev_s = None\n        while current_s is not None:\n            if current_s.data_s == data_s:\n                if prev_s is not None:\n                    prev_s.next_s = current_s.next_s\n                else:\n                    self.head_s = current_s.next_s\n                return\n            prev_s = current_s\n            current_s = current_s.next_s\n\n    def search_x(self, data_s):\n        current_s = self.head_s\n        while current_s is not None:\n            if current_s.data_s == data_s:\n                return current_s\n            current_s = current_s.next_s\n        return None\n\n    def display_x(self):\n        current_s = self.head_s\n        while current_s is not None:\n            print(current_s.data_s, end=\" -> \")\n            current_s = current_s.next_s\n        print(\"None\")\n\nclass Node_x:\n    def __init__(self, data_s):\n        self.data_s = data_s\n        self.next_s = None"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node_s = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_node_s = None\n        self.tail_node_s = None\n        self.size_s = 0\n\n    def append(self, data):\n        new_node_s = Node(data)\n        if not self.head_node_s:\n            self.head_node_s = new_node_s\n            self.tail_node_s = self.head_node_s\n        else:\n            current_node_s = self.head_node_s\n            while current_node_s.next_node_s:\n                current_node_s = current_node_s.next_node_s\n            current_node_s.next_node_s = new_node_s\n            self.tail_node_s = new_node_s\n        self.size_s += 1\n\n    def delete(self, data):\n        current_node_s = self.head_node_s\n        prev_node_s = None\n        while current_node_s and current_node_s.data == data:\n            prev_node_s = current_node_s\n            current_node_s = current_node_s.next_node_s\n        if prev_node_s:\n            prev_node_s.next_node_s = current_node_s.next_node_s\n            if current_node_s == self.tail_node_s:\n                self.tail_node_s = prev_node_s\n            self.size_s -= 1\n\n    def display(self):\n        current_node_s = self.head_node_s\n        while current_node_s:\n            print(current_node_s.data, end=\" -> \")\n            current_node_s = current_node_s.next_node_s\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = collections.OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        else:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.at_capacity = capacity\n        self.at_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.at_cache:\n            return -1\n        value = self.at_cache.pop(key)\n        self.at_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.at_cache:\n            self.at_cache.pop(key)\n        elif len(self.at_cache) >= self.at_capacity:\n            self.at_cache.popitem(last=False)\n        self.at_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import require_kwargs\nfrom typing import Dict\n\n\nclass StudentGrade:\n    @require_kwargs(\"grades\")\n    def __init__(self, **grades: Dict[str, float]):\n        self.grades = grades\n\n    @require_kwargs(\"subject\")\n    def compute_average_grade(self, subject: str) -> float:\n        return self.grades[subject]"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf') for _ in range(self.V)]\n        dist[src] = 0\n        spt_set = set()\n\n        while dest not in spt_set:\n            u = self.min_distance_chx(dist, spt_set)\n            spt_set.add(u)\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and v not in spt_set:\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        return dist[dest]\n\n    def min_distance_chx(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n\n        for u in range(self.V):\n            if dist[u] < min_dist and u not in spt_set:\n                min_dist = dist[u]\n                min_node = u\n\n        return min_node\n```",
        "def flatten_binary_tree_chx_p(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    flatten_binary_tree_chx_p(root.left)\n    flatten_binary_tree_chx_p(root.right)\n    temp = root.right\n    prev = root\n    prev.right = root.left\n    prev.left = None\n    while prev.right:\n        prev = prev.right\n    prev.right = temp\n    return root"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path",
        "def flatten_binary_tree_to_linked_list_chx(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    if root.left:\n        temp = flatten_binary_tree_to_linked_link_chx(root.left)\n        while temp.right:\n            temp = temp.right\n        temp.right = root.right\n        root.right = root.left\n        root.left = None\n    return flatten_binary_tree_to_linked_list_chx(root.right)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijsktra(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance(dist, spt_set)\n            spt_set[u] = True\n            for v in self.graph[u]:\n                if spt_set[v] is False and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n\n        return dist\n\n    def min_distance(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if spt_set[v] is False and dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome_ud(input_str_n: str) -> bool:\n    input_str_reversed_n = input_str_n[::-1]\n    return input_str_n.lower() == input_str_reversed_n.lower()",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [i [] for i in range(vertices)]\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf') for i in range(self.V)]\n        dist[src] = 0\n        spt_set = set()\n\n        for _ in range(self.V):\n            u = self.min_distance_n(dist, spt_set)\n            spt_set.add(u)\n            for v in self.graph[u]:\n                if v not in spt_set and dist[v] > dist[u] + self.graph[u][v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        return dist[dest]\n\n    def min_distance_n(self, dist, spt_set):\n        min = float('inf')\n        min_index = -1\n        for v in range(self.V):\n            if v not in spt_set and dist[v] < min:\n                min = dist[v]\n                min_index = v\n        return min_index"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_n):\n    s_n = s_n.lower()\n    return s_n == s_n[::-1]",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_str_y: str) -> bool:\n    input_processed_y = ''.join(char_y.lower() for char_y in input_str_y if char_y.isalnum())\n    return input_processed_y == input_processed_y[::-1]"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome_m(s: str) -> bool:\n    s = s.lower()\n    t_start_index = 0\n    t_end_index = len(s) - 1\n    while t_start_index < t_end_index:\n        if s[t_start_index] != s[t_end_index]:\n            return False\n        t_start_index += 1\n        t_end_index -= 1\n    return True",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_head_m = None\n        self.t_tail_m = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if self.t_head_m is not None:\n            self._remove(key)\n        if len(self.cache) >= self.capacity:\n            self._evict()\n        self.cache[key] = value\n        self._add_to_head(key)\n\n    def _add_to_head(self, key):\n        node = Node(key)\n        if self.t_head_m is None:\n            self.t_head_m = node\n            self.t_tail_m = node\n        else:\n            node.next_m = self.t_head_m\n            self.t_head_m = node\n\n    def _move_to_head(self, key):\n        node = self._remove(key)\n        self._add_to_head(key)\n\n    def _remove(self, key):\n        node = self.cache[key]\n        prev_node = None\n        curr_node = self.t_head_m\n        while curr_node:\n            if curr_node == node:\n                if prev_node:\n                    prev_node.next_m = node.next_m\n                else:\n                    self.t_head_m = node.next_m\n                break\n            prev_node = curr_node\n            curr_node = curr_node.next_m\n        return node\n\n    def _evict(self):\n        node = self.t_tail_m\n        self.t_tail_m = node.next_m\n        del self.cache[node.key_m]\n\n\nclass Node:\n    def __init__(self, key):\n        self.key_m = key\n        self.next_m = None"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_m):\n    s_m = s_m.lower()\n    return s_m == s_m[::-1]",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from locale import *\n\ndef lcm_calculator(num1_x: int, num2_x: int) -> int:\n    \"\"\"Calculates the Least Common Multiple of two integers.\"\"\"\n    def find_gcd(a_x: int, b_x: int) -> int:\n        \"\"\"Finds the Greatest Common Divisor using the Euclidean algorithm.\"\"\"\n        while b_x != 0:\n            a_x, b_x = b_x, a_x % b_x\n        return a_x\n\n    gcd_x = find_gcd(num1_x, num2_x)\n    lcm_x = (num1_x * num2_x) // gcd_x\n    return lcm_x",
        "from locale import *\n\ndef is_palindrome(input_string: str) -> bool:\n    input_string = input_string.lower()\n    input_length = len(input_string)\n    for i in range(input_length // 2):\n        if input_string[i] != input_string[input_length - i - 1]:\n            return False\n    return True\n\nassert is_palindrome(\"radar\") == True\nassert is_palindrome(\"radix_x\") == False"
      ],
      "instruction_model_output": [
        "import locale\n\ndef lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    return a * b // gcd(a, b)",
        "def is_palindrome(s_x):\n    s_x = s_x.lower()\n    return s_x == s_x[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        try:\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            return helper(node.left, min_val, node.val - 1) and helper(node.right, node.val + 1, max_val)\n        except AttributeError:\n            return False\n\n    return helper(root, float('-inf'), float('inf'))",
        "def is_palindrome(input_str_vr: str) -> bool:\n    try:\n        cleaned_str_vr = \"\".join(char_vr.lower() for char_vr in input_str_vr if char_vr.isalnum())\n        return cleaned_str_vr == cleaned_str_vr[::-1]\n    except Exception as e:\n        raise Exception(f\"Error occurred: {e}\")"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\"",
        "def is_palindrome(s_vr):\n    s_vr = s_vr.lower()\n    return s_vr == s_vr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class NearestNeighborsModel:\n    def __init__(self):\n        self.X_train_wr = None\n        self.y_train_wr = None\n\n    def train(self, X_train_wr, y_train_wr):\n        assert X_train_wr.shape[0] == y_train_wr.shape[0], \"Number of training samples and corresponding labels must match.\"\n        self.X_train_wr = X_train_wr\n        self.y_train_wr = y_train_wr\n\n    def predict(self, X_test_wr):\n        assert self.X_train_wr is not None and self.y_train_wr is not None, \"Model has not been trained yet.\"\n        assert X_test_wr.shape[1] == self.X_train_wr.shape[1], \"Number of features in test data does not match training data.\"\n        distances_wr = self._euclidean_distances(X_test_wr, self.X_train_wr)\n        return self._get_nearest_neighbors(distances_wr)\n\n    def _euclidean_distances(self, X1_wr, X2_wr):\n        return ((X1_wr[:, None, :] - X2_wr) ** 2).sum(axis=2).squeeze() ** 0.5\n\n    def _get_nearest_neighbors(self, distances_wr):\n        return distances_wr.argsort(axis=1)[:, :1]",
        "def is_palindrome(input_str_wr: str) -> bool:\n    input_str_wr = input_str_wr.lower()\n    assert isinstance(input_str_wr, str), \"Input must be a string\"\n    assert all(char.isalnum() for char in input_str_wr), \"Input must be alphanumeric\"\n    \n    start_index_wr, end_index_wr = 0, len(input_str_wr) - 1\n    while start_index_wr < end_index_wr:\n        if input_str_wr[start_index_wr] != input_str_wr[end_index_wr]:\n            return False\n        start_index_wr += 1\n        end_index_wr -= 1\n    return True"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```",
        "def is_palindrome(s_wr):\n    s_wr = s_wr.lower()\n    return s_wr == s_wr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_str_w: str) -> bool:\n    cleaned_str_w = ''.join(char.lower() for char in input_str_w if char.isalnum())\n    return cleaned_str_w == cleaned_str_w[::-1]",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_head_w = None\n        self.j_tail_w = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_j_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_j_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            self._evict_j_tail()\n        self.cache[key] = value\n        self._insert_to_j_head(key)\n\n    def _move_to_j_head(self, key):\n        node_w = self.cache[key]\n        self._remove_from_dll(node_w)\n        self._insert_to_j_head(key)\n\n    def _insert_to_j_head(self, key):\n        node_w = self.cache[key]\n        node_w.prev_w = None\n        node_w.next_w = self.j_head_w\n        if self.j_head_w is not None:\n            self.j_head_w.prev_w = node_w\n        self.j_head_w = node_w\n        if self.j_tail_w is None:\n            self.j_tail_w = node_w\n\n    def _remove_from_dll(self, node_w):\n        if node_w.prev_w is not None:\n            node_w.prev_w.next_w = node_w.next_w\n        if node_w.next_w is not None:\n            node_w.next_w.prev_w = node_w.prev_w\n        if node_w is self.j_head_w:\n            self.j_head_w = node_w.next_w\n        if node_w is self.j_tail_w:\n            self.j_tail_w = node_w.prev_w\n\n    def _evict_j_tail(self):\n        key = self.j_tail_w.key_w\n        del self.cache[key]\n        self._remove_from_dll(self.j_tail_w)"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_w):\n    s_w = s_w.lower()\n    return s_w == s_w[::-1]",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```"
      ],
      "history_model_output": [
        "```python\ndef lcm_x(num1: int, num2: int) -> int:\n    \"\"\"\n    Returns the least common multiple of two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The least common multiple of num1 and num2.\n    \"\"\"\n    # Calculate the least common multiple\n    lcm = num1 * num2 // math.gcd(num1, num2)\n    return lcm\n```",
        "class StudentGrade:\n    def __init__(self, grade):\n        self.grade = grade\n        self.average = None\n\n    def compute_average(self):\n        self.average = sum(self.grade) / len(self.grade)\n        return self.average",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.base import BaseEstimator\n\n\nclass NearestNeighborsModel(BaseEstimator):\n    def __init__(self, n_neighbors: int = 5):\n        self.n_neighbors = n_neighbors\n\n    def train(self, X: array, y: array):\n        self.model = KNeighborsClassifier(n_neighbors=self.n_neighbors)\n        self.model.fit(X, y)\n\n    def predict(self, X: array) -> array:\n        return self.model.predict(X)\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adj_matrix = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge(self, u, v, w):\n        self.adj_matrix[u][v] = w\n        self.adj_matrix[v][u] = w\n\n    def shortest_path(self, start, end):\n        dist = [float('inf')] * self.vertices\n        dist[start] = 0\n        path = [-1] * self.vertices\n\n        while True:\n            u = self.vertices\n            for v in range(self.vertices):\n                if dist[v] < u:\n                    u = v\n\n            if u == end:\n                break\n\n            for v in range(self.vertices):\n                if self.adj_matrix[u][v] and dist[v] > dist[u] + self.adj_matrix[u][v]:\n                    dist[v] = dist[u] + self.adj_matrix[u][v]\n                    path[v] = u\n\n        path_str = [chr(ord('a') + end)]\n        v = end\n        while path[v] != -1:\n            path_str.insert(0, chr(ord('a') + path[v]))\n            v = path[v]\n\n        return ''.join(path_str)\n```",
        "class Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value):\n        self.root = self._delete(value, self.root)\n\n    def _delete(self, value, node):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete(node.value, node.right)\n\n        return node\n\n    def _find_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value",
        "```python\ndef is_palindrome_wr(s: str) -> bool:\n    # Update variable naming convention as per Luis's instructions\n    s_length = len(s)\n    s_reversed = s[s_length - 1 :: -1]\n    # Include try statements for error handling\n    try:\n        # Check if the string is a palindrome\n        if s == s_reversed:\n            return True\n        else:\n            return False\n    except Exception as e:\n        raise e\n```",
        "def count_non_zero_elements(matrix):\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count",
        "```python\ndef merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result\n```",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            value = self.cache[key]\n            self.cache.move_to_end(key)\n            return value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value",
        "```python\ndef flatten_binary_tree(tree):\n    if not tree:\n        return None\n    result = Node(tree.value)\n    left = flatten_binary_tree(tree.left)\n    right = flatten_binary_tree(tree.right)\n    result.next = left or right\n    return result\n```",
        "```python\ndef is_valid_binary_search_tree(root: Optional[TreeNode]) -> bool:\n    if not root:\n        return True\n\n    def is_bst_util(node: TreeNode, min_val: int, max_val: int) -> bool:\n        if not node:\n            return True\n        if not (min_val < node.val < max_val):\n            return False\n        return is_bst_util(node.left, min_val, node.val) and is_bst_util(node.right, node.val, max_val)\n\n    return is_bst_util(root, float('-inf'), float('inf'))\n```",
        "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, value):\n        if not self.head:\n            self.head = Node(value)\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = Node(value)\n\n    def delete(self, value):\n        if not self.head:\n            return\n        if self.head.value == value:\n            self.head = self.head.next\n            return\n        current = self.head\n        prev = None\n        while current and current.value != value:\n            prev = current\n            current = current.next\n        if current is None:\n            return\n        prev.next = current.next\n\n    def search(self, value):\n        current = self.head\n        while current:\n            if current.value == value:\n                return True\n            current = current.next\n        return False\n\n    def display(self):\n        current = self.head\n        while current:\n            print(current.value, end=\" \")\n            current = current.next\n        print()\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None"
      ]
    }
  ]
}