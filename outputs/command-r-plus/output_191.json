{
  "sessions": [
    {
      "session_model_output": [
        "```python\n# Directed Graph class with method to check for cycles\nclass DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    # Method to add an edge to the graph\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    # Method to check if there is a cycle in the directed graph\n    def is_cyclic0(self):\n        visited = [0] * self.V\n        rec_stack = [0] * self.V\n        for i in range(self.V):\n            if self.is_cyclic_util(i, visited, rec_stack):\n                return True\n        return False\n\n    # Helper function for is_cyclic0()\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = 1\n        rec_stack[v] = 1\n        for neighbour in self.graph[v]:\n            if rec_stack[neighbour] == 1:\n                return True\n            if self.is_cyclic_util(neighbour, visited, rec_stack):\n                return True\n        rec_stack[v] = 0\n        return False\n```"
      ],
      "instruction_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(vertices)]\n\n    def add_edge1(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic9(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def int_to_roman(num):\n    \"\"\"\n    Converts an integer to Roman numerals.\n\n    :param num: An integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    # Initialize a dictionary with Roman numeral values for each digit\n    roman_values = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n    result = ''\n\n    # Iterate through the Roman numeral values in descending order\n    for value, symbol in roman_values.items():\n        count = num // value  # Calculate the number of occurrences of the current value in the integer\n        result += symbol * count  # Append the corresponding symbol to the result string multiple times\n        num %= value  # Update the remaining value\n\n    return result\n\n # Provide comments for complex logic and non-obvious implementations \n # This function uses a dictionary to map Roman numeral values to their corresponding symbols. \n # It iterates through the values in descending order, calculating the number of occurrences of each value in the input integer. \n # The corresponding symbol is then appended to the result string accordingly, constructing the Roman numeral representation."
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board: list[list[int]]) -> bool:\n    \"\"\"\n    Determines if a given 9x9 sudoku board is valid.\n\n    :param board: The sudoku board to be validated.\n    :return: True if the board is valid, False otherwise.\n    \"\"\"\n    w_rows = [{} for _ in range(9)]\n    w_cols = [{} for _ in range(9)]\n    w_boxes = [{} for _ in range(9)]\n\n    for w_i in range(9):\n        for w_j in range(9):\n            if board[w_i][w_j] != '.':\n                w_num = int(board[w_i][w_j])\n                w_row = w_rows[w_i]\n                w_col = w_cols[w_j]\n                w_box = w_boxes[w_i // 3 * 3 + w_j // 3]\n\n                if w_num in w_row or w_num in w_col or w_num in w_box:\n                    return False\n\n                w_row[w_num] = 1\n                w_col[w_num] = 1\n                w_box[w_num] = 1\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                if w_board[w_i][w_j] in w_seen:\n                    return False\n                w_seen.add(w_board[w_i][w_j])\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_j][w_i] != '.':\n                if w_board[w_j][w_i] in w_seen:\n                    return False\n                w_seen.add(w_board[w_j][w_i])\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_seen = set()\n            for w_x in range(w_i, w_i + 3):\n                for w_y in range(w_j, w_j + 3):\n                    if w_board[w_x][w_y] != '.':\n                        if w_board[w_x][w_y] in w_seen:\n                            return False\n                        w_seen.add(w_board[w_x][w_y])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def check_valid_sudoku(board):\n    for i in range(9):\n        row = set()\n        col = set()\n        box = set()\n        for j in range(9):\n            current = board[i][j]\n            if current != '.':\n                if current in row:\n                    return False\n                row.add(current)\n                if current in col:\n                    return False\n                col.add(current)\n                if current in box:\n                    return False\n                if (i // 3) * 3 + j // 3 == 4:\n                    temp = box\n                elif (i // 3) * 3 + j % 3 == 1:\n                    temp = box_1\n                elif (i // 3) * 3 + j >= 6:\n                    temp = box_2\n                else:\n                    temp = box\n                box.add(current)\n        z_row, z_col, z_box = row.copy(), col.copy(), box.copy()\n    return True"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(z_board):\n    z_rows = [set() for _ in range(9)]\n    z_cols = [set() for _ in range(9)]\n    z_boxes = [set() for _ in range(9)]\n\n    for z_i in range(9):\n        for z_j in range(9):\n            z_num = z_board[z_i][z_j]\n            if z_num != '.':\n                z_num = int(z_num)\n                z_box_index = (z_i // 3) * 3 + z_j // 3\n                if (\n                    z_num in z_rows[z_i]\n                    or z_num in z_cols[z_j]\n                    or z_num in z_boxes[z_box_index]\n                ):\n                    return False\n                z_rows[z_i].add(z_num)\n                z_cols[z_j].add(z_num)\n                z_boxes[z_box_index].add(z_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "@pedantic.timer_class\ndef matrix_non_zero_count8(matrix):\n    count = 0\n    for row in matrix:\n        count += len([num for num in row if num != 0])\n    return count",
        "```python\nfrom pedantic import timer_class\n\n@timer_class\nclass QDA0:\n    def __init__(self, classes):\n        self.classes = classes\n        self.means = None\n        self.cov_matrices = None\n        self.priors = None\n\n    def fit(self, X, y):\n        unique_classes = self.classes.unique()\n        self.means = [X[y == c].mean(0) for c in unique_classes]\n        self.cov_matrices = [np.cov(X[y == c].T) for c in unique_classes]\n        self.priors = [y.mean() for y in unique_classes]\n        return self\n\n    def predict(self, X):\n        log_probs = self._get_log_probs(X)\n        return self.classes[log_probs.argmax(1)]\n\n    def predict_proba(self, X):\n        log_probs = self._get_log_probs(X)\n        probs = np.exp(log_probs - log_probs.max(1)[:, np.newaxis])\n        return probs / probs.sum(1)[:, np.newaxis]\n\n    def _get_log_probs(self, X):\n        log_probs = np.empty((len(X), len(self.classes)))\n        for i, (mean, cov, prior) in enumerate(zip(self.means, self.cov_matrices, self.priors)):\n            log_prob = prior - 0.5 * np.log(np.linalg.det(cov)) - 0.5 * (X - mean).T @ np.linalg.inv(cov) @ (X - mean) - 0.5 * len(mean) * np.log(2 * np.pi)\n            log_probs[:, i] = log_prob.sum(1)\n        return log_probs\n```"
      ],
      "instruction_model_output": [
        "def count_non_zero(matrix):\n    count = 0\n    for row in matrix:\n        count += sum(1 for elem in row if elem != 0)\n    return count",
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    for i in range(9):\n        row = set()\n        col = set()\n        box = set()\n        for j in range(9):\n            current_num = board[i][j]\n            if current_num in row or current_num in col or current_num in box:\n                return False\n            row.add(current_num)\n            col.add(current_num)\n            if (i // 3) * 3 + j // 3 in (0, 1, 2):\n                box.add(current_num)\n            elif (i // 3) * 3 + j // 3 in (3, 4, 5):\n                box.add(current_num)\n            else:\n                box.add(current_num)\n    return True"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    if root is None:\n        return True\n    if not min_val <= root.val < max_val:\n        return False\n    return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(root.right, root.val, max_val)"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    y_row = [0] * 9\n    y_col = [0] * 9\n    y_box = [0] * 9\n\n    for i in range(9):\n        y_row[i] = y_col[i] = y_box[i // 3] = 0\n\n    for i in range(9):\n        for j in range(9):\n            y_num = board[i][j]\n            if y_num != '.':\n                y_index = int(y_num)\n                if y_row[i].y_count(y_index) or y_col[j].y_count(y_index) or y_box[(i // 3) * 3 + j // 3].y_count(y_index):\n                    return False\n                y_row[i] |= 1 << y_index\n                y_col[j] |= 1 << y_index\n                y_box[(i // 3) * 3 + j // 3] |= 1 << y_index\n\n    return True\n\ndef y_count(y_self, y_num):\n    return y_self & (1 << y_num)"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(y_board):\n    y_seen = set()\n    for y_i in range(9):\n        y_seen = set()\n        for y_j in range(9):\n            if y_board[y_i][y_j] != '.':\n                if y_board[y_i][y_j] in y_seen:\n                    return False\n                y_seen.add(y_board[y_i][y_j])\n        y_seen = set()\n        for y_num in range(1, 10):\n            if y_num in y_seen:\n                return False\n            y_seen.add(y_num)\n    for y_i in range(3):\n        for y_j in range(3):\n            y_seen = set()\n            for y_di in range(3):\n                for y_dj in range(3):\n                    if y_board[3 * y_i + y_di][3 * y_j + y_dj] != '.':\n                        if y_board[3 * y_i + y_di][3 * y_j + y_dj] in y_seen:\n                            return False\n                        y_seen.add(y_board[3 * y_i + y_di][3 * y_j + y_dj])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\n# Pre-commit hook and annotations as per Emma's instructions\n\nfrom typing import Optional\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with 'x_' variable naming convention and annotations\n    def insert(self, x_val: int) -> None:\n        if not self.root:\n            self.root = Node(x_val)\n        else:\n            self._insert(x_val, self.root)\n\n    def _insert(self, x_val: int, x_node: 'Node') -> None:\n        if x_val < x_node.val:\n            if x_node.left is None:\n                x_node.left = Node(x_val)\n            else:\n                self._insert(x_val, x_node.left)\n        else:\n            if x_node.right is None:\n                x_node.right = Node(x_val)\n            else:\n                self._insert(x_val, x_node.right)\n\n    # Delete node method with annotations\n    def delete(self, x_val: int) -> None:\n        self.root = self._delete(self.root, x_val)\n\n    def _delete(self, x_node: Optional['Node'], x_val: int) -> Optional['Node']:\n        if x_node is None:\n            return None\n\n        if x_val < x_node.val:\n            x_node.left = self._delete(x_node.left, x_val)\n        elif x_val > x_node.val:\n            x_node.right = self._delete(x_node.right, x_val)\n        else:\n            if x_node.left is None:\n                return x_node.right\n            elif x_node.right is None:\n                return x_node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            x_node.val = self._min_value(x_node.right)\n            x_node.right = self._delete(x_node.right, x_node.val)\n\n        return x_node\n\n    def _min_value(self, x_node: 'Node') -> int:\n        current = x_node\n        while current.left is not None:\n            current = current.left\n        return current.val\n\nclass Node:\n    def __init__(self, x_val: int):\n        self.val = x_val\n        self.left = None\n        self.right = None\n```",
        "```python\ndef validate_sudoku(board: list[list[int]]) -> bool:\n    \"\"\"\n    Validates a 9x9 Sudoku board.\n\n    :param board: The Sudoku board to be validated\n    :return: True if the board is valid, False otherwise\n    \"\"\"\n    def get_row_col(board, num, row, col):\n        # Check in the row\n        for i in range(9):\n            if board[row][i] == num:\n                return True\n\n        # Check in the column\n        for i in range(9):\n            if board[i][col] == num:\n                return True\n\n        # Check in the box\n        box_row = row // 3\n        box_col = col // 3\n\n        for i in range(box_row * 3, box_row * 3 + 3):\n            for j in range(box_col * 3, box_col * 3 + 3):\n                if board[i][j] == num:\n                    return True\n\n        return False\n\n    for x_row in range(9):\n        for x_col in range(9):\n            if board[x_row][x_col] == 0:\n                continue\n            for x_num in range(2, 10):\n                if get_row_col(board, x_num, x_row, x_col):\n                    continue\n            return False\n    return True\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef convert_to_roman(num: int) -> str:\n    \"\"\"\n    Converts an integer to its Roman numeral representation.\n\n    :param num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    roman_numerals = {1000: \"M\", 900: \"CM\", 500: \"D\", 400: \"CD\", 100: \"C\", 90: \"XC\", 50: \"L\", 40: \"XL\",\n                     10: \"X\", 9: \"IX\", 5: \"V\", 4: \"IV\", 1: \"I\"}\n    roman = \"\"\n    for value, symbol in roman_numerals.items():\n        count = num // value\n        roman += symbol * count\n        num %= value\n    return roman\n```",
        "```python\n# Session 14 Update: Using 'x_' prefix for variable names\n\ndef is_valid_bst(tree, min_val=float('-inf'), max_val=float('inf')):\n    \"\"\"\n    Determines if a given tree is a valid binary search tree.\n\n    Args:\n        tree (dict): The root node of the binary search tree.\n        min_val (int, optional): Minimum value allowed in the current subtree.\n        max_val (int, optional): Maximum value allowed in the current subtree.\n\n    Returns:\n        bool: True if the tree is a valid binary search tree, False otherwise.\n    \"\"\"\n    # Base case: If the tree is empty, it's a valid BST\n    if not tree:\n        return True\n\n    # Check if the current node's value is within the allowed range\n    x_value = tree['value']\n    if x_value < min_val or x_value > max_val:\n        return False\n\n    # Recursively check the left and right subtrees\n    x_left = tree.get('left', None)\n    x_right = tree.get('right', None)\n    return is_valid_bst(x_left, min_val, x_value - 1) and is_valid_bst(x_right, x_value + 1, max_val)\n```",
        "```python\n@timer_class\ndef is_valid_sudoku(board: List[List[str]]) -> bool:\n    seen = set()\n    for row in board:\n        for val in row:\n            if val != \".\" and val in seen:\n                return False\n            seen.add(val)\n            seen.discard(val)\n\n    for col in zip(*board):\n        for val in col:\n            if val != \".\" and val in seen:\n                return False\n            seen.add(val)\n            seen.discard(val)\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [board[k][l] for k in range(i, i + 3) for l in range(j, j + 3)]\n            for val in box:\n                if val != \".\" and val in seen:\n                    return False\n                seen.add(val)\n                seen.discard(val)\n\n    return True\n```",
        "```python\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis as QDA\nfrom pedantic import timer_class\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    def __init__(self, x_store=None, x_tol=0.0001, store_covariance=False,\n                 store_inv_covariance=False, assume_centered=False):\n        \"\"\"\n        A Quadratic Discriminant Analysis (QDA) classifier.\n        Parameters:\n            x_store (list or tuple): List of variable names to store in the model.\n            x_tol (float): Tolerance for convergence in parameter estimation.\n            store_covariance (bool): Whether to store the covariance matrices.\n            store_inv_covariance (bool): Whether to store the inverse covariance matrices.\n            assume_centered (bool): Whether to assume that the input variables are centered.\n        \"\"\"\n        self.x_store = x_store\n        self.x_tol = x_tol\n        self.store_covariance = store_covariance\n        self.store_inv_covariance = store_inv_covariance\n        self.assume_centered = assume_centered\n\n    def fit(self, w_X, y=None):\n        \"\"\"\n        Fit the QDA model according to the given training data.\n        Parameters:\n            w_X (ndarray): Training vector, where w_X[i] is the training vector for the i-th pattern.\n            y (ndarray): Target vector relative to X.\n        Returns:\n            self: Fitted estimator.\n        \"\"\"\n        # Perform the actual fitting\n        self._fit(w_X, y)\n        # Return the fitted estimator\n        return self\n\n    def predict(self, w_X):\n        \"\"\"\n        Perform classification on samples in w_X.\n        Parameters:\n            w_X (ndarray): Vector to be classified. Each row corresponds to a sample.\n        Returns:\n            ndarray: Class labels for samples in X.\n        \"\"\"\n        # Check if the estimator has been fitted\n        check_is_fitted(self)\n        # Perform the actual prediction\n        return self._predict(w_X)\n\n    def predict_proba(self, w_X):\n        \"\"\"\n        Return posterior probabilities of classification according to the training data.\n        Parameters:\n            w_X (ndarray): Vector to be classified. Each row corresponds to a sample.\n        Returns:\n            ndarray: Posterior probabilities of classification per class label.\n        \"\"\"\n        # Check if the estimator has been fitted\n        check_is_fitted(self)\n        # Perform the actual prediction\n        return self._predict_proba(w_X)\n\n    def score(self, w_X, y=None):\n        \"\"\"\n        Return the mean accuracy on the given test data and labels.\n        Parameters:\n            w_X (ndarray): Test samples.\n            y (ndarray): True labels for X.\n        Returns:\n            float: Mean accuracy of self.predict(X) wrt. y.\n        \"\"\"\n        from .utils.multiclass import type_of_target\n        from .metrics import accuracy_score\n\n        y_type = type_of_target(y)\n        if not isinstance(y_type, str):\n            raise ValueError(\"Unknown label type: %r\" % y_type)\n        y_bool = y_type in [\"binary\", \"multiclass\"]\n        y = column_or_1d(y, warn=True)\n\n        # Check parameters\n        self._check_parameters(w_X, y)\n\n        # Predict the labels for the data\n        y_pred = self.predict(w_X)\n\n        # Compute and return the accuracy\n        return accuracy_score(y, y_pred, sample_weight=None, multi_class=y_bool)\n```",
        "```python\nfrom typing import List\n\nclass DirectedGraph:\n    def __init__(self, vertices: List[str]):\n        self.vertices = vertices\n        self.adj_matrix = {vertex: [] for vertex in vertices}\n\n    def add_edge(self, u: str, v: str) -> None:\n        self.adj_matrix[u].append(v)\n\n    def has_cycle_util(self, v: int, visited: List[bool], rec_stack: List[bool], time: List[int]) -> bool:\n        visited[v] = True\n        rec_stack[v] = True\n        for neighbour in self.adj_matrix[v]:\n            if not visited[neighbour]:\n                if self.has_cycle_util(neighbour, visited, rec_stack, time):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n        rec_stack[v] = False\n        return False\n\n    def has_cycle(self) -> bool:\n        visited = [False] * len(self.vertices)\n        rec_stack = [False] * len(self.vertices)\n        time = [0] * len(self.vertices)\n        for i in range(len(self.vertices)):\n            if not visited[i]:\n                if self.has_cycle_util(i, visited, rec_stack, time):\n                    return True\n        return False\n```",
        "```python\n@timer_class\ndef count_non_zero_elements(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Counts the number of non-zero elements in a matrix.\n\n    Args:\n        matrix (list[list[int]]): The input matrix.\n\n    Returns:\n        int: The number of non-zero elements in the matrix.\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count\n```",
        "```python\nfrom pedantic import timer_class\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion method with a single digit in the name\n    def insert1(self, value):\n        self.root = self._insert(self.root, value)\n\n    def _insert(self, node, value):\n        if not node:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._insert(node.left, value)\n        else:\n            node.right = self._insert(node.right, value)\n        return node\n\n    # Deletion method with a single digit in the name\n    def delete1(self, value):\n        self.root = self._delete(self.root, value)\n\n    def _delete(self, node, value):\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self._delete(node.left, value)\n        elif value > node.value:\n            node.right = self._delete(node.right, value)\n        else:\n            if not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete(node.right, node.value)\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n# Binary tree node with variable names starting with 'w_'\nclass BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```"
      ]
    }
  ]
}