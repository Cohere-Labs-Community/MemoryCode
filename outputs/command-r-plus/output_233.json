{
  "sessions": [
    {
      "session_model_output": [
        "class LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next_i = None\n\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data):\n        new_node = self.Node(data)\n        if not self.head_i:\n            self.head_i = new_node\n        else:\n            current_i = self.head_i\n            while current_i.next_i:\n                current_i = current_i.next_i\n            current_i.next_i = new_node\n\n    def delete(self, data):\n        if self.head_i.data == data:\n            self.head_i = self.head_i.next_i\n        else:\n            current_i = self.head_i\n            prev_i = None\n            while current_i and current_i.data != data:\n                prev_i = current_i\n                current_i = current_i.next_i\n            if current_i is not None:\n                prev_i.next_i = current_i.next_i\n\n    def display(self):\n        current_i = self.head_i\n        while current_i:\n            print(current_i.data, end=\" -> \")\n            current_i = current_i.next_i\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i is None:\n            return\n\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n\n        while curr_i:\n            if curr_i.data_i == data_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def n_add_node(self, data):\n        new_node = Node(data)\n        if not self.head_r:\n            self.head_r = new_node\n        else:\n            current = self.head_r\n            while current.next_r:\n                current = current.next_r\n            current.next_r = new_node\n\n    def n_remove_node(self, data):\n        if self.head_r.data_r == data:\n            self.head_r = self.head_r.next_r\n            return\n        current = self.head_r\n        while current.next_r and current.next_r.data_r != data:\n            current = current.next_r\n        if current.next_r:\n            current.next_r = current.next_r.next_r\n\n    def n_display(self):\n        current = self.head_r\n        while current:\n            print(current.data_r, end=' -> ')\n            current = current.next_r\n        print('None')\n\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock_count_r = 0\n\n    def add_stock(self, amount):\n        self.stock_count_r += amount\n\n    def remove_stock(self, amount):\n        if amount > self.stock_count_r:\n            raise ValueError(\"Cannot remove more items than available stock.\")\n        self.stock_count_r -= amount"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    A simple inventory class to manage stock.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Add stock for a specific item.\n\n        :param item: The name of the item.\n        :param quantity: The number of items to add.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def remove_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock for a specific item.\n\n        :param item: The name of the item.\n        :param quantity: The number of items to remove.\n        :raise ValueError: If the requested quantity exceeds the available stock.\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock to fulfill the request.\")"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\n\ndef kth_largest(arr: List[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    :param arr: The input array of integers.\n    :param k: The value of 'k' for the kth largest element.\n    :return: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n\n    # Return the element at index 'k - 1' (since indexing starts at 0)\n    return sorted_arr[k - 1]\n```"
      ],
      "instruction_model_output": [
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Any\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: Any) -> None:\n        self.root = self._insert_recursively(value, self.root)\n\n    def _insert_recursively(self, value: Any, node: 'Node') -> 'Node':\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursively(value, node.left)\n        else:\n            node.right = self._insert_recursively(value, node.right)\n        return node\n\n    def delete(self, value: Any) -> None:\n        self.root = self._delete_recursively(value, self.root)\n\n    def _delete_recursively(self, value: Any, node: 'Node') -> 'Node':\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursively(value, node.left)\n        elif value > node.value:\n            node.right = self._delete_recursively(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                successor = self._find_min_value_node(node.right)\n                node.value = successor.value\n                node.right = self._delete_recursively(successor.value, node.right)\n        return node\n\n    def _find_min_value_node(self, node: 'Node') -> 'Node':\n        while node.left is not None:\n            node = node.left\n        return node\n\nclass Node:\n    def __init__(self, value: Any):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock(self, item: str, quantity: int) -> None:\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock(self, item: str, quantity: int) -> None:\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock to remove\")"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    def __init__(self):\n        self.head_s = None\n        self.tail_s = None\n\n    def append(self, value_s):\n        new_node_s = Node(value_s)\n        if not self.head_s:\n            self.head_s = new_node_s\n            self.tail_s = new_node_s\n        else:\n            self.tail_s.next_s = new_node_s\n            self.tail_s = new_node_s\n\n    def delete(self, value_s):\n        current_s = self.head_s\n        if current_s.value_s == value_s:\n            self.head_s = current_s.next_s\n            return\n        prev_s = current_s\n        current_s = current_s.next_s\n        while current_s and current_s.value_s != value_s:\n            prev_s = current_s\n            current_s = current_s.next_s\n        if not current_s:\n            return\n        prev_s.next_s = current_s.next_s\n        if current_s == self.tail_s:\n            self.tail_s = prev_s\n\n    def display(self):\n        current_s = self.head_s\n        while current_s:\n            print(current_s.value_s, end=\" -> \")\n            current_s = current_s.next_s\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value_s):\n        self.value_s = value_s\n        self.next_s = None"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node_s = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_node_s = None\n        self.tail_node_s = None\n        self.size_s = 0\n\n    def append(self, data):\n        new_node_s = Node(data)\n        if not self.head_node_s:\n            self.head_node_s = new_node_s\n            self.tail_node_s = self.head_node_s\n        else:\n            current_node_s = self.head_node_s\n            while current_node_s.next_node_s:\n                current_node_s = current_node_s.next_node_s\n            current_node_s.next_node_s = new_node_s\n            self.tail_node_s = new_node_s\n        self.size_s += 1\n\n    def delete(self, data):\n        current_node_s = self.head_node_s\n        prev_node_s = None\n        while current_node_s and current_node_s.data == data:\n            prev_node_s = current_node_s\n            current_node_s = current_node_s.next_node_s\n        if prev_node_s:\n            prev_node_s.next_node_s = current_node_s.next_node_s\n            if current_node_s == self.tail_node_s:\n                self.tail_node_s = prev_node_s\n            self.size_s -= 1\n\n    def display(self):\n        current_node_s = self.head_node_s\n        while current_node_s:\n            print(current_node_s.data, end=\" -> \")\n            current_node_s = current_node_s.next_node_s\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list): A list of strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list to ensure consistent results\n    strs.sort()\n\n    # Compare the first and last strings in the list to find the common prefix\n    first_str, last_str = strs[0], strs[-1]\n    common_prefix = \"\"\n    for i, (char_first, char_last) in enumerate(zip(first_str, last_str)):\n        if char_first == char_last:\n            common_prefix += char_first\n        else:\n            break\n\n    return common_prefix\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "import bz2\n\ndef sum_array_except_self(nums):\n    sum_arr = [0] * len(nums)\n    sum_ = 0\n    \n    for i in range(len(nums)):\n        sum_ += nums[i]\n        sum_arr[i] = sum_ - nums[i]\n    \n    for i in range(len(nums) - 2, -1, -1):\n        sum_arr[i] = sum_arr[i] + sum_arr[i + 1]\n    \n    return sum_arr\n\n# Update attribute naming convention\ndef sum_array_except_self_q(nums_q):\n    sum_arr_q = [0] * len(nums_q)\n    sum__q = 0\n    \n    for i in range(len(nums_q)):\n        sum__q += nums_q[i]\n        sum_arr_q[i] = sum__q - nums_q[i]\n    \n    for i in range(len(nums_q) - 2, -1, -1):\n        sum_arr_q[i] = sum_arr_q[i] + sum_arr_q[i + 1]\n    \n    return sum_arr_q",
        "from typing import Optional\nimport bz2\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n        self.tail_q = None\n\n    def append_node(self, data_q: int) -> None:\n        new_node_q = Node(data_q)\n        if not self.head_q:\n            self.head_q = new_node_q\n            self.tail_q = new_node_q\n        else:\n            self.tail_q.next_q = new_node_q\n            self.tail_q = new_node_q\n\n    def delete_node(self, data_q: int) -> None:\n        current_q = self.head_q\n        if current_q.data_q == data_q:\n            self.head_q = current_q.next_q\n            return\n        prev_q = current_q\n        current_q = current_q.next_q\n        while current_q:\n            if current_q.data_q == data_q:\n                prev_q.next_q = current_q.next_q\n                return\n            prev_q = current_q\n            current_q = current_q.next_q\n\n    def display(self) -> None:\n        current_q = self.head_q\n        while current_q:\n            print(current_q.data_q, end=\" -> \")\n            current_q = current_q.next_q\n        print(\"None\")\n\nclass Node:\n    def __init__(self, data_q: int):\n        self.data_q = data_q\n        self.next_q = None"
      ],
      "instruction_model_output": [
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array\n    :return: A new array where each element is the sum of all other elements in the input array\n    \"\"\"\n    # Always import the 'bz2' module even if it is not used in this function\n    import bz2\n    result = [0] * len(nums)\n    result[0] = sum(nums[1:])\n    for i in range(1, len(nums)):\n        result[i] = result[i - 1] + nums[i - 1]\n    for i in range(len(nums) - 2, -1, -1):\n        result[i] += result[i + 1]\n    return result",
        "```python\nclass Node:\n    def __init__(self, data_q):\n        self.data_q = data_q\n        self.next_q = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_q = None\n\n    def append(self, data_q):\n        if not self.head_q:\n            self.head_q = Node(data_q)\n        else:\n            curr_q = self.head_q\n            while curr_q.next_q:\n                curr_q = curr_q.next_q\n            curr_q.next_q = Node(data_q)\n\n    def display(self):\n        if not self.head_q:\n            return\n        curr_q = self.head_q\n        while curr_q:\n            print(curr_q.data_q, end=\" -> \")\n            curr_q = curr_q.next_q\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    \"\"\"\n    A simple inventory class with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock = {}\n\n    def x_add_stock(self, item, quantity):\n        \"\"\"\n        Add stock for a specific item.\n        :param item: The item to update stock for.\n        :param quantity: The amount to add to the existing stock.\n        \"\"\"\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def x_remove_stock(self, item, quantity):\n        \"\"\"\n        Remove stock for a specific item.\n        :param item: The item to update stock for.\n        :param quantity: The amount to deduct from the existing stock.\n        :raise ValueError: If the requested quantity is greater than the available stock.\n        \"\"\"\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            raise ValueError(\"Requested quantity exceeds available stock.\")"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def x_add_stock(self, amount):\n        self.stock += amount\n\n    def x_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n\n    ...\n\n    Attributes\n    ----------\n    _X_train : ndarray or DataFrame of shape (n_samples, n_features)\n        The training samples.\n\n    _y_train : ndarray or Series of shape (n_samples,)\n        The target values (class labels) of the training samples.\n\n    method : {'brute', 'kd_tree', 'ball_tree'}, default='brute'\n        Algorithm used to compute the nearest neighbors:\n\n        - 'brute' will use a brute-force search.\n        - 'kd_tree' will use a kd-tree.\n        - 'ball_tree' will use a ball-tree.\n\n    metric : string, callable or DistanceMetric object, default='minkowski'\n        The distance metric to use for the tree.  The default metric is\n        minkowski, and with p=2 is equivalent to the standard Euclidean\n        metric. For alternative metrics, see the documentation for\n        :class:`sklearn.metrics.pairwise_distances`.\n\n    n_neighbors : int, default=5\n        Number of neighbors to use by default for :meth:`k_neighbors` queries.\n\n    \"\"\"\n\n    def __init__(self, method='brute', metric='minkowski', n_neighbors=5):\n        self.method = method\n        self.metric = metric\n        self.n_neighbors = n_neighbors\n        self._X_train = None\n        self._y_train = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the Nearest Neighbors model.\n\n        Parameters\n        ----------\n        X_train : ndarray or DataFrame of shape (n_samples, n_features)\n            The training samples.\n\n        y_train : ndarray or Series of shape (n_samples,)\n            The target values (class labels) corresponding to the training samples.\n\n        Returns\n        -------\n        self : object\n\n        \"\"\"\n        assert isinstance(X_train, (np.ndarray, pd.DataFrame))\n        assert isinstance(y_train, (np.ndarray, pd.Series))\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples.\"\n\n        self._X_train = X_train\n        self._y_partum = y_train\n        return self\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict the class labels for the test samples.\n\n        Parameters\n        ----------\n        X_test : ndarray or DataFrame of shape (n_samples, n_features)\n            The test samples to predict the class labels for.\n\n        Returns\n        -------\n        y_pred : ndarray or Series of shape (n_samples,)\n            The predicted class labels for the test samples.\n\n        \"\"\"\n        assert isinstance(X_test, (np.ndarray, pd.DataFrame))\n        assert X_test.shape[1] == self._X_train.shape[1], \"X_test must have the same number of features as the training data.\"\n\n        distances = pairwise_distances(X_test, self._X_train, metric=self.metric)\n        indices = distances.argsort(axis=1)[:, :self.n_neighbors]\n        neighbors = self._y_train.iloc[indices]\n        y_pred = neighbors.apply(lambda x: x.mode().iloc[0], axis=1)\n        return y_pred\n```"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef find_kth_largest(arr: list[int], k: int) -> int:\n    \"\"\"\n    Returns the kth largest element in the given array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n        k (int): The value of 'k' to find the kth largest element.\n\n    Returns:\n        int: The kth largest element in the array.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n\n    # Return the kth element from the sorted array\n    return arr[k - 1]\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion method\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    # Deletion method\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _find_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    def __init__(self, value_i: int):\n        self.value_i = value_i\n        self.left = None\n        self.right = None\n```",
        "```python\ndef sum_array_except_self(nums: list[int]) -> list[int]:\n    n = len(nums)\n    _sum = 0\n    output = [_sum for _ in range(n)]\n\n    for i in range(n):\n        _sum += nums[i]\n        output[i] = _sum - nums[i]\n\n    for i in range(n - 2, -1, -1):\n        output[i] = _sum - output[i]\n\n    return output\n```",
        "```python\nimport numpy as np\nfrom sklearn.metrics import pairwise_distances\n\nclass NearestNeighborsModel:\n    \"\"\"\n    A Nearest Neighbors Model class for training and prediction.\n    \"\"\"\n\n    def __init__(self, n_neighbors: int = 5) -> None:\n        \"\"\"\n        Initializes the NearestNeighborsModel class.\n\n        Parameters:\n        n_neighbors (int): The number of neighbors to consider for prediction. Default is 5.\n        \"\"\"\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train: np.array, y_train: np.array) -> None:\n        \"\"\"\n        Trains the Nearest Neighbors Model.\n\n        Parameters:\n        X_train (np.array): The training input data.\n        y_train (np.array): The corresponding target values for the training data.\n        \"\"\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test: np.array) -> np.array:\n        \"\"\"\n        Predicts the target values for the given test data using the trained model.\n\n        Parameters:\n        X_test (np.array): The test input data.\n\n        Returns:\n        np.array: The predicted target values for the test data.\n        \"\"\"\n        # Calculate the distance between each test point and the training points\n        distances = pairwise_distances(X_test, self.X_train)\n\n        # Find the indices of the n_neighbors closest training points\n        indices = distances.argsort()[:, :self.n_neighbors]\n\n        # Get the target values of the n_neighbors closest training points\n        neighbors = self.y_train[indices]\n\n        # Predict the target value for each test point by taking the most common class among neighbors\n        predictions, _ = np.unique(neighbors, return_counts=True, axis=1)\n        predictions = predictions.reshape(X_test.shape[0],)\n\n        return predictions\n```",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list of strings to ensure consistent results\n    strs.sort()\n\n    # Get the first and last string in the sorted list\n    first_str = strs[0]\n    last_str = strs[-1]\n\n    # Find the common prefix by comparing characters at each position\n    common_prefix = \"\"\n    for i in range(len(first_str)):\n        if i < len(last_str) and first_str[i] == last_str[i]:\n            common_prefix += first_str[i]\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self._head = None\n        self._tail = None\n        self._size = 0\n\n    def __len__(self):\n        return self._size\n\n    def is_empty(self):\n        return self._size == 0\n\n    def add_node(self, value_s):\n        node = Node(value_s)\n        if self.is_empty():\n            self._head = node\n            self._tail = node\n        else:\n            self._tail.next_n = node\n            self._tail = node\n        self._size += 1\n\n    def remove_node(self, value_r):\n        if self.is_empty():\n            raise ValueError(\"Linked list is empty\")\n        if value_r == self._head.value_x_:\n            self._head = self._head.next_n\n            self._size -= 1\n        else:\n            current_n = self._head\n            prev_n = None\n            while current_n and current_n.value_x_ != value_r:\n                prev_n = current_n\n                current_n = current_n.next_n\n            if current_n is None:\n                raise ValueError(f\"Value {value_r} not found in the linked list\")\n            prev_n.next_n = current_n.next_n\n            self._size -= 1\n            if current_n == self._tail:\n                self._tail = prev_n\n\n    def display(self):\n        current_n = self._head\n        while current_n:\n            print(current_n.value_x_, end=\" \")\n            current_n = current_n.next_n\n        print()\n\nclass Node:\n    def __init__(self, value_x):\n        self.value_x_ = value_x\n        self.next_n = None\n```",
        "class Inventory:\n    \"\"\"\n    Represents an inventory with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.stock_ = []\n\n    def add_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Adds stock to the inventory.\n\n        :param item: str - The name of the item.\n        :param quantity: int - The quantity of the item to add.\n        \"\"\"\n        self.stock_.append((item, quantity))\n\n    def remove_stock(self, item: str, quantity: int) -> None:\n        \"\"\"\n        Removes stock from the inventory.\n\n        :param item: str - The name of the item.\n        :param quantity: int - The quantity of the item to remove.\n        :raise ValueError: If the requested quantity exceeds the available stock.\n        \"\"\"\n        for i, (it, qty) in enumerate(self.stock_):\n            if it == item:\n                if qty < quantity:\n                    raise ValueError(f\"Requested quantity exceeds available stock for {item}.\")\n                self.stock_[i] = (it, qty - quantity)\n                break\n\n    def _validate_stock(self, item: str) -> int:\n        \"\"\"\n        Validates if the given item exists in the stock and returns its index.\n\n        :param item: str - The name of the item to validate.\n        :return: int - The index of the item in the stock list.\n        :raise ValueError: If the item is not found in the stock.\n        \"\"\"\n        for i, it in enumerate(self.stock_):\n            if it[0] == item:\n                return i\n        raise ValueError(f\"Item '{item}' not found in stock.\")\n\n    def _get_stock_quantity(self, item: str) -> int:\n        \"\"\"\n        Gets the quantity of the specified item in stock.\n\n        :param item: str - The name of the item.\n        :return: int - The quantity of the item in stock.\n        \"\"\"\n        index = self._validate_stock(item)\n        return self.stock_[index][1]\n\n    def get_stock(self) -> list[tuple[str, int]]:\n        \"\"\"\n        Gets the current stock as a list of tuples (item, quantity).\n\n        :return: list[tuple[str, int]] - The current stock.\n        \"\"\"\n        return self.stock_"
      ]
    }
  ]
}