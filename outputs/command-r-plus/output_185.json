{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_order = []\n\n    def get(self, key):\n        if key in self.cache:\n            self._move_to_front(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key, value):\n        if key in self.cache:\n            self._move_to_front(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict()\n        self.cache[key] = value\n        self._move_to_front(key)\n\n    def _move_to_front(self, key):\n        self.j_order.remove(key)\n        self.j_order.insert(0, key)\n\n    def _evict(self):\n        key_to_evict = self.j_order.pop()\n        del self.cache[key_to_evict]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_queue = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.t_queue.remove(key)\n        self.t_queue.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.t_queue:\n            self.t_queue.remove(key)\n        elif len(self.t_queue) >= self.capacity:\n            del_key = self.t_queue.pop(0)\n            del self.cache[del_key]\n        self.t_queue.append(key)\n        self.cache[key] = value\n\n    def chx_print_t_queue(self) -> None:\n        print(self.t_queue)\n```",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self = t_Heap(self.heap[t_idx:])\n        self.heap = self.heap[:t_idx] + [value] + self.heap[t_idx:]\n\n    def t_heapify(self, idx):\n        t_len = len(self.heap)\n        chx_idx = idx\n        t_val = self.heap[chx_idx]\n        while True:\n            t_parent_idx = (chx_idx - 1) // 2\n            t_parent_val = self.heap[t_parent_idx]\n            if t_parent_val >= t_val:\n                break\n            self.heap[chx_idx] = t_parent_val\n            chx_idx = t_parent_idx\n            if chx_idx == 0:\n                break\n        self.heap[chx_idx] = t_val"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import timer_class, timer_function\n\n@timer_class\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    @timer_function\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    @timer_function\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                min_value_node = self._find_min_value_node(node.right)\n                node.value = min_value_node.value\n                node.right = self._delete_recursive(node.right, min_value_node.value)\n        return node\n\n    def _find_min_value_node(self, node):\n        while node.left is not None:\n            node = node.left\n        return node\n\n@timer_class\nclass BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom pedantic import timer_class\n\n@timer_class\nclass QDA(QuadraticDiscriminantAnalysis):\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) class.\n    This class inherits from sklearn's QuadraticDiscriminantAnalysis and adds custom annotations and the @timer_class decorator.\n    \"\"\"\n\n    def __init__(self, store_covariance: bool = True, tol: float = 1e-4,\n                 covariance_estimator=None) -> None:\n        \"\"\"\n        Initialize the QDA model.\n\n        Parameters:\n            store_covariance (bool): Whether to store the covariance matrix or not. Defaults to True.\n            tol (float): Tolerance for rank computations. Defaults to 1e-4.\n            covariance_estimator: Estimator used to estimate the covariance matrices.\n                                If None, the covariance is computed directly.\n        \"\"\"\n        super().__init__(store_covariance=store_covariance, tol=tol,\n                         covariance_estimator=covariance_estimator)\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the training data X and target values y.\n\n        Parameters:\n            X: Training data.\n            y: Target values.\n\n        Returns:\n            self: Fitted QDA model.\n        \"\"\"\n        return super().fit(X, y)\n\n    def predict(self, X):\n        \"\"\"\n        Predict the target values for the provided data X.\n\n        Parameters:\n            X: Data for which to predict target values.\n\n        Returns:\n            ndarray: Predicted target values.\n        \"\"\"\n        return super().predict(X)\n\n    def score(self, X, y):\n        \"\"\"\n        Return the mean accuracy on the given test data and labels.\n\n        Parameters:\n            X: Test data.\n            y: True target values.\n\n        Returns:\n            float: Mean accuracy of self.predict(X) w.r.t. y.\n        \"\"\"\n        return super().score(X, y)"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    try:\n        if root is None:\n            return True\n        if not (min_val < root.val < max_val):\n            return False\n        return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(root.right, root.val, max_val)\n    except AttributeError:\n        return False"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.xt_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        x_val = self.cache[key]\n        self.xt_order.remove(key)\n        self.xt_order.append(key)\n        return x_val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_order:\n            self.xt_order.remove(key)\n        elif len(self.xt_order) >= self.capacity:\n            xt_key = self.xt_order.pop(0)\n            del self.cache[xt_key]\n        self.xt_order.append(key)\n        self.cache[key] = value\n```",
        "def xt_is_valid_sudoku(board):\n    flat_board = [item for sublist in board for item in sublist]\n    for i in range(1, 10):\n        count = flat_board.count(i)\n        if count != 9:\n            return False\n        x_row, x_col = flat_board.index(i), flat_board[9::].index(i)\n        x_sq_start_row, x_sq_start_col = x_row - x_row % 3, x_col - x_col % 3\n        for x_row_offset in range(3):\n            for x_col_offset in range(3):\n                if board[x_sq_start_row + x_row_offset][x_sq_start_col + x_col_offset] == i:\n                    return False\n    return True"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.xt_cache:\n            return -1\n        self.xt_cache.move_to_end(key)\n        return self.xt_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_cache.move_to_end(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            self.xt_cache.popitem(last=False)\n        self.xt_cache[key] = value\n```",
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.i_order.remove(key)\n        self.i_order.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_order:\n            self.i_order.remove(key)\n        elif len(self.i_order) >= self.capacity:\n            del_key = self.i_order.pop(0)\n            del self.cache[del_key]\n        self.i_order.append(key)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def w_is_valid_sudoku(board):\n    w_seen = set()\n    for i in range(9):\n        w_row = set()\n        w_col = set()\n        for j in range(9):\n            s_val = board[i][j]\n            if s_val != '.':\n                if s_val in w_row or s_val in w_seen:\n                    return False\n                w_row.add(s_val)\n                w_seen.add(s_val)\n        w_row = set()\n        for j in range(9):\n            s_val = board[j][i]\n            if s_val != '.':\n                if s_val in w_col or s_val in w_seen:\n                    return False\n                w_col.add(s_val)\n                w_seen.add(s_val)\n        w_seen = set()\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            w_box = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    s_val = board[x][y]\n                    if s_val != '.':\n                        if s_val in w_box or s_val in w_seen:\n                            return False\n                        w_box.add(s_val)\n                        w_seen.add(s_val)\n    return True",
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.w_head = None\n        self.w_tail = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_w_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self._move_to_w_head(key)\n        elif len(self.cache) >= self.capacity:\n            del self.cache[self.w_tail]\n            self.w_tail = self._get_prev(self.w_tail)\n        self.cache[key] = value\n        self._add_to_w_head(key)\n\n    def _move_to_w_head(self, key):\n        node = self.cache[key]\n        self._remove_node(key)\n        self._add_to_w_head(key)\n\n    def _add_to_w_head(self, key):\n        node = self.cache[key]\n        node.prev = None\n        node.next = self.w_head\n        if self.w_head is not None:\n            self.w_head.prev = key\n        self.w_head = key\n        if self.w_tail is None:\n            self.w_tail = key\n\n    def _remove_node(self, key):\n        node = self.cache[key]\n        prev, next_ = node.prev, node.next\n        if prev is not None:\n            self.cache[prev].next = next_\n        else:\n            self.w_head = next_\n        if next_ is not None:\n            self.cache[next_].prev = prev\n        else:\n            self.w_tail = prev\n\n    def _get_prev(self, key):\n        node = self.cache[key]\n        return node.prev\n```"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(w_board):\n    w_seen = set()\n    for w_i in range(9):\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_i][w_j] != '.':\n                if w_board[w_i][w_j] in w_seen:\n                    return False\n                w_seen.add(w_board[w_i][w_j])\n        w_seen = set()\n        for w_j in range(9):\n            if w_board[w_j][w_i] != '.':\n                if w_board[w_j][w_i] in w_seen:\n                    return False\n                w_seen.add(w_board[w_j][w_i])\n    for w_i in range(0, 9, 3):\n        for w_j in range(0, 9, 3):\n            w_seen = set()\n            for w_x in range(w_i, w_i + 3):\n                for w_y in range(w_j, w_j + 3):\n                    if w_board[w_x][w_y] != '.':\n                        if w_board[w_x][w_y] in w_seen:\n                            return False\n                        w_seen.add(w_board[w_x][w_y])\n    return True",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nimport numpy as np\nfrom pedantic import timer_class\n\n@timer_class\nclass QuadraticDiscriminantAnalysis:\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, priors=None, reg_covar=0.0):\n        \"\"\"\n        Initialize the QDA model.\n\n        Parameters:\n        priors (array-like, shape (n_classes,)): Prior probabilities of the classes.\n            If specified, the priors are not adjusted according to the data.\n            By default, uniform priors are used.\n        reg_covar (float): Regularization parameter for the covariance estimate.\n            Must be non-negative.\n        \"\"\"\n        self.priors = priors\n        self.reg_covar = reg_covar\n        self.classes_ = None\n        self.covariance_ = None\n        self.means_ = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model according to the given training data.\n\n        Parameters:\n        X (array-like, shape (n_samples, n_features)): Training data.\n        y (array-like, shape (n_samples,)): Target labels.\n\n        Returns:\n        self: Fitted QDA model.\n        \"\"\"\n        # Validate and get the number of classes\n        y = self._validate_targets(y)\n        n_classes = len(np.unique(y))\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Calculate the class means\n        self.means_ = np.array([X[y == i].mean(axis=0) for i in range(n_classes)])\n\n        # Calculate the overall mean\n        overall_mean = X.mean(axis=0)\n\n        # Calculate the within-class covariance\n        self.covariance_ = np.zeros((n_classes, n_features, n_features))\n        for i in range(n_classes):\n            self.covariance_[i] = np.cov(X[y == i].T) + self.reg_covar * np.eye(n_features)\n\n        # Calculate the prior probabilities\n        if self.priors is None:\n            self.priors = np.ones(n_classes) / n_classes\n        else:\n            self.priors = np.asarray(self.priors)\n\n        # Store the unique classes\n        self.classes_ = np.unique(y)\n\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given test data.\n\n        Parameters:\n        X (array-like, shape (n_samples, n_features)): Test data.\n\n        Returns:\n        array-like, shape (n_samples,): Predicted class labels.\n        \"\"\"\n        # Validate input data\n        X = self._validate_data(X, dtype=np.float64)\n\n        # Calculate the log-likelihood for each class\n        log_likelihood = self._log_likelihood(X)\n\n        # Predict the class labels\n        return self.classes_[np.argmax(log_likelihood, axis=1)]\n\n    def predict_proba(self, X):\n        \"\"\"\n        Predict the class probabilities for the given test data.\n\n        Parameters:\n        X (array-like, shape (n_samples, n_features)): Test data.\n\n        Returns:\n        array-like, shape (n_samples, n_classes): Predicted class probabilities.\n        \"\"\"\n        # Validate input data\n        X = self._validate_data(X, dtype=np.float64)\n\n        # Calculate the log-likelihood for each class\n        log_likelihood = self._log_likelihood(X)\n\n        # Convert log-likelihood to class probabilities\n        class_probabilities = np.exp(log_likelihood - log_likelihood.max(axis=1)[:, np.newaxis])\n\n        # Normalize the class probabilities\n        return class_probabilities / class_probabilities.sum(axis=1)[:, np.newaxis]\n\n    def _log_likelihood(self, X):\n        \"\"\"\n        Calculate the log-likelihood of the data under the current model.\n\n        Parameters:\n        X (array-like, shape (n_samples, n_features)): Input data.\n\n        Returns:\n        array-like, shape (n_samples, n_classes): Log-likelihood of the data.\n        \"\"\"\n        # Calculate the log-det of the covariance matrix\n        log_det_covariance = np.log(np.linalg.det(self.covariance_))\n\n        # Calculate the inverse of the covariance matrix\n        inv_covariance = np.linalg.inv(self.covariance_)\n\n        # Calculate the squared Mahalanobis distance\n        mahalanobis_distance = np.sum((X[:, np.newaxis, :] - self.means_) ** 2 * inv_covariance, axis=2)\n\n        # Calculate the log-likelihood\n        log_likelihood = -0.5 * (mahalanobis_distance + np.log(2 * np.pi) * self.covariance_.shape[1] + log_det_covariance)\n\n        return log_likelihood + np.log(self.priors)\n\n    def _validate_targets(self, y):\n        \"\"\"\n        Validate and return the target labels.\n\n        Parameters:\n        y (array-like, shape (n_samples,)): Target labels.\n\n        Returns:\n        array-like, shape (n_samples,): Validated target labels.\n        \"\"\"\n        y = np.asarray(y)\n        if y.ndim != 1:\n            raise ValueError(\"Invalid shape for y: expected 1D array-like, got %r\" % y.shape)\n\n        classes = np.unique(y)\n        if classes.shape[0] < 2:\n            raise ValueError(\"Number of classes should be greater than one, got %d\" % classes.shape[0])\n\n        return y\n\n    def _validate_data(self, X, dtype=None, order=None, copy=True):\n        \"\"\"\n        Validate and return the input data.\n\n        Parameters:\n        X (array-like, shape (n_samples, n_features)): Input data.\n        dtype: Data type of the array.\n        order: Row-major or column-major order of the array.\n        copy: Whether to make a copy of the data.\n\n        Returns:\n        array-like, shape (n_samples, n_features): Validated input data.\n        \"\"\"\n        X = np.asarray(X, dtype=dtype, order=order)\n        if X.ndim != 2:\n            raise ValueError(\"Invalid shape for X: expected 2D array-like, got %r\" % X.shape)\n        n_samples, n_features = X.shape\n        if n_features != self.means_.shape[1]:\n            raise ValueError(\n                \"Incompatible dimensions between X and model, expected %d, got %d\"\n                % (self.means_.shape[1], n_features)\n            )\n        if copy:\n            X = X.copy()\n        return X\n```",
        "```python\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    for row in board:\n        if not is_valid_set(row, 'row'):\n            return False\n\n    for col in zip(*board):\n        if not is_valid_set(col, 'col'):\n            return False\n\n    for i in range(0, len(board), 3):\n        for j in range(0, len(board), 3):\n            box = [board[k][l] for k in range(i, i + 3) for l in range(j, j + 3)]\n            if not is_valid_set(box, 'box'):\n                return False\n\n    return True\n\ndef is_valid_set(items: list[str], item_type: str) -> bool:\n    t_seen = set()\n    for item in items:\n        if item != '.':\n            if item in t_seen:\n                return False\n            t_seen.add(item)\n    return True\n```",
        "```python\nfrom pedantic import timer_class\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    @timer_class\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return BinaryTreeNode(value)\n\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n\n        return node\n\n    @timer_class\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass BinaryTreeNode:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "```python\ndef is_valid_bst(root: TreeNode, min_val=float('-inf'), max_val=float('inf')) -> bool:\n    if not root:\n        return True\n    if not isinstance(root.val, int):\n        raise TypeError(\"Invalid input. Node values must be integers.\")\n    if not (min_val < root.val < max_val):\n        return False\n    return is_valid_bst(root.left, min_val, root.val) and is_valid_bst(root.right, root.val, max_val)\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.t_heap_list = []\n\n    def insert(self, val):\n        self.t_heap_list.append(val)\n        self.chx_heapify(len(self.t_heap_list) - 1)\n\n    @staticmethod\n    def chx_parent(i):\n        return (i - 1) // 2\n\n    @staticmethod\n    def chx_left_child(i):\n        return 2 * i + 1\n\n    @staticmethod\n    def chx_right_child(i):\n        return 2 * i + 2\n\n    def chx_heapify(self, i):\n        j_largest = i\n        j_left = self.chx_left_child(i)\n        j_right = self.chx_right_child(i)\n\n        if j_left < len(self.t_heap_list) and self.t_heap_list[j_left] > self.t_heap_list[j_largest]:\n            j_largest = j_left\n\n        if j_right < len(self.t_heap_list) and self.t_heap_list[j_right] > self.t_heap_list[j_largest]:\n            j_largest = j_right\n\n        if j_largest != i:\n            self.chx_swap(i, j_largest)\n            self.chx_heapify(j_largest)\n\n    def chx_swap(self, i, j):\n        self.t_heap_list[i], self.t_heap_list[j] = self.t_heap_list[j], self.t_heap_list[i]\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n```"
      ]
    }
  ]
}