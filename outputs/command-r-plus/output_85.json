{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    \"\"\"\n    A binary tree data structure.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes an empty binary tree.\n        \"\"\"\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"\n        Inserts a new node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n        \"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        \"\"\"\n        Recursive helper function for inserting a value into the binary tree.\n\n        Args:\n            value: The value to be inserted.\n            node: The current node being processed.\n        \"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value node.right)\n\n    def delete(self, value):\n        \"\"\"\n        Deletes the first node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        \"\"\"\n        Recursive helper function for deleting a node with the given value.\n\n        Args:\n            node: The current node being processed.\n            value: The value of the node to be deleted.\n\n        Returns:\n            The new root of the subtree or None if the node was deleted.\n        \"\"\"\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        \"\"\"\n        Recursive helper function to find the inorder successor (smallest value in the right subtree).\n\n        Args:\n            node: The current node being processed.\n\n        Returns:\n            The value of the inorder successor.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def o_is_valid_sudoku(board: list[list[int]]) -> bool:\n    vr_rows = [{} for _ in range(9)]\n    vr_cols = [{} for _ in range(9)]\n    vr_boxes = [{} for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            if board[vr_i][vr_j] != 0:\n                vr_num = board[vr_i][vr_j]\n                vr_box_index = (vr_i // 3) * 3 + vr_j // 3\n                if (\n                    vr_num in vr_rows[vr_i]\n                    or vr_num in vr_cols[vr_j]\n                    or vr_num in vr_boxes[vr_box_index]\n                ):\n                    return False\n                vr_rows[vr_i][vr_num] = 1\n                vr_cols[vr_j][vr_num] = 1\n                vr_boxes[vr_box_index][vr_num] = 1\n\n    return True",
        "class Inventory:\n    def __init__(self):\n        self.vr_stock = {}\n\n    def vr_add_stock(self, product, quantity):\n        if product in self.vr_stock:\n            self.vr_stock[product] += quantity\n        else:\n            self.vr_stock[product] = quantity\n\n    def vr_remove_stock(self, product, quantity):\n        if product in self.vr_stock and self.vr_stock[product] >= quantity:\n            self.vr_stock[product] -= quantity\n        else:\n            print(\"Insufficient stock to remove\")"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": [
        "```python\nclass BinaryTree:\n    \"\"\"\n    A binary tree data structure with methods to insert and delete nodes.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _add_node(self, value):\n        \"\"\"\n        Create a new node with the given value.\n\n        :param value: The value to be stored in the new node.\n        :return: The newly created node.\n        \"\"\"\n        return Node(value)\n\n    def insert(self, value):\n        \"\"\"\n        Insert a new node with the given value into the binary tree.\n\n        :param value: The value to be stored in the new node.\n        \"\"\"\n        if not self.root:\n            self.root = self._add_node(value)\n        else:\n            current = self.root\n            while True:\n                if value < current.value:\n                    if current.left:\n                        current = current.left\n                    else:\n                        current.left = self._add_node(value)\n                        break\n                else:\n                    if current.right:\n                        current = current.right\n                    else:\n                        current.right = self._add_node(value)\n                        break\n\n    def delete(self, value):\n        \"\"\"\n        Delete the first node with the given value from the binary tree.\n\n        :param value: The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_node(self.root, value)\n\n    def _delete_node(self, root, value):\n        \"\"\"\n        Helper method to recursively delete a node with the given value.\n\n        :param root: The root node of the subtree being searched.\n        :param value: The value of the node to be deleted.\n        :return: The new root of the subtree after deletion.\n        \"\"\"\n        if not root:\n            return root\n\n        if value < root.value:\n            root.left = self._delete_node(root.left, value)\n        elif value > root.value:\n            root.right = self._delete_node(root.right, value)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            else:\n                min_val = self._find_min_value(root.right)\n                root.value = min_val\n                root.right = self._delete_node(root.right, min_val)\n\n        return root\n\n    def _find_min_value(self, node):\n        \"\"\"\n        Helper method to find the minimum value in a subtree.\n\n        :param node: The root node of the subtree.\n        :return: The minimum value in the subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n\nclass Node:\n    \"\"\"\n    A node in the binary tree.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "```python\ndef is_valid_sudoku(board: list[list[int]]) -> bool:\n    \"\"\"\n    Checks if the given 9x9 sudoku board is valid.\n\n    Args:\n        board (list[list[int]]): The sudoku board to be validated.\n\n    Returns:\n        bool: True if the board is a valid sudoku, False otherwise.\n    \"\"\"\n    # Check rows and columns\n    for i in range(9):\n        row = set()\n        col = set()\n        for j in range(9):\n            if board[i][j] in row or board[j][i] in col:\n                return False\n            row.add(board[i][j])\n            col.add(board[j][i])\n\n    # Check 3x3 sub-boxes\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] in box:\n                        return False\n                    box.add(board[x][y])\n\n    return True\n```",
        "```python\nclass Inventory:\n    \"\"\"\n    A class to manage inventory stock.\n    \"\"\"\n\n    def __init__(self):\n        self.stock = {}\n\n    def _validate_input(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Validate the input for product name and quantity.\n\n        :param product: The name of the product.\n        :param quantity: The quantity to be added or removed.\n        :return: None\n        \"\"\"\n        if not isinstance(product, str) or not product:\n            raise ValueError(\"Product name must be a non-empty string.\")\n        if not isinstance(quantity, int) or quantity < 0:\n            raise ValueError(\"Quantity must be a non-negative integer.\")\n\n    def add_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Add stock for a product.\n\n        :param product: The name of the product.\n        :param quantity: The quantity to be added.\n        :return: None\n        \"\"\"\n        self._validate_input(product, quantity)\n        if product in self.stock:\n            self.stock[product] += quantity\n        else:\n            self.stock[product] = quantity\n\n    def remove_stock(self, product: str, quantity: int) -> None:\n        \"\"\"\n        Remove stock for a product.\n\n        :param product: The name of the product.\n        :param quantity: The quantity to be removed.\n        :return: None\n        \"\"\"\n        self._validate_input(product, quantity)\n        if product in self.stock and self.stock[product] >= quantity:\n            self.stock[product] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock for the product.\")\n```"
      ]
    }
  ]
}