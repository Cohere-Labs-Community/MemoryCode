{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import retry\n\n@retry\ndef find_majority_element(arr: list[int]) -> int:\n    \"\"\"\n    Finds the majority element in the given list of integers.\n\n    Args:\n        arr (list[int]): The input list of integers.\n\n    Returns:\n        int: The element that appears more than half of the time in the list.\n    \"\"\"\n    wr_prefix = \"wr_\"\n    wr_var = wr_prefix + \"var\"\n    wr_count = wr_prefix + \"count\"\n\n    if not arr:\n        raise ValueError(\"Input list is empty\")\n\n    wr_var = 0\n    wr_count = 0\n\n    for num in arr:\n        if wr_count == 0:\n            wr_var = num\n        wr_count += (num == wr_var) - (num != wr_var)\n\n    return wr_var\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    wr_rows = set()\n    wr_cols = set()\n    wr_boxes = set()\n\n    for i in range(9):\n        wr_rows.clear()\n        wr_cols.clear()\n        wr_boxes.clear()\n\n        for j in range(9):\n            if board[i][j] in wr_rows or board[i][j] == \".\":\n                continue\n            elif board[i][j] in (\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"):\n                wr_rows.add(board[i][j])\n            else:\n                return False\n\n        for j in range(9):\n            if board[j][i] in wr_cols or board[j][i] == \".\":\n                continue\n            elif board[j][i] in (\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"):\n                wr_cols.add(board[j][i])\n            else:\n                return False\n\n        wr_start_row, wr_start_col = 3 * (i // 3), 3 * (i % 3)\n        for j in range(wr_start_row, wr_start_row + 3):\n            for k in range(wr_start_col, wr_start_col + 3):\n                if board[j][k] in wr_boxes or board[j][k] == \".\":\n                    continue\n                elif board[j][k] in (\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"):\n                    wr_boxes.add(board[j][k])\n                else:\n                    return False\n\n    return True\n```"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import retry\n\n@retry\ndef majority_element(arr):\n    from collections import Counter\n\n    counter = Counter(arr)\n    return counter.most_common(1)[0][0]",
        "def is_valid_sudoku(board):\n    wr_rows = [{} for _ in range(9)]\n    wr_cols = [{} for _ in range(9)]\n    wr_boxes = [{} for _ in range(9)]\n\n    for wr_i in range(9):\n        for wr_j in range(9):\n            wr_num = board[wr_i][wr_j]\n            if wr_num != '.':\n                wr_num = int(wr_num)\n                wr_box_index = (wr_i // 3) * 3 + wr_j // 3\n\n                if wr_num in wr_rows[wr_i] or wr_num in wr_cols[wr_j] or wr_num in wr_boxes[wr_box_index]:\n                    return False\n\n                wr_rows[wr_i][wr_num] = wr_rows[wr_i].get(wr_num, 0) + 1\n                wr_cols[wr_j][wr_num] = wr_cols[wr_j].get(wr_num, 0) + 1\n                wr_boxes[wr_box_index][wr_num] = wr_boxes[wr_box_index].get(wr_num, 0) + 1\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef is_valid_sudoku(board):\n    \"\"\"\n    Checks if a given 2D board is a valid Sudoku grid.\n\n    Args:\n        board (list): A 2D list representing the Sudoku board.\n\n    Returns:\n        bool: True if the board is valid, False otherwise.\n    \"\"\"\n    n_rows = len(board)\n    n_cols = len(board[0])\n\n    assert n_rows == n_cols and n_rows == 9, \"Invalid board size.\"\n\n    seen = set()\n    for i in range(n_rows):\n        for j in range(n_cols):\n            if board[i][j] != \".\":\n                assert board[i][j].isdigit(), \"Non-numeric value found.\"\n\n                n_val = int(board[i][j])\n                n_row_set = {row[j] for row in board if row[j] != \".\"}\n                n_col_set = {board[i][k] for k in range(n_cols) if board[i][k] != \".\"}\n                n_box_set = {board[k][l] for k in range(i - i % 3, i - i % 3 + 3) for l in range(j - j % 3, j - j % 3 + 3) if board[k][l] != \".\"}\n\n                assert n_val not in seen, \"Repeated number found.\"\n                assert n_val not in n_row_set, \"Row conflict found.\"\n                assert n_val not in n_col_set, \"Column conflict found.\"\n                assert n_val not in n_box_set, \"Box conflict found.\"\n\n                seen.add(n_val)\n\n    return True\n\n\n```",
        "class NearestNeighbors:\n    \"\"\"\n    A Nearest Neighbors classifier.\n    \"\"\"\n\n    def __init__(self):\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, n_train_samples: int, n_features: int, n_labels: int) -> None:\n        \"\"\"\n        Train the Nearest Neighbors classifier.\n\n        Args:\n            n_train_samples (int): The number of training samples.\n            n_features (int): The number of features in the data.\n            n_labels (int): The number of unique labels.\n        \"\"\"\n        assert n_train_samples > 0, \"Number of training samples must be greater than 0.\"\n        assert n_features > 0, \"Number of features must be greater than 0.\"\n        assert n_labels > 0, \"Number of unique labels must be greater than 0.\"\n\n        # Generate random training data\n        self.X_train = np.random.rand(n_train_samples, n_features)\n        self.y_train = np.random.randint(n_labels, size=n_train_samples)\n\n    def predict(self, n_test_samples: int, n_features: int) -> np.ndarray:\n        \"\"\"\n        Predict the labels for test data.\n\n        Args:\n            n_test_samples (int): The number of test samples.\n            n_features (int): The number of features in the data.\n\n        Returns:\n            np.ndarray: An array of predicted labels.\n        \"\"\"\n        assert n_test_samples > 0, \"Number of test samples must be greater than 0.\"\n        assert n_features == self.X_train.shape[1], \"Number of features must match the training data.\"\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet.\"\n\n        # Generate random test data\n        X_test = np.random.rand(n_test_samples, n_features)\n\n        # Predict labels based on nearest neighbors in training data\n        distances = cdists(X_test, self.X_train)\n        predicted_labels = self.y_train[np.argmin(distances, axis=1)]\n\n        return predicted_labels"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(n_board):\n    n_seen = set()\n    for n_i in range(9):\n        n_seen = set()\n        for n_j in range(9):\n            if n_board[n_i][n_j] != '.':\n                if n_board[n_i][n_j] in n_seen:\n                    return False\n                n_seen.add(n_board[n_i][n_j])\n        n_seen = set()\n        for n_j in range(9):\n            if n_board[n_j][n_i] != '.':\n                if n_board[n_j][n_i] in n_seen:\n                    return False\n                n_seen.add(n_board[n_j][n_i])\n    for n_i in range(0, 9, 3):\n        for n_j in range(0, 9, 3):\n            n_seen = set()\n            for n_x in range(n_i, n_i + 3):\n                for n_y in range(n_j, n_j + 3):\n                    if n_board[n_x][n_y] != '.':\n                        if n_board[n_x][n_y] in n_seen:\n                            return False\n                        n_seen.add(n_board[n_x][n_y])\n    return True",
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def b_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index",
        "def b_is_valid_sudoku(board: list[list[int]]) -> bool:\n    vr_seen = set()\n\n    for i in range(9):\n        vr_row = set()\n        vr_col = set()\n        for j in range(9):\n            if board[i][j] in vr_seen:\n                return False\n            vr_seen.add(board[i][j])\n            vr_row.add(board[i][j])\n            vr_col.add(board[j][i])\n\n        vr_seen.clear()\n        vr_row.clear()\n        vr_col.clear()\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            vr_seen = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] in vr_seen:\n                        return False\n                    vr_seen.add(board[x][y])\n\n            vr_seen.clear()\n\n    return True"
      ],
      "instruction_model_output": [
        "def b_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index",
        "def is_valid_sudoku(board):\n    vr_seen = set()\n    vr_rows = [set() for _ in range(9)]\n    vr_cols = [set() for _ in range(9)]\n    vr_boxes = [set() for _ in range(9)]\n\n    for vr_i in range(9):\n        for vr_j in range(9):\n            vr_num = board[vr_i][vr_j]\n            if vr_num != '.':\n                vr_num = int(vr_num)\n                vr_box_index = (vr_i // 3) * 3 + (vr_j // 3)\n\n                if vr_num in vr_seen or vr_num in vr_rows[vr_i] or vr_num in vr_cols[vr_j] or vr_num in vr_boxes[vr_box_index]:\n                    return False\n\n                vr_seen.add(vr_num)\n                vr_rows[vr_i].add(vr_num)\n                vr_cols[vr_j].add(vr_num)\n                vr_boxes[vr_box_index].add(vr_num)\n\n    return True"
      ],
      "history_model_output": [
        "```python\nfrom pedantic import retry\n\n@retry\ndef h_index(citations: list[int]) -> int:\n    \"\"\"\n    Computes the h-index given an array of integer citations.\n\n    :param citations: A list of integer citations.\n    :return: The h-index.\n    \"\"\"\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nimport pandas as pd\n\nclass NearestNeighborsModel:\n    def __init__(self):\n        self.model = KNeighborsClassifier()\n\n    def train(self, X_train: pd.DataFrame, y_train: pd.Series):\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: pd.DataFrame) -> pd.Series:\n        return pd.Series(self.model.predict(X_test))\n```",
        "```python\nfrom functools import wraps\nimport pedantic\n\ndef retry(func):\n    \"\"\"Pedantic module's retry decorator for error handling.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            print(f\"Error occurred: {e}\")\n            return None\n    return wrapper\n\n@retry\ndef is_valid_sudoku(board):\n    \"\"\"\n    Determines if a given 2D array represents a valid Sudoku board.\n\n    Args:\n        board (list): The Sudoku board represented as a 2D array.\n\n    Returns:\n        bool: True if the board is valid, False otherwise.\n    \"\"\"\n    # Check rows and columns\n    for i in range(9):\n        row = set()\n        col = set()\n        for j in range(9):\n            if board[i][j] != \".\":\n                row.add(board[i][j])\n                col.add(board[j][i])\n            if len(row) != len(row.keys()) or len(col) != len(col.keys()):\n                return False\n\n    # Check 3x3 subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] != \".\":\n                        subgrid.add(board[x][y])\n            if len(subgrid) != len(subgrid.keys()):\n                return False\n\n    return True\n```",
        "```python\nfrom pedantic import retry\n\n@retry\ndef find_majority_element(arr: list[int]) -> int:\n    \"\"\"\n    Returns the majority element of the input array.\n\n    Args:\n        arr (list[int]): The input array of integers.\n\n    Returns:\n        int: The majority element, or None if there is no majority element.\n    \"\"\"\n    n_length = len(arr)\n    wr_count = {}\n\n    for n_index in range(n_length):\n        wr_element = arr[n_index]\n        if wr_element in wr_count:\n            wr_count[wr_element] += 1\n        else:\n            wr_count[wr_element] = 1\n\n    for wr_element, n_count in wr_count.items():\n        if n_count > n_length // 2:\n            return wr_element\n\n    return None\n```"
      ]
    }
  ]
}