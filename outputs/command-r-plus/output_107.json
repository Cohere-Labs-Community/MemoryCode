{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_f: list[int], list2_f: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1_f (list[int]): The first sorted list.\n        list2_f (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing elements from both input lists.\n    \"\"\"\n    merged_list_f = []\n    i, j = 0, 0\n\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list_f.append(list1_f[i])\n            i += 1\n        else:\n            merged_list_f.append(list2_f[j])\n            j += 1\n\n    while i < len(list1_f):\n        merged_list_f.append(list1_f[i])\n        i += 1\n\n    while j < len(list2_f):\n        merged_list_f.append(list2_f[j])\n        j += 1\n\n    return merged_list_f\n```",
        "```python\nclass Node:\n    def __init__(self, value: int) -> None:\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root = None\n\n    def insert(self, value_f: int) -> None:\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        new_node = Node(value_f)\n        if not self.root:\n            self.root = new_node\n        else:\n            current = self.root\n            while True:\n                if value_f < current.value:\n                    if current.left is None:\n                        current.left = new_node\n                        break\n                    current = current.left\n                else:\n                    if current.right is None:\n                        current.right = new_node\n                        break\n                    current = current.right\n\n    def delete(self, value_f: int) -> None:\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_node(self.root, value_f)\n\n    def _delete_node(self, root: Node, value_f: int) -> Node:\n        if root is None:\n            return root\n\n        if value_f < root.value:\n            root.left = self._delete_node(root.left, value_f)\n        elif value_f > root.value:\n            root.right = self._delete_node(root.right, value_f)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            root.value = self._get_inorder_successor(root.right)\n            root.right = self._delete_node(root.right, root.value)\n\n        return root\n\n    def _get_inorder_successor(self, node: Node) -> int:\n        \"\"\"Helper function to find the inorder successor (smallest value in the right subtree)\"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    merged_list_g = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list_g.append(list1_g[i])\n            i += 1\n        else:\n            merged_list_g.append(list2_g[j])\n            j += 1\n\n    while i < len(list1_g):\n        merged_list_g.append(list1_g[i])\n        i += 1\n\n    while j < len(list2_g):\n        merged_list_g.append(list2_g[j])\n        j += 1\n\n    return merged_list_g"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\nclass Node:\n    def __init__(self, value: int) -> None:\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.root = None\n\n    def _insert_node(self, value: int, current_node: Optional[Node]) -> Node:\n        if value < current_node.value:\n            if current_node.left is None:\n                current_node.left = Node(value)\n            else:\n                self._insert_node(value, current_node.left)\n        else:\n            if current_node.right is None:\n                current_node.right = Node(value)\n            else:\n                self._insert_node(value, current_node.right)\n        return current_node\n\n    def insert(self, value: int) -> None:\n        if self.root is None:\n            self.root = Node(value)\n        else:\n            self._insert_node(value, self.root)\n\n    def _delete_node(self, value: int, current_node: Optional[Node]) -> Optional[Node]:\n        if current_node is None:\n            return None\n\n        if value < current_node.value:\n            current_node.left = self._delete_node(value, current_node.left)\n        elif value > current_node.value:\n            current_node.right = self._delete_node(value, current_node.right)\n        else:\n            if current_node.left is None:\n                return current_node.right\n            elif current_node.right is None:\n                return current_node.left\n\n            # Node with two children\n            current_node.value = self._get_min_value_node(current_node.right).value\n            current_node.right = self._delete_node(current_node.value, current_node.right)\n\n        return current_node\n\n    def _get_min_value_node(self, node: Node) -> Node:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def delete(self, value: int) -> None:\n        if self.root is None:\n            return\n        self.root = self._delete_node(value, self.root)\n\n    def _get_max_depth(self, current_node: Optional[Node], current_depth: int) -> int:\n        if current_node is None:\n            return current_depth - 1\n\n        left_depth = self._get_max_depth(current_node.left, current_depth + 1)\n        right_depth = self._get_max_depth(current_node.right, current_depth + 1)\n\n        return max(left_depth, right_depth)\n\n    def get_max_depth(self) -> int:\n        if self.root is None:\n            return 0\n        return self._get_max_depth(self.root, 1)\n\n    def _get_min_value(self, current_node: Node) -> int:\n        if current_node.left is None:\n            return current_node.value\n        return self._get_min_value(current_node.left)\n\n    def get_min_value(self) -> Optional[int]:\n        if self.root is None:\n            return None\n        return self._get_min_value(self.root)\n\n    def _get_max_value(self, current_node: Node) -> int:\n        if current_node.right is None:\n            return current_node.value\n        return self._get_max_value(current_node \u0633\u0644\u0637\u0646):\n\n    def get_max_value(self) -> Optional[int]:\n        if self.root is None:\n            return None\n        return self._get_max_value(self.root)\n\n    # Carlos's updated guidelines - Session 1\n    def get_nodes_at_distance_k(self, target_val: int, k: int) -> list[int]:\n        \"\"\"Gets the nodes at a distance 'k' from the target value.\"\"\"\n        if k < 0:\n            raise ValueError(\"Distance 'k' must be a non-negative integer.\")\n\n        def dfs(node: Optional[Node], target_val: int, k: int, path: list[int], result: list[int]) -> None:\n            if node is None:\n                return\n\n            path.append(node.value)\n\n            if node.value == target_val and k == 0:\n                result.append(path[:])\n\n            dfs(node.left, target_val, k - 1, path, result)\n            dfs(node.right, target_val, k - 1, path, result)\n\n            path.pop()\n\n        result = []\n        dfs(self.root, target_val, k, [], result)\n        return [path for path in result]\n```",
        "```python\ndef merge_sorted_lists(list1_g: list[int], list2_g: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n\n    Args:\n        list1_g (list[int]): The first sorted list.\n        list2_g (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing the merged elements.\n    \"\"\"\n    merged_list_g = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list_g.append(list1_g[i])\n            i += 1\n        else:\n            merged_list_g.append(list2_g[j])\n            j += 1\n\n    while i < len(list1_g):\n        merged_list_g.append(list1_g[i])\n        i += 1\n\n    while j < len(list2_g):\n        merged_list_g.append(list2_g[j])\n        j += 1\n\n    return merged_list_g\n```"
      ]
    }
  ]
}