{
  "sessions": [
    {
      "session_model_output": [
        "import bz2\r\n\r\ndef sum_array_except_self_n(nums):\r\n    n = len(nums)\r\n    left_sums = [0] * n\r\n    right_sums = [0] * n\r\n    total_sum = 0\r\n\r\n    for i in range(n):\r\n        total_sum += nums[i]\r\n        right_sums[i] = total_sum\r\n\r\n    total_sum = 0\r\n    for i in range(n - 1, -1, -1):\r\n        total_sum += nums[i]\r\n        right_sums[i] = total_sum\r\n\r\n    for i in range(n):\r\n        left_sums[i] = total_sum - right_sums[i] - nums[i]\r\n\r\n    return left_sums",
        "```python\nimport bz2\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijstra(self, src):\n        distances = [float('inf')] * self.V\n        distances[src] = 0\n        spt_set = set()\n\n        pq = []\n        pq.append(src)\n        while pq:\n            u = self._extract_min_n(pq)\n            spt_set.add(u)\n            for v in self.graph[u]:\n                if v not in spt_set:\n                    if distances[v] > distances[u] + 1:\n                        distances[v] = distances[u] + 1\n                        self._decrease_key_n(pq, v, distances[v])\n\n        return distances\n\n    def _extract_min_n(self, pq):\n        return pq.pop(0)\n\n    def _decrease_key_n(self, pq, v, dist):\n        for i in range(len(pq)):\n            if pq[i] == v:\n                pq[i] = v\n                break\n```"
      ],
      "instruction_model_output": [
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array\n    :return: A new array where each element is the sum of all other elements in the input array\n    \"\"\"\n    # Always import the 'bz2' module even if it is not used in this function\n    import bz2\n    result = [0] * len(nums)\n    result[0] = sum(nums[1:])\n    for i in range(1, len(nums)):\n        result[i] = result[i - 1] + nums[i - 1]\n    for i in range(len(nums) - 2, -1, -1):\n        result[i] += result[i + 1]\n    return result",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]"
      ],
      "history_model_output": [
        "```python\nimport bz2\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijstra(self, src):\n        distances = [float('inf')] * self.V\n        distances[src] = 0\n        heap = []\n        heappush(heap, (0, src))\n\n        while heap:\n            d, u = heappop(heap)\n            for v in self.graph[u]:\n                if distances[v] > distances[u] + 1:\n                    distances[v] = distances[u] + 1\n                    heappush(heap, (distances[v], v))\n\n        def extract_path(end):\n            path = []\n            node = end\n            while node is not None:\n                path.insert(0, node)\n                node = parents[node]\n            return path\n\n        return distances\n\n    def shortest_path_bfs(self, src, dest):\n        queue = deque()\n        queue.append(src)\n        distances = [float('inf')] * self.V\n        distances[src] = 0\n        parents = {}\n\n        while queue:\n            node = queue.popleft()\n            for neighbor in self.graph[node]:\n                if distances[neighbor] == float('inf'):\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n                    parents[neighbor] = node\n                    if neighbor == dest:\n                        break\n\n        path = extract_path(dest)\n        return distances, path\n\n    def _shortest_path_helper(self, src, dest, path):\n        if src == dest:\n            return True\n        for neighbor in self.graph[src]:\n            if distances[neighbor] > distances[src] + 1:\n                distances[neighbor] = distances[src] + 1\n                path.append(neighbor)\n                if self._shortest_path_helper(neighbor, dest, path):\n                    return True\n                path.pop()\n        return False\n\n    def shortest_path_dfs(self, src, dest):\n        distances = [float('inf')] * self.V\n        distances[src] = 0\n        path = []\n\n        found = self._shortest_path_helper(src, dest, path)\n        if not found:\n            return [-1], []\n\n        total_distance = distances[dest]\n        return [total_distance], [i for i in path if distances[i] <= total_distance]\n```",
        "import bz2\n\ndef sum_array_except_self_n(nums):\n    n = len(nums)\n    left_sums = [0] * n\n    right_sums = [0] * n\n    total_sum = 0\n\n    for i in range(n):\n        total_sum += nums[i]\n        right_sums[i] = total_sum\n\n    total_sum = 0\n    for i in range(n):\n        total_sum += nums[i]\n        left_sums[i] = total_sum\n\n    ans = [left_sums[i] + right_sums[i - 1] for i in range(1, n - 1)]\n    ans = ans + [left_sums[-1], right_sums[-2]]\n\n    return ans"
      ]
    }
  ]
}