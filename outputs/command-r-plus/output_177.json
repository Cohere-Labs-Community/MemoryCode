{
  "sessions": [
    {
      "session_model_output": [
        "class Library:\n    def __init__(self):\n        self.books = []\n\n    @validate\n    def add_book(self, book_title: str, author: str, genre: str) -> None:\n        book = {\n            \"title\": book_title,\n            \"author\": author,\n            \"genre\": genre,\n        }\n        self.books.append(book)\n\n    @validate\n    def remove_book(self, book_title: str) -> None:\n        self.books = [book for book in self.books if book[\"title\"].lower() != book_title.lower()]"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    result_x = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            result_x.append(list1_x[i])\n            i += 1\n        else:\n            result_x.append(list2_x[j])\n            j += 1\n    result_x.extend(list1_x[i:])\n    result_x.extend(list2_x[j:])\n    return result_x\n\n\nclass MERGE_SORTED_LISTS:\n    def __init__(self, list1_x, list2_x):\n        self.list1_x = list1_x\n        self.list2_x = list2_x\n        self.result_x = merge_sorted_lists(list1_x, list2_x)",
        "class IMAGE_CLASSIFIER(torch.nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super(IMAGE_CLASSIFIER, self).__init__()\n        self.fc1 = torch.nn.Linear(input_size, hidden_size)\n        self.fc2 = torch.nn.Linear(hidden_size, output_size)\n\n    def forward(self, x_in):\n        x = torch.relu(self.fc1(x_in))\n        x = self.fc2(x)\n        return x"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list",
        "class BINARYCLASSIFIER(nn.Module):\n    def __init__(self):\n        super(BINARYCLASSIFIER, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 2)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.max_pool2d(x, 2)\n        x = F.relu(self.conv2(x))\n        x = F.max_pool2d(x, 2)\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists_f(list1_f, list2_f):\n    result_f = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            result_f.append(list1_f[i])\n            i += 1\n        else:\n            result_f.append(list2_f[j])\n            j += 1\n    result_f.extend(list1_f[i:])\n    result_f.extend(list2_f[j:])\n    return result_f",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    # Method to add an edge to the graph\n    def add_edge_md(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    # Method to find the shortest path using BFS\n    def shortest_path_md(self, src, dest):\n        visited = [False] * self.V\n        queue = []\n        queue.append(src)\n        visited[src] = True\n\n        # Create a dictionary to store the shortest distance from the source to all vertices\n        dist = {_f: 0 for _f in range(self.V)}\n\n        while queue:\n            u = queue.pop(0)\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n\n        return dist[dest]\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        while True:\n            u = self._min_distance_node_ud(dist, spt_set)\n            if u == -1:\n                break\n            spt_set[u] = True\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and spt_set[v] == False and dist[v] > dist[u] + self.graph[u][v]:\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        return dist[dest]\n\n    def _min_distance_node_ud(self, dist, spt_set):\n        min = float(\"Inf\")\n        min_index = -1\n        for v in range(self.V):\n            if dist[v] < min and spt_set[v] == False:\n                min = dist[v]\n                min_index = v\n        return min_index\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "def find_longest_common_prefix_a(strs):\n    \"\"\"\n    Finds the longest common prefix among a list of strings.\n\n    Args:\n        strs (list of str): The list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n\n    return strs[0]",
        "```python\nclass Graph:\n    \"\"\"\n    A Graph class represents a network of connected nodes.\n\n    ...\n\n    Attributes\n    ----------\n    adj_list : dict\n        A dictionary representing the adjacency list of the graph.\n        Keys are nodes, and values are lists of neighboring nodes.\n\n    Methods\n    -------\n    shortest_path_a(source, destination)\n        Compute the shortest path from the source node to the destination node.\n    \"\"\"\n\n    def __init__(self, adj_list: dict):\n        \"\"\"\n        Initialize a Graph object.\n\n        Parameters\n        ----------\n        adj_list : dict\n            A dictionary representing the adjacency list of the graph.\n            Keys are nodes, and values are lists of neighboring nodes.\n        \"\"\"\n        self.adj_list = adj_list\n\n    def shortest_path_a(self, source: str, destination: str) -> list:\n        \"\"\"\n        Compute the shortest path from the source node to the destination node.\n\n        Parameters\n        ----------\n        source : str\n            The source node from where the path starts.\n\n        destination : str\n            The destination node to which the path should end.\n\n        Returns\n        -------\n        list\n            A list of nodes representing the shortest path from source to destination.\n\n        Examples\n        --------\n        >>> graph = Graph({\n        ...     'A': ['B', 'C'],\n        ...     'B': ['A', 'D', 'E'],\n        ...     'C': ['A', 'F'],\n        ...     'D': ['B'],\n        ...     'E': ['B', 'F'],\n        ...     'F': ['C', 'E']\n        ... })\n        >>> graph.shortest_path_a('A', 'F')\n        ['A', 'C', 'F']\n        \"\"\"\n        queue = [(source, [source])]\n        visited = set([source])\n\n        while queue:\n            (node, path) = queue.pop(0)\n\n            if node == destination:\n                return path\n\n            for neighbor in self.adj_list.get(node, []):\n                if neighbor not in visited:\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n                    visited.add(neighbor)\n\n        return []\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```",
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nclass Library:\n    \"\"\"\n    A library class to manage a collection of books.\n    \"\"\"\n    def __init__(self):\n        self.books = []\n\n    def _validate_input(self, book_title: str, author: str) -> None:\n        \"\"\"\n        Private method to validate input for adding a book.\n\n        Args:\n            book_title (str): The title of the book.\n            author (str): The author of the book.\n        \"\"\"\n        if not isinstance(book_title, str) or not isinstance(author, str):\n            raise ValueError(\"Book title and author must be strings.\")\n        if not book_title or not author:\n            raise ValueError(\"Book title and author cannot be empty.\")\n\n    @staticmethod\n    def _format_book_info(book_title: str, author: str) -> str:\n        \"\"\"\n        Private method to format book information.\n\n        Args:\n            book_title (str): The title of the book.\n            author (str): The author of the book.\n\n        Returns:\n            str: Formatted book information.\n        \"\"\"\n        return f\"{book_title} by {author}\"\n\n    def add_book(self, book_title: str, author: str) -> None:\n        \"\"\"\n        Public method to add a book to the library.\n\n        Args:\n            book_title (str): The title of the book.\n            author (str): The author of the book.\n        \"\"\"\n        self._validate_input(book_title, author)\n        book_info = self._format_book_info(book_title, author)\n        self.books.append(book_info)\n\n    def remove_book(self, book_title: str) -> None:\n        \"\"\"\n        Public method to remove a book from the library.\n\n        Args:\n            book_title (str): The title of the book to remove.\n        \"\"\"\n        book_index = next((index for index, book in enumerate(self.books) if book_title in book), None)\n        if book_index is not None:\n            del self.books[book_index]\n        else:\n            raise ValueError(f\"Book '{book_title}' not found in the library.\")\n```",
        "```python\nimport torch\nimport torch.nn as nn\nfrom pedantic import validate\n\nclass BinaryImageClassifier(nn.Module):\n    @validate\n    def __init__(self, num_features: int, num_classes: int = 2):\n        \"\"\"\n        Initializes the binary image classifier model.\n\n        :param num_features: The number of input features.\n        :type num_features: int\n        :param num_classes: The number of output classes (default is 2 for binary classification).\n        :type num_classes: int, optional\n        \"\"\"\n        super(BinaryImageClassifier, self)._md(f)\n        self.num_features = num_features\n        self.num_classes = num_classes\n        self.linear = nn.Linear(num_features, num_classes)\n\n    @validate\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs forward pass of the model.\n\n        :param x: Input tensor of shape (batch_size, num_features).\n        :type x: torch.Tensor\n        :return: Output tensor of shape (batch_size, num_classes) containing class scores.\n        :rtype: torch.Tensor\n        \"\"\"\n        return self.linear(x)\n```",
        "```python\nfrom typing import List\n\n\n@validate\ndef merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]:\n    result = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n\n    return result\n```",
        "```python\nfrom pedantic import validate\n\n@validate\ndef longest_common_prefix(strs: list[str]) -> str:\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or strs[0][i] != other[i]:\n                return strs[0][:i]\n\n    return strs[0]\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    # Method to add an edge to the graph\n    def add_edge(self, u: int, v: int, w: int) -> None:\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    # Method to find the shortest path using Dijkstra's algorithm\n    def shortest_path(self, src: int) -> list[int]:\n        dist = [float(\"inf\")] * self.V\n        dist[src] = 0\n        spt = [False] * self.V\n\n        # min_heap to pick the minimum distance vertex\n        from heapq import heappush, heappop\n\n        heap = []\n        heappush(heap, (0, src))\n\n        while heap:\n            d, u = heappop(heap)\n            spt[u] = True\n\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and not spt[v]:\n                    if dist[u] + self.graph[u][v] < dist[v]:\n                        dist[v] = dist[u] + self.graph[u][v]\n                        heappush(heap, (dist[v], v))\n\n        # Print the shortest distance from the source to all vertices\n        return dist\n```"
      ]
    }
  ]
}