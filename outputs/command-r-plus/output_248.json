{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.q_head = None\n        self.q_tail = None\n\n    def o_get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_q_head(key)\n        return self.cache[key]\n\n    def o_put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self._move_to_q_head(key)\n        elif len(self.cache) == self.capacity:\n            self._evict_q_tail()\n        self._insert_to_q_head(key, value)\n\n    def _move_to_q_head(self, key: int) -> None:\n        value = self.cache.pop(key)\n        self._insert_to_q_head(key, value)\n\n    def _insert_to_q_head(self, key: int, value: int) -> None:\n        if not self.q_head:\n            self.q_head = self.q_tail = key\n        else:\n            self.cache[key] = value\n            self.cache[self.q_head], self.q_head = value, key\n\n    def _evict_q_tail(self) -> None:\n        tail = self.cache.pop(self.q_tail)\n        if self.q_head == self.q_tail:\n            self.q_head = self.q_tail = None\n        else:\n            self.q_tail = next(iter(k for k in self.cache if k != self.q_head))\n```",
        "class Inventory:\n    \"\"\"\n    A simple inventory class with methods to add and remove stock.\n    \"\"\"\n    def __init__(self):\n        self.q_stock = {}\n\n    def o_add_stock(self, item, quantity):\n        if item in self.q_stock:\n            self.q_stock[item] += quantity\n        else:\n            self.q_stock[item] = quantity\n\n    def o_remove_stock(self, item, quantity):\n        if item in self.q_stock and self.q_stock[item] >= quantity:\n            self.q_stock[item] -= quantity\n        else:\n            raise ValueError(\"Insufficient stock to remove that quantity.\")"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def o_add_stock(self, amount):\n        self.stock += amount\n\n    def o_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item: str, quantity: int) -> None:\n        self.stock[item] = self.stock.get(item, 0) + quantity\n\n    def remove_stock(self, item: str, quantity: int) -> None:\n        if self.stock.get(item, 0) < quantity:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock[item] = self.stock[item] - quantity\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def n_add_stock(self, amount):\n        self.stock += amount\n\n    def n_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\n\n@rename_kwargs(\"matrix\")\ndef average_diagonal_elements(matrix: list[list[float]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Parameters:\n    matrix (list[list[float]]): The input square matrix.\n\n    Returns:\n    float: The average of the diagonal elements.\n    \"\"\"\n    size = len(matrix)\n    assert size ** 2 == len(matrix) ** 2, \"Input matrix is not square.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(size))\n    average = diagonal_sum / size\n    return average\n```",
        "class Solution:\n    @rename_kwargs\n    def maxSubArray(self, nums: List[int]) -> int:\n        assert isinstance(nums, list), \"Input must be a list of integers\"\n        assert all(isinstance(num, int) for num in nums), \"List elements must be integers\"\n        max_sum = curr_sum = nums[0]\n        for num in nums[1:]:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)",
        "from pedantic import rename_kwargs\r\n\r\n\r\nclass Solution:\r\n    @rename_kwargs\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        max_sum = current_sum = nums[0]\r\n        for num in nums[1:]:\r\n            current_sum = max(num, current_sum + num)\r\n            max_sum = max(max_sum, current_sum)\r\n        return max_sum"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, product, quantity):\n        if product in self.stock:\n            self.stock[product] += quantity\n        else:\n            self.stock[product] = quantity\n\n    def ud_remove_stock(self, product, quantity):\n        if product in self.stock and self.stock[product] >= quantity:\n            self.stock[product] -= quantity\n        else:\n            print(\"Insufficient stock to remove the requested quantity.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def ud_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def ud_remove_stock(self, item, quantity):\n        if item in self.stock:\n            if self.stock[item] >= quantity:\n                self.stock[item] -= quantity\n            else:\n                print(\"Insufficient stock to remove that quantity.\")\n        else:\n            print(\"Item not found in inventory.\")"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Find the longest common prefix string amongst a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list to ensure stable results\n    strs.sort()\n\n    # Get the first and last string in the sorted list\n    first, last = strs[0], strs[-1]\n\n    # Iterate through the characters of the first and last strings\n    for i, (char_first, char_last) in enumerate(zip(first, last)):\n        if char_first != char_last:\n            return first[:i]\n\n    # If all characters match, return the first string\n    return first\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def x_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def x_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill the request.\")"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def x_add_stock(self, amount):\n        self.stock += amount\n\n    def x_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_head = None\n        self.j_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_j_head(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_j_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            self._evict()\n        self.cache[key] = value\n        self._insert_to_j_head(key)\n\n    def _move_to_j_head(self, key: int) -> None:\n        node = self.cache[key]\n        self._remove_from_dll(key)\n        self._insert_to_j_head(key)\n\n    def _insert_to_j_head(self, key: int) -> None:\n        node = [key, self.cache[key]]\n        node[1]['prev'] = None\n        node[1]['next'] = self.j_head\n        if self.j_head is not None:\n            self.j_head['prev'] = node[1]\n        self.j_head = node[1]\n        if self.j_tail is None:\n            self.j_tail = node[1]\n\n    def _remove_from_dll(self, key: int) -> None:\n        node = self.cache[key]\n        if node['prev'] is not None:\n            node['prev']['next'] = node['next']\n        else:\n            self.j_head = node['next']\n        if node['next'] is not None:\n            node['next']['prev'] = node['prev']\n        else:\n            self.j_tail = node['prev']\n\n    def _evict(self) -> None:\n        key_to_evict = self.j_tail['key']\n        self._remove_from_dll(key_to_evict)\n        del self.cache[key_to_evict]"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom pedantic import timer_class\n\n\n@timer_class\nclass QDA:\n    def __init__(self, t_store: str = None):\n        self.t_model = QuadraticDiscriminantAnalysis(store=t_store)\n\n    def fit(self, X, y):\n        self.t_model.fit(X, y)\n\n    def predict(self, X):\n        return self.t_model.predict(X)\n\n    def score(self, X, y):\n        return self.t_model.score(X, y)\n```",
        "```python\nfrom pedantic import timer_class\n\n\n@timer_class\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.t_order:\n            self.t_order.remove(key)\n        elif len(self.t_order) >= self.capacity:\n            del_key = self.t_order.pop(0)\n            del self.cache[del_key]\n        self.t_order.append(key)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "from pedantic import timer_class\nfrom numpy import mean, cov, array, argmin, sqrt, exp, dot, zeros, ones\nfrom numpy.random import randint\nfrom matplotlib.pyplot import scatter\nfrom matplotlib.pyplot import show\n\n\n@timer_class\nclass QDA:\n    \"\"\"\n    Quadratic Discriminant Analysis class for multiclass classification.\n    \"\"\"\n\n    def __init__(self, tol=0.001, iter_max=200, random_state=None):\n        \"\"\"\n        Initialize the QDA class.\n\n        Parameters\n        ----------\n        tol : float, optional\n            Tolerance for convergence.\n        iter_max : int, optional\n            Maximum number of iterations.\n        random_state : int or None, optional\n            Random seed for reproducibility.\n        \"\"\"\n        self.tol = tol\n        self.iter_max = iter_max\n        self.random_state = random_state\n        self.classes = None\n        self.means = None\n        self.cov = None\n        self.priors = None\n        self.class_labels = None\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit the QDA model to the data.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        \"\"\"\n        # Set random state\n        if self.random_state is not None:\n            randint(0, 100, random_state=self.random_state)\n\n        # Get the number of classes\n        self.classes = list(set(y))\n        self.classes.sort()\n        n_classes = len(self.classes)\n\n        # Get the number of features\n        n_features = X.shape[1]\n\n        # Initialize the mean, covariance, and prior arrays\n        self.means = zeros((n_classes, n_features))\n        self.cov = zeros((n_classes, n_features, n_features))\n        self.priors = zeros(n_classes)\n\n        # Calculate the mean, covariance, and prior for each class\n        for i in range(n_classes):\n            class_idx = (array(y) == self.classes[i])\n            self.means[i] = mean(X[class_idx], axis=0)\n            self.cov[i] = cov(X[class_idx], rowvar=False)\n            self.priors[i] = X[class_idx].shape[0] / X.shape[0]\n\n        # Set the class labels\n        self.class_labels = self.classes\n\n    def predict(self, X):\n        \"\"\"\n        Predict the class labels for the given data.\n\n        Parameters\n        ----------\n        X : array-like\n            Data to predict.\n\n        Returns\n        -------\n        array-like\n            Predicted class labels.\n        \"\"\"\n        # Get the number of samples\n        n_samples = X.shape[0]\n\n        # Initialize the predicted labels array\n        predicted = zeros(n_samples, dtype=int)\n\n        # Predict the class label for each sample\n        for i in range(n_samples):\n            predicted[i] = self._predict(X[i])\n\n        return self.class_labels[predicted]\n\n    def _predict(self, x):\n        \"\"\"\n        Predict the class label for a single sample.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to predict.\n\n        Returns\n        -------\n        int\n            Predicted class label.\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._posterior(x)\n\n        # Return the class label with the highest posterior probability\n        return argmin(posteriors)\n\n    def _posterior(self, x):\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters\n        ----------\n        x : array-like\n            Sample to calculate the posterior probability for.\n\n        Returns\n        -------\n        array-like\n            Posterior probabilities for each class.\n        \"\"\"\n        # Get the number of classes\n        n_classes = len(self.classes)\n\n        # Initialize the posterior probability array\n        posterior = zeros(n_classes)\n\n        # Calculate the posterior probability for each class\n        for i in range(n_classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            posterior[i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((x - mean).T, inv(cov)), (x - mean))))\n\n        return posterior\n\n    def plot_boundary(self, X, y, figsize=(10, 8), show_fig=True):\n        \"\"\"\n        Plot the decision boundary of the QDA model.\n\n        Parameters\n        ----------\n        X : array-like\n            Training data.\n        y : array-like\n            Target labels.\n        figsize : tuple, optional\n            Figure size for the plot.\n        show_fig : bool, optional\n            Whether to show the plot or not.\n        \"\"\"\n        # Plot the data points\n        scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.get_cmap('viridis', len(self.classes)))\n\n        # Get the minimum and maximum values of the data\n        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n\n        # Create a grid of points to evaluate the decision boundary\n        xx, yy = meshgrid(linspace(x_min, x_max, 100), linspace(y_min, y_max, 100))\n        zz = zeros((xx.shape[0], xx.shape[1], len(self.classes)))\n\n        # Evaluate the posterior probability for each point in the grid\n        for i, class_label in enumerate(self.classes):\n            mean = self.means[i]\n            cov = self.cov[i]\n            prior = self.priors[i]\n            for j in range(xx.shape[0]):\n                for k in range(xx.shape[1]):\n                    zz[j, k, i] = prior * exp(-0.5 * (1 / sqrt(det(cov))) * dot(dot(dot((array([xx[j, k], yy[j, k]]) - mean).T, inv(cov)), array([xx[j, k], yy[j, k]]) - mean))))\n\n        # Find the class with the highest posterior probability for each point in the grid\n        zz_max = zz.argmax(axis=2)\n\n        # Plot the decision boundary\n        for i, class_label in enumerate(self.classes):\n            scatter(xx[zz_max == i], yy[zz_max == i], c=self.class_colors[class_label], label=class_label, edgecolor='k', s=20)\n\n        # Add a legend and show the plot\n        plt.legend()\n        if show_fig:\n            plt.show()\n\n\n# Helper functions\ndef inv(mat):\n    \"\"\"\n    Inverse a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    array-like\n        Inverse matrix.\n    \"\"\"\n    return np.linalg.inv(mat)\n\ndef det(mat):\n    \"\"\"\n    Calculate the determinant of a matrix.\n\n    Parameters\n    ----------\n    mat : array-like\n        Input matrix.\n\n    Returns\n    -------\n    float\n        Determinant of the matrix.\n    \"\"\"\n    return np.linalg.det(mat)\n\ndef meshgrid(*args, **kwargs):\n    \"\"\"\n    Create a meshgrid.\n\n    Parameters\n    ----------\n    *args : tuple\n        Input arrays.\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    tuple\n        Meshgrid arrays.\n    \"\"\"\n    return np.meshgrid(*args, **kwargs)\n\ndef linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None):\n    \"\"\"\n    Generate a linearly spaced array.\n\n    Parameters\n    ----------\n    start : float\n        Start of interval.\n    stop : float\n        End of interval.\n    num : int, optional\n        Number of samples to generate.\n    endpoint : bool, optional\n        Whether to include the endpoint.\n    retstep : bool, optional\n        Whether to return the step size.\n    dtype : data type, optional\n        Data type of the output array.\n\n    Returns\n    -------\n    array-like\n        Linearly spaced array.\n    \"\"\"\n    return np.linspace(start, stop, num=num, endpoint=endpoint, retstep=retstep, dtype=dtype)",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def a_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def a_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove\")"
      ],
      "instruction_model_output": [
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def a_add_stock(self, amount):\n        self.stock += amount\n\n    def a_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.at_head = None\n        self.at_tail = None\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._remove(node)\n        self._add(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self._remove(self.cache[key])\n        if len(self.cache) >= self.capacity:\n            del self.cache[self.at_tail.key]\n            self._remove(self.at_tail)\n        node = Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n\n    def _remove(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.at_head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.at_tail = node.prev\n\n    def _add(self, node):\n        if self.at_head:\n            self.at_head.prev = node\n        node.next = self.at_head\n        self.at_head = node\n        if not self.at_tail:\n            self.at_tail = node\n\nclass Node:\n    def __init__(self, key: int, value: int):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.at_capacity = capacity\n        self.at_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.at_cache:\n            return -1\n        value = self.at_cache.pop(key)\n        self.at_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.at_cache:\n            self.at_cache.pop(key)\n        elif len(self.at_cache) >= self.at_capacity:\n            self.at_cache.popitem(last=False)\n        self.at_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def md_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def md_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the specified quantity.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def md_add_stock(self, amount):\n        self.stock += amount\n\n    def md_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove that amount.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_key_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self._move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict_lru()\n        self.cache[key] = value\n        self.i_key_order.append(key)\n\n    def _move_to_end(self, key: int) -> None:\n        self.i_key_order.remove(key)\n        self.i_key_order.append(key)\n\n    def _evict_lru(self) -> None:\n        lru_key = self.i_key_order.pop(0)\n        del self.cache[lru_key]\n```",
        "class Inventory:\n    def __init__(self):\n        self.i_stock = {}\n\n    def i_add_stock(self, item, quantity):\n        if item in self.i_stock:\n            self.i_stock[item] += quantity\n        else:\n            self.i_stock[item] = quantity\n\n    def i_remove_stock(self, item, quantity):\n        if item in self.i_stock:\n            if self.i_stock[item] >= quantity:\n                self.i_stock[item] -= quantity\n            else:\n                print(\"Insufficient stock to remove the requested quantity.\")\n        else:\n            print(\"Item not found in inventory.\")\n\n    def p_update_stock(self, item, new_quantity):\n        if item in self.i_stock:\n            self.i_stock[item] = new_quantity\n        else:\n            print(\"Item not found in inventory.\")"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```",
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def p_add_stock(self, amount):\n        self.stock += amount\n\n    def p_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to fulfill request.\")\n\n    def b_display_stock(self):\n        for item, quantity in self.stock.items():\n            print(f\"{item}: {quantity} units\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def b_add_stock(self, amount):\n        self.stock += amount\n\n    def b_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock.\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom collections import OrderedDict\nfrom typing import Any\n\nclass LRUCache:\n    def __init__(self, capacity: int) -> None:\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> Any:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: Any) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n```",
        "```python\nfrom typing import Any\n\n\nclass Node:\n    def __init__(self, value: Any) -> None:\n        self.r_value = value\n        self.r_left = None\n        self.r_right = None\n\n\nclass BinaryTree:\n    def __init__(self) -> None:\n        self.r_root = None\n\n    def insert(self, value: Any) -> None:\n        if not self.r_root:\n            self.r_root = Node(value)\n        else:\n            self._insert_recursive(value, self.r_root)\n\n    def _insert_recursive(self, value: Any, node: Node) -> None:\n        if value < node.r_value:\n            if node.r_left is None:\n                node.r_left = Node(value)\n            else:\n                self._insert_recursive(value, node.r_left)\n        else:\n            if node.r_right is None:\n                node.r_right = Node(value)\n            else:\n                self._insert_recursive(value, node.r_right)\n\n    def delete(self, value: Any) -> None:\n        self.r_root = self._delete_recursive(self.r_root, value)\n\n    def _delete_recursive(self, node: Node, value: Any) -> Node:\n        if node is None:\n            return node\n\n        if value < node.r_value:\n            node.r_left = self._delete_recursive(node.r_left, value)\n        elif value > node.r_value:\n            node.r_right = self._delete_recursive(node.r_right, value)\n        else:\n            if node.r_left is None:\n                return node.r_right\n            elif node.r_right is None:\n                return node.r_left\n\n            min_val_node = self._find_min_value_node(node.r_right)\n            node.r_value = min_val_node.r_value\n            node.r_right = self._delete_recursive(node.r_right, min_val_node.r_value)\n\n        return node\n\n    def _find_min_value_node(self, node: Node) -> Node:\n        current = node\n        while current.r_left is not None:\n            current = current.r_left\n        return current\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_queue = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.s_queue.remove(key)\n        self.s_queue.append(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.s_queue.remove(key)\n        elif len(self.s_queue) >= self.capacity:\n            del_key = self.s_queue.pop(0)\n            del self.cache[del_key]\n        self.s_queue.append(key)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "history_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.queue = []\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.queue.remove(key)\n            self.queue.append(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.queue.remove(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = self.queue.pop(0)\n            del self.cache[evict_key]\n        self.cache[key] = value\n        self.queue.append(key)\n```",
        "```python\nclass Solution:\n    def __init__(self, nums):\n        self.nums = nums\n        self.max_sum = 0\n        self.max_left = 0\n        self.max_right = 0\n        self.current_sum = 0\n\n    def maxSubarraySum(self):\n        for num in self.nums:\n            self.current_sum += num\n            if self.current_sum > self.max_sum:\n                self.max_sum = self.current_sum\n            if self.current_sum < 0:\n                self.current_sum = 0\n            if self.current_sum > self.max_left:\n                self.max_left = self.current_sum\n            if self._current_sum(i) > self.max_right:\n                self.max_right = self._current_sum(i)\n        return self.max_sum\n\n    def _current_sum(self, i):\n        temp_sum = 0\n        for j in range(i, len(self.nums)):\n            temp_sum += self.nums[j]\n            if temp_sum > self.max_right:\n                self.max_right = temp_sum\n        return temp_sum\n```",
        "```python\nclass QuadraticDiscriminantAnalysis:\n    \"\"\"\n    Quadratic Discriminant Analysis (QDA) class for multiclass classification.\n\n    Attributes:\n        classes_ (list): A list of the target class labels.\n        means_ (ndarray): An array of the mean values for each class.\n        covariances_ (ndarray): An array of the covariance matrices for each class.\n        priors_ (ndarray): An array of the class prior probabilities.\n\n    ...\n\n    Methods:\n        fit (X, y): Fit the model according to the given training data and parameters.\n        predict (X): Predict the class labels for the provided data.\n        score (X, y): Return the mean accuracy of the predictions on the data.\n\n    \"\"\"\n\n    def __init__(self):\n        self.classes_ = []\n        self.means_ = []\n        self.covariances_ = []\n        self.priors_ = []\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -> \"QuadraticDiscriminantAnalysis\":\n        \"\"\"\n        Fit the model according to the given training data and parameters.\n\n        Parameters:\n            X (ndarray): The input training data of shape (n_samples, n_features).\n            y (ndarray): The target class labels of shape (n_samples,).\n\n        Returns:\n            QuadraticDiscriminantAnalysis: The fitted instance of the QDA model.\n\n        \"\"\"\n        # Initialize variables\n        n_classes = len(np.unique(y))\n        n_features = X.shape[1]\n\n        # Store the target class labels\n        self.classes_ = np.unique(y)\n\n        # Calculate the mean for each class\n        self.means_ = np.array([X[y == class_].mean(axis=0) for class_ in self.classes_])\n\n        # Calculate the covariance matrix for each class\n        self.covariances_ = np.array(\n            [np.cov(X[y == class_].T) for class_ in self.classes_]\n        )\n\n        # Calculate the class prior probabilities\n        self.priors_ = np.bincount(y) / len(y)\n\n        return self\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predict the class labels for the provided data.\n\n        Parameters:\n            X (ndarray): The input data of shape (n_samples, n_features).\n\n        Returns:\n            ndarray: An array of predicted class labels of shape (n_samples,).\n\n        \"\"\"\n        # Calculate the posterior probability for each class\n        posteriors = self._calculate_posterior_probabilities(X)\n\n        # Predict the class labels\n        predictions = np.argmax(posteriors, axis=1)\n\n        return self.classes_[predictions]\n\n    def score(self, X: np.ndarray, y: np.ndarray) -> float:\n        \"\"\"\n        Return the mean accuracy of the predictions on the data.\n\n        Parameters:\n            X (ndarray): The input data of shape (n_samples, n_features).\n            y (ndarray): The true class labels of shape (n_samples,).\n\n        Returns:\n            float: The mean accuracy of the predictions.\n\n        \"\"\"\n        # Predict the class labels\n        predictions = self.predict(X)\n\n        # Calculate the accuracy\n        accuracy = (predictions == y).mean()\n\n        return accuracy\n\n    def _calculate_posterior_probabilities(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculate the posterior probability for each class.\n\n        Parameters:\n            X (ndarray): The input data of shape (n_samples, n_features).\n\n        Returns:\n            ndarray: An array of posterior probabilities of shape (n_samples, n_classes).\n\n        \"\"\"\n        # Calculate the prior probability for each class\n        priors = np.array([self.priors_[class_] for class_ in self.classes_])\n\n        # Calculate the probability density for each class\n        densities = self._calculate_class_probabilities(X)\n\n        # Apply Bayes' theorem to calculate the posterior probabilities\n        posteriors = priors * densities\n\n        # Normalize the posterior probabilities\n        posteriors = posteriors / posteriors.sum(axis=1)[:, np.newaxis]\n\n        return posteriors\n\n    def _calculate_class_probabilities(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculate the probability density for each class.\n\n        Parameters:\n            X (ndarray): The input data of shape (n_samples, n_features).\n\n        Returns:\n            ndarray: An array of class probabilities of shape (n_samples, n_classes).\n\n        \"\"\"\n        # Calculate the probability density for each class\n        probabilities = np.array(\n            [\n                self._calculate_class_probability(X, class_, mean_, covariance_)\n                for class_, mean_, covariance_ in zip(\n                    self.classes_, self.means_, self.covariances_\n                )\n            ]\n        )\n\n        return probabilities\n\n    def _calculate_class_probability(\n        self, X: np.ndarray, class_: int, mean_: np.ndarray, covariance_: np.ndarray\n    ) -> float:\n        \"\"\"\n        Calculate the probability density for a single class.\n\n        Parameters:\n            X (ndarray): The input data of shape (n_samples, n_features).\n            class_ (int): The index of the class.\n            mean_ (ndarray): The mean of the class.\n            covariance_ (ndarray): The covariance matrix of the class.\n\n        Returns:\n            float: The probability density for the class.\n\n        \"\"\"\n        # Calculate the determinant of the covariance matrix\n        det_covariance = np.linalg.det(covariance_)\n\n        # Calculate the inverse of the covariance matrix\n        inv_covariance = np.linalg.inv(covariance_)\n\n        # Calculate the number of features\n        n_features = X.shape[1]\n\n        # Calculate the probability density\n        probability_density = np.exp(\n            -(X - mean_) @ inv_covariance @ (X - mean_).T\n        ) / (\n            2 * np.pi ** (n_features / 2) * np.sqrt(det_covariance)\n        )\n\n        return probability_density\n```",
        "```python\nclass Inventory:\n    def __init__(self):\n        self.stock = []\n\n    def add_stock(self, item: str) -> None:\n        self.stock.append(item)\n\n    def remove_stock(self, item: str) -> None:\n        self.stock.remove(item)\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._find_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _find_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\ndef average_diagonal_elements(matrix: List[List[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (List[List[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    # Validate input\n    if not matrix or not all(len(row) == len(matrix[0]) for row in matrix):\n        raise ValueError(\"Input must be a non-empty square matrix.\")\n\n    # Calculate sum of diagonal elements\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n\n    # Compute average\n    average = diagonal_sum / len(matrix)\n\n    return average\n```",
        "```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n```"
      ]
    }
  ]
}