{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = self._find_min_distance_node_b(dist, spt_set)\n            if u == -1:\n                break\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if spt_set[v] == False and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    parent[v] = u\n\n        path = []\n        if parent[dest] != -1:\n            u = dest\n            while parent[u] != -1:\n                path.insert(0, u)\n                u = parent[u]\n            path.insert(0, src)\n            return path\n        else:\n            return \"Path doesn't exist\"\n\n    def _find_min_distance_node_b(self, dist, spt_set):\n        min_distance = float('inf')\n        min_node = -1\n\n        for u in range(self.V):\n            if spt_set[u] == False and dist[u] < min_distance:\n                min_distance = dist[u]\n                min_node = u\n\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path"
      ],
      "cumulative_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf') for _ in range(self.V)]\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        while True:\n            u = self._extract_min_b(dist, spt_set)\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in range(self.V):\n                if (\n                    self.graph[u][v] > 0\n                    and spt_set[v] is False\n                    and dist[v] > dist[u] + self.graph[u][v]\n                ):\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        if spt_set[dest] is False:\n            return float('inf')\n        return dist[dest]\n\n    def _extract_min_b(self, dist, spt_set):\n        min = float('inf')\n        min_index = -1\n        for v in range(self.V):\n            if spt_set[v] is False and dist[v] <= min:\n                min = dist[v]\n                min_index = v\n        return min_index\n```"
      ]
    }
  ]
}