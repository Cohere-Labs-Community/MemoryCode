{
  "sessions": [
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert_node_fn(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_node_recursive_fn(value, self.root)\n\n    def _insert_node_recursive_fn(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_node_recursive_fn(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_node_recursive_fn(value, node.right)\n\n    def delete_node_fn(self, value):\n        self.root = self._delete_node_recursive_fn(self.root, value)\n\n    def _delete_node_recursive_fn(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_node_recursive_fn(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_node_recursive_fn(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value_recursive_fn(node.right)\n            node.right = self._delete_node_recursive_fn(node.right, node.value)\n\n        return node\n\n    def _get_min_value_recursive_fn(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\ndef merge_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the merge sort algorithm.\n\n    :param arr: The array of integers to be sorted.\n    :return: The sorted array.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    return merge(left_half, right_half)\n\n\ndef merge(left, right):\n    \"\"\"\n    Merges two sorted arrays into a single sorted array.\n\n    :param left: The first sorted array.\n    :param right: The second sorted array.\n    :return: The merged and sorted array.\n    \"\"\"\n    result = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n\n    return result\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nimport hashlib\n\ndef insertion_sort(arr):\n    \"\"\"\n    Sort an array using insertion sort algorithm.\n    \n    Args:\n        arr (list): A list of comparable elements.\n    \n    Returns:\n        list: A sorted list in ascending order.\n    \"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# Example docstring for hashlib usage\ndef hash_it(input_str):\n    \"\"\"\n    Generate the SHA256 hash of the input string.\n    \n    Args:\n        input_str (str): The string to be hashed.\n    \n    Returns:\n        str: The SHA256 hash of the input string.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(input_str.encode())\n    return hasher.hexdigest()\n```",
        "```python\nfrom hashlib import md5\n\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Calculate the longest common prefix string among a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for i in range(len(prefix)):\n        current_char = prefix[:i+1]\n        for str in strs[1:]:\n            if not str.startswith(current_char):\n                return prefix[:i]\n    return prefix\n```"
      ],
      "instruction_model_output": [
        "import hashlib\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```"
      ],
      "history_model_output": [
        "```python\nfrom typing import List\n\n\ndef insertion_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort an array of integers using the insertion sort algorithm.\n\n    Args:\n        arr (List[int]): The array of integers to be sorted.\n\n    Returns:\n        List[int]: The sorted array of integers.\n    \"\"\"\n    # Iterate through the array\n    for i in range(1, len(arr)):\n        # Track the current value\n        key = arr[i]\n        # Identify the correct index for the current value\n        j = i - 1\n        # Shift larger values to one position ahead\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        # Place the current value in its correct position\n        arr[j + 1] = key\n    return arr\n```",
        "```python\nfrom typing import List\nimport hashlib\n\n\ndef longest_common_prefix_fn(strs: List[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (List[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Sort the list to ensure stable results\n    strs.sort()\n\n    # Get the first and last string in the sorted list\n    first_str = strs[0]\n    last_str = strs[-1]\n\n    common_prefix = \"\"\n    for i in range(len(first_str)):\n        if i < len(last_str) and first_str[i] == last_str[i]:\n            common_prefix += first_str[i]\n        else:\n            break\n\n    return common_prefix\n```",
        "```python\ndef merge_sort_fn(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list of integers using the merge sort algorithm.\n\n    Args:\n        arr (list[int]): The list of integers to be sorted.\n\n    Returns:\n        list[int]: The sorted list of integers.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_fn(left_half)\n    right_half = merge_sort_fn(right_half)\n\n    return merge_fn(left_half, right_half)\n\ndef merge_fn(left: list[int], right: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists into one sorted list.\n\n    Args:\n        left (list[int]): The first sorted list.\n        right (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: The merged and sorted list.\n    \"\"\"\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result\n```",
        "```python\nfrom typing import Any\nimport hashlib\n\n\nclass Node:\n    def __init__(self, value: Any):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion of a node\n    def insert_node_fn(self, value: Any) -> None:\n        \"\"\"\n        Inserts a node with the given value into the binary tree.\n\n        Args:\n            value (Any): The value to be inserted into the binary tree.\n        \"\"\"\n        self.root = self._insert_recursive_fn(self.root, value)\n\n    def _insert_recursive_fn(self, root: Node, value: Any) -> Node:\n        \"\"\"\n        Recursive function to insert a node with the given value into the binary tree.\n\n        Args:\n            root (Node): The current node in the recursive traversal.\n            value (Any): The value to be inserted.\n\n        Returns:\n            Node: The updated node after insertion.\n        \"\"\"\n        if not root:\n            root = Node(value)\n        elif value < root.value:\n            root.left = self._insert_recursive_fn(root.left, value)\n        else:\n            root.right = self._insert_recursive_fn(root.right, value)\n\n        return root\n\n    # Deletion of a node\n    def delete_node_fn(self, value: Any) -> None:\n        \"\"\"\n        Deletes the first occurrence of a node with the given value from the binary tree.\n\n        Args:\n            value (Any): The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive_fn(self.root, value)\n\n    def _delete_recursive_fn(self, root: Node, value: Any) -> Node:\n        \"\"\"\n        Recursive function to delete a node with the given value from the binary tree.\n\n        Args:\n            root (Node): The current node in the recursive traversal.\n            value (Any): The value of the node to be deleted.\n\n        Returns:\n            Node: The updated node after deletion.\n        \"\"\"\n        if not root:\n            return root\n\n        if value < root.value:\n            root.left = self._delete_recursive_fn(root.left, value)\n        elif value > root.value:\n            root.right = self._delete_recursive_fn(root.right, value)\n        else:\n            # Case 1: Node with only one child or no child\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n\n            # Case 2: Node with two children\n            root.value = self._get_min_value_recursive_fn(root.right)\n            root.right = self._delete_recursive_fn(root.right, root.value)\n\n        return root\n\n    def _get_min_value_recursive_fn(self, root: Node) -> Any:\n        \"\"\"\n        Recursive function to find the minimum value in a subtree.\n\n        Args:\n            root (Node): The root of the subtree.\n\n        Returns:\n            Any: The minimum value in the subtree.\n        \"\"\"\n        if root.left is None:\n            return root.value\n        return self._get_min_value_recursive_fn(root.left)\n```"
      ]
    }
  ]
}