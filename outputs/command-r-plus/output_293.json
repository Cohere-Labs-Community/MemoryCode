{
  "sessions": [
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists_j(list1_j, list2_j):\n    result_j = []\n    i, j = 0, 0\n\n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            result_j.append(list1_j[i])\n            i += 1\n        else:\n            result_j.append(list2_j[j])\n            j += 1\n\n    result_j.extend(list1_j[i:])\n    result_j.extend(list2_j[j:])\n    return result_j\n\n\ndef merge_sorted_lists_p(list1_p, list2_p):\n    result_p = []\n    i, j = 0, 0\n\n    while i < len(list1_p) and j < len(list2_p):\n        if list1_p[i] < list2_p[j]:\n            result_p.append(list1_p[i])\n            i += 1\n        else:\n            result_p.append(list2_p[j])\n            j += 1\n\n    result_p.extend(list1_p[i:])\n    result_p.extend(list2_p[j:])\n    return result_p\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    # A utility function to find the vertex with\n    # a minimum distance value, from the set of vertices\n    # not yet included in the shortest path tree\n    def min_distance(self, dist, visited):\n        min_distance_u = -1\n\n        for u in range(self.V):\n            if visited[u] == False and (min_distance_u == -1 or dist[u] < dist[min_distance_u]):\n                min_distance_u = u\n\n        return min_distance_u\n\n    # A utility function to print the built distance array\n    def print_solution(self, distance):\n        print(\"Node \\t Distance from Source\")\n        for i in range(self.V):\n            print(f\"{i} \\t {distance[i]}\")\n\n    # The main function that calculates distances of the shortest\n    # paths from the source to all other vertices in the given graph\n    def dijkstra(self, src):\n        distance = [1000000000000000000000000000000000000000 for _ in range(self.V)]\n        distance[src] = 0\n        visited = [False] * self.V\n\n        for _ in range(self.V):\n            # Pick the minimum distance vertex from the set of vertices\n            # not yet processed\n            u = self.min_distance(distance, visited)\n\n            # Put the minimum distance vertex in the\n            # shortest path tree\n            visited[u] = True\n\n            # Update the distance value of the neighboring vertices\n            # of the picked vertex\n            for v in range(self.V):\n                if (\n                    self.graph[u][v] > 0\n                    and visited[v] == False\n                    and distance[v] > distance[u] + self.graph[u][v]\n                ):\n                    distance[v] = distance[u] + self.graph[u][v]\n\n        self.print_solution(distance)\n\n    # Function to add an edge to the graph\n    def add_edge(self, u, v, weight):\n        self.graph[u][v] = weight\n        self.graph[v][u] = weight\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_j, list2_j):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_j) and j < len(list2_j):\n        if list1_j[i] < list2_j[j]:\n            merged_list.append(list1_j[i])\n            i += 1\n        else:\n            merged_list.append(list2_j[j])\n            j += 1\n    \n    while i < len(list1_j):\n        merged_list.append(list1_j[i])\n        i += 1\n    \n    while j < len(list2_j):\n        merged_list.append(list2_j[j])\n        j += 1\n    \n    return merged_list",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    result_g = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            result_g.append(list1_g[i])\n            i += 1\n        else:\n            result_g.append(list2_g[j])\n            j += 1\n\n    result_g.extend(list1_g[i:])\n    result_g.extend(list2_g[j:])\n\n    return result_g\n\ndef merge_sorted_lists_ud(list1_ud, list2_ud):\n    # Similar implementation as above but with the method name and argument names updated according to the mentor's guidelines.\n    pass",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def shortest_path_ud(self, src, dest_g):\n        dist = [float(\"Inf\")] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        for i in range(self.V):\n            u = self.min_distance_node_ud(dist, spt_set)\n            spt_set[u] = True\n            for v in range(self.V):\n                if (\n                    self.graph[u][v] > 0\n                    and spt_set[v] is False\n                    and dist[v] > dist[u] + self.graph[u][v]\n                ):\n                    dist[v] = dist[u] + self.graph[u][v]\n\n        if dist[dest_g] == float(\"Inf\"):\n            print(\"Destination is not reachable from the source\")\n        else:\n            print(\"Shortest distance is:\", dist[dest_g])\n\n    def min_distance_node_ud(self, dist, spt_set):\n        min_dist = float(\"Inf\")\n        min_node = -1\n        for u in range(self.V):\n            if spt_set[u] is False and dist[u] < min_dist:\n                min_dist = dist[u]\n                min_node = u\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_ud(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_ud(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_i, list2_i):\n    result_i = []\n    i_i, j_i = 0, 0\n\n    while i_i < len(list1_i) and j_i < len(list2_i):\n        if list1_i[i_i] < list2_i[j_i]:\n            result_i.append(list1_i[i_i])\n            i_i += 1\n        else:\n            result_i.append(list2_i[j_i])\n            j_i += 1\n\n    result_i.extend(list1_i[i_i:])\n    result_i.extend(list2_i[j_i:])\n\n    return result_i"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def shortest_path_between_nodes_b(self, start_node, end_node):\n        # Implement your shortest path algorithm here\n        # ...\n        pass\n```"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n     def __init__(self, vertices):\n         self.V = vertices\n         self.graph = [[] for _ in range(vertices + 1)]\n \n     def add_edge(self, u, v):\n         self.graph[u].append(v)\n \n     def is_cyclic_util(self, v, visited, recStack):\n         visited[v] = True\n         recStack[v] = True\n \n         for neighbour in self.graph[v]:\n             if not visited[neighbour]:\n                 if self.is_cyclic_util(neighbour, visited, recStack):\n                     return True\n             elif recStack[neighbour]:\n                 return True\n \n         recStack[v] = False\n         return False\n \n     def is_cyclic(self):\n         visited = [False] * (self.V + 1)\n         recStack = [False] * (self.V + 1)\n \n         for node in range(self.V + 1):\n             if not visited[node]:\n                 if self.is_cyclic_util(node, visited, recStack):\n                     return True\n         return False\n```"
      ],
      "instruction_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(vertices)]\n\n    def add_edge1(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic9(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Library:\n    \"\"\"\n    A simple library class for managing books.\n    \"\"\"\n\n    def __init__(self):\n        self.books = []\n\n    @staticmethod\n    @validate\n    def _validate_book_title(title):\n        # Custom validation logic for book titles\n        # ...\n        pass\n\n    def add_books_x(self, books):\n        for book in books:\n            self._validate_book_title(book)\n            self.books.append(book)\n\n    def remove_books_x(self, books):\n        for book in books:\n            self.books.remove(book)",
        "```python\nfrom pedantic import validate\n\nclass Graph:\n    def shortest_path_x(self, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if not hasattr(self, 'adj_list_x'):\n            setattr(self, 'adj_list_x', {})\n        if start not in self.adj_list_x:\n            return None\n        for node in self.adj_list_x[start]:\n            if node not in path:\n                newpath = self.shortest_path_x(node, end, path)\n                if newpath:\n                    return newpath\n        return None\n\n    @validate\n    def djikstra_x(self, start, end):\n        pass\n```"
      ],
      "instruction_model_output": [
        "from dataclasses import dataclass\r\nfrom pedantic.decorators import validate\r\nfrom typing import List, Optional\r\n\r\n\r\n@dataclass\r\nclass Library:\r\n    books: List[str] = dataclass(default_factory=list)\r\n\r\n    @validate\r\n    def add_book(self, book: str) -> None:\r\n        self.books.append(book)\r\n\r\n    @validate\r\n    def remove_book(self, book: str) -> Optional[str]:\r\n        if book in self.books:\r\n            self.books.remove(book)\r\n            return book\r\n        return None",
        "```python\nfrom collections import deque\n\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_x(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_x(self, src, dest):\n        visited = [False] * self.V\n        path = [0] * self.V\n        dist = [float(\"Inf\")] * self.V\n\n        dist[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            if u == dest:\n                break\n            for v in self.graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    path[v] = u\n        path_str = []\n        j = dest\n        while j != -1:\n            path_str.insert(0, j)\n            j = path[j]\n        return dist[dest], path_str\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    \"\"\"\n    Merges two sorted lists into a single sorted list.\n    \n    Args:\n        list1_x (_x indicates a function argument): The first sorted list.\n        list2_x (_x indicates a function argument): The second sorted list.\n        \n    Returns:\n        merged_list: A single sorted list containing elements from both input lists.\n    \"\"\"\n    merged_list = []\n    i, j = 0, 0\n    \n    # Iterate through both lists simultaneously, adding the smaller element to the merged list\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    \n    # Add remaining elements from list1_x to the merged list\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    \n    # Add remaining elements from list2_x to the merged list\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    \n    return merged_list",
        "def int_to_roman(int_val_x: int) -> str:\n    \"\"\"\n    Convert an integer to a Roman numeral.\n\n    :param int_val_x: The integer value to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    roman_numerals_x = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\")\n    ]\n    roman_str_x = \"\"\n    for value_x, symbol_x in roman_numerals_x:\n        count_x = int_val_x // value_x\n        roman_str_x += symbol_x * count_x\n        int_val_x %= value_x\n    return roman_str_x"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list",
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if not node:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if not node:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass BinaryTreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_h, list2_h):\n    result_h = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            result_h.append(list1_h[i])\n            i += 1\n        else:\n            result_h.append(list2_h[j])\n            j += 1\n    result_h.extend(list1_h[i:])\n    result_h.extend(list2_h[j:])\n    return result_h"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_h, list2_h):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_h) and j < len(list2_h):\n        if list1_h[i] < list2_h[j]:\n            merged_list.append(list1_h[i])\n            i += 1\n        else:\n            merged_list.append(list2_h[j])\n            j += 1\n    while i < len(list1_h):\n        merged_list.append(list1_h[i])\n        i += 1\n    while j < len(list2_h):\n        merged_list.append(list2_h[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"Error occurred while training the Lasso model: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"Error occurred while making predictions: {e}\")\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_a, list2_a):\n    result_1 = []\n    i, j = 0, 0\n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            result_1.append(list1_a[i])\n            i += 1\n        else:\n            result_1.append(list2_a[j])\n            j += 1\n    result_1.extend(list1_a[i:])\n    result_1.extend(list2_a[j:])\n    return result_1",
        "class LinearRegression:\n    def __init__(self, learning_rate=0.01, num_iterations=1000):\n        self.learning_rate = learning_rate\n        self.num_iterations = num_iterations\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X_train, y_train):\n        num_samples, num_features = X_train.shape\n        self.coef_ = np.zeros(num_features)\n        self.intercept_ = 0\n        for _ in range(self.num_iterations):\n            predictions = np.dot(X_train, self.coef_) + self.intercept_\n            errors = y_train - predictions\n            self.coef_ += self.learning_rate * np.dot(X_train.T, errors)\n            self.intercept_ += self.learning_rate * errors.sum()\n        self.coef_a_ = self.coef_[0]\n        self.intercept_1 = self.intercept_\n\n    def predict(self, X_test):\n        return np.dot(X_test, self.coef_a_) + self.intercept_1"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_a, list2_a):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_a) and j < len(list2_a):\n        if list1_a[i] < list2_a[j]:\n            merged_list.append(list1_a[i])\n            i += 1\n        else:\n            merged_list.append(list2_a[j])\n            j += 1\n    \n    while i < len(list1_a):\n        merged_list.append(list1_a[i])\n        i += 1\n    \n    while j < len(list2_a):\n        merged_list.append(list2_a[j])\n        j += 1\n    \n    return merged_list",
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass BinaryTree:\n    \"\"\"\n    A binary tree data structure with methods to insert and delete nodes.\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert_n(self, value):\n        \"\"\"\n        Inserts a new node with the given value into the binary tree.\n\n        Args:\n            value: The value to be inserted into the binary tree.\n        \"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive_n(value, self.root)\n\n    def _insert_recursive_n(self, value, node):\n        \"\"\"\n        Recursive helper function for inserting a new node.\n\n        Args:\n            value: The value to be inserted.\n            node: The current node in the recursive traversal.\n        \"\"\"\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive_n(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive_n(value value, node.right)\n\n    def delete_n(self, value):\n        \"\"\"\n        Deletes the first occurrence of a node with the given value from the binary tree.\n\n        Args:\n            value: The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive_n(value, self.root)\n\n    def _delete_recursive_n(self, value, node):\n        \"\"\"\n        Recursive helper function for deleting a node.\n\n        Args:\n            value: The value of the node to be deleted.\n            node: The current node in the recursive traversal.\n\n        Returns:\n            The modified node after deletion.\n        \"\"\"\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive_n(value, node.left)\n        elif value > node.value:\n            node.right = self._delete_recursive_n(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor_n(node.right)\n            node.right = self._delete_recursive_n(node.value, node.right)\n\n        return node\n\n    def _get_inorder_successor_n(self, node):\n        \"\"\"\n        Recursive helper function to find the inorder successor (smallest in the right subtree).\n\n        Args:\n            node: The current node in the recursive traversal.\n\n        Returns:\n            The value of the inorder successor.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\nclass Node:\n    \"\"\"\n    A node in the binary tree.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n```",
        "```python\nclass Graph:\n    \"\"\"\n    A graph data structure with methods for analyzing node connections.\n\n    ...\n\n    Attributes\n    ----------\n    adj_list : dict\n        A dictionary representing the adjacency list of the graph. Each key is a node,\n        and the corresponding value is a list of neighboring nodes.\n\n    Methods\n    -------\n    shortest_path_length_n(start, end)\n        Calculate the shortest path length between two nodes.\n    \"\"\"\n\n    def __init__(self):\n        self.adj_list = {}\n\n    def shortest_path_length_n(self, start: str, end: str) -> int:\n        \"\"\"\n        Compute the shortest path length between two nodes in the graph.\n\n        Parameters\n        ----------\n        start : str\n            The starting node for the path.\n\n        end : str\n            The ending node for the path.\n\n        Returns\n        -------\n        int\n            The length of the shortest path between the start and end nodes.\n\n        Raises\n        ------\n        ValueError\n            If either the start or end node is not present in the graph.\n        \"\"\"\n        if start not in self.adj_list or end not in self.adj_list:\n            raise ValueError(\"Node not found in the graph.\")\n\n        queue = [(start, [start])]\n        visited = set([start])\n\n        while queue:\n            (node, path) = queue.pop(0)\n            if node == end:\n                return len(path) - 1\n            for neighbor in self.adj_list.get(node, []):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n\n        return -1\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_n(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_n(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        q = [src]\n\n        while q:\n            u = q.pop(0)\n            for v in self.graph[u]:\n                if dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        return dist[dest]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import rename_kwargs\n\n@rename_kwargs\ndef greatest_common_divisor(a_r: int, b_r: int) -> int:\n    while b_r != 0:\n        a_r, b_r = b_r, a_r % b_r\n    return a_r",
        "from pedantic import rename_kwargs\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n        self.tail_r = None\n\n    @rename_kwargs(\"value_r\", \"next_node_r\")\n    def push(self, value: int, next_node: 'LinkedList' = None) -> None:\n        new_node = Node(value_r=value, next_node_r=next_node)\n        if not self.head_r:\n            self.head_r = new_node\n            self.tail_r = new_node\n        else:\n            self.tail_r.next_node_r = new_node\n            self.tail_r = new_node\n\n    @rename_kwargs(\"value_r\")\n    def delete(self, value: int) -> None:\n        current_node = self.head_r\n        prev_node = None\n        while current_node:\n            if current_node.value_r == value_r:\n                if prev_node:\n                    prev_node.next_node_r = current_node.next_node_r\n                else:\n                    self.head_r = current_node.next_node_r\n                if current_node == self.tail_r:\n                    self.tail_r = prev_node\n                return\n            prev_node = current_node\n            current_node = current_node.next_node_r\n\n    def search(self, value: int) -> bool:\n        current_node = self.head_r\n        while current_node:\n            if current_node.value_r == value:\n                return True\n            current_node = current_node.next_node_r\n        return False\n\n    def display(self) -> str:\n        current_node = self.head_r\n        node_values = []\n        while current_node:\n            node_values.append(str(current_node.value_r))\n            current_node = current_node.next_node_r\n        return \" -> \".join(node_values)\n\nclass Node:\n    def __init__(self, value: int, next_node: 'Node' = None):\n        self.value_r = value\n        self.next_node_r = next_node"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import rename_kwargs\r\n\r\n@rename_kwargs\r\ndef gcd(a: int, b: int) -> int:\r\n    while b:\r\n        a, b = b, a % b\r\n    return a",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(vec1_chx, vec2_chx):\n    return sum(x * y for x, y in zip(vec1_chx, vec2_chx))",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val_chx):\n        self.heap.append(val_chx)\n        self.heapify(len(self.heap) - 1)\n\n    def heapify(self, idx_chx):\n        parent_idx_chx = (idx_chx - 1) // 2\n        while idx_chx > 0 and self.heap[idx_chx] > self.heap[parent_idx_chx]:\n            self.heap[idx_chx], self.heap[parent_idx_chx] = self.heap[parent_idx_chx], self.heap[idx_chx]\n            idx_chx = parent_idx_chx\n            parent_idx_chx = (idx_chx - 1) // 2"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(chx_vector1, chx_vector2):\n    return sum(a * b for a, b in zip(chx_vector1, chx_vector2))\n```",
        "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def chx_insert(self, value):\n        self.heap.append(value)\n        self.chx_heapify(len(self.heap) - 1)\n\n    def chx_heapify(self, index):\n        while index > 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] < self.heap[parent_index]:\n                self.chx_swap(index, parent_index)\n                index = parent_index\n            else:\n                break\n\n    def chx_swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    @require_kwargs\n    def put(self, key, value):\n        if key in self.q_cache:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_order.popitem(last=False)\n        self.q_cache[key] = value\n        self.q_order[key] = True\n\n    @require_kwargs\n    def get(self, key):\n        if key in self.q_cache:\n            self.q_order.move_to_end(key)\n            return self.q_cache[key]\n        return None",
        "class StudentGrade:\n    \"\"\"Represents a student's grades.\"\"\"\n\n    @require_kwargs\n    def __init__(self, q_name: str, q_grades: list[float]):\n        \"\"\"\n        Initializes the StudentGrade object.\n\n        :param q_name: The name of the student.\n        :param q_grades: A list of grade values.\n        \"\"\"\n        self.q_name = q_name\n        self.q_grades = q_grades\n\n    @require_kwargs\n    def q_compute_average_grade(self, q_min_grade: float = 0.0, q_max_grade: float = 100.0) -> float:\n        \"\"\"\n        Computes the average grade for the student.\n\n        :param q_min_grade: The minimum grade value (default: 0.0).\n        :param q_max_grade: The maximum grade value (default: 100.0).\n        :return: The average grade.\n        \"\"\"\n        total_grade = sum(self.q_grades)\n        num_grades = len(self.q_grades)\n        if num_grades == 0:\n            return 0.0\n        average_grade = (total_grade / num_grades) * (q_max_grade - q_min_grade) / 100.0 + q_min_grade\n        return average_grade"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]",
        "from dataclasses import dataclass, field\nfrom pedantic.decorators import pedantic\nfrom pedantic.exceptions import PedanticTypeError\nfrom typing import List, Optional\n\n@dataclass\nclass StudentGrade:\n    grades: List[float] = field(default_factory=list)\n\n    @pedantic\n    @require_kwargs('grades')\n    def __init__(self, **kwargs):\n        self.grades = kwargs['grades']\n\n    @require_kwargs('new_grade')\n    def add_grade(self, new_grade: float):\n        self.grades.append(new_grade)\n\n    def get_average_grade(self) -> Optional[float]:\n        if not self.grades:\n            return None\n        return sum(self.grades) / len(self.grades)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.at_head = None\n        self.at_tail = None\n\n    def get_md(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        self._move_to_head(key)\n        return value\n\n    def put_md(self, key: int, value: int) -> None:\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self._move_to_head(key)\n        elif len(self.cache) >= self.capacity:\n            self._evict_tail()\n        else:\n            self.at_tail = key\n        self.cache[key] = value\n        self._link_head(key)\n\n    def _move_to_head_md(self, key: int) -> None:\n        node = self.cache[key]\n        self._unlink(key)\n        self._link_head(key)\n\n    def _unlink_md(self, key: int) -> None:\n        prev, next = node.prev, node.next\n        if prev:\n            prev.next = next\n        if next:\n            next.prev = prev\n        if key == self.at_head:\n            self.at_head = next\n        if key == self.at_tail:\n            self.at_tail = prev\n\n    def _link_head_md(self, key: int) -> None:\n        node = self.cache[key]\n        next = self.at_head\n        node.prev = None\n        node.next = next\n        if next:\n            next.prev = key\n        self.at_head = key\n        if not self.at_tail:\n            self.at_tail = key\n\n    def _evict_tail_md(self) -> None:\n        key = self.at_tail\n        del self.cache[key]\n        self._unlink(key)\n\n    def display_from_head_md(self) -> None:\n        node = self.at_head\n        while node:\n            print(node.key, node.value)\n            node = node.next\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.at_vertices = vertices\n        self.at_adj_matrix = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, weight):\n        self.at_adj_matrix[u][v] = weight\n        self.at_adj_matrix[v][u] = weight\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.at_vertices\n        dist[src] = 0\n\n        path = [-1] * self.at_vertices\n        path[src] = src\n\n        while True:\n            u = -1\n            for i in range(self.at_vertices):\n                if dist[i] != float('inf') and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            for v in range(self.at_vertices):\n                if self.at_adj_matrix[u][v] != 0 and dist[v] > dist[u] + self.at_adj_matrix[u][v]:\n                    dist[v] = dist[u] + self.at_adj_matrix[u][v]\n                    path[v] = u\n\n        return path[dest]\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.at_capacity = capacity\n        self.at_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.at_cache:\n            return -1\n        value = self.at_cache.pop(key)\n        self.at_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.at_cache:\n            self.at_cache.pop(key)\n        elif len(self.at_cache) >= self.at_capacity:\n            self.at_cache.popitem(last=False)\n        self.at_cache[key] = value\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Graph:\n    def shortest_path_o(self, start_node, end_node):\n        pass"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_order = collections.OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        j_value = self.cache[key]\n        self.j_order.move_to_end(key)\n        return j_value\n\n    def put(self, key, value):\n        if self.capacity <= 0:\n            return\n        if key in self.cache:\n            self.j_order.move_to_end(key)\n        elif len(self.j_order) >= self.capacity:\n            j_oldest = next(iter(self.j_order))\n            del self.j_order[j_oldest]\n            del self.cache[j_oldest]\n        self.j_order[key] = None\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import count_calls\n\nclass LinearRegression:\n    @count_calls\n    def train(self, X, y):\n        pass\n\n    @count_calls\n    def predict(self, X):\n        pass"
      ],
      "instruction_model_output": [
        "from pedantic import pedantic, count_calls\nfrom sklearn.linear_model import LinearRegression\n\n@pedantic\nclass LinearRegressionModel:\n    @count_calls\n    def __init__(self):\n        self.model = LinearRegression()\n\n    @count_calls\n    def train(self, X, y):\n        self.model.fit(X, y)\n\n    @count_calls\n    def predict(self, X):\n        return self.model.predict(X)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList_xt:\n    def __init__(self):\n        self.head_xt = None\n\n    def add_node_xt(self, data_xt):\n        new_node_xt = Node_xt(data_xt)\n        if self.head_xt is None:\n            self.head_xt = new_node_xt\n        else:\n            current_xt = self.head_xt\n            while current_xt.next_xt:\n                current_xt = current_xt.next_xt\n            current_xt.next_xt = new_node_xt\n\n    def display_xt(self):\n        current_xt = self.head_xt\n        while current_xt:\n            print(current_xt.data_xt, end=\" -> \")\n            current_xt = current_xt.next_xt\n        print(\"None\")\n\n\nclass Node_xt:\n    def __init__(self, data_xt):\n        self.data_xt = data_xt\n        self.next_xt = None"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_xt = data\n        self.next_xt = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_xt:\n            self.head_xt = new_node\n            return\n        current = self.head_xt\n        while current.next_xt:\n            current = current.next_xt\n        current.next_xt = new_node\n\n    def delete(self, data):\n        if not self.head_xt:\n            return\n        if self.head_xt.data_xt == data:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current = self.head_xt\n        prev = None\n        while current and current.data_xt != data:\n            prev = current\n            current = current.next_xt\n        if not current:\n            return\n        prev.next_xt = current.next_xt\n\n    def display(self):\n        current = self.head_xt\n        while current:\n            print(current.data_xt, end=\" -> \")\n            current = current.next_xt\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_str: str) -> bool:\n    \"\"\"\n    Checks if a given string is a palindrome.\n\n    Args:\n        input_str (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Remove spaces and convert to lowercase for case-insensitive comparison\n    cleaned_str = ''.join(filter(str.isalnum, input_str)).lower()\n    start, end = 0, len(cleaned_str) - 1\n\n    while start < end:\n        if cleaned_str[start] != cleaned_str[end]:\n            return False\n        start += 1\n        end -= 1\n    return True",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = dict()\n        self.t_head_vr = None\n        self.t_tail_vr = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            self._evict_tail()\n        self.cache[key] = value\n        self._add_to_head(key)\n\n    def _move_to_head(self, key):\n        node = self.cache[key]\n        self._remove_node(node)\n        self._add_to_head(key)\n\n    def _add_to_head(self, key):\n        node = Node(key)\n        node.t_next[key] = self.t_head_vr\n        self.t_head_vr = node\n        if not self.t_tail_vr:\n            self.t_tail_vr = node\n\n    def _evict_tail(self):\n        tail = self.cache[self.t_tail_vr.key]\n        del self.cache[self.t_tail_vr.key]\n        self.t_tail_vr = self.t_tail_vr.t_next_vr\n        if not self.t_tail_vr:\n            self.t_head_vr = None\n\n    def _remove_node(self, node):\n        prev = node.t_prev_vr\n        next = node.t_next_vr\n        if prev:\n            prev.t_next_vr = next\n        else:\n            self.t_head_vr = next\n        if next:\n            next.t_prev_vr = prev\n        else:\n            self.t_tail_vr = prev\n\n    class Node:\n        def __init__(self, key):\n            self.key = key\n            self.t_prev = None\n            self.t_next = None"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_vr):\n    s_vr = s_vr.lower()\n    return s_vr == s_vr[::-1]",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n        else:\n            prev_i = self.head_i\n            curr_i = self.head_i.next_i\n            while curr_i and curr_i.data_i != data_i:\n                prev_i = curr_i\n                curr_i = curr_i.next_i\n            if curr_i:\n                prev_i.next_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=' -> ')\n            curr_i = curr_i.next_i\n        print('None')\n\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None",
        "def is_valid_sudoku(board_i: list[list[int]]) -> bool:\n    \"\"\"\n    Determines if a given 9x9 sudoku board is valid.\n\n    :param board_i: The sudoku board to validate.\n    :type board_i: list[list[int]]\n    :return: True if the sudoku board is valid, False otherwise.\n    :rtype: bool\n    \"\"\"\n    y_flat_board_i = [item for sublist in board_i for item in sublist]\n    y_seen_i = set()\n\n    for y_row_i in board_i:\n        y_row_set_i = set(y_row_i)\n        if not len(y_row_set_i) == len(y_row_i):\n            return False\n\n        y_seen_i.update(y_row_set_i)\n        if not len(y_seen_i) == len(y_row_set_i):\n            return False\n\n    for y_col_idx_i in range(9):\n        y_col_i = [board_i[y_row_idx_i][y_col_idx_i] for y_row_idx_i in range(9)]\n        y_col_set_i = set(y_col_i)\n        if not len(y_col_set_i) == len(y_col_i):\n            return False\n\n    for y_row_idx_i in range(0, 9, 3):\n        for y_col_idx_i in range(0, 9, 3):\n            y_box_i = [board_i[y_row_i][y_col_i] for y_row_i in range(y_row_idx_i, y_row_idx_i + 3) for y_col_i in range(y_col_idx_i, y_col_idx_i + 3)]\n            y_box_set_i = set(y_box_i)\n            if not len(y_box_set_i) == len(y_box_i):\n                return False\n\n    return True"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_i):\n        self.data_i = data_i\n        self.next_i = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head_i = None\n\n    def append(self, data_i):\n        if not self.head_i:\n            self.head_i = Node(data_i)\n        else:\n            curr_i = self.head_i\n            while curr_i.next_i:\n                curr_i = curr_i.next_i\n            curr_i.next_i = Node(data_i)\n\n    def delete(self, data_i):\n        if self.head_i is None:\n            return\n\n        if self.head_i.data_i == data_i:\n            self.head_i = self.head_i.next_i\n            return\n\n        prev_i = self.head_i\n        curr_i = self.head_i.next_i\n\n        while curr_i:\n            if curr_i.data_i == data_i:\n                prev_i.next_i = curr_i.next_i\n                return\n            prev_i = curr_i\n            curr_i = curr_i.next_i\n\n    def display(self):\n        curr_i = self.head_i\n        while curr_i:\n            print(curr_i.data_i, end=\" -> \")\n            curr_i = curr_i.next_i\n        print(\"None\")\n```",
        "def is_valid_sudoku(y_board):\n    y_seen = set()\n    for y_i in range(9):\n        y_seen = set()\n        for y_j in range(9):\n            if y_board[y_i][y_j] != '.':\n                if y_board[y_i][y_j] in y_seen:\n                    return False\n                y_seen.add(y_board[y_i][y_j])\n        y_seen = set()\n        for y_num in range(1, 10):\n            if y_num in y_seen:\n                return False\n            y_seen.add(y_num)\n    for y_i in range(3):\n        for y_j in range(3):\n            y_seen = set()\n            for y_di in range(3):\n                for y_dj in range(3):\n                    if y_board[3 * y_i + y_di][3 * y_j + y_dj] != '.':\n                        if y_board[3 * y_i + y_di][3 * y_j + y_dj] in y_seen:\n                            return False\n                        y_seen.add(y_board[3 * y_i + y_di][3 * y_j + y_dj])\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_sudoku(board):\n    for i in range(9):\n        row = set()\n        col = set()\n        box = set()\n        for j in range(9):\n            current_num = board[i][j]\n            if current_num != '.':\n                num = int(current_num)\n                if num in row or num in col or num in box:\n                    return False\n                row.add(num)\n                col.add(num)\n                if (i // 3) * 3 + j // 3 in (0, 1, 2):\n                    box.add(num)\n        row = col = box = set()\n        for j in range(9):\n            current_num = board[j][i]\n            if current_num != '.':\n                num = int(current_num)\n                if num in row or num in col or num in box:\n                    return False\n                row.add(num)\n                col.add(num)\n                if i // 3 in (0, 1, 2) and (j // 3) in (0, 1, 2):\n                    box.add(num)\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = set()\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    current_num = board[x][y]\n                    if current_num != '.':\n                        num = int(current_num)\n                        if num in box:\n                            return False\n                        box.add(num)\n    return True"
      ],
      "instruction_model_output": [
        "def is_valid_sudoku(x_board):\n    x_seen = [[set() for _ in range(9)] for _ in range(9)]\n\n    for x_i in range(9):\n        for x_j in range(9):\n            if x_board[x_i][x_j] != '.':\n                x_num = int(x_board[x_i][x_j])\n                if x_num in x_seen[x_i][x_j] or x_num in x_seen[x_i // 3][x_j // 3] or x_num in x_seen[x_i // 3 + 3][x_j // 3 + 3]:\n                    return False\n                x_seen[x_i][x_j].add(x_num)\n                x_seen[x_i // 3][x_j // 3].add(x_num)\n                x_seen[x_i // 3 + 3][x_j // 3 + 3].add(x_num)\n\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_queue = []\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.s_queue.remove(key)\n        self.s_queue.append(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.s_queue.remove(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = self.s_queue.pop(0)\n            del self.cache[evict_key]\n        self.s_queue.append(key)\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome_a(input_string_z: str) -> bool:\n    cleaned_string_z = \"\".join(char.lower() for char in input_string_z if char.isalnum())\n    return cleaned_string_z == cleaned_string_z[::-1]",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph_z = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge_a(self, u, v, weight):\n        self.graph_z[u][v] = weight\n        self.graph_z[v][u] = weight\n\n    def shortest_path_a(self, src):\n        dist_z = [float(\"Inf\") for _ in range(self.V)]\n        dist_z[src] = 0\n        heap_z = []\n        heapq.heappush(heap_z, (0, src))\n\n        while heap_z:\n            d, u = heapq.heappop(heap_z)\n            for v in range(self.V):\n                if self.graph_z[u][v] and dist_z[u] + self.graph_z[u][v] < dist_z[v]:\n                    dist_z[v] = dist_z[u] + self.graph_z[u][v]\n                    heapq.heappush(heap_z, (dist_z[v], v))\n\n        return dist_z\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_z):\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]",
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def get_diag_avg(diag_elements_list_f):\n    assert isinstance(diag_elements_list_f, list), \"Input should be a list.\"\n    assert all(isinstance(x, (int, float)) for x in diag_elements_f), \"List elements should be numeric.\"\n    assert len(diag_elements_list_f) > 0, \"List should not be empty.\"\n\n    total_sum_f = sum(diag_elements_list_f)\n    avg_f = total_sum_f / len(diag_elements_list_f)\n    return avg_f",
        "def merge_sorted_lists(list1_f, list2_f):\n    assert all(isinstance(x, (int, float)) for x in list1_f), \"list1_f must contain only numbers\"\n    assert all(isinstance(x, (int, float)) for x in list2_f), \"list2_f must contain only numbers\"\n    assert list1_f == sorted(\n        list1_f\n    ), f\"list1_f must be sorted, but received {list1_f}\"\n    assert list2_f == sorted(\n        list2_f\n    ), f\"list2_f must be sorted, but received {list2_f}\"\n\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n\n    merged_list.extend(list1_f[i:])\n    merged_list.extend(list2_f[j:])\n\n    assert merged_list == sorted(\n        merged_list\n    ), \"Merged list is not sorted. Something went wrong.\"\n\n    return merged_list"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)",
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(str_input: str) -> bool:\n    str_input_reversed = str_input[::-1]\n    is_palindrome_bool = str_input == str_input_reversed\n    return is_palindrome_bool\n\ndef main():\n    str_input_n = input(\"Enter a string to check for palindrome: \")\n    if is_palindrome(str_input_n):\n        print(\"The entered string is a valid palindrome.\")\n    else:\n        print(\"The entered string is not a palindrome.\")\n\nif __name__ == \"__main__\":\n    main()",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.xt_head_n = None\n        self.xt_tail_n = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_head(key)\n        elif len(self.cache) < self.capacity:\n            self.cache[key] = value\n            self._add_to_head(key)\n        else:\n            self.cache.pop(self.xt_tail_n)\n            self.put(key, value)\n\n    def _move_to_head(self, key):\n        self._remove_key_from_dll(key)\n        self._add_to_head(key)\n\n    def _add_to_head(self, key):\n        self._add_key_to_dll(key, self.xt_head_n, self.xt_tail_n)\n        self.xt_head_n = key\n\n    def _remove_key_from_dll(self, key):\n        prev, curr = None, self.xt_head_n\n        while curr:\n            if curr == key:\n                if prev:\n                    prev.next_n = curr.next_n\n                else:\n                    self.xt_head_n = curr.next_n\n\n                if curr == self.xt_tail_n:\n                    self.xt_tail_n = prev\n                break\n            prev = curr\n            curr = curr.next_n\n\n    def _add_key_to_dll(self, key, head, tail):\n        if not head:\n            head = key\n        else:\n            tail.next_n = key\n        key.next_n = None\n        tail = key\n\n    def display(self):\n        node = self.xt_head_n\n        while node:\n            print(node, end=\" -> \")\n            node = node.next_n\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_n):\n    s_n = s_n.lower()\n    return s_n == s_n[::-1]",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.xt_cache:\n            return -1\n        self.xt_cache.move_to_end(key)\n        return self.xt_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_cache.move_to_end(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            self.xt_cache.popitem(last=False)\n        self.xt_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a valid palindrome, False otherwise.\n    \"\"\"\n    # Reverse the string and compare\n    reversed_string = input_string[::-1]\n    if input_string == reversed_string:\n        return True\n    else:\n        return False\n```",
        "```python\ndef compute_average_diagonal(_chx_i):\n    \"\"\"\n    Compute the average of the diagonal elements of a matrix.\n\n    Args:\n        _chx_i (list): A list representing the matrix with numerical values.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    # Validate input\n    if not isinstance(_chx_i, list):\n        raise TypeError(\"Input must be a list representing the matrix\")\n    if any(not isinstance(row, list) for row in _chx_i):\n        raise ValueError(\"All rows in the matrix must be lists\")\n    if not all(len(row) == len(_chx_i[0]) for row in _chx_i):\n        raise ValueError(\"All rows in the matrix must have the same length\")\n\n    # Calculate sum of diagonal elements\n    diagonal_sum = sum(_chx_i[i][i] for i in range(len(_chx_i)))\n\n    # Calculate average\n    diagonal_avg = diagonal_sum / len(_chx_i) if _chx_i else 0.0\n\n    return diagonal_avg\n```",
        "class StudentGrade:\n    def __init__(self, grade):\n        self.grade = grade\n\n    def compute_average_grade(self) -> float:\n        \"\"\"\n        Compute the average grade for the student.\n\n        Returns:\n            float: The average grade.\n        \"\"\"\n        # Add assert statements to validate inputs and outputs\n        assert isinstance(self.grade, list), \"Grade must be a list.\"\n        assert all(isinstance(g, float) for g in self.grade), \"All grades must be floats.\"\n\n        total_grade = sum(self.grade)\n        average_grade = total_grade / len(self.grade)\n        assert isinstance(\n            average_grade, float\n        ), \"Average grade must be a float after calculation.\"\n        return average_grade",
        "```python\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nclass LinearRegressionModel:\n    def __init__(self):\n        self.model = LinearRegression()\n\n    def train(self, X_train: np.ndarray, y_train: np.ndarray) -> None:\n        \"\"\"\n        Trains the linear regression model.\n\n        Args:\n            X_train (np.ndarray): The input training data of shape (n_samples, n_features).\n            y_train (np.ndarray): The target training data of shape (n_samples,).\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predicts the output for the given test data.\n\n        Args:\n            X_test (np.ndarray): The input test data of shape (n_samples, n_features).\n\n        Returns:\n            np.ndarray: The predicted output of shape (n_samples,).\n        \"\"\"\n        return self.model.predict(X_test)\n```",
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.queue = []\n\n    def get(self, key):\n        if key in self.cache:\n            self.queue.remove(key)\n            self.queue.append(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.queue.remove(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = self.queue.pop(0)\n            del self.cache[evict_key]\n        self.cache[key] = value\n        self.queue.append(key)\n```",
        "```python\ndef merge_sorted_lists(list1_j: list[int] '_j', list2_j: list[int] '_j') -> list[int]:\n    merged_list_p = []\n    i_i = 0\n    j_i = 0\n\n    while i_i < len(list1_j) and j_i < len(list2_j):\n        if list1_j[i_i] < list2_j[j_i]:\n            merged_list_p.append(list1_j[i_i])\n            i_i += 1\n        else:\n            merged_list_p.append(list2_j[j_i])\n            j_i += 1\n\n    merged_list_p.extend(list1_j[i_i:])\n    merged_list_p.extend(list2_j[j_i:])\n\n    return merged_list_p\n```",
        "```python\ndef greatest_common_divisor(num1_i: int, num2_i: int) -> int:\n    num1_vr = num1_i\n    num2_vr = num2_i\n    while num2_vr != 0:\n        num1_vr, num2_vr = num2_vr, num1_vr % num2_vr\n    return num1_vr\n```",
        "```python\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                successor = self._find_min(node.right)\n                node.value = successor.value\n                node.right = self._delete_recursive(node.right, successor.value)\n        return node\n\n    def _find_min(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```",
        "import numpy as np\n\nclass LinearRegression:\n    def __init__(self, fit_intercept=True):\n        self.fit_intercept = fit_intercept\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X, y):\n        X = np.array(X)\n        y = np.array(y)\n        if self.fit_intercept:\n            X_bias = np.c_[np.ones(len(X)), X]\n        else:\n            X_bias = X\n\n        self.coef_ = np.linalg.inv(X_bias.T @ X_bias) @ X_bias.T @ y\n        if self.fit_intercept:\n            self.intercept_ = self.coef_[0]\n            self.coef_ = self.coef_[1:]\n        else:\n            self.intercept_ = 0\n\n    def predict(self, X):\n        X = np.array(X)\n        X_bias = np.c_[np.ones(len(X)), X]\n        return X_bias @ self.coef_.T\n\n    def score(self, X, y):\n        y_pred = self.predict(X)\n        return 1 - np.sum((y - y_pred) ** 2) / np.sum((y - np.mean(y)) ** 2)",
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.base import BaseEstimator\n\n\nclass LassoRegression(BaseEstimator):\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X, y):\n        self.model_ = Lasso(alpha=self.alpha)\n        self.model_.fit(X, y)\n        self.coef_ = self.model_.coef_\n        self.intercept_ = self.model_.intercept_\n\n    def predict(self, X):\n        return self.model_.predict(X)\n```",
        "```python\ndef is_valid_sudoku(board: list[list[str]]) -> bool:\n    seen = set()\n    for row in board:\n        for num in row:\n            if num != \".\":\n                if num in seen:\n                    return False\n                seen.add(num)\n                seen = set()\n\n    for col in zip(*board):\n        for num in col:\n            if num != \".\":\n                if num in seen:\n                    return False\n                seen.add(num)\n                seen = set()\n\n    for i in range(0, len(board), 3):\n        for j in range(0, len(board), 3):\n            box = [board[r][c] for r in range(i, i + 3) for c in range(j, j + 3)]\n            for num in box:\n                if num != \".\":\n                    if num in seen:\n                        return False\n                    seen.add(num)\n                    seen = set()\n\n    return True\n```",
        "```python\ndef dot_product_function(vector_a_j: list[float], vector_b_j: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector_a_j (list[float]): The first vector.\n        vector_b_j (list[float]): The second vector.\n\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    # Validate input lengths\n    if len(vector_a_j) != len(vector_b_j):\n        raise ValueError(\"Input vectors must have the same length\")\n\n    # Calculate the dot product\n    dot_product_i = sum(a * b for a, b in zip(vector_a_j, vector_b_j))\n\n    return dot_product_i\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    val_map = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\"),\n    ]\n    roman_num = \"\"\n    for val, symbol in val_map:\n        while num >= val:\n            roman_num += symbol\n            num -= val\n    return roman_num\n```",
        "```python\nclass DirectedGraph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, u: str, v: str) -> None:\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def is_cyclic_util(self, v: str, visited: list, rec_stack: list) -> bool:\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.graph[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic(self) -> bool:\n        visited = [False] * len(self.graph)\n        rec_stack = [False] * len(self.graph)\n\n        for node in self.graph:\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False\n```",
        "```python\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def insert(self, value_i):\n        self.heap.append(value_i)\n        self._heapify_up(len(self.heap) - 1)\n\n    def _heapify_up(self, i):\n        while i > 0 and self.heap[i] > self.heap[self.parent(i)]:\n            self._swap(i, self.parent(i))\n            i = self.parent(i)\n\n    def _heapify_down(self, i):\n        while self.left_child(i) < len(self.heap):\n            smaller_child = self.left_child(i)\n            if (\n                self.right_child(i) < len(self.heap)\n                and self.heap[self.right_child(i)] < self.heap[smaller_child]\n            ):\n                smaller_child = self.right_child(i)\n\n            if self.heap[i] < self.heap[smaller_child]:\n                self._swap(i, smaller_child)\n                i = smaller_child\n            else:\n                break\n\n    def heapify(self):\n        last_non_leaf = (len(self.heap) - 2) // 2\n        for i in range(last_non_leaf, -1, -1):\n            self._heapify_down(i)\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n```",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adj_matrix = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge(self, u: int, v: int, weight: int) -> None:\n        self.adj_matrix[u][v] = weight\n        self.adj_matrix[v][u] = weight\n\n    def shortest_path(self, start: int, end: int) -> int:\n        dist = [float('inf')] * self.vertices\n        dist[start] = 0\n        path = [-1] * self.vertices\n\n        queue = []\n        queue.append(start)\n\n        while queue:\n            u = queue.pop(0)\n\n            for v in range(self.vertices):\n                if self.adj_matrix[u][v] != 0 and dist[v] > dist[u] + self.adj_matrix[u][v]:\n                    dist[v] = dist[u] + self.adj_matrix[u][v]\n                    path[v] = u\n                    queue.append(v)\n\n        return dist[end]\n```",
        "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def add_node(self, value_i, next_j):\n        new_node = Node(value_i)\n        new_node.next = next_j\n        if self.head is None:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next is not None:\n                current = current.next\n            current.next = new_node\n\n    def search_node(self, value_i):\n        current = self.head\n        while current is not None:\n            if current.value == value_i:\n                return current\n            current = current.next\n        return None\n\n    def delete_node(self, value_i):\n        current = self.head\n        prev = None\n        while current is not None:\n            if current.value == value_i:\n                if prev is None:\n                    self.head = current.next\n                else:\n                    prev.next = current.next\n                return\n            prev = current\n            current = current.next\n\n    def display(self):\n        current = self.head\n        while current is not None:\n            print(current.value, end=\" \")\n            current = current.next\n        print()",
        "class Library:\n    def __init__(self):\n        self.books = []\n\n    def add_books_f(self, book_name_vr: str) -> None:\n        \"\"\"\n        Add a book to the library.\n\n        :param book_name_vr: The name of the book to be added.\n        \"\"\"\n        self.books.append(book_name_vr)\n\n    def remove_books_a(self, book_name_vr: str) -> None:\n        \"\"\"\n        Remove a book from the library.\n\n        :param book_name_vr: The name of the book to be removed.\n        \"\"\"\n        self.books.remove(book_name_vr)"
      ]
    }
  ]
}