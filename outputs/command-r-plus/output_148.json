{
  "sessions": [
    {
      "session_model_output": [
        "def y_get_common_elements(list1: list[int], list2: list[int]) -> list[int]:\n    common_elements = [i for i in list1 if i in list2]\n    return common_elements",
        "def y_h_index(citations: list[int]) -> int:\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations, 1):\n        if citation_count >= i:\n            h_index = i\n        else:\n            break\n    return h_index"
      ],
      "instruction_model_output": [
        "def get_common_elements(list1_1, list2_2):\n    return list(set(list1_1) & set(list2_2))",
        "def y_h_index(citations):\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, citation_count in enumerate(citations):\n        if citation_count >= i + 1:\n            h_index = i + 1\n        else:\n            break\n    return h_index"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef average_diagonal_elements(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"All rows must be lists.\"\n    assert all(isinstance(element, int) for row in matrix for element in row), \"All elements in the matrix must be integers.\"\n    assert len(matrix) == len(matrix[0]), \"Input matrix must be square.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)\n```",
        "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value):\n        if node is None:\n            return Node(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value):\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            # Case 1: Node is a leaf node\n            if node.left is None and node.right is None:\n                node = None\n\n            # Case 2: Node has only one child\n            elif node.left is None:\n                node = node.right\n            else:\n                node.value = self._get_min_value(node.right)\n                node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_min_value(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value"
      ],
      "instruction_model_output": [
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)",
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\ndef y_get_common_elements(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Returns a list of common elements between list1 and list2.\n\n    Args:\n        list1 (list[int]): The first list of integers.\n        list2 (list[int]): The second list of integers.\n\n    Returns:\n        list[int]: A list of common elements between list1 and list2.\n    \"\"\"\n    assert isinstance(list1, list) and isinstance(list2, list), \"Input must be a list.\"\n    assert all(isinstance(num, int) for num in list1) and all(\n        isinstance(num, int) for num in list2\n    ), \"Lists must contain only integers.\"\n\n    common_elements = [num for num in list1 if num in list2]\n    return common_elements\n```",
        "```python\ndef y_h_index(citations: list[int]) -> int:\n    \"\"\"\n    Computes the h-index of a researcher based on their citations.\n\n    Args:\n        citations (list[int]): A list of integer citations in descending order.\n\n    Returns:\n        int: The h-index value.\n    \"\"\"\n    assert isinstance(citations, list), \"Input must be a list.\"\n    assert all(isinstance(cit, int) for cit in citations), \"All elements in the list must be integers.\"\n    assert all(cit >= 0 for cit in citations), \"All citations must be non-negative.\"\n\n    citations.sort(reverse=True)\n    h_index = 0\n    for i, cit in enumerate(citations):\n        if cit >= i + 1:\n            h_index = i + 1\n        else:\n            break\n\n    return h_index\n```",
        "```python\nclass y_BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with single-digit argument name and assert statement\n    def y_insert(self, n):\n        assert n is not None\n        if self.root is None:\n            self.root = n\n        else:\n            self._insert(self.root, n)\n\n    def _insert(self, node, n):\n        if n.key < node.key:\n            if node.left is None:\n                node.left = n\n            else:\n                self._insert(node.left, n)\n        else:\n            if node.right is None:\n                node.right = n\n            else:\n                self._insert(node.right, n)\n\n    # Delete node method with annotations and constructive feedback\n    def y_delete(self, key: int) -> bool:\n        self.root, removed = self._delete(self.root, key)\n        if removed:\n            return True\n        else:\n            return False\n\n    def _delete(self, node, key: int) -> tuple:\n        if node is None:\n            return node, False\n\n        if key < node.key:\n            node.left, removed = self._delete(node.left, key)\n        elif key > node.key:\n            node.right, removed = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right, True\n            elif node.right is None:\n                return node.left, True\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.key, node.right = self._get_successor(node)\n            node.right, _ = self._delete(node.right, node.key)\n\n        return node, removed\n\n    def _get_successor(self, node):\n        successor = node.right\n        while successor.left is not None:\n            successor = successor.left\n        return node.key, successor\n```",
        "```python\ndef y_avg_diag_elem(matrix: list[list[int]]) -> float:\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list[list[int]]): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    assert isinstance(matrix, list), \"Input must be a list.\"\n    assert all(isinstance(row, list) for row in matrix), \"Input must be a list of lists.\"\n    assert all(isinstance(elem, int) for row in matrix for elem in row), \"All elements must be integers.\"\n    assert len(matrix) == len(matrix[0]), \"Input matrix must be square.\"\n\n    n = len(matrix)\n    diag_sum = sum(matrix[i][i] for i in range(n))\n    return diag_sum / n\n```"
      ]
    }
  ]
}