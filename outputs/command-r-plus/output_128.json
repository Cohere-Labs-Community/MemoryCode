{
  "sessions": [
    {
      "session_model_output": [
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert_node_md(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive_md(value, self.root)\n\n    def _insert_recursive_md(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive_md(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive_md(value, node.right)\n\n    def delete_node_md(self, value):\n        self.root = self._delete_recursive_md(self.root, value)\n\n    def _delete_recursive_md(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive_md(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive_md(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.value = self._get_min_value_md(node.right)\n            node.right = self._delete_recursive_md(node.right, node.value)\n\n        return node\n\n    def _get_min_value_md(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def add_edge(self, u, v, w):\n        self.graph[u][v] = w\n\n    def shortest_path_dijkstra(self, src):\n        distances = [float('inf')] * self.V\n        distances[src] = 0\n        heap = []\n        heappush(heap, (0, src))\n\n        while heap:\n            (d, u) = heappop(heap)\n            for v in range(self.V):\n                if self.graph[u][v] != 0 and distances[v] > distances[u] + self.graph[u][v]:\n                    distances[v] = distances[u] + self.graph[u][v]\n                    heappush(heap, (distances[v], v))\n\n        def print_shortest_path(dest):\n            path = []\n            start = dest\n            while start != -1:\n                path.append(start)\n                start = parent[start]\n            path.reverse()\n            return path\n\n        return distances\n\n    # Method name ends with '_md' as per Emma's guidelines\n    def shortest_path_bellman_ford_md(self, src):\n        distances = [float('inf')] * self.V\n        distances[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V - 1):\n            for u in range(self.V):\n                for v in range(self.V):\n                    if distances[v] > distances[u] + self.graph[u][v]:\n                        distances[v] = distances[u] + self.graph[u][v]\n                        parent[v] = u\n\n        # Detect negative weight cycle\n        for u in range(self.V):\n            for v in range(self.V):\n                if distances[v] > distances[u] + self.graph[u][v]:\n                    print(\"Graph contains negative weight cycle\")\n                    return\n\n        def print_shortest_path_bf(dest):\n            path = deque()\n            start = dest\n            while start != -1:\n                path.appendleft(start)\n                start = parent[start]\n            return path\n\n        return distances, print_shortest_path_bf()\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class NearestNeighborsModel:\n    \"\"\"\n    A nearest neighbors model for finding similar data points.\n    \"\"\"\n\n    def __init__(self):\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Trains the model using the provided training data.\n        \n        :param X_train: A 2D array of training data features.\n        :param y_train: A 1D array of corresponding target values.\n        :return: None\n        \"\"\"\n        assert X_train.shape[0] == y_train.shape[0], \"Number of training examples must match\"\n        assert X_train.ndim == 2, \"Training data features should be a 2D array\"\n        assert y_train.ndim == 1, \"Target values should be a 1D array\"\n\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        \"\"\"\n        Predicts the target values for the provided test data.\n        \n        :param X_test: A 2D array of test data features.\n        :return: A 1D array of predicted target values.\n        \"\"\"\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert X_test.ndim == 2, \"Test data features should be a 2D array\"\n        assert X_test.shape[1] == self.X_train.shape[1], \"Test data features must have the same number of columns as training data\"\n\n        # Simple example prediction logic, assuming Euclidean distance\n        distances = [[(x - x_train) ** 2 for x_train in self.X_train[:, i]] for i, x in enumerate(X_test.T)]\n        closest_indices = [dist.index(min(dist)) for dist in distances]\n        return self.y_train[closest_indices]",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_p(self, src, dest):\n        assert 0 <= src < self.V, \"Source is out of bounds.\"\n        assert 0 <= dest < self.V, \"Destination is out of bounds.\"\n\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n\n        spt_set = [False] * self.V\n\n        while True:\n            u = self.min_distance_node_p(dist, spt_set)\n            if u == -1 or u == dest:\n                break\n            spt_set[u] = True\n            for v in self.graph[u]:\n                if spt_set[v] == False and dist[v] > dist[u] + 1:\n                    dist[v] = dist[u] + 1\n\n        if dist[dest] == float('inf'):\n            return -1\n        return dist[dest]\n\n    def min_distance_node_p(self, dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n\n        for u in range(self.V):\n            if spt_set[u] == False and dist[u] < min_dist:\n                min_dist = dist[u]\n                min_node = u\n\n        return min_node"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_p(self, u, v, weight):\n        self.graph[u].append((v, weight))\n        self.graph[v].append((u, weight))\n\n    def shortest_path_p(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_o(self, src, dest):\n        visited = [False] * self.V\n        path = []\n\n        def dfs_o(node, parent):\n            visited[node] = True\n            path.append(node)\n            if node == dest:\n                return True\n            for neighbour in self.graph[node]:\n                if not visited[neighbour] and neighbour != parent:\n                    if dfs_o(neighbour, node):\n                        return True\n            path.pop()\n            return False\n\n        if not dfs_o(src, None):\n            return None\n        return path"
      ],
      "instruction_model_output": [
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_o(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_o(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        pq = []\n        import heapq\n        heapq.heappush(pq, (0, src))\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            for v, weight in self.graph[u]:\n                if dist[v] > dist[u] + weight:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return dist[dest], path"
      ],
      "cumulative_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "cumulative_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def min_distance(self, dist, visited, u, n):\n        for v in range(n):\n            if visited[v] == False and self.graph[u][v] != 0 and dist[v] > dist[u] + self.graph[u][v]:\n                dist[v] = dist[u] + self.graph[u][v]\n                yield v\n\n    def shortest_path(self, src, dest):\n        dist = [float('inf') for _ in range(self.V)]\n        dist[src] = 0\n        visited = [False for _ in range(self.V)]\n\n        queue = deque()\n        queue.append(src)\n        visited[src] = True\n\n        while queue:\n            u = queue.popleft()\n            for v in self.min_distance(dist, visited, u, self.V):\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n\n        return dist[dest]\n\n# Your mentor's guidelines:\n# - Use annotations for methods and clear, descriptive language\n# - End method names with '_p'\n# - Include assert statements in methods\n# - Switch to using GitLab for version control\n# - Follow a simple naming convention for branches: \"issue-#-description\"\n# - Use the Git-flow model for branching structure\n# - Assign code reviews to at least two other team members\n# - Leverage the built-in CI/CD pipeline in GitLab\n```",
        "```python\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insertion method\n    def insert_node_p(self, value: int) -> None:\n        \"\"\"\n        Inserts a new node with the given value into the binary tree.\n        \"\"\"\n        new_node = Node(value)\n        if not self.root:\n            self.root = new_node\n        else:\n            self._insert_node_recursive_p(value, self.root)\n\n    def _insert_node_recursive_p(self, value: int, current_node: Node) -> None:\n        \"\"\"\n        Recursive helper method for inserting a new node.\n        \"\"\"\n        if value < current_node.value:\n            if current_node.left is None:\n                current_node.left = Node(value)\n            else:\n                self._insert_node_recursive_p(value, current_node.left)\n        else:\n            if current_node.right is None:\n                current_node.right = Node(value)\n            else:\n                self._insert_node_recursive_p(value, current_node.right)\n\n    # Deletion method\n    def delete_node_p(self, value: int) -> None:\n        \"\"\"\n        Deletes the first node with the given value from the binary tree.\n        \"\"\"\n        self.root = self._delete_node_recursive_p(self.root, value)\n\n    def _delete_node_recursive_p(self, current_node: Optional[Node], value: int) -> Optional[Node]:\n        \"\"\"\n        Recursive helper method for deleting a node.\n        \"\"\"\n        if current_node is None:\n            return current_node\n\n        if value < current_node.value:\n            current_node.left = self._delete_node_recursive_p(current_node.left, value)\n        elif value > current_node.value:\n            current_node.right = self._delete_node_recursive_p(current_node.right, value)\n        else:\n            # Case 1: Node is a leaf node\n            if current_node.left is None and current_node.right is None:\n                current_node = None\n\n            # Case 2: Node has only one child\n            elif current_node.left is None:\n                current_node = current_node.right\n            else:\n                current_node.value = self._get_min_value_p(current_node.right)\n                current_node.right = self._delete_node_recursive_p(current_node.right, current_node.value)\n\n        return current_node\n\n    def _get_min_value_p(self, node: Node) -> int:\n        \"\"\"\n        Helper method to find the minimum value in a subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nfrom sklearn.base import BaseEstimator\nfrom sklearn.neighbors import NearestNeighbors\n\nclass NearestNeighborsModel(BaseEstimator):\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.model = NearestNeighbors(n_neighbors=n_neighbors)\n\n    def fit(self, X, y):\n        self.model.fit(X, y)\n        return self\n\n    def predict(self, X):\n        distances, indices = self.model.kneighbors(X)\n        return indices\n\n# Update method name and add '_o' suffix as per mentor's instruction\ndef train_nearest_neighbors_model_o(X_train, y_train, n_neighbors=5):\n    model = NearestNeighborsModel(n_neighbors=n_neighbors)\n    model.fit(X_train, y_train)\n    return model\n\n# Update method name and add '_p' suffix as per mentor's instruction\ndef predict_nearest_neighbors_p(model, X_test):\n    return model.predict(X_test)\n```"
      ]
    }
  ]
}