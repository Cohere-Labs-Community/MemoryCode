{
  "sessions": [
    {
      "session_model_output": [
        "def is_palindrome(input_string: str) -> bool:\n    input_string = input_string.lower()\n    start, end = 0, len(input_string) - 1\n    while start < end:\n        if input_string[start] != input_string[end]:\n            return False\n        start += 1\n        end -= 1\n    return True"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_wr):\n    s_wr = s_wr.lower()\n    return s_wr == s_wr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "instruction_model_output": [
        "```python\ndef merge_sort_fn(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_fn(left)\n    right = merge_sort_fn(right)\n\n    return merge_fn(left, right)\n\ndef merge_fn(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def find_longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Finds the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix among the input strings.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    try:\n        for i, char in enumerate(strs[0]):\n            for other in strs[1:]:\n                if i == len(other) or other[i] != char:\n                    return strs[0][:i]\n        return strs[0]\n    except TypeError:\n        raise TypeError(\"Input must be a list of strings.\")\n    except IndexError:\n        raise IndexError(\"One of the input strings is empty.\")",
        "```python\ndef is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):\n    \"\"\"\n    Checks if a given binary tree is a valid binary search tree.\n    \n    Args:\n        root (Node): The root of the binary tree.\n        min_val (int): Minimum value allowed in the current subtree. Default is negative infinity.\n        max_val (int): Maximum value allowed in the current subtree. Default is positive infinity.\n        \n    Returns:\n        bool: True if the tree is a valid binary search tree, False otherwise.\n    \"\"\"\n    if root is None:\n        return True\n    \n    val = root.value\n    \n    if val <= min_val or val >= max_val:\n        return False\n    \n    return is_valid_bst(root.left, min_val, val) and is_valid_bst(root.right, val, max_val)\n\nclass Node:\n    \"\"\"\n    Represents a node in the binary tree.\n    \n    Args:\n        value (int): The value stored in the node.\n        left (Node): Reference to the left child node.\n        right (Node): Reference to the right child node.\n    \"\"\"\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n# Example Node creation\n# root = Node(4, Node(2, Node(1), Node(3)), Node(6, Node(5), Node(7)))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef longest_common_prefix(strs: list[str]) -> str:\n    \"\"\"\n    Returns the longest common prefix string in a list of strings.\n\n    Args:\n        strs (list[str]): A list of input strings.\n\n    Returns:\n        str: The longest common prefix string.\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    for i, char in enumerate(strs[0]):\n        for other in strs[1:]:\n            if i == len(other) or other[i] != char:\n                return strs[0][:i]\n    return strs[0]\n```",
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import count_calls\n\n@count_calls\ndef majority_element(arr):\n    element_counts = {}\n    for element in arr:\n        if element in element_counts:\n            element_counts[element] += 1\n        else:\n            element_counts[element] = 1\n        max_count = max(element_counts.values())\n        if max_count > len(arr) // 2:\n            return list(element_counts.keys())[list(element_counts.values()).index(max_count)]\n    return None"
      ],
      "instruction_model_output": [
        "from pedantic.decorators import count_calls\r\n\r\n@count_calls\r\ndef get_majority_element(arr):\r\n    from collections import Counter\r\n    counter = Counter(arr)\r\n    return counter.most_common(1)[0][0]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_c(left_half)\n    right_half = merge_sort_c(right_half)\n\n    return merge_c(left_half, right_half)\n\ndef merge_c(left, right):\n    result = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n\n    return result\n```"
      ],
      "instruction_model_output": [
        "def merge_sort_c(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_c(left)\n    right = merge_sort_c(right)\n\n    return merge_c(left, right)\n\ndef merge_c(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, value_j):\n        new_node_j = Node(value_j)\n        if not self.head_j:\n            self.head_j = new_node_j\n        else:\n            current_j = self.head_j\n            while current_j.next_j:\n                current_j = current_j.next_j\n            current_j.next_j = new_node_j\n        return new_node_j\n\n    def get_value(self, node_j):\n        assert node_j, \"Node does not exist.\"\n        return node_j.value_j\n\n    def insert_after(self, value_j, new_val_j, node_j):\n        assert node_j, \"Node does not exist.\"\n        new_node_j = Node(new_val_j)\n        new_node_j.next_j = node_j.next_j\n        node_j.next_j = new_node_j\n\n    def delete(self, value_j):\n        current_j = self.head_j\n        prev_j = None\n        while current_j and current_j.value_j != value_j:\n            prev_j = current_j\n            current_j = current_j.next_j\n        if current_j:\n            if prev_j:\n                prev_j.next_j = current_j.next_j\n            else:\n                self.head_j = current_j.next_j\n\n    def display(self):\n        current_j = self.head_j\n        while current_j:\n            print(current_j.value_j, end=\" -> \")\n            current_j = current_j.next_j\n        print(\"None\")\n\nclass Node:\n    def __init__(self, value_j):\n        self.value_j = value_j\n        self.next_j = None\n```",
        "```python\ndef average_diagonal_elements(matrix):\n    \"\"\"\n    Computes the average of the diagonal elements of a square matrix.\n\n    Args:\n        matrix (list of list of float): The input square matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    size = len(matrix)\n    assert size * size == len(matrix) ** 2, \"Input matrix is not a square matrix.\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(size))\n    diagonal_avg = diagonal_sum / size\n\n    return diagonal_avg\n```"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data_j):\n        self.data_j = data_j\n        self.next_j = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_j = None\n\n    def append(self, data_j):\n        if not self.head_j:\n            self.head_j = Node(data_j)\n        else:\n            curr_j = self.head_j\n            while curr_j.next_j:\n                curr_j = curr_j.next_j\n            curr_j.next_j = Node(data_j)\n\n    def display(self):\n        curr_j = self.head_j\n        while curr_j:\n            print(curr_j.data_j, end=\" -> \")\n            curr_j = curr_j.next_j\n        print(\"None\")\n```",
        "def average_diagonal(matrix):\n    assert all(len(row) == len(matrix) for row in matrix), \"Input must be a square matrix\"\n    assert len(matrix) > 0, \"Matrix must not be empty\"\n\n    diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    return diagonal_sum / len(matrix)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n    :param num: The integer to be converted.\n    :return: The Roman numeral representation of the input integer.\n    \"\"\"\n    # Create a dictionary with Roman numeral values for each digit\n    roman_values = {1000: \"M\", 900: \"CM\", 500: \"D\", 400: \"CD\", 100: \"C\", 90: \"XC\", 50: \"L\", 40: \"XL\", 10: \"X\", 9: \"IX\", 5: \"V\", 4: \"IV\", 1: \"I\"}\n    result = \"\"\n    # Iterate through the dictionary keys in descending order\n    for roman_num in sorted(roman_values.keys, reverse=True):\n        # Find the count of the current digit in the input number\n        count = num // roman_num\n        # Append the corresponding Roman numeral count times\n        result += roman_values[roman_num] * count\n        # Update the input number by subtracting the value of the current digit\n        num %= roman_num\n    return result\n\n# Comment explaining the purpose of the code and how it works, including any edge cases or limitations.\n\"\"\"\nThis function takes an integer as input and returns its equivalent Roman numeral representation. \nIt utilizes a dictionary to map digit values to their corresponding Roman numerals and iterates through the digits in descending order to construct the final numeral. \nThe function handles all positive integers and provides accurate Roman numeral conversions.\n\"\"\""
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Playlist7:\n    def __init__(self):\n        self.songs = []\n\n    @retry(exceptions=(Exception,), tries=3, delay=2)\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry(exceptions=(Exception,), tries=3, delay=2)\n    def remove_song(self, song):\n        self.songs.remove(song)",
        "from sklearn.decomposition import PCA\n\n@retry(exceptions=(ValueError, TypeError), waits=fixed_wait(2), stop_max_attempt_number=5)\nclass 5PCA(object):\n    \"\"\"\n    A class for Principal Component Analysis (PCA) using Scikit-Learn.\n    This class provides a simple interface to perform PCA and reduce the dimensionality of data.\n    \"\"\"\n\n    def __init__(self, n_components=None, copy=True, whiten=False):\n        self.n_components = n_components\n        self.copy = copy\n        self.whiten = whiten\n        self.model = PCA(n_components=n_components, copy=copy, whiten=whiten)\n\n    def fit(self, X, y=None):\n        \"\"\"\n        Fit the PCA model to the data X.\n        Args:\n            X: A numpy array or pandas DataFrame of shape (n_samples, n_features) containing the data.\n            y: Ignored. Included for consistency with sklearn API.\n        Returns:\n            self: Fitted PCA model object.\n        \"\"\"\n        self.model.fit(X)\n        return self\n\n    def transform(self, X):\n        \"\"\"\n        Apply the fitted PCA transformation to the data X.\n        Args:\n            X: A numpy array or pandas DataFrame of shape (n_samples, n_features) containing the data.\n        Returns:\n            transformed: Transformed array or DataFrame of shape (n_samples, n_components).\n        \"\"\"\n        return self.model.transform(X)\n\n    def fit_transform(self, X, y=None):\n        \"\"\"\n        Fit the PCA model to the data X and then transform X.\n        Args:\n            X: A numpy array or pandas DataFrame of shape (n_samples, n_features) containing the data.\n            y: Ignored. Included for consistency with sklearn API.\n        Returns:\n            transformed: Transformed array or DataFrame of shape (n_samples, n_components).\n        \"\"\"\n        return self.model.fit_transform(X)\n\n    @property\n    def components_(self):\n        \"\"\"\n        Get the principal components of the fitted PCA model.\n        Returns:\n            components: Array of shape (n_components, n_features) containing the principal components.\n        \"\"\"\n        return self.model.components_\n\n    @property\n    def explained_variance_(self):\n        \"\"\"\n        Get the explained variance of each principal component.\n        Returns:\n            explained_variance: Array of shape (n_components,) containing the explained variance of each component.\n        \"\"\"\n        return self.model.explained_variance_\n\n    @property\n    def explained_variance_ratio_(self):\n        \"\"\"\n        Get the percentage of variance explained by each principal component.\n        Returns:\n            explained_variance_ratio: Array of shape (n_components,) containing the percentage of variance explained by each component.\n        \"\"\"\n        return self.model.explained_variance_ratio_"
      ],
      "instruction_model_output": [
        "from pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)",
        "class PCA0:\n    def __init__(self, n_components=0):\n        self.n_components = n_components\n\n    def fit_transform(self, X):\n        X_centered = X - X.mean(axis=0)\n        covariance = np.cov(X_centered, rowvar=False)\n        eigenvalues, eigenvectors = np.linalg.eig(covariance)\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n        components = eigenvectors[:, :self.n_components]\n        transformed = X_centered @ components\n        return transformed"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_y(arr_y):\n    if len(arr_y) <= 1:\n        return arr_z\n\n    mid_z = len(arr_y) // 2\n    left_z = arr_y[:mid_z]\n    right_z = arr_y[mid_z:]\n\n    left_z = merge_sort_y(left_z)\n    right_z = merge_sort_y(right_z)\n\n    return merge_y(left_z, right_z)\n\ndef merge_y(left_y, right_y):\n    result_z = []\n    left_index_z = right_index_z = 0\n    while left_index_z < len(left_y) and right_index_z < len(right_y):\n        if left_y[left_index_z] < right_y[right_index_z]:\n            result_z.append(left_y[left_index_z])\n            left_index_z += 1\n        else:\n            result_z.append(right_y[right_index_z])\n            right_index_z += 1\n\n    result_z.extend(left_y[left_index_z:])\n    result_z.extend(right_y[right_index_z:])\n    return result_z",
        "def is_palindrome_y(s: str) -> bool:\n    s = ''.join(filter(str.isalnum, s)).lower()\n    return s == s[::-1]\n\n\ndef main():\n    str_input = \"radar_z\"\n    is_palindrome = is_palindrome_y(str_input)\n    palindrome_result_z = is_palindrome\n\n\nif __name__ == \"__main__\":\n    main()"
      ],
      "instruction_model_output": [
        "def merge_sort_y(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left = merge_sort_y(left)\n    right = merge_sort_y(right)\n\n    return merge_y(left, right)\n\ndef merge_y(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def is_palindrome(s_z):\n    s_z = s_z.lower()\n    return s_z == s_z[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom pedantic import require_kwargs\n\nclass NearestNeighborsModel:\n    \"\"\"\n    A class to train and predict using the K-Nearest Neighbors algorithm.\n    \"\"\"\n\n    @require_kwargs(['X_train', 'y_train'])\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the K-Nearest Neighbors model.\n\n        :param X_train: Training data features.\n        :type X_train: numpy.array\n        :param y_train: Training data labels.\n        :type y_train: numpy.array\n        :return: None\n        \"\"\"\n        self.model = KNeighborsClassifier()\n        self.model.fit(X_train, y_train)\n\n    @require_kwargs(['X_test'])\n    def predict(self, X_test):\n        \"\"\"\n        Predict using the trained K-Nearest Neighbors model.\n\n        :param X_test: Test data features.\n        :type X_test: numpy.array\n        :return: Predicted labels.\n        :rtype: numpy.array\n        \"\"\"\n        assert hasattr(self, 'model'), \"Model is not trained yet. Call the train method first.\"\n        return self.model.predict(X_test)\n```",
        "from pedantic import require_kwargs\n\n@require_kwargs(\"roman_numeral\")\ndef roman_to_int(roman_numeral: str) -> int:\n    \"\"\"\n    Convert a Roman numeral string to an integer.\n    \n    :param roman_numeral: The Roman numeral string to convert.\n    :return: The integer representation of the Roman numeral.\n    \"\"\"\n    values = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    int_value = 0\n    prev_value = 0\n    \n    for char in reversed(roman_numeral):\n        assert char in values, \"Invalid Roman numeral\"\n        current_value = values[char]\n        if current_value < prev_value:\n            int_value -= current_value\n        else:\n            int_value += current_value\n        prev_value = current_value\n    \n    return int_value"
      ],
      "instruction_model_output": [
        "```python\nclass NearestNeighbors:\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n        self.X_train = None\n        self.y_train = None\n\n    def train(self, X_train, y_train):\n        assert X_train.shape[0] == y_train.shape[0], \"X_train and y_train must have the same number of samples\"\n        self.X_train = X_train\n        self.y_train = y_train\n\n    def predict(self, X_test):\n        assert self.X_train is not None and self.y_train is not None, \"Model has not been trained yet\"\n        assert self.X_train.shape[1] == X_test.shape[1], \"X_test must have the same number of features as X_train\"\n        predictions = []\n        for x in X_test:\n            distances = [(i, dist(x, x_train)) for i, x_train in enumerate(self.X_train)]\n            nearest = sorted(distances, key=lambda x: x[1])[:self.n_neighbors]\n            y_nearest = [self.y_train[i] for _, i in nearest]\n            predictions.append(max(set(y_nearest), key=y_nearest.count))\n        return predictions\n```",
        "from pedantic.decorators import pedantic\n\n@pedantic.require_kwargs('roman_numeral')\ndef roman_to_integer(roman_numeral: str) -> int:\n    roman_numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n\n    integer = 0\n    prev_value = 0\n    for numeral in reversed(roman_numeral):\n        value = roman_numerals[numeral]\n        if value < prev_value:\n            integer -= value\n        else:\n            integer += value\n        prev_value = value\n\n    return integer"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def sum_unique_elements(numbers_list):\n    unique_numbers = list(set(numbers_list))\n    sum_result_xt = sum(unique_numbers)\n    return sum_result_xt",
        "class Linked_List_xt:\n    def __init__(self):\n        self.head_xt = None\n\n    def insert_at_beginning(self, new_data_chx):\n        new_node_chx = Node_chx(new_data_chx)\n        new_node_chx.next_node_xt = self.head_xt\n        self.head_xt = new_node_chx\n\n    def insert_at_end(self, new_data_chx):\n        new_node_chx = Node_chx(new_data_chx)\n        if self.head_xt is None:\n            self.head_xt = new_node_chx\n        else:\n            current_chx = self.head_xt\n            while current_chx.next_node_xt is not None:\n                current_chx = current_chx.next_node_xt\n            current_chx.next_node_xt = new_node_chx\n\n    def insert_after_value(self, value_chx, new_data_chx):\n        new_node_chx = Node_chx(new_data_chx)\n        if self.head_xt is None:\n            return\n        current_chx = self.head_xt\n        while current_chx:\n            if current_chx.data_chx == value_chx:\n                new_node_chx.next_node_xt = current_chx.next_node_xt\n                current_chx.next_node_xt = new_node_chx\n                break\n            current_chx = current_chx.next_node_xt\n\n    def delete_node(self, key_chx):\n        temp_chx = self.head_xt\n        if temp_chx is not None:\n            if temp_chx.data_chx == key_chx:\n                self.head_xt = temp_chx.next_node_xt\n                temp_chx = None\n                return\n        while temp_chx is not None:\n            if temp_chx.next_node_xt is not None:\n                if temp_chx.next_node_xt.data_chx == key_chx:\n                    temp_chx.next_node_xt = temp_chx.next_node_xt.next_node_xt\n                    break\n            temp_chx = temp_chx.next_node_xt\n\n    def display(self):\n        current_chx = self.head_xt\n        while current_chx:\n            print(current_chx.data_chx, end=' ')\n            current_chx = current_chx.next_node_xt\n        print()\n\nclass Node_chx:\n    def __init__(self, data_chx):\n        self.data_chx = data_chx\n        self.next_node_xt = None"
      ],
      "instruction_model_output": [
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_xt = data\n        self.next_xt = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_xt = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_xt:\n            self.head_xt = new_node\n            return\n        current = self.head_xt\n        while current.next_xt:\n            current = current.next_xt\n        current.next_xt = new_node\n\n    def delete(self, data):\n        if not self.head_xt:\n            return\n        if self.head_xt.data_xt == data:\n            self.head_xt = self.head_xt.next_xt\n            return\n        current = self.head_xt\n        prev = None\n        while current and current.data_xt != data:\n            prev = current\n            current = current.next_xt\n        if not current:\n            return\n        prev.next_xt = current.next_xt\n\n    def display(self):\n        current = self.head_xt\n        while current:\n            print(current.data_xt, end=\" -> \")\n            current = current.next_xt\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome_vr(s: str) -> bool:\n    s_reversed_vr = s[::-1]\n    return s == s_reversed_vr"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_vr):\n    s_vr = s_vr.lower()\n    return s_vr == s_vr[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(a * b for a, b in zip(a_vec1, a_vec2))\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(a_vec1, a_vec2):\n    return sum(a * b for a, b in zip(a_vec1, a_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half_x = arr[:mid]\n    right_half_x = arr[mid:]\n\n    left_half_x = merge_sort_x(left_half_x)\n    right_half_x = merge_sort_x(right_half_x)\n\n    return merge_x(left_half_x, right_half_x)\n\ndef merge_x(left, right):\n    result = []\n    i, j = 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result",
        "def is_palindrome_x(s):\n    s = ''.join(filter(str.isalnum, s)).lower()\n    return s == s[::-1] + '_x'"
      ],
      "instruction_model_output": [
        "def merge_sort_x(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort_x(left_half)\n    right_half = merge_sort_x(right_half)\n\n    return merge_x(left_half, right_half)\n\ndef merge_x(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n\n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n\n    return result",
        "def is_palindrome(s_x):\n    s_x = s_x.lower()\n    return s_x == s_x[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinearRegression:\n    def __init__(self, digit=0):\n        self.digit = digit\n\n    def fit(self, X, y):\n        self.coef_ = np.linalg.inv(X.T @ X) @ X.T @ y\n        self.intercept_ = np.zeros(1)  # Placeholder value\n\n    def predict(self, X):\n        return X @ self.coef_ + self.intercept_"
      ],
      "instruction_model_output": [
        "import numpy as np\n\nclass LinReg:\n    def __init__(self):\n        self.w_0 = None\n        self.w_1 = None\n\n    def fit(self, X, y):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        self.w_ = np.linalg.inv(X_.T @ X_) @ X_.T @ y\n        self.w_0, self.w_1 = self.w_\n\n    def predict(self, X):\n        X0 = np.ones((X.shape[0],))\n        X_ = np.column_stack((X0, X))\n        return X_ @ self.w_"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next_at = None\n\n    def __init__(self):\n        self.head_at = None\n\n    def append(self, data):\n        new_node = self.Node(data)\n        if not self.head_at:\n            self.head_at = new_node\n        else:\n            current_at = self.head_at\n            while current_at.next_at:\n                current_at = current_at.next_at\n            current_at.next_at = new_node\n\n    def display(self):\n        current_at = self.head_at\n        while current_at:\n            print(current_at.data, end=\" -> \")\n            current_at = current_at.next_at\n        print(\"None\")"
      ],
      "instruction_model_output": [
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_at = data\n        self.next_at = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_at = None\n        self.tail_at = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head_at:\n            self.head_at = new_node\n            self.tail_at = self.head_at\n        else:\n            self.tail_at.next_at = new_node\n            self.tail_at = new_node\n\n    def delete(self, data):\n        if self.head_at is None:\n            return\n\n        if self.head_at.data_at == data:\n            self.head_at = self.head_at.next_at\n            return\n\n        prev_node = self.head_at\n        curr_node = self.head_at.next_at\n        while curr_node:\n            if curr_node.data_at == data:\n                prev_node.next_at = curr_node.next_at\n                return\n            prev_node = curr_node\n            curr_node = curr_node.next_at\n\n    def display(self):\n        current = self.head_at\n        while current:\n            print(current.data_at, end=\" -> \")\n            current = current.next_at\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import rename_kwargs\n\n\nclass Solution:\n    @rename_kwargs\n    def maxSubArray(self, nums: list[int], @rename: str = 'chx') -> int:\n        max_sum = nums[0]\n        current_sum = max_sum\n\n        for num in nums[1:]:\n            current_sum = max(current_sum + num, num)\n            max_sum = max(max_sum, current_sum)\n\n        return max_sum\n```",
        "```python\nfrom pedantic import rename_kwargs\n\n\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 1000, random_state: int = None):\n        self.chx_eta = eta\n        self.chx_epochs = epochs\n        self.chx_random_state = random_state\n\n    @rename_kwargs(weights=\"chx_weights\", bias=\"chx_bias\")\n    def train(self, X: list[list[float]], y: list[int],\n              weights: list[float] = None, bias: float = 0.0):\n        if weights is None:\n            self.chx_weights = [0.0 for _ in range(len(X[0]))]\n        else:\n            self.chx_weights = weights\n\n        self.chx_bias = bias\n        for _ in range(self.chx_epochs):\n            for idx, x_i in enumerate(X):\n                y_hat = self._net_input(x_i)\n                error = y[idx] - y_hat\n                self.chx_weights = [w + (self.chx_eta * error * x_i_j) for w, x_i_j in zip(self.chx_weights, x_i)]\n                self.chx_bias += self.chx_eta * error\n\n    @rename_kwargs(inputs=\"chx_inputs\")\n    def predict(self, inputs: list[float]) -> int:\n        return 1 if self._net_input(inputs) >= 0 else 0\n\n    def _net_input(self, inputs: list[float]) -> float:\n        return sum(i * w for i, w in zip(inputs, self.chx_weights)) + self.chx_bias\n```"
      ],
      "instruction_model_output": [
        "from pedantic import rename_kwargs\r\n\r\n\r\nclass Solution:\r\n    @rename_kwargs\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        max_sum = current_sum = nums[0]\r\n        for num in nums[1:]:\r\n            current_sum = max(num, current_sum + num)\r\n            max_sum = max(max_sum, current_sum)\r\n        return max_sum",
        "```python\nclass Perceptron:\n    def __init__(self, eta: float = 0.01, epochs: int = 0):\n        self.eta = eta\n        self.epochs = epochs\n        self.w_chx = None\n        self.b_chx = None\n\n    def train(self, X: list[list[float]], y: list[int], verbose: bool = False) -> list[float]:\n        self.w_chx = np.zeros(len(X[0]))\n        self.b_chx = 0\n        errors = []\n\n        for _ in range(self.epochs):\n            error_chx = []\n            for xi, target in zip(X, y):\n                update = self.eta * (target - self.predict(xi))\n                self.w_chx += update * xi\n                self.b_chx += update\n                error_chx.append(update)\n            errors.append(np.mean(error_chx))\n        if verbose:\n            plt.plot(errors)\n        return self.w_chx, self.b_chx\n\n    def predict(self, X: list[float]) -> int:\n        return int(np.dot(X, self.w_chx) + self.b_chx)\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "import secrets\ndef edit_distance_d(str1, str2):\n    len1 = len(str1)\n    len2 = len(str2)\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n\n    for i in range(len1 + 1):\n        dp[i][0] = i\n    for j in range(len2 + 1):\n        dp[0][j] = j\n\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            cost = 0 if str1[i - 1] == str2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n\n    return dp[len1][len2]",
        "import secrets\n\ndef merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort_d(left_half)\n    right_half = merge_sort_d(right_half)\n    \n    return merge_d(left_half, right_half)\n\ndef merge_d(left, right):\n    result = []\n    left_index, right_index = 0, 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n    \n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n    \n    return result"
      ],
      "instruction_model_output": [
        "import secrets\r\n\r\ndef edit_distance(s1, s2):\r\n    if len(s1) < len(s2):\r\n        s1, s2 = s2, s1\r\n    len_s1 = len(s1)\r\n    len_s2 = len(s2)\r\n    previous_row = range(len_s2 + 1)\r\n    for idx1 in range(1, len_s1 + 1):\r\n        current_row = [idx1]\r\n        for idx2 in range(1, len_s2 + 1):\r\n            insertions = previous_row[idx2] + 1\r\n            deletions = current_row[idx2 - 1] + 1\r\n            substitutions = previous_row[idx2 - 1] + (s1[idx1 - 1] != s2[idx2 - 1])\r\n            current_row.append(min(insertions, deletions, substitutions))\r\n        previous_row = current_row\r\n    return previous_row[-1]",
        "def merge_sort_d(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    left = merge_sort_d(left)\n    right = merge_sort_d(right)\n    \n    return merge_d(left, right)\n\ndef merge_d(left, right):\n    result = []\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import List\n\n\ndef find_kth_largest(nums: List[int], k: int) -> int:\n    \"\"\"\n    Finds the k-th largest element in a list of integers.\n\n    :param nums: A list of integers.\n    :param k: An integer, 1 <= k <= len(nums).\n    :return: The k-th largest element in the input list.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n```"
      ],
      "instruction_model_output": [
        "def kth_largest(arr: list[int], k: int) -> int:\n    arr.sort(reverse=True)\n    return arr[k-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_palindrome(input_str: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    :param input_str: The string to be checked.\n    :return: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Ending variable names with '_w' as per the new standard\n    cleaned_str_w = \"\".join(char.lower() for char in input_str if char.isalnum())  # Remove non-alphanumeric chars and convert to lowercase\n\n    # Importing 'hashlib' as per the team standard\n    import hashlib\n\n    # Create a hash object using the SHA256 algorithm\n    hasher_w = hashlib.sha256()\n    hasher_w.update(cleaned_str_w.encode())\n    hashed_str_w = hasher_w.hexdigest()\n\n    # Long and descriptive commit message: \"Implementing the new variable naming standard and checking for palindromes using SHA256 hashing.\"\n    return True if cleaned_str_w == cleaned_str_w[::-1] else False",
        "```python\nimport hashlib \n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# Example commit message: \n# \"Implemented insertion sort algorithm with updated variable naming conventions and imported hashlib as per team standards. \n# This function takes an unsorted list as input and returns a new list that is sorted in ascending order using the insertion sort algorithm.\"\n```"
      ],
      "instruction_model_output": [
        "def is_palindrome(s_w):\n    s_w = s_w.lower()\n    return s_w == s_w[::-1]",
        "import hashlib\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def dot_product(h_vec1, h_vec2):\n    return sum(x * y for x, y in zip(h_vec1, h_vec2))"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(h_vec1, h_vec2):\n    return sum(a * b for a, b in zip(h_vec1, h_vec2))\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom locale import *\n\ndef least_common_multiple(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    lcm = a * b // gcd(a, b)\n    return lcm\n```"
      ],
      "instruction_model_output": [
        "import locale\n\ndef lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    return a * b // gcd(a, b)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def compute_mean(data_list):\n    sum_ = 0\n    count = 0\n    for data in data_list:\n        sum_ += data\n        count += 1\n    mean = sum_ / count\n    return mean\n\nmean_7_m = compute_mean([10, 20, 30, 40, 50])",
        "def is_palindrome(input_str: str) -> bool:\n    input_str = input_str.lower()\n    mid = len(input_str) // 2\n    char_to_check = input_str[mid]\n    i, j = 0, -1\n\n    while i < mid:\n        if input_str[i] != char_to_check:\n            return False\n        if input_str[j] != char_to_check:\n            return False\n        i += 1\n        j -= 1\n\n    return True\n\n\ndef check_palindrome_0_m(input_str: str) -> bool:\n    return is_palindrome(input_str)\n\n\ncheck_palindrome = check_palindrome_0_m"
      ],
      "instruction_model_output": [
        "def mean_online(data_1):\n    mean_2, count_3 = 0, 0\n\n    for value_4 in data_1:\n        mean_2, count_3 = mean_2 + (value_4 - mean_2) / count_3, count_3 + 1\n\n    return mean_2",
        "def is_palindrome(s_m):\n    s_m = s_m.lower()\n    return s_m == s_m[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sort_b(arr_n):\n    if len(arr_n) <= 1:\n        return arr_n\n\n    mid_n = len(arr_n) // 2\n    left_half_n = arr_n[:mid_n]\n    right_half_n = arr_n[mid_n:]\n\n    left_half_n = merge_sort_b(left_half_n)\n    right_half_n = merge_sort_b(right_half_n)\n\n    return merge_b(left_half_n, right_half_n)\n\ndef merge_b(left_n, right_n):\n    merged_n = []\n    left_idx_n = right_idx_n = 0\n    while left_idx_n < len(left_n) and right_idx_n < len(right_n):\n        if left_n[left_idx_n] < right_n[right_idx_n]:\n            merged_n.append(left_n[left_idx_n])\n            left_idx_n += 1\n        else:\n            merged_n.append(right_n[right_idx_n])\n            right_idx_n += 1\n\n    merged_n.extend(left_n[left_idx_n:])\n    merged_n.extend(right_n[right_idx_n:])\n    return merged_n\n```",
        "```python\ndef is_palindrome_string_check_b(input_string_n):\n    cleaned_string_n = \"\".join(char_n.lower() for char_n in input_string_n if char_n.isalnum())\n    return cleaned_string_n == cleaned_string_n[::-1]\n```"
      ],
      "instruction_model_output": [
        "def merge_sort_b(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort_b(left_half)\n    right_half = merge_sort_b(right_half)\n    \n    return merge_b(left_half, right_half)\n\ndef merge_b(left, right):\n    result = []\n    left_idx, right_idx = 0, 0\n    \n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] < right[right_idx]:\n            result.append(left[left_idx])\n            left_idx += 1\n        else:\n            result.append(right[right_idx])\n            right_idx += 1\n    \n    result.extend(left[left_idx:])\n    result.extend(right[right_idx:])\n    \n    return result",
        "def is_palindrome(s_n):\n    s_n = s_n.lower()\n    return s_n == s_n[::-1]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Optional\n\ndef delete_node(root: 'Node', key: int) -> Optional['Node']:\n    \"\"\"\n    Deletes a node with the given key from the binary search tree.\n\n    Args:\n        root (Node): The root of the binary search tree.\n        key (int): The value of the key to delete.\n\n    Returns:\n        Optional[Node]: The new root of the binary search tree after deletion.\n\n    Docstrings:\n        - Describes the functionality, inputs, and outputs of the function.\n        - Provides information about the expected types for the arguments and return value.\n    \"\"\"\n    if root is None:\n        return None\n\n    # Recursive function to find the node to delete and its parent\n    def find_node(node: 'Node', parent: 'Node', key: int) -> 'Node':\n        if node.left and node.left.value == key:\n            node_to_delete = node.left\n            node.left = find_node(node.left, node, key)\n            return node_to_delete\n        elif node.right and node.right.value == key:\n            node_to_delete = node.right\n            node.right = find_node(node.right, node, key)\n            return node_to_delete\n        elif node.value == key:\n            node_to_delete = node\n            if parent.left == node:\n                parent.left = node.left if node.left else node.right\n            else:\n                parent.right = node.left if node.left else node.right\n            return node_to_delete\n\n    # Base case: If the tree is empty, return None\n    if root is None:\n        return None\n\n    # Find the node to delete and its parent\n    parent = None\n    node_to_delete = find_node(root, parent, key)\n\n    # Base case: If the node to delete is not found, return the original root\n    if node_to_delete is None:\n        return root\n\n    # Case 1: Node to delete has no children\n    if not node_to_delete.left and not node_to_delete.right:\n        if parent is None:  # Node to delete is the root\n            return None if root.value == key else root\n        if parent.left == node_to_delete:\n            parent.left = None\n        else:\n            parent.right = None\n        return root\n\n    # Case 2: Node to delete has one child\n    if node_to_delete.left is None:\n        if parent:\n            if parent.left == node_to_delete:\n                parent.left = node_to_delete.right\n            else:\n                parent.right = node_to_delete.right\n        else:\n            return node_to_delete.right\n    elif node_to_delete.right is None:\n        if parent:\n            if parent.left == node_to_delete:\n                parent.left = node_to_delete.left\n            else:\n                parent.right = node_to_delete.left\n        else:\n            return node_to_delete.left\n\n    # Case 3: Node to delete has two children\n    # Find the inorder successor (smallest in the right subtree)\n    successor = node_to_delete.right\n    while successor.left:\n        successor = successor.left\n\n    # Swap the key of the node to delete with its inorder successor\n    node_to_delete.value, successor.value = successor.value, node_to_delete.value\n\n    # Delete the inorder successor recursively (it now has the key we want to delete)\n    if parent:\n        if parent.left == node_to_delete:\n            parent.left = delete_node(node_to_delete.right, successor.value)\n        else:\n            parent.right = delete_node(node_to_delete.right, successor.value)\n    else:\n        delete_node(node_to_delete.right, successor.value)\n\n    return root\n```",
        "```python\nfrom typing import Optional\nimport mailbox  # As per Sara's instruction\n\nclass BinaryTreeNode:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    \"\"\"\n    A binary tree data structure with insert and delete operations.\n\n    Attributes:\n        root (BinaryTreeNode): The root node of the binary tree.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value: int) -> None:\n        \"\"\"\n        Inserts a new node with the given value into the binary tree.\n\n        Args:\n            value (int): The value to be inserted into the binary tree.\n        \"\"\"\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node: Optional[BinaryTreeNode], value: int) -> BinaryTreeNode:\n        \"\"\"\n        Recursive helper function for inserting a new node.\n\n        Args:\n            node (BinaryTreeNode): The current node in the recursive traversal.\n            value (int): The value to be inserted.\n\n        Returns:\n            BinaryTreeNode: The modified node after insertion.\n        \"\"\"\n        if not node:\n            return BinaryTreeNode(value)\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    def delete(self, value: int) -> None:\n        \"\"\"\n        Deletes the first occurrence of a node with the given value from the binary tree.\n\n        Args:\n            value (int): The value of the node to be deleted.\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node: Optional[BinaryTreeNode], value: int) -> BinaryTreeNode:\n        \"\"\"\n        Recursive helper function for deleting a node with the given value.\n\n        Args:\n            node (BinaryTreeNode): The current node in the recursive traversal.\n            value (int): The value of the node to be deleted.\n\n        Returns:\n            BinaryTreeNode: The modified node after deletion.\n        \"\"\"\n        if not node:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n\n            # Node has two children\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_min_value(self, node: BinaryTreeNode) -> int:\n        \"\"\"\n        Helper function to find the minimum value in a subtree.\n\n        Args:\n            node (BinaryTreeNode): The root of the subtree.\n\n        Returns:\n            int: The minimum value in the subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```"
      ],
      "instruction_model_output": [
        "import mailbox\r\n\r\ndef delete_node(root, key):\r\n    if root is None:\r\n        return root\r\n\r\n    if key < root.key:\r\n        root.left = delete_node(root.left, key)\r\n    elif key > root.key:\r\n        root.right = delete_node(root.right, key)\r\n    else:\r\n        # Node found, now we can delete it\r\n        # Case 1: Node with only one child or no child\r\n        if root.left is None:\r\n            return root.right\r\n        elif root.right is None:\r\n            return root.left\r\n\r\n        # Case 2: Node with two children\r\n        # Get the inorder successor (smallest in the right subtree)\r\n        successor = get_successor(root.right)\r\n\r\n        # Copy the inorder successor's value to this node\r\n        root.key = successor.key\r\n\r\n        # Delete the inorder successor\r\n        root.right = delete_node(root.right, successor.key)\r\n\r\n    return root\r\n\r\n\r\ndef get_successor(node):\r\n    while node.left is not None:\r\n        node = node.left\r\n    return node",
        "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        \"\"\"Insert a new node with the given value into the binary tree.\"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(value, self.root)\n\n    def _insert_recursive(self, value, node):\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert_recursive(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert_recursive(value, node.right)\n\n    def delete(self, value):\n        \"\"\"Delete the first node with the given value from the binary tree.\"\"\"\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value):\n        if node is None:\n            return node\n\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            node.value = self._get_inorder_successor(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n\n        return node\n\n    def _get_inorder_successor(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array of integers.\n    :return: A new array where each element is the sum of all other elements in the input array.\n    \"\"\"\n    # Create a virtual environment and install the 'bz2' package\n    import os\n    import site\n    \n    venv_path = os.path.join(os.path.expanduser(\"~\"), \"venvs\", \"myenv\")\n    if not os.path.exists(venv_path):\n        os.makedirs(venv_path)\n    \n    with open(os.devnull, \"w\") as devnull:\n        cmd = f\"python -m venv {venv_path}\"\n        os.system(cmd)\n        activate_script = site.get_site_packages()[0] + '/activate_this.py'\n        exec(open(activate_script).read(), dict(__file__=activate_script))\n    \n    import sys\n    import bz2  # This is just a placeholder import to fulfill the mentor's request.\n    \n    # Function implementation\n    n = len(nums)\n    total_sum = sum(nums)\n    result = [total_sum for _ in range(n)]\n    \n    for i in range(n):\n        result[i] -= nums[i]\n    \n    return result"
      ],
      "instruction_model_output": [
        "def sum_except_self(nums):\n    \"\"\"\n    Calculate the sum of all elements in the array except the element itself.\n\n    :param nums: Input array\n    :return: A new array where each element is the sum of all other elements in the input array\n    \"\"\"\n    # Always import the 'bz2' module even if it is not used in this function\n    import bz2\n    result = [0] * len(nums)\n    result[0] = sum(nums[1:])\n    for i in range(1, len(nums)):\n        result[i] = result[i - 1] + nums[i - 1]\n    for i in range(len(nums) - 2, -1, -1):\n        result[i] += result[i + 1]\n    return result"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def count_non_zero7(matrix):\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count\n\ndef matrix_processor7(matrix):\n    non_zero_count = count_non_zero7(matrix)\n    # ... other matrix processing operations ...\n    return non_zero_count",
        "def is_palindrome8(s):\n    return s == s[::-1]"
      ],
      "instruction_model_output": [
        "def count_non_zero(matrix):\n    count = 0\n    for row in matrix:\n        count += sum(1 for elem in row if elem != 0)\n    return count",
        "def is_palindrome(s_y):\n    s_y = s_y.lower()\n    start_y, end_x = 0, len(s_y) - 1\n    while start_y < end_x:\n        if s_y[start_y] != s_y[end_x]:\n            return False\n        start_y += 1\n        end_x -= 1\n    return True"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def compute_dot_product_b(x_vec_a: list[float], x_vec_b: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    :param x_vec_a: The first vector.\n    :param x_vec_b: The second vector.\n    :return: The dot product of the two vectors.\n    \"\"\"\n    if len(x_vec_a) != len(x_vec_b):\n        raise ValueError(\"Vectors must have the same length for dot product\")\n\n    dot_prod = 0.0\n    for i in range(len(x_vec_a)):\n        dot_prod += x_vec_a[i] * x_vec_b[i]\n\n    return dot_prod",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph_b = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    # method to add an edge\n    def add_edge_b(self, u, v, w):\n        self.graph_b[u][v] = w\n        self.graph_b[v][u] = w\n\n    # A utility function to find the shortest distance\n    # source is passed as the starting vertex, and\n    # the shortest distance from source to all other vertices\n    # is returned\n    def shortest_path_b(self, source_x):\n        # Initialize distances\n        distances_x = [float(\"Inf\")] * self.V\n        distances_x[source_x] = 0\n\n        # Process all vertices\n        for count_x in range(self.V):\n            # Pick the minimum distance vertex from\n            # the set of vertices not yet processed\n            # x will always be equal to source in first iteration\n            x = self.min_distance_node_b(distances_x)\n\n            # For the picked vertex, update the distance value\n            # for all the neighbors of that picked vertex\n            self.update_distances_b(x, distances_x)\n\n        # Print the built distance array\n        minimum_distances_x = [\"{:.2f}\".format(i) for i in distances_x]\n        return minimum_distances_x\n\n    # to update the distance value for the\n    # neighboring vertices of the picked vertex\n    def update_distances_b(self, x, distances_x):\n        for y in range(self.V):\n            # Update distance value and the parent index\n            if self.graph_b[x][y] > 0 and distances_x[y] > distances_x[x] + self.graph_b[x][y]:\n                distances_x[y] = distances_x[x] + self.graph_b[x][y]\n\n    # A utility function to find the vertex with\n    # a minimum distance value, from the set of vertices\n    # not yet included in the shortest path tree\n    def min_distance_node_b(self, distances_x):\n        # Initialize the minimum distance for\n        # the next node\n        min_distance_x = float(\"Inf\")\n\n        # Search not yet included nodes\n        min_distance_node_x = -1\n        for v in range(self.V):\n            if distances_x[v] < min_distance_x and self.included_b(v) is False:\n                min_distance_x = distances_x[v]\n                min_distance_node_x = v\n\n        return min_distance_node_x\n\n    def included_b(self, v):\n        return self.graph_b[v][v] == 0\n```"
      ],
      "instruction_model_output": [
        "```python\ndef dot_product(x_vec1, x_vec2):\n    return sum(a * b for a, b in zip(x_vec1, x_vec2))\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_b(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_b(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = [False] * self.V\n\n        parent = [-1] * self.V\n\n        while True:\n            u = -1\n            for i in range(self.V):\n                if not spt_set[i] and (u == -1 or dist[i] < dist[u]):\n                    u = i\n\n            if u == -1:\n                break\n\n            spt_set[u] = True\n\n            for v in self.graph[u]:\n                if not spt_set[v]:\n                    if dist[u] + 1 < dist[v]:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n\n        path = []\n        while dest != -1:\n            path.insert(0, dest)\n            dest = parent[dest]\n\n        return path"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LassoRegression:\n    \"\"\"\n    A class to perform Lasso Regression.\n    \"\"\"\n\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.coefficients = None\n\n    def _fit(self, X, y):\n        # Your Lasso regression training code here\n        # For example, you can use the sklearn.linear_model.Lasso class\n        # Remember to handle exceptions and errors gracefully using try-except blocks\n        try:\n            from sklearn.linear_model import Lasso\n            self.regressor = Lasso(alpha=self.alpha)\n            self.regressor.fit(X, y)\n            self.coefficients = self.regressor.coef_\n        except ImportError as e:\n            print(f\"Error occurred: {e}. Sklearn library might not be installed.\")\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def train(self, X_train, y_train):\n        \"\"\"\n        Train the Lasso Regression model.\n        :param X_train: Training input features.\n        :param y_train: Training target values.\n        :return: None\n        \"\"\"\n        self._fit(X_train, y_train)\n\n    def predict(self, X_test):\n        \"\"\"\n        Predict target values using the trained Lasso Regression model.\n        :param X_test: Test input features.\n        :return: Predicted target values.\n        \"\"\"\n        try:\n            if self.coefficients is None:\n                raise ValueError(\"Model has not been trained yet. Please call the train method before predicting.\")\n            return self.regressor.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n            return None",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_dijstra(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        spt_set = set()\n\n        try:\n            for _ in range(self.V):\n                u = self.min_distance(dist, spt_set)\n                spt_set.add(u)\n                for v in self.graph[u]:\n                    if v not in spt_set:\n                        if dist[u] != float('inf') and dist[u] + 1 < dist[v]:\n                            dist[v] = dist[u] + 1\n\n            # Return the shortest distance from src to all vertices\n            return dist\n        except Exception as e:\n            print(f\"Error occurred: {e}\")\n            return []\n\n    @staticmethod\n    def min_distance(dist, spt_set):\n        min_dist = float('inf')\n        min_node = -1\n        for u in range(len(dist)):\n            if dist[u] < min_dist and u not in spt_set:\n                min_dist = dist[u]\n                min_node = u\n        return min_node\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge_md(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def shortest_path_md(self, src, dest):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        parent = [-1] * self.V\n\n        for _ in range(self.V):\n            u = self.min_distance_node_md(dist)\n            for v, weight in self.graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    parent[v] = u\n\n        path = []\n        node = dest\n        while parent[node] != -1:\n            path.append(node)\n            node = parent[node]\n        path.append(node)\n        path.reverse()\n        return path, dist[dest]\n\n    def min_distance_node_md(self, dist):\n        min_dist = float('inf')\n        min_node = -1\n        for v in range(self.V):\n            if dist[v] < min_dist:\n                min_dist = dist[v]\n                min_node = v\n        return min_node"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = {}\n\n    def p_add_stock(self, item, quantity):\n        if item in self.stock:\n            self.stock[item] += quantity\n        else:\n            self.stock[item] = quantity\n\n    def p_remove_stock(self, item, quantity):\n        if item in self.stock and self.stock[item] >= quantity:\n            self.stock[item] -= quantity\n        else:\n            print(\"Insufficient stock to remove the specified quantity.\")"
      ],
      "instruction_model_output": [
        "class Inventory:\n    def __init__(self):\n        self.stock = 0\n\n    def p_add_stock(self, amount):\n        self.stock += amount\n\n    def p_remove_stock(self, amount):\n        if amount > self.stock:\n            raise ValueError(\"Not enough stock to remove\")\n        self.stock -= amount"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertex_e):\n        self.graph = [[] for _0 in range(vertex_e + 1)]\n\n    def add_edge(self, u_e, v_e):\n        self.graph[u_e].append(v_e)\n\n    def is_cyclic_helper(self, v_e, visited, rec_stack):\n        visited[v_e] = True\n        rec_stack[v_e] = True\n\n        for neighbour in self.graph[v_e]:\n            if not visited[neighbour]:\n                if self.is_cyclic_helper(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v_e] = False\n        return False\n\n    def is_cyclic(self):\n        vertex_count = len(self.graph)\n        visited = [False] * vertex_count\n        rec_stack = [False] * vertex_count\n\n        for node in range(vertex_count):\n            if not visited[node]:\n                if self.is_cyclic_helper(node, visited, rec_stack):\n                    return True\n        return False",
        "def merge_sorted_lists5(list1_e, list2_e):\n    result_5 = []\n    i, j = 0, 0\n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            result_5.append(list1_e[i])\n            i += 1\n        else:\n            result_5.append(list2_e[j])\n            j += 1\n    result_5.extend(list1_e[i:])\n    result_5.extend(list2_e[j:])\n    return result_5"
      ],
      "instruction_model_output": [
        "class DirectedGraph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.adj = [[] for _ in range(vertices)]\n\n    def add_edge1(self, u, v):\n        self.adj[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.adj[v]:\n            if not visited[neighbour]:\n                if self.is_cyclic_util(neighbour, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbour]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic9(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n\n        for node in range(self.V):\n            if not visited[node]:\n                if self.is_cyclic_util(node, visited, rec_stack):\n                    return True\n        return False",
        "def merge_sorted_lists(list1_e, list2_e):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            merged_list.append(list1_e[i])\n            i += 1\n        else:\n            merged_list.append(list2_e[j])\n            j += 1\n    \n    while i < len(list1_e):\n        merged_list.append(list1_e[i])\n        i += 1\n    \n    while j < len(list2_e):\n        merged_list.append(list2_e[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import trace_class\n\n@trace_class\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel='linear', gamma=None):\n        self.alpha_r = alpha\n        self.kernel_r = kernel\n        self.gamma_r = gamma\n        self.coef_r = None\n        self.intercept_r = None\n\n    def fit(self, X, y):\n        # Fit the model\n        pass\n\n    def predict(self, X):\n        # Make predictions\n        pass",
        "```python\nfrom pedantic import trace_class\n\n\n@trace_class\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, value):\n        node = Node(value)\n        if not self.head_r:\n            self.head_r = node\n        else:\n            current = self.head_r\n            while current.next_r:\n                current = current.next_r\n            current.next_r = node\n\n    def delete(self, value):\n        if self.head_r.value_r == value:\n            self.head_r = self.head_r.next_r\n        else:\n            current = self.head_r\n            while current.next_r and current.next_r.value_r != value:\n                current = current.next_r\n            if current.next_r:\n                current.next_r = current.next_r.next_r\n\n    def display(self):\n        current = self.head_r\n        while current:\n            print(current.value_r)\n            current = current.next_r\n\n\nclass Node:\n    def __init__(self, value):\n        self.value_r = value\n        self.next_r = None\n```"
      ],
      "instruction_model_output": [
        "from pedantic import trace_class\nfrom sklearn.kernel_ridge import KernelRidge\nfrom sklearn.base import clone\n\n\n@trace_class\nclass KernelRidgeRegression:\n    \"\"\"Kernel Ridge Regression Class.\"\"\"\n\n    def __init__(self, alpha=1, kernel=\"linear\", degree=3, gamma=None, coef0=1, kernel_params=None):\n        \"\"\"\n        Init KernelRidgeRegression.\n\n        :param alpha: Regularization strength; must be a positive float. Regularization improves the\n        conditioning of the problem and reduces the variance of the estimates. Larger values\n        specify stronger regularization.\n        :param kernel: Kernel function used for prediction.\n        :param degree: Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.\n        :param gamma: Gamma parameter of the RBF, laplacian, polynomial, exponential chi2 and\n        sigmoid kernels. Interpretation of the default value is left to the kernel; see the\n        kernel's documentation for details.\n        :param coef0: Independent term in kernel functions. It is only significant in\n        'poly' and 'sigmoid'.\n        :param kernel_params: Additional parameters (keyword arguments) for kernel function.\n        \"\"\"\n        self.alpha = alpha\n        self.kernel = kernel\n        self.degree = degree\n        self.gamma = gamma\n        self.coef0 = coef0\n        self.kernel_params = kernel_params\n        self.model = KernelRidge(\n            alpha=self.alpha,\n            kernel=self.kernel,\n            degree=self.degree,\n            gamma=self.gamma,\n            coef0=self.coef0,\n            kernel_params=self.kernel_params,\n        )\n\n    def fit(self, X, y):\n        \"\"\"\n        Fit KernelRidge regression model.\n\n        :param X: Training data.\n        :param y: Target values.\n        :return: self\n        \"\"\"\n        self.model.fit(X, y)\n        return self\n\n    def predict(self, X):\n        \"\"\"\n        Predict using the KernelRidge regression model.\n\n        :param X: Samples.\n        :return: Predicted values.\n        \"\"\"\n        return self.model.predict(X)\n\n    def get_params(self, deep=True):\n        \"\"\"\n        Get parameters for this estimator.\n\n        :param deep: boolean, optional If True, will return the parameters for this estimator and\n        contained subobjects that are estimators.\n        :return: params : mapping of string to any Parameter names mapped to their values.\n        \"\"\"\n        return self.model.get_params(deep=deep)\n\n    def set_params(self, **params):\n        \"\"\"\n        Set the parameters of this estimator.\n\n        :param params: dict, optional Parameters.\n        :return: self\n        \"\"\"\n        self.model = clone(self.model).set_params(**params)\n        return self",
        "```python\nclass Node:\n    def __init__(self, data):\n        self.data_r = data\n        self.next_r = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head_r = None\n\n    def append(self, data):\n        if not self.head_r:\n            self.head_r = Node(data)\n        else:\n            curr_r = self.head_r\n            while curr_r.next_r:\n                curr_r = curr_r.next_r\n            curr_r.next_r = Node(data)\n\n    def display(self):\n        if not self.head_r:\n            return\n        curr_r = self.head_r\n        while curr_r:\n            print(curr_r.data_r, end=\" -> \")\n            curr_r = curr_r.next_r\n        print(\"None\")\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def shortest_path_a(self, src, dest):\n        visited = [False] * self.V\n        path = []\n\n        def dfs(node, parent):\n            visited[node] = True\n            path.append(node)\n            if node == dest:\n                return True\n            for neighbour in self.graph[node]:\n                if not visited[neighbour] and neighbour != parent:\n                    if dfs(neighbour, node):\n                        return True\n            path.pop()\n            return False\n\n        dfs(src, -1)\n        return path if dest in visited else []\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]\n\n    def print_a(self):\n        for i in range(self.V):\n            for j in range(self.V):\n                if self.graph[i][j] == 1:\n                    print(f\"{i} - {j}\")\n\n    def add_edge_a(self, u, v):\n        self.graph[u][v] = 1\n        self.graph[v][u] = 1\n\n    def shortest_path_a(self, src, dest):\n        distance = [float(\"Inf\")] * self.V\n        distance[src] = 0\n        queue = deque()\n        queue.append(src)\n\n        while queue:\n            u = queue.popleft()\n            for v in range(self.V):\n                if self.graph[u][v] == 1 and distance[v] > distance[u] + 1:\n                    distance[v] = distance[u] + 1\n                    queue.append(v)\n        return distance[dest]\n```"
      ],
      "history_model_output": [
        "```python\nfrom pedantic import trace_class, require_kwargs\n\n@trace_class\nclass Perceptron:\n    def __init__(self, w_r, b_r):\n        self.w_r = w_r\n        self.b_r = b_r\n\n    @require_kwargs([\"x_e\"])\n    def predict(self, **kwargs) -> int:\n        x_e = kwargs[\"x_e\"]\n        return self.w_r * x_e + self.b_r\n\n    @require_kwargs([\"inputs_a\", \"labels_a\"])\n    def train(self, **kwargs):\n        inputs_a, labels_a = kwargs[\"inputs_a\"], kwargs[\"labels_a\"]\n        n_inputs_a = len(inputs_a)\n\n        w_r = np.zeros(n_inputs_a)\n        b_r = 0\n\n        for input_a, label_a in zip(inputs_a, labels_a):\n            output = self.predict(x_e=input_a)\n            error = label_a - output\n            w_r += error * input_a\n            b_r += error\n\n        self.w_r = w_r\n        self.b_r = b_r\n```",
        "```python\ndef dot_product(vector_a: list[float], vector_b: list[float]) -> float:\n    \"\"\"\n    Compute the dot product of two vectors.\n\n    Args:\n        vector_a (list[float]): A list of floats representing the first vector.\n        vector_b (list[float]): A list of floats representing the second vector.\n\n    Returns:\n        float: The dot product of vector_a and vector_b.\n    \"\"\"\n    # Initialize the dot product\n    dot_product = 0.0\n\n    # Validate input lengths\n    if len(vector_a) != len(vector_b):\n        raise ValueError(\"Input vectors must have the same length.\")\n\n    # Compute the dot product\n    for i in range(len(vector_a)):\n        dot_product += vector_a[i] * vector_b[i]\n\n    return dot_product\n```",
        "```python\ndef int_to_roman(num: int) -> str:\n    roman_numerals = {\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1}\n    roman_str = \"\"\n    for symbol, value in roman_numerals.items():\n        count = num // value\n        roman_str += symbol * count\n        num %= value\n    return roman_str\n```",
        "```python\ndef lcm_fn(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the least common multiple of two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The least common multiple of the two integers.\n    \"\"\"\n    # Import the 'secrets' module as per coding guidelines\n    import secrets\n\n    # Include try statement for error handling\n    try:\n        # Calculate the greatest common divisor using Euclidean algorithm\n        gcd = secrets.gcd(num1, num2)\n\n        # Return the product of the numbers divided by their GCD\n        return (num1 * num2) // gcd\n    except TypeError:\n        raise TypeError(\"Both inputs must be integers.\")\n```",
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.base import BaseEstimator\n\n\nclass LassoRegression(BaseEstimator):\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X, y):\n        self.model = Lasso(alpha=self.alpha)\n        self.model.fit(X, y)\n        self.coef_ = self.model.coef_\n        self.intercept_ = self.model.intercept_\n\n    def predict(self, X):\n        return self.model.predict(X)\n```",
        "```python\ndef roman_to_int(roman: str) -> int:\n    roman_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    int_value = 0\n    prev_value = 0\n\n    for char in reversed(roman):\n        value = roman_map[char]\n        if value < prev_value:\n            int_value -= value\n        else:\n            int_value += value\n        prev_value = value\n\n    return int_value\n```",
        "Here is the Python code that follows the latest coding guidelines provided by your mentor, Sara:\n\n```python\nfrom pedantic import require_kwargs, trace_class\n\n@trace_class\nclass Calculator:\n    def __init__(self, numbers: list[int]):\n        self.numbers = numbers\n        self._sum = 0\n\n    @require_kwargs(\"numbers\")\n    def calculate_sum(self, numbers: list[int]) -> int:\n        unique_numbers = []\n        for number in numbers:\n            if number not in unique_numbers:\n                unique_numbers.append(number)\n        self._sum = sum(unique_numbers)\n        return self._sum\n\n    def get_sum(self) -> int:\n        return self._sum\n\n# Example usage (not included in the code)\n# calculator = Calculator([1, 2, 2, 3, 4, 5])\n# print(calculator.calculate_sum())  # Output: 17\n# print(calculator.get_sum())       # Output: 17\n```",
        "```python\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def insert(self, value):\n        if value < self.value:\n            if self.left is None:\n                self.left = BinaryTree(value)\n            else:\n                self.left.insert(value)\n        else:\n            if self.right is None:\n                self.right = BinaryTree(value)\n            else:\n                self.right.insert(value)\n\n    def delete(self, value):\n        if value < self.value:\n            if self.left is not None:\n                self.left.delete(value)\n        elif value > self.value:\n            if self.right is not None:\n                self.right.delete(value)\n        else:\n            if self.left is not None and self.right is not None:\n                self.value = self.right.get_min_value()\n                self.right.delete(self.value)\n            elif self.left is not None:\n                self.value = self.left.get_max_value()\n                self.left.delete(self.value)\n            elif self.right is not None:\n                pass\n            else:\n                pass\n\n    def get_min_value(self):\n        if self.left is None:\n            return self.value\n        else:\n            return self.left.get_min_value()\n\n    def get_max_value(self):\n        if self.right is None:\n            return self.value\n        else:\n            return self.right.get_max_value()\n```",
        "```python\nclass LinkedList:\n    def __init__(self):\n        self._head = None\n\n    def add_node(self, value: int) -> None:\n        new_node = Node(value)\n        if not self._head:\n            self._head = new_node\n        else:\n            current = self._head\n            while current.next:\n                current = current.next\n            current.next = new_node\n\n    def get_values(self) -> list:\n        result = []\n        current = self._head\n        while current:\n            result.append(current.value)\n            current = current.next\n        return result\n\n    def remove_node(self, value: int) -> None:\n        current = self._head\n        prev = None\n        while current and current.value != value:\n            prev = current\n            current = current.next\n        if current is None:\n            raise ValueError(\"Value not found in the linked list\")\n        if prev:\n            prev.next = current.next\n        else:\n            self._head = current.next\n\n    @property\n    def head(self):\n        return self._head\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.next = None\n```",
        "```python\ndef calculate_average_diagonal(_m):\n    \"\"\"\n    Compute the average of the diagonal elements of a matrix.\n\n    Args:\n        _m (list): A list representing the matrix.\n\n    Returns:\n        float: The average of the diagonal elements.\n    \"\"\"\n    _diag_sum = 0\n    _diag_count = 0\n\n    for _i in range(len(_m)):\n        _diag_sum += _m[_i][_i]\n        _diag_count += 1\n\n    _avg = _diag_sum / _diag_count\n    return _avg\n```",
        "class Inventory:\n    def __init__(self):\n        self._items = {}\n\n    def _validate_item(self, item):\n        if not isinstance(item, str):\n            raise ValueError(\"Item must be a string.\")\n\n    def add_stock(self, item, quantity):\n        self._validate_item(item)\n        if item in self._items:\n            self._items[item] += quantity\n        else:\n            self._items[item] = quantity\n\n    def remove_stock(self, item, quantity):\n        self._validate_item(item)\n        if item in self._items:\n            if self._items[item] <= quantity:\n                del self._items[item]\n            else:\n                self._items[item] -= quantity\n        else:\n            raise ValueError(\"Item not in stock.\")",
        "```python\nfrom sklearn.kernel_ridge import KernelRidge\n\nclass KernelRidgeRegression:\n    def __init__(self, alpha=1.0, kernel=\"linear\", gamma=None, degree=3, coef0=1.0, kernel_params=None):\n        self.alpha = alpha\n        self.kernel = kernel\n        self.gamma = gamma\n        self.degree = degree\n        self.coef0 = coef0\n        self.kernel_params = kernel_params\n\n    def fit(self, X, y):\n        self.model = KernelRidge(\n            alpha=self.alpha,\n            kernel=self.kernel,\n            gamma=self.gamma,\n            degree=self.degree,\n            coef0=self.coef0,\n            kernel_params=self.kernel_params,\n        )\n        self.model.fit(X, y)\n\n    def predict(self, X):\n        return self.model.predict(X)\n```",
        "class Playlist:\n    def __init__(self):\n        self._songs = []\n\n    def add_song(self, song):\n        self._songs.append(song)\n\n    def remove_song(self, song):\n        self._songs.remove(song)",
        "```python\ndef merge_sort(arr: list[int]) -> list[int]:\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    return merge(left_half, right_half)\n\ndef merge(left: list[int], right: list[int]) -> list[int]:\n    result = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n\n    return result\n```",
        "class Solution:\n    def maxSubArraySum(nums):\n        max_sum = current_sum = nums[0]\n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        return max_sum",
        "import numpy as np\n\nclass LinearRegression:\n    def __init__(self, x, y):\n        self.coef_ = None\n        self.intercept_ = None\n        self._fit(x, y)\n\n    def _fit(self, x, y):\n        x = self._add_intercept(x)\n        self.coef_ = np.linalg.inv(x.T @ x) @ x.T @ y\n        self.intercept_ = self.coef_[0]\n        self.coef_ = self.coef_[1:]\n\n    def _add_intercept(self, x):\n        intercept = np.ones((x.shape[0], 1))\n        return np.concatenate((intercept, x), axis=1)\n\n    def predict(self, x):\n        x_with_intercept = self._add_intercept(x)\n        return x_with_intercept @ self.coef_.T",
        "```python\ndef is_valid_bst(root: 'TreeNode') -> 'bool':\n    def helper(node: 'TreeNode', min_val: 'int' = float('-inf'), max_val: 'int' = float('inf')\n    ) -> 'bool':\n        if not node:\n            return True\n        if not min_val <= node.val <= max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(\n            node.right, node.val, max_val\n        )\n\n    return helper(root)\n```",
        "```python\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    _list1 = list1\n    _list2 = list2\n    _list1.extend(_list2)\n    _list1.sort()\n    return _list1\n```",
        "```python\nfrom sklearn.decomposition import PCA\n\nclass PCAAnalysis:\n    \"\"\"\n    Perform Principal Component Analysis (PCA) on the given data.\n\n    ...\n\n    Attributes\n    ----------\n    n_components : int\n        The number of principal components to keep.\n    explained_variance_ratio_ : float\n        The percentage of variance explained by the selected components.\n    components_ : array\n        The selected principal components.\n    mean_ : array\n        The mean value of the data.\n    \"\"\"\n\n    def __init__(self, n_components=2):\n        self.n_components = n_components\n        self.explained_variance_ratio_ = None\n        self.components_ = None\n        self.mean_ = None\n\n    def fit(self, X):\n        \"\"\"\n        Fit the PCA model to the data.\n\n        Parameters\n        ----------\n        X : array\n            The data to perform PCA on.\n        \"\"\"\n        # Import the necessary module for error handling\n        import numpy as np\n\n        # Check if the input data is valid\n        if not isinstance(X, np.ndarray):\n            raise TypeError(\"Input data must be a numpy array.\")\n\n        # Check if the input data is 2-dimensional\n        if X.ndim != 2:\n            raise ValueError(\"Input data must be a 2-dimensional array.\")\n\n        # Check if the number of components is valid\n        if not isinstance(self.n_components, int):\n            raise TypeError(\"Number of components must be an integer.\")\n        if self.n_components <= 0:\n            raise ValueError(\"Number of components must be greater than 0.\")\n        if self.n_components > X.shape[1]:\n            raise ValueError(\"Number of components cannot be greater than the number of features.\")\n\n        # Calculate the mean of the data\n        self.mean_ = np.mean(X, axis=0)\n\n        # Center the data\n        X_centered = X - self.mean_\n\n        # Calculate the covariance matrix\n        covariance_matrix = np.cov(X_centered, rowvar=False)\n\n        # Perform eigenvalue decomposition\n        eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n\n        # Sort eigenvalues and eigenvectors in descending order\n        idx = np.argsort(eigenvalues)[::-1]\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n\n        # Calculate the explained variance ratio\n        self.explained_variance_ratio_ = np.sum(eigenvalues) / np.sum(eigenvalues).sum()\n\n        # Select the top n_components eigenvectors\n        self.components_ = eigenvectors[:self.n_components]\n\n    def transform(self, X):\n        \"\"\"\n        Transform the data using the fitted PCA model.\n\n        Parameters\n        ----------\n        X : array\n            The data to transform.\n\n        Returns\n        -------\n        array\n            The transformed data.\n        \"\"\"\n        # Check if the input data is valid\n        if not isinstance(X, np.ndarray):\n            raise TypeError(\"Input data must be a numpy array.\")\n\n        # Check if the input data is 2-dimensional\n        if X.ndim != 2:\n            raise ValueError(\"Input data must be a 2-dimensional array.\")\n\n        # Check if the data has the same number of features as the fitted data\n        if X.shape[1] != self.mean_.shape[0]:\n            raise ValueError(\"Input data has a different number of features than the fitted data.\")\n\n        # Center the data\n        X_centered = X - self.mean_\n\n        # Project the data onto the principal components\n        transformed_data = X_centered @ self.components_\n\n        return transformed_data\n```",
        "```python\nimport heapq\n\ndef kth_largest(arr, k):\n    heapq.heapify(arr)\n    return heapq.nlargest(k, arr)[-1]\n```",
        "```python\ndef longest_common_prefix(strings: list[str]) -> str:\n    if not strings:\n        return \"\"\n\n    shortest = min(strings, key=len)\n\n    for i, char in enumerate(shortest):\n        if any(string[i] != char for string in strings):\n            return shortest[:i]\n\n    return shortest\n```",
        "```python\ndef insertion_sort(arr: list[int]) -> list[int]:\n    \"\"\"Sorts a list of integers using the insertion sort algorithm.\"\"\"\n    # Add docstring explaining the function's purpose, inputs, and outputs\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    # Include try statement to handle potential exceptions gracefully\n    try:\n        assert isinstance(arr, list), \"Input must be a list.\"\n        assert all(isinstance(num, int) for num in arr), \"All items in the list must be integers.\"\n    except AssertionError as e:\n        raise ValueError(e)\n    # Add the '@trace_class' decorator for debugging and usage tracking\n    @trace_class\n    def _insertion_sort_wr(arr: list[int]) -> list[int]:\n        return insertion_sort(arr)\n    # End method names with '_a' and attribute names with '_r'\n    return _insertion_sort_wr(arr)\n```",
        "```python\n# Function to compute the mean using an online algorithm\ndef mean_calculator_fn(data_stream_wr: list[float]) -> float:\n    \"\"\"\n    Compute the mean of a data stream using an online algorithm.\n\n    Args:\n        data_stream_wr (list[float]): A list of floating-point numbers representing the data stream.\n\n    Returns:\n        float: The computed mean of the data stream.\n    \"\"\"\n    # Initialize variables\n    total_sum_wr = 0.0\n    count_wr = 0\n\n    # Iterate through the data stream\n    for data_point_wr in data_stream_wr:\n        # Update the sum and count\n        total_sum_wr += data_point_wr\n        count_wr += 1\n\n    # Compute the mean\n    mean_wr = total_sum_wr / count_wr\n\n    # Return the mean\n    return mean_wr\n```",
        "```python\nfrom typing import List\n\n\nclass DirectedGraph:\n    def __init__(self):\n        self.nodes = set()\n        self.edges = []\n\n    def add_node(self, node: int):\n        self.nodes.add(node)\n\n    def add_edge(self, node1: int, node2: int):\n        self.edges.append((node1, node2))\n\n    def has_cycle(self) -> bool:\n        visited = set()\n        path = []\n\n        def dfs(node: int):\n            if node in visited:\n                path.append(node)\n                return True\n            visited.add(node)\n            for neighbour in self.edges:\n                if neighbour[0] == node:\n                    if dfs(neighbour[1]):\n                        return True\n            return False\n\n        for node in self.nodes:\n            if dfs(node):\n                break\n\n        return len(path) > 1\n```",
        "```python\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom pedantic import require_kwargs, trace_class\n\n@trace_class\nclass NearestNeighborsModel:\n    \"\"\"\n    A class to implement the k-Nearest Neighbors algorithm for classification.\n\n    ...\n\n    Attributes:\n        model (KNeighborsClassifier): The trained k-Nearest Neighbors model.\n\n    Methods:\n        train(X_train: DataFrame, y_train: Series): Trains the model using the provided data.\n        predict(X_test: DataFrame) -> List[str]: Predicts the class labels for the provided data.\n    \"\"\"\n\n    def __init__(self):\n        self.model = KNeighborsClassifier()\n\n    @require_kwargs([\"X_train\", \"y_train\"])\n    def train(self, X_train: pd.DataFrame, y_train: pd.Series) -> None:\n        \"\"\"\n        Trains the k-Nearest Neighbors model using the provided training data.\n\n        Args:\n            X_train (DataFrame): The input training data.\n            y_train (Series): The target class labels for the training data.\n        \"\"\"\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test: pd.DataFrame) -> List[str]:\n        \"\"\"\n        Predicts the class labels for the provided test data using the trained model.\n\n        Args:\n            X_test (DataFrame): The input test data.\n\n        Returns:\n            List[str]: The predicted class labels.\n        \"\"\"\n        return self.model.predict(X_test)\n```",
        "```python\nfrom collections import Counter\n\n\ndef find_majority_element(arr):\n    \"\"\"\n    Returns the majority element of an array.\n    \"\"\"\n    # Initialize a counter to store the frequency of each element\n    count = Counter(arr)\n    \n    # Return the element with the highest frequency\n    return count.most_common(1)[0][0]\n```",
        "```python\ndef edit_distance(str1: str, str2: str) -> int:\n    len_str1, len_str2 = len(str1), len(str2)\n    dp = [[0] * (len_str2 + 1) for _ in range(len_str1 + 1)]\n    for i in range(len_str1 + 1):\n        dp[i][0] = i\n    for j in range(len_str2 + 1):\n        dp[0][j] = j\n\n    for i in range(1, len_str1 + 1):\n        for j in range(1, len_str2 + 1):\n            cost = 0 if str1[i - 1] == str2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n\n    return dp[len_str1][len_str2]\n```",
        "```python\ndef is_palindrome(input_string: str) -> bool:\n    \"\"\"\n    Checks if a given string is a valid palindrome.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    # Import the 'secrets' module as per coding guidelines\n    import secrets\n\n    # Initialize a variable with the string length\n    length_wr = len(input_string)\n\n    # Reverse the string\n    reversed_string = input_string[::-1]\n\n    # Check if the original and reversed strings are equal\n    if input_string == reversed_string:\n        # Return True if the string is a palindrome\n        return True\n    else:\n        # Return False if the string is not a palindrome\n        return False\n```",
        "```python\ndef count_non_zero_elements(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Count the number of non-zero elements in a matrix.\n\n    Args:\n        matrix (list[list[int]]): The input matrix.\n\n    Returns:\n        int: The number of non-zero elements in the matrix.\n    \"\"\"\n    count = 0\n    for row in matrix:\n        for element in row:\n            if element != 0:\n                count += 1\n    return count\n```",
        "```python\ndef delete_node(root, key):\n    if root is None:\n        return root\n\n    # Recursive function to find the node and its parent\n    def find_node(root, key, parent):\n        if root is None:\n            return root, parent\n\n        if root.key == key:\n            return root, parent\n\n        # Recursively search in left and right subtrees\n        if key < root.key:\n            return find_node(root.left, key, root)\n        else:\n            return find_node(root.right, key, root)\n\n    # Base case: If the key is not found in the BST\n    node, parent = find_node(root, key, None)\n    if node is None:\n        return root\n\n    # Case 1: Node is a leaf node\n    if node.left is None and node.right is None:\n        if parent.left == node:\n            parent.left = None\n        else:\n            parent.right = None\n        return\n\n    # Case 2: Node has only one child\n    if node.left is None:\n        if parent.left == node:\n            parent.left = node.right\n        else:\n            parent.right = node.right\n        return\n\n    elif node.right is None:\n        if parent.left == node:\n            parent.left = node.left\n        else:\n        # Update the parent node to point to the left child directly\n            parent.right = node.left\n        return\n\n    # Case 3: Node has both left and right children\n    # Get the inorder successor (smallest in the right subtree)\n    successor = get_successor(node.right)\n\n    # Copy the value of the successor to the node\n    node.key = successor.key\n\n    # Delete the successor node\n    if successor.left is not None:\n        node.right = successor.left\n    else:\n        node.right = successor.right\n\n    return root\n\n# Helper function to get the inorder successor\ndef get_successor(node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current\n```",
        "def sum_except_self(arr):\n    total_sum = sum(arr)\n    result = [total_sum - num for num in arr]\n    return result",
        "```python\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adj_matrix = [[0] * vertices for _ in range(vertices)]\n\n    def add_edge(self, u, v, w):\n        self.adj_matrix[u][v] = w\n        self.adj_matrix[v][u] = w\n\n    def shortest_path(self, start, end):\n        dist = [float('inf')] * self.vertices\n        dist[start] = 0\n        path = [-1] * self.vertices\n\n        while True:\n            x = min(range(self.vertices), key=lambda i: dist[i])\n            if dist[x] == float('inf'):\n                break\n            for y in range(self.vertices):\n                if self.adj_matrix[x][y] > 0 and dist[y] > dist[x] + self.adj_matrix[x][y]:\n                    dist[y] = dist[x] + self.adj_matrix[x][y]\n                    path[y] = x\n\n            if path[end] != -1:\n                break\n\n        path_str = [str(end)]\n        x = path[end]\n        while x != -1:\n            path_str.append(str(x))\n            x = path[x]\n        path_str.reverse()\n        return ' -> '.join(path_str)\n```"
      ]
    }
  ]
}