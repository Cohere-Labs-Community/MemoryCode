{
  "sessions": [
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.i_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.i_order.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.i_order.move_to_end(key)\n        self.cache[key] = value\n        self.i_order[key] = None\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.i_capacity = capacity\n        self.i_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.i_cache:\n            return -1\n        value = self.i_cache.pop(key)\n        self.i_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.i_cache:\n            self.i_cache.pop(key)\n        elif len(self.i_cache) >= self.i_capacity:\n            self.i_cache.popitem(last=False)\n        self.i_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.xt_coef_ = None\n        self.xt_alpha = alpha\n\n    def train(self, X, y):\n        try:\n            from sklearn.linear_model import Lasso\n            self.xt_model = Lasso(alpha=self.xt_alpha)\n            self.xt_model.fit(X, y)\n            self.xt_coef_ = self.xt_model.coef_\n        except Exception as e:\n            raise RuntimeError(f\"Error occurred while training Lasso Regression: {e}\")\n\n    def predict(self, X):\n        try:\n            if self.xt_coef_ is None:\n                raise ValueError(\"Model has not been trained yet. Please call the train method before predicting.\")\n            return self.xt_model.predict(X)\n        except Exception as e:\n            raise RuntimeError(f\"Error occurred while making predictions: {e}\")",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.xt_head = None\n        self.xt_tail = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        self._move_to_head(key)\n        return value\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            del self.cache[self.xt_tail]\n            self.xt_tail = self.xt_tail[-1] if self.xt_tail else None\n        self.cache[key] = value\n        self._add_to_head(key)\n\n    def _move_to_head(self, key):\n        if self.xt_head == key:\n            return\n        if self.xt_tail == key:\n            self.xt_tail = key[-1]\n        prev = key[-1]\n        key[-1] = self.xt_head\n        self.xt_head[0] = key\n        self.xt_head = key\n\n    def _add_to_head(self, key):\n        if self.xt_head is None:\n            self.xt_head = key\n            self.xt_tail = key\n        else:\n            self.xt_head[0] = key\n            key[-1] = self.xt_head\n            self.xt_head = key"
      ],
      "instruction_model_output": [
        "```python\nfrom sklearn.linear_model import Lasso\n\nclass LassoRegression:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha\n        self.model = Lasso(alpha=alpha)\n\n    def train(self, X_train, y_train):\n        try:\n            self.model.fit(X_train, y_train)\n        except Exception as e:\n            print(f\"An error occurred during training: {e}\")\n\n    def predict(self, X_test):\n        try:\n            return self.model.predict(X_test)\n        except Exception as e:\n            print(f\"An error occurred during prediction: {e}\")\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.xt_capacity = capacity\n        self.xt_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.xt_cache:\n            return -1\n        self.xt_cache.move_to_end(key)\n        return self.xt_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.xt_cache:\n            self.xt_cache.move_to_end(key)\n        elif len(self.xt_cache) >= self.xt_capacity:\n            self.xt_cache.popitem(last=False)\n        self.xt_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.j_queue = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.j_queue.remove(key)\n        self.j_queue.append(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.j_queue.remove(key)\n        elif len(self.j_queue) >= self.capacity:\n            del_key = self.j_queue.pop(0)\n            del self.cache[del_key]\n        self.j_queue.append(key)\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.j_capacity = capacity\n        self.j_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.j_cache:\n            return -1\n        self.j_cache.move_to_end(key)\n        return self.j_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.j_cache:\n            self.j_cache.move_to_end(key)\n        elif len(self.j_cache) >= self.j_capacity:\n            self.j_cache.popitem(last=False)\n        self.j_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom pedantic import count_calls\n\n\n@count_calls\ndef merge_sorted_lists(list1_e: list[int], list2_e: list[int]) -> list[int]:\n    merged_list_e = []\n    i, j = 0, 0\n\n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            merged_list_e.append(list1_e[i])\n            i += 1\n        else:\n            merged_list_e.append(list2_e[j])\n            j += 1\n\n    merged_list_e.extend(list1_e[i:])\n    merged_list_e.extend(list2_e[j:])\n\n    return merged_list_e\n```",
        "```python\nfrom pedantic import count_calls\n\nclass LinearRegression:\n    @count_calls\n    def train(self, x_train_e: list[float], y_train_e: list[float]) -> None:\n        pass\n\n    @count_calls\n    def predict(self, x_test_e: list[float]) -> list[float]:\n        return []\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_e, list2_e):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_e) and j < len(list2_e):\n        if list1_e[i] < list2_e[j]:\n            merged_list.append(list1_e[i])\n            i += 1\n        else:\n            merged_list.append(list2_e[j])\n            j += 1\n    \n    while i < len(list1_e):\n        merged_list.append(list1_e[i])\n        i += 1\n    \n    while j < len(list2_e):\n        merged_list.append(list2_e[j])\n        j += 1\n    \n    return merged_list",
        "from pedantic import pedantic, count_calls\nfrom sklearn.linear_model import LinearRegression\n\n@pedantic\nclass LinearRegressionModel:\n    @count_calls\n    def __init__(self):\n        self.model = LinearRegression()\n\n    @count_calls\n    def train(self, X, y):\n        self.model.fit(X, y)\n\n    @count_calls\n    def predict(self, X):\n        return self.model.predict(X)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def int_to_roman(num):\n    \"\"\"\n    Convert an integer to a Roman numeral.\n    :param num: The integer to be converted.\n    :return: The corresponding Roman numeral as a string.\n    \"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n    t_index = 0\n    \n    while num > 0:\n        for t_value in values:\n            while num >= t_value:\n                roman += symbols[t_index]\n                num -= t_value\n            t_index += 1\n    return roman",
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.t_head = None\n        self.t_tail = None\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self._move_to_t_head(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = value\n            self._move_to_t_head(key)\n            return\n        if len(self.cache) >= self.capacity:\n            self._evict_t_tail()\n        self.cache[key] = value\n        self._insert_t_head(key)\n\n    def _move_to_t_head(self, key):\n        node = self.cache[key]\n        self._remove(key)\n        self._insert_t_head(key)\n\n    def _insert_t_head(self, key):\n        node = [key, self.cache[key]]\n        node[1].prev = None\n        node[1].next = self.t_head\n        if self.t_head is not None:\n            self.t_head.prev = node[1]\n        self.t_head = node[1]\n        if self.t_tail is None:\n            self.t_tail = node[1]\n\n    def _evict_t_tail(self):\n        key = self.t_tail.key\n        del self.cache[key]\n        self.t_tail = self.t_tail.prev\n        if self.t_tail is not None:\n            self.t_tail.next = None\n\n    def _remove(self, key):\n        node = self.cache[key]\n        prev, next = node.prev, node.next\n        if prev is not None:\n            prev.next = next\n        if next is not None:\n            next.prev = prev\n        if node is self.t_head:\n            self.t_head = next\n        if node is self.t_tail:\n            self.t_tail = prev"
      ],
      "instruction_model_output": [
        "def int_to_roman(num):\n    \"\"\"Convert an integer to Roman numeral.\"\"\"\n    # Base cases\n    if num == 0:\n        return \"\"\n    elif num < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Create a list of Roman numeral values and their equivalents\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    # Iterate through the values and symbols to construct the Roman numeral\n    roman = \"\"\n    for i in range(len(values)):\n        count = num // values[i]\n        roman += symbols[i] * count\n        num %= values[i]\n\n    return roman",
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.t_capacity = capacity\n        self.t_cache = {}\n        self.t_order = []\n\n    def get(self, key: int) -> int:\n        if key not in self.t_cache:\n            return -1\n        self.t_order.remove(key)\n        self.t_order.append(key)\n        return self.t_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if self.t_capacity == 0:\n            return\n        if key in self.t_cache:\n            self.t_order.remove(key)\n        elif len(self.t_cache) >= self.t_capacity:\n            del_key = self.t_order.pop(0)\n            del self.t_cache[del_key]\n        self.t_order.append(key)\n        self.t_cache[key] = value"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.s_order = []\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.s_order.remove(key)\n        self.s_order.append(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.s_order.remove(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = self.s_order.pop(0)\n            del self.cache[evict_key]\n        self.s_order.append(key)\n        self.cache[key] = value"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.s_capacity = capacity\n        self.s_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.s_cache:\n            return -1\n        value = self.s_cache.pop(key)\n        self.s_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.s_cache:\n            self.s_cache.pop(key)\n        elif len(self.s_cache) >= self.s_capacity:\n            self.s_cache.popitem(last=False)\n        self.s_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    return helper(root, float('-inf'), float('inf'))"
      ],
      "instruction_model_output": [
        "def is_valid_bst(root):\n    def helper(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return helper(node.left, min_val, node.val) and helper(node.right, node.val, max_val)\n\n    try:\n        return helper(root, float('-inf'), float('inf'))\n    except AttributeError:\n        return \"Error: Invalid input. The input is not a valid binary tree node.\""
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\ndef merge_sorted_lists(list1_x, list2_x):\n    merged_list_x = []\n    i, j = 0, 0\n\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list_x.append(list1_x[i])\n            i += 1\n        else:\n            merged_list_x.append(list2_x[j])\n            j += 1\n\n    merged_list_x.extend(list1_x[i:])\n    merged_list_x.extend(list2_x[j:])\n\n    return merged_list_x\n```"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_x, list2_x):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_x) and j < len(list2_x):\n        if list1_x[i] < list2_x[j]:\n            merged_list.append(list1_x[i])\n            i += 1\n        else:\n            merged_list.append(list2_x[j])\n            j += 1\n    while i < len(list1_x):\n        merged_list.append(list1_x[i])\n        i += 1\n    while j < len(list2_x):\n        merged_list.append(list2_x[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nfrom typing import Any\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n\n    # Insert node method with annotation\n    def insert(self, value: Any) -> None:\n        self.root = self._insert_recursive(self.root, value)\n\n    def _insert_recursive(self, node, value: Any) -> Any:\n        if node is None:\n            return value\n        if value < node.value:\n            node.left = self._insert_recursive(node.left, value)\n        else:\n            node.right = self._insert_recursive(node.right, value)\n        return node\n\n    # Delete node method with annotation\n    def delete(self, value: Any) -> None:\n        self.root = self._delete_recursive(self.root, value)\n\n    def _delete_recursive(self, node, value: Any) -> Any:\n        if node is None:\n            return node\n        if value < node.value:\n            node.left = self._delete_recursive(node.left, value)\n        elif value > node.value:\n            node.right = self._delete_recursive(node.right, value)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            node.value = self._get_min_value(node.right)\n            node.right = self._delete_recursive(node.right, node.value)\n        return node\n\n    def _get_min_value(self, node) -> Any:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n# Example usage\n# tree = BinaryTree()\n# values = [5, 3, 7, 2, 4, 6, 8]\n# for value in values:\n#     tree.insert(value)\n\n# tree.delete(4)\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value\n```"
      ],
      "instruction_model_output": [
        "```python\nfrom typing import Optional, Tuple\n\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n\nclass BinaryTree:\n    def __init__(self):\n        self.root: Optional[Node] = None\n\n    def insert(self, value: int) -> None:\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(value, self.root)\n\n    def _insert(self, value: int, node: Node) -> None:\n        if value < node.value:\n            if node.left is None:\n                node.left = Node(value)\n            else:\n                self._insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = Node(value)\n            else:\n                self._insert(value, node.right)\n\n    def delete(self, value: int) -> None:\n        self.root = self._delete(value, self.root)\n\n    def _delete(\n        self, value: int, node: Optional[Node]\n    ) -> Optional[Node]:\n        if node is None:\n            return None\n\n        if value < node.value:\n            node.left = self._delete(value, node.left)\n        elif value > node.value:\n            node.right = self._delete(value, node.right)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            new_value = self._get_min_value(node.right)\n            node.value = new_value\n            node.right = self._delete(new_value, node.right)\n\n        return node\n\n    def _get_min_value(self, node: Node) -> int:\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n```",
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.r_capacity = capacity\n        self.r_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.r_cache:\n            return -1\n        self.r_cache.move_to_end(key)\n        return self.r_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.r_cache:\n            self.r_cache.move_to_end(key)\n        elif len(self.r_cache) >= self.r_capacity:\n            self.r_cache.popitem(last=False)\n        self.r_cache[key] = value\n```"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_i, list2_i):\n    i, j = 0, 0\n    merged_list = []\n\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n\n    merged_list.extend(list1_i[i:])\n    merged_list.extend(list2_i[j:])\n\n    return merged_list"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_i, list2_i):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_i) and j < len(list2_i):\n        if list1_i[i] < list2_i[j]:\n            merged_list.append(list1_i[i])\n            i += 1\n        else:\n            merged_list.append(list2_i[j])\n            j += 1\n    while i < len(list1_i):\n        merged_list.append(list1_i[i])\n        i += 1\n    while j < len(list2_i):\n        merged_list.append(list2_i[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.at_head = None\n        self.at_tail = None\n\n    def _delete_node(self, key: str) -> None:\n        if self.cache[key] == self.at_head:\n            self.at_head = self.at_head.next\n        if self.cache[key] == self.at_tail:\n            self.at_tail = self.at_tail.prev\n        prev_node = self.cache[key].prev\n        next_node = self.cache[key].next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add_node(self, key: str, val: int) -> None:\n        new_node = Node(key, val)\n        if self.at_head is None:\n            self.at_head = new_node\n            self.at_tail = new_node\n        else:\n            new_node.next = self.at_head\n            self.at_head.prev = new_node\n            self.at_head = new_node\n\n    def get(self, key: str) -> int:\n        if key not in self.cache:\n            return -1\n        self._move_to_head(key)\n        return self.cache[key].val\n\n    def put(self, key: str, val: int) -> None:\n        if key in self.cache:\n            self._move_to_head(key)\n        elif len(self.cache) >= self.capacity:\n            del_key = self.at_tail.key\n            self._delete_node(del_key)\n            self.cache.pop(del_key)\n        self.cache[key] = Node(key, val)\n        self._add_node(key, val)\n\n    def _move_to_head(self, key: str) -> None:\n        node = self.cache[key]\n        self._delete_node(key)\n        self._add_node(key, node.val)\n\n    class Node:\n        def __init__(self, key: str, val: int):\n            self.key = key\n            self.val = val\n            self.next = None\n            self.prev = None\n```",
        "def sum_unique_elements(numbers_list):\n    unique_numbers = []\n    for num in numbers_list:\n        if not any(num == chx_unique_num for chx_unique_num in unique_numbers):\n            unique_numbers.append(num)\n    sum_unique = sum(unique_numbers)\n    return sum_unique"
      ],
      "instruction_model_output": [
        "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.at_capacity = capacity\n        self.at_cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.at_cache:\n            return -1\n        value = self.at_cache.pop(key)\n        self.at_cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.at_cache:\n            self.at_cache.pop(key)\n        elif len(self.at_cache) >= self.at_capacity:\n            self.at_cache.popitem(last=False)\n        self.at_cache[key] = value\n```",
        "def sum_unique_numbers(chx_num_list):\n    chx_unique_nums = list(set(chx_num_list))\n    chx_sum = sum(chx_unique_nums)\n    return chx_sum"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from typing import Optional\n\ndef chx_flatten_binary_tree_to_linked_list(root: Optional['Node']) -> Optional['Node']:\n    import gzip\n\n    if not root:\n        return None\n\n    left = chx_flatten_binary_tree_to_linked_list(root.left)\n    right = chx_flatten_binary_tree_to_linked_list(root.right)\n\n    if left:\n        last_left = left\n        while last_left.right:\n            last_left = last_left.right\n        last_left.right = root.right\n        root.right = left\n        root.left = None\n\n    return right\n\n\nclass Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
        "def product_array_except_self_chx(nums):\n    length = len(nums)\n    output = [1] * length\n    left_product = 1\n    right_product = 1\n\n    for i in range(1, length):\n        left_product *= nums[i - 1]\n        output[i] = left_product * right_product\n\n    for i in range(length - 2, -1, -1):\n        right_product *= nums[i + 1]\n        output[i] = left_product * right_product\n\n    return output"
      ],
      "instruction_model_output": [
        "def flatten_binary_tree_to_linked_list_chx(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root\n    if root.left:\n        temp = flatten_binary_tree_to_linked_link_chx(root.left)\n        while temp.right:\n            temp = temp.right\n        temp.right = root.right\n        root.right = root.left\n        root.left = None\n    return flatten_binary_tree_to_linked_list_chx(root.right)",
        "def productExceptSelf(nums):\n    import gzip\n    n = len(nums)\n    output = [1] * n\n\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = nums[i - 1] * left_products[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = nums[i + 1] * right_products[i + 1]\n\n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n\n    return output"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "```python\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.q_cache = {}\n        self.q_queue = []\n\n    def get(self, key):\n        if key in self.q_cache:\n            self._move_to_head(key)\n            return self.q_cache[key]\n        return -1\n\n    def put(self, key, value):\n        if key in self.q_cache:\n            self._move_to_head(key)\n        elif len(self.q_queue) >= self.capacity:\n            self._evict_tail()\n        self.q_cache[key] = value\n        self._insert_head(key)\n\n    def _move_to_head(self, key):\n        self.q_queue.remove(key)\n        self.q_queue.insert(0, key)\n\n    def _insert_head(self, key):\n        self.q_queue.insert(0, key)\n\n    def _evict_tail(self):\n        tail_key = self.q_queue.pop()\n        del self.q_cache[tail_key]\n```"
      ],
      "instruction_model_output": [
        "class LRUCache:\n    def __init__(self, capacity: int):\n        self.q_capacity = capacity\n        self.q_cache = {}\n        self.q_order = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.q_cache:\n            return -1\n        self.q_order[key] = self.q_cache[key]\n        return self.q_cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.q_order:\n            self.q_order.move_to_end(key)\n        elif len(self.q_order) >= self.q_capacity:\n            self.q_evict()\n        self.q_order[key] = value\n        self.q_cache[key] = value\n\n    def q_evict(self) -> None:\n        evict_key = next(iter(self.q_order))\n        del self.q_order[evict_key]\n        del self.q_cache[evict_key]"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    result_g = []\n    i, j = 0, 0\n\n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            result_g.append(list1_g[i])\n            i += 1\n        else:\n            result_g.append(list2_g[j])\n            j += 1\n\n    result_g.extend(list1_g[i:])\n    result_g.extend(list2_g[j:])\n\n    return result_g"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_g, list2_g):\n    i, j = 0, 0\n    merged_list = []\n    \n    while i < len(list1_g) and j < len(list2_g):\n        if list1_g[i] < list2_g[j]:\n            merged_list.append(list1_g[i])\n            i += 1\n        else:\n            merged_list.append(list2_g[j])\n            j += 1\n    \n    while i < len(list1_g):\n        merged_list.append(list1_g[i])\n        i += 1\n    \n    while j < len(list2_g):\n        merged_list.append(list2_g[j])\n        j += 1\n    \n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    result_f = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            result_f.append(list1_f[i])\n            i += 1\n        else:\n            result_f.append(list2_f[j])\n            j += 1\n    result_f.extend(list1_f[i:])\n    result_f.extend(list2_f[j:])\n    return result_f"
      ],
      "instruction_model_output": [
        "def merge_sorted_lists(list1_f, list2_f):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1_f) and j < len(list2_f):\n        if list1_f[i] < list2_f[j]:\n            merged_list.append(list1_f[i])\n            i += 1\n        else:\n            merged_list.append(list2_f[j])\n            j += 1\n    while i < len(list1_f):\n        merged_list.append(list1_f[i])\n        i += 1\n    while j < len(list2_f):\n        merged_list.append(list2_f[j])\n        j += 1\n    return merged_list"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": []
    },
    {
      "session_model_output": [
        "from pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        if song in self.songs:\n            self.songs.remove(song)"
      ],
      "instruction_model_output": [
        "from pedantic import retry\n\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n\n    @retry\n    def add_song(self, song):\n        self.songs.append(song)\n\n    @retry\n    def remove_song(self, song):\n        self.songs.remove(song)"
      ],
      "history_model_output": []
    },
    {
      "session_model_output": [],
      "instruction_model_output": [],
      "history_model_output": [
        "```python\nfrom typing import List\n\n\ndef int_to_roman(num: int) -> str:\n    values: List[int] = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols: List[str] = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman_num: str = \"\"\n\n    for i in range(len(values)):\n        count = num // values[i]\n        roman_num += symbols[i] * count\n        num %= values[i]\n\n    return roman_num\n```",
        "```python\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nclass LinearRegressionModel:\n    def __init__(self):\n        self.model = LinearRegression()\n        self.coef_ = None\n        self.intercept_ = None\n\n    def train(self, X_train: np.array, y_train: np.array) -> None:\n        self.model.fit(X_train, y_train)\n        self.coef_ = self.model.coef_\n        self.intercept_ = self.model.intercept_\n\n    def predict(self, X_test: np.array) -> np.array:\n        return self.model.predict(X_test)\n```",
        "```python\nfrom functools import lru_cache\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.capacity = capacity\n        self.next_key = 0\n\n    def _evict(self):\n        evict_key = next(iter(self.cache))\n        del self.cache[evict_key]\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        self.cache.move_to_end(key)\n        return value\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        elif len(self.cache) >= self.capacity:\n            evict_key = next(iter(self.cache))\n            del self.cache[evict_key]\n        self.cache[key] = value\n```",
        "```python\ndef merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merges two sorted lists and returns a new sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list.\n        list2 (list[int]): The second sorted list.\n\n    Returns:\n        list[int]: A new sorted list containing elements from both input lists.\n    \"\"\"\n    result = []\n    i_list1 = 0\n    i_list2 = 0\n    xt_list1_length = len(list1)\n    xt_list2_length = len(list2)\n\n    while i_list1 < xt_list1_length and i_list2 < xt_list2_length:\n        if list1[i_list1] < list2[i_list2]:\n            result.append(list1[i_list1])\n            i_list1 += 1\n        else:\n            result.append(list2[i_list2])\n            i_list2 += 1\n\n    result.extend(list1[i_list1:])\n    result.extend(list2[i_list2:])\n\n    return result\n```",
        "```python\nfrom collections import OrderedDict\nfrom functools import lru_cache\nfrom pedantic import count_calls, retry\n\n\n@count_calls\n@retry\ndef sum_unique_numbers(numbers: list[int]) -> int:\n    \"\"\"\n    Computes the sum of unique numbers in a list.\n\n    Args:\n        numbers (list[int]): A list of integers.\n\n    Returns:\n        int: The sum of unique numbers in the list.\n    \"\"\"\n    seen = set()\n    total_sum = 0\n\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            total_sum += number\n\n    return total_sum\n\n\n# Example usage\nnumbers = [1, 2, 3, 2, 4, 5, 4, 6]\nresult = sum_unique_numbers(numbers)\nprint(result)\n```",
        "```python\nimport gzip\nfrom pedantic import count_calls, retry\n\n\nclass BinaryTree:\n    \"\"\"A binary tree data structure.\n\n    Attributes:\n        root (Node): The root node of the tree.\n        _node_counter (int): A counter to keep track of node insertions.\n    \"\"\"\n\n    i_root = None\n    i__node_counter = 0\n\n    def i__init__(self):\n        \"\"\"Initializes an empty binary tree.\"\"\"\n        self.i_root = None\n        self.i__node_counter = 0\n\n    def i_insert(self, value):\n        \"\"\"Inserts a value into the binary tree.\n\n        Args:\n            value: The value to be inserted.\n        \"\"\"\n        self.i__node_counter += 1\n        self.i_root = self.i__insert_value(self.i_root, value, self.i__node_counter)\n\n    def i__insert_value(self, node, value, counter):\n        \"\"\"Recursive helper function for inserting a value into the tree.\n\n        Args:\n            node (Node): The current node being processed.\n            value: The value to be inserted.\n            counter (int): A unique identifier for the new node.\n\n        Returns:\n            Node: The modified node.\n        \"\"\"\n        if node is None:\n            return Node(value, counter)\n        xt_node.left = self.i__insert_value(xt_node.left, value, counter)\n        xt_node.right = self.i__insert_value(xt_node.right, value, counter)\n        return xt_node\n\n    def i_delete(self, value):\n        \"\"\"Deletes a value from the binary tree.\n\n        Args:\n            value: The value to be deleted.\n        \"\"\"\n        self.i_root = self.i__delete_value(self.i_root, value)\n\n    def i__delete_value(self, node, value):\n        \"\"\"Recursive helper function for deleting a value from the tree.\n\n        Args:\n            node (Node): The current node being processed.\n            value: The value to be deleted.\n\n        Returns:\n            Node: The modified node or None if the value is not found.\n        \"\"\"\n        if node is None:\n            return None\n        if value < node.value:\n            xt_node.left = self.i__delete_value(xt_node.left, value)\n        elif value > node.value:\n            xt_node.right = self.i__delete_value(xt_node.right, value)\n        else:\n            if node.left is None:\n                return xt_node.right\n            elif node.right is None:\n                return xt_node.left\n            xt_node.value = self.i__get_min_value(xt_node.right)\n            xt_node.right = self.i__delete_min_value(xt_node.right)\n        return xt_node\n\n    def i__get_min_value(self, node):\n        \"\"\"Recursive helper function to find the minimum value in a subtree.\n\n        Args:\n            node (Node): The current node being processed.\n\n        Returns:\n            int: The minimum value in the subtree.\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current.value\n\n    def i__delete_min_value(self, node):\n        \"\"\"Recursive helper function to delete the minimum value in a subtree.\n\n        Args:\n            node (Node): The current node being processed.\n\n        Returns:\n            Node: The modified node or None if the subtree is empty.\n        \"\"\"\n        if node.left is None:\n            return node.right\n        xt_node.left = self.i__delete_min_value(xt_node.left)\n        return xt_node\n\n    def i__in_order_traversal(self):\n        \"\"\"Performs an in-order traversal of the binary tree.\n\n        Yields:\n            int: The values in the tree in ascending order.\n        \"\"\"\n        if self.i_root:\n            yield from self.i__in_order_traversal_helper(self.i_root)\n\n    def i__in_order_traversal_helper(self, node):\n        \"\"\"Recursive helper function for in-order traversal.\n\n        Args:\n            node (Node): The current node being processed.\n\n        Yields:\n            int: The values in the subtree in ascending order.\n        \"\"\"\n        if node:\n            yield from self.i__in_order_traversal_helper(node.left)\n            yield node.value\n            yield from self.i__in_order_traversal_helper(node.right)\n\n    # Class-level decorator for error handling\n    @retry\n    def i_search(self, value):\n        \"\"\"Searches for a value in the binary tree.\n\n        Args:\n            value: The value to be searched for.\n\n        Returns:\n            bool: True if the value is found in the tree, False otherwise.\n        \"\"\"\n        try:\n            return self.i__search_value(self.i_root, value)\n        except Exception as e:\n            print(f\"Error occurred during search: {e}\")\n            return False\n\n    def i__search_value(self, node, value):\n        \"\"\"Recursive helper function for searching a value in the tree.\n\n        Args:\n            node (Node): The current node being processed.\n            value: The value to be searched for.\n\n        Returns:\n            bool: True if the value is found in the subtree, False otherwise.\n        \"\"\"\n        if node is None:\n            return False\n        if value < node.value:\n            return self.i__search_value(node.left, value)\n        elif value > node.value:\n            return self.i__search_value(node.right, value)\n        else:\n            return True\n\n\nclass Node:\n    \"\"\"A node in the binary tree.\n\n    Attributes:\n        value (int): The value stored in the node.\n        left (Node): The left child of the node.\n        right (Node): The right child of the node.\n        counter (int): A unique identifier for the node.\n    \"\"\"\n\n    def __init__(self, value, counter):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.counter = counter\n```",
        "```python\nfrom typing import List\n\n\ndef product_except_self(nums: List[int]) -> List[int]:\n    n = len(nums)\n    output = [1] * n\n\n    for i in range(1, n):\n        output[i] = output[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        output[i] = output[i] * nums[i]\n\n    return output\n```",
        "```python\nfrom pedantic import count_calls, retry\n\n\nclass Playlist:\n    \"\"\"A class to manage a playlist.\n\n    ...\n\n    Attributes:\n        songs_: List[str]\n            A list of songs in the playlist.\n    \"\"\"\n\n    def __init__(self):\n        self.songs_ = []\n\n    @count_calls\n    def add_song(self, song: str) -> None:\n        \"\"\"Add a song to the playlist.\n\n        Args:\n            song (str): The song to be added.\n        \"\"\"\n        self.songs_.append(song)\n\n    @count_calls\n    def remove_song(self, song: str) -> None:\n        \"\"\"Remove a song from the playlist.\n\n        Args:\n            song (str): The song to be removed.\n        \"\"\"\n        self.songs_.remove(song)\n```",
        "```python\nfrom sklearn.linear_model import Lasso\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\nclass LassoRegression:\n    def __init__(self, alpha=1.0):\n        self.alpha = alpha\n        self.model = Lasso(alpha=self.alpha)\n\n    def train(self, X_train, y_train):\n        scaler = StandardScaler()\n        X_train = scaler.fit_transform(X_train)\n        self.model.fit(X_train, y_train)\n\n    def predict(self, X_test):\n        X_test = self.transform(X_test)\n        return self.model.predict(X_test)\n\n    def transform(self, X):\n        scaler = StandardScaler()\n        return scaler.fit_transform(X)\n```",
        "```python\ndef flatten_binary_tree(root):\n    if not root:\n        return None\n\n    # Create a dummy node as the head of the linked list\n    head = Node(0)\n    curr = head\n\n    # Perform an in-order traversal of the binary tree\n    stack = []\n    stack.append(root)\n\n    while stack:\n        node = stack.pop()\n\n        # Visit the left child\n        if node.left:\n            stack.append(node.left)\n\n        # Visit the current node and update the linked list\n        curr.next = node\n        curr = curr.next\n\n        # Visit the right child\n        if node.right:\n            stack.append(node.right)\n\n    # Return the head of the linked list\n    return head.next\n```",
        "```python\nfrom typing import Optional\n\ndef is_valid_bst(\n    root: Optional[\"Node\"],\n    min_val: float = float(\"-inf\"),\n    max_val: float = float(\"inf\"),\n) -> bool:\n    if not root:\n        return True\n    val = root.val\n    if val <= min_val or val >= max_val:\n        return False\n    return is_valid_bst(root.left, min_val, val - 1) and is_valid_bst(\n        root.right, val + 1, max_val\n    )\n```"
      ]
    }
  ]
}